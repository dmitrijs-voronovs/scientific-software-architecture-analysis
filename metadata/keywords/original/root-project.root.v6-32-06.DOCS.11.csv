id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:13711,Modifiability,variab,variable,13711,"etrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173af50 ""int i =; (IntegerLiteral 0x173afa8 'int' 0)""); <<>>; (BinaryOperator 0x173b060 '_Bool' '<'; (ImplicitCastExpr 0x173b030 'int'; (DeclRefExpr 0x173afe0 'int' lvalue Var 0x173af50 'i' 'int')); (ImplicitCastExpr 0x173b048 'int'; (DeclRefExpr 0x173b008 'const int' lvalue Var 0x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:15553,Modifiability,variab,variables,15553,"x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know that the declaration and increments both match, or this; loop wouldn't have been dumped. The culprit lies in the implicit cast; applied to the first operand (i.e. the LHS) of the less-than operator,; an L-value to R-value conversion applied to the expression referencing; ``i``. Thankfully, the matcher library offers a solution to this problem; in the form of ``ignoringParenImpCasts``, which instructs the matcher to; ignore implicit casts and parentheses before continuing to match.; Adjusting the condition operator will restore the desired match. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(ignoringParenImpCasts(declRefExpr(; to(varDecl(hasType(isInteger())))))),; hasRHS(expr(hasType(isInteger()))))). After adding binds to the expressions we wished to capture and; extracting the identifier strings into variables, we have array-step-2; completed. Step 4: Retrieving Matched Nodes; ================================. So far, the matcher callback isn't very interesting: it just dumps the; loop's AST. At some point, we will need to make changes to the input; source code. Next, we'll work on using the nodes we bound in the; previous step. The ``MatchFinder::run()`` callback takes a; ``MatchFinder::MatchResult&`` as its parameter. We're most interested in; its ``Context`` and ``Nodes`` members. Clang uses the ``ASTContext``; class to represent contextual information about the AST, as the name; implies, though the most functionally important detail is that several; operations require an ``ASTContext*`` parameter. More immediately useful; is the set of matched nodes, and how we retrieve them. Since we bind three variables (identified by ConditionVarName,; InitVarName, and IncrementVarName), we can obtain the matched nodes by; using the ``getNodeAs()`` member functi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:16368,Modifiability,variab,variables,16368,"teger()))))). After adding binds to the expressions we wished to capture and; extracting the identifier strings into variables, we have array-step-2; completed. Step 4: Retrieving Matched Nodes; ================================. So far, the matcher callback isn't very interesting: it just dumps the; loop's AST. At some point, we will need to make changes to the input; source code. Next, we'll work on using the nodes we bound in the; previous step. The ``MatchFinder::run()`` callback takes a; ``MatchFinder::MatchResult&`` as its parameter. We're most interested in; its ``Context`` and ``Nodes`` members. Clang uses the ``ASTContext``; class to represent contextual information about the AST, as the name; implies, though the most functionally important detail is that several; operations require an ``ASTContext*`` parameter. More immediately useful; is the set of matched nodes, and how we retrieve them. Since we bind three variables (identified by ConditionVarName,; InitVarName, and IncrementVarName), we can obtain the matched nodes by; using the ``getNodeAs()`` member function. In ``LoopConvert.cpp`` add. .. code-block:: c++. #include ""clang/AST/ASTContext.h"". Change ``LoopMatcher`` to. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(; hasSingleDecl(varDecl(hasInitializer(integerLiteral(equals(0)))); .bind(""initVarName"")))),; hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(; to(varDecl(hasType(isInteger())).bind(""incVarName"")))))),; hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(ignoringParenImpCasts(declRefExpr(; to(varDecl(hasType(isInteger())).bind(""condVarName""))))),; hasRHS(expr(hasType(isInteger())))))).bind(""forLoop"");. And change ``LoopPrinter::run`` to. .. code-block:: c++. void LoopPrinter::run(const MatchFinder::MatchResult &Result) {; ASTContext *Context = Result.Context;; const ForStmt *FS = Result.Nodes.getNodeAs<ForStmt>(""forLoop"");; // We do not want to convert header files!; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:17936,Modifiability,variab,variable,17936,"arName"")))))),; hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(ignoringParenImpCasts(declRefExpr(; to(varDecl(hasType(isInteger())).bind(""condVarName""))))),; hasRHS(expr(hasType(isInteger())))))).bind(""forLoop"");. And change ``LoopPrinter::run`` to. .. code-block:: c++. void LoopPrinter::run(const MatchFinder::MatchResult &Result) {; ASTContext *Context = Result.Context;; const ForStmt *FS = Result.Nodes.getNodeAs<ForStmt>(""forLoop"");; // We do not want to convert header files!; if (!FS || !Context->getSourceManager().isWrittenInMainFile(FS->getForLoc())); return;; const VarDecl *IncVar = Result.Nodes.getNodeAs<VarDecl>(""incVarName"");; const VarDecl *CondVar = Result.Nodes.getNodeAs<VarDecl>(""condVarName"");; const VarDecl *InitVar = Result.Nodes.getNodeAs<VarDecl>(""initVarName"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:17962,Modifiability,variab,variable,17962,"arName"")))))),; hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(ignoringParenImpCasts(declRefExpr(; to(varDecl(hasType(isInteger())).bind(""condVarName""))))),; hasRHS(expr(hasType(isInteger())))))).bind(""forLoop"");. And change ``LoopPrinter::run`` to. .. code-block:: c++. void LoopPrinter::run(const MatchFinder::MatchResult &Result) {; ASTContext *Context = Result.Context;; const ForStmt *FS = Result.Nodes.getNodeAs<ForStmt>(""forLoop"");; // We do not want to convert header files!; if (!FS || !Context->getSourceManager().isWrittenInMainFile(FS->getForLoc())); return;; const VarDecl *IncVar = Result.Nodes.getNodeAs<VarDecl>(""incVarName"");; const VarDecl *CondVar = Result.Nodes.getNodeAs<VarDecl>(""condVarName"");; const VarDecl *InitVar = Result.Nodes.getNodeAs<VarDecl>(""initVarName"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5536,Performance,load,loading,5536,"t...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:19498,Security,hash,hash,19498,"Name"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr`` later. Before; you run the new code on the additional loops added to; test-files/simple.cpp, try to figure out which ones will be considered; potentially convertible.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:1791,Testability,test,test,1791,"ad LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:1858,Testability,test,tests,1858,"git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5361,Testability,test,test,5361,"n all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5388,Testability,test,test,5388,"p CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10309,Testability,test,test,10309,"rDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");. class LoopPrinter : public MatchFinder::MatchCallback {; public :; virtual void run(const MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10414,Testability,test,test-files,10414," MatchFinder::MatchCallback {; public :; virtual void run(const MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same vari",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10461,Testability,test,test-files,10461,"st MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a mat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:11512,Testability,log,logic,11512,"ing for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:14001,Testability,test,test-files,14001,"outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173af50 ""int i =; (IntegerLiteral 0x173afa8 'int' 0)""); <<>>; (BinaryOperator 0x173b060 '_Bool' '<'; (ImplicitCastExpr 0x173b030 'int'; (DeclRefExpr 0x173afe0 'int' lvalue Var 0x173af50 'i' 'int')); (ImplicitCastExpr 0x173b048 'int'; (DeclRefExpr 0x173b008 'const int' lvalue Var 0x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know that the declaration and increments both match, or this; loop wouldn't have been dumped. The culprit lies in the implicit cast; applied to the first operand (i.e. the LHS) of the less-than operator,; an L-value to R-value conversion applied to the expression referencing; ``i``. Thankfully",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:18739,Testability,test,test,18739,"Name"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr`` later. Before; you run the new code on the additional loops added to; test-files/simple.cpp, try to figure out which ones will be considered; potentially convertible.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:19638,Testability,test,test-files,19638,"Name"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr`` later. Before; you run the new code on the additional loops added to; test-files/simple.cpp, try to figure out which ones will be considered; potentially convertible.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:958,Usability,guid,guide,958,"===============================================================; Tutorial for building tools using LibTooling and LibASTMatchers; ===============================================================. This document is intended to show how to build a useful source-to-source; translation tool based on Clang's `LibTooling <LibTooling.html>`_. It is; explicitly aimed at people who are new to Clang, so all you should need; is a working knowledge of C++ and the command line. In order to work on the compiler, you need some basic knowledge of the; abstract syntax tree (AST). To this end, the reader is encouraged to; skim the :doc:`Introduction to the Clang; AST <IntroductionToTheClangAST>`. Step 0: Obtaining Clang; =======================. As Clang is part of the LLVM project, you'll need to download LLVM's; source code first. Both Clang and LLVM are in the same git repository,; under different directories. For further information, see the `getting; started guide <https://llvm.org/docs/GettingStarted.html>`_. .. code-block:: console. mkdir ~/clang-llvm && cd ~/clang-llvm; git clone https://github.com/llvm/llvm-project.git. Next you need to obtain the CMake build system and Ninja build tool. .. code-block:: console. cd ~/clang-llvm; git clone https://github.com/martine/ninja.git; cd ninja; git checkout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/ll",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2516,Usability,simpl,simplest,2516,"kay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConvert.cpp; ); target_link_libraries(loop-convert; PRIVATE; clangAST; clangASTMatchers; clangBasic; clangFrontend; clangSerialization; clangTooling; ). With that done, Ninja will be able to compile our tool. Let's give it; something to compile! Put the following into; ``clang-tools-extra/loop-conve",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:5792,Usability,simpl,simple,5792," return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. And that's it! You can compile our new tool by running ninja from the; ``build`` directory. .. code-block:: console. cd ~/clang-llvm/build; ninja. You should now be able to run the syntax checker, which is located in; ``~/clang-llvm/build/bin``, on any source file. Try it!. .. code-block:: console. echo ""int main() { return 0; }"" > test.cpp; bin/loop-convert test.cpp --. Note the two dashes after we specify the source file. The additional; options for the compiler are passed after the dashes rather than loading; them from a compilation database - there just aren't any options needed; right now. Intermezzo: Learn AST matcher basics; ====================================. Clang recently introduced the :doc:`ASTMatcher; library <LibASTMatchers>` to provide a simple, powerful, and; concise way to describe specific patterns in the AST. Implemented as a; DSL powered by macros and templates (see; `ASTMatchers.h <../doxygen/ASTMatchers_8h_source.html>`_ if you're; curious), matchers offer the feel of algebraic data types common to; functional programming languages. For example, suppose you wanted to examine only binary operators. There; is a matcher to do exactly that, conveniently named ``binaryOperator``.; I'll give you one guess what this matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7259,Usability,simpl,simply,7259," matcher does:. .. code-block:: c++. binaryOperator(hasOperatorName(""+""), hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10425,Usability,simpl,simple-loops,10425," MatchFinder::MatchCallback {; public :; virtual void run(const MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same vari",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10472,Usability,simpl,simple-loops,10472,"st MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a mat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10567,Usability,simpl,simple,10567,"o:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12231,Usability,simpl,simply,12231,"nst; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:14012,Usability,simpl,simple,14012,"outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173af50 ""int i =; (IntegerLiteral 0x173afa8 'int' 0)""); <<>>; (BinaryOperator 0x173b060 '_Bool' '<'; (ImplicitCastExpr 0x173b030 'int'; (DeclRefExpr 0x173afe0 'int' lvalue Var 0x173af50 'i' 'int')); (ImplicitCastExpr 0x173b048 'int'; (DeclRefExpr 0x173b008 'const int' lvalue Var 0x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know that the declaration and increments both match, or this; loop wouldn't have been dumped. The culprit lies in the implicit cast; applied to the first operand (i.e. the LHS) of the less-than operator,; an L-value to R-value conversion applied to the expression referencing; ``i``. Thankfully",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:19649,Usability,simpl,simple,19649,"Name"");. if (!areSameVariable(IncVar, CondVar) || !areSameVariable(IncVar, InitVar)); return;; llvm::outs() << ""Potential array-based loop discovered.\n"";; }. Clang associates a ``VarDecl`` with each variable to represent the variable's; declaration. Since the ""canonical"" form of each declaration is unique by; address, all we need to do is make sure neither ``ValueDecl`` (base class of; ``VarDecl``) is ``NULL`` and compare the canonical Decls. .. code-block:: c++. static bool areSameVariable(const ValueDecl *First, const ValueDecl *Second) {; return First && Second &&; First->getCanonicalDecl() == Second->getCanonicalDecl();; }. If execution reaches the end of ``LoopPrinter::run()``, we know that the; loop shell looks like. .. code-block:: c++. for (int i= 0; i < expr(); ++i) { ... }. For now, we will just print a message explaining that we found a loop.; The next section will deal with recursively traversing the AST to; discover all changes needed. As a side note, it's not as trivial to test if two expressions are the same,; though Clang has already done the hard work for us by providing a way to; canonicalize expressions:. .. code-block:: c++. static bool areSameExpr(ASTContext *Context, const Expr *First,; const Expr *Second) {; if (!First || !Second); return false;; llvm::FoldingSetNodeID FirstID, SecondID;; First->Profile(FirstID, *Context, true);; Second->Profile(SecondID, *Context, true);; return FirstID == SecondID;; }. This code relies on the comparison between two; ``llvm::FoldingSetNodeIDs``. As the documentation for; ``Stmt::Profile()`` indicates, the ``Profile()`` member function builds; a description of a node in the AST, based on its properties, along with; those of its children. ``FoldingSetNodeID`` then serves as a hash we can; use to compare expressions. We will need ``areSameExpr`` later. Before; you run the new code on the additional loops added to; test-files/simple.cpp, try to figure out which ones will be considered; potentially convertible.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:731,Availability,avail,available,731,".. role:: raw-html(raw); :format: html. Libclang tutorial; =================; The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, and other facilities that support Clang-based development tools.; This C interface to Clang will never provide all of the information representation stored in Clang's C++ AST, nor should it: the intent is to maintain an API that is relatively stable from one release to the next, providing only the basic functionality needed to support development tools.; The entire C interface of libclang is available in the file `Index.h`_. Essential types overview; -------------------------. All types of libclang are prefixed with ``CX``. CXIndex; ~~~~~~~; An Index that consists of a set of translation units that would typically be linked together into an executable or library. CXTranslationUnit; ~~~~~~~~~~~~~~~~~; A single translation unit, which resides in an index. CXCursor; ~~~~~~~~; A cursor representing a pointer to some element in the abstract syntax tree of a translation unit. Code example; """""""""""""""""""""""". .. code-block:: cpp. // file.cpp; struct foo{; int bar;; int* bar_pointer;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:4184,Availability,avail,available,4184,"mation from a Cursor; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; .. The following functions take a ``CXCursor`` as an argument and return associated information. Extracting the Cursor kind; """""""""""""""""""""""""""""""""""""""""""""""""""". ``CXCursorKind clang_getCursorKind(CXCursor)`` Describes the kind of entity that a cursor refers to. Example values:. - ``CXCursor_StructDecl``: A C or C++ struct.; - ``CXCursor_FieldDecl``: A field in a struct, union, or C++ class.; - ``CXCursor_CallExpr``: An expression that calls a function. Extracting the Cursor type; """"""""""""""""""""""""""""""""""""""""""""""""""""; ``CXType clang_getCursorType(CXCursor)``: Retrieve the type of a CXCursor (if any). A ``CXType`` represents a complete C++ type, including qualifiers and pointers. It has a member field ``CXTypeKind kind`` and additional opaque data. Example values for ``CXTypeKind kind``. - ``CXType_Invalid``: Represents an invalid type (e.g., where no type is available); - ``CXType_Pointer``: A pointer to another type; - ``CXType_Int``: Regular ``int``; - ``CXType_Elaborated``: Represents a type that was referred to using an elaborated type keyword e.g. struct S, or via a qualified name, e.g., N::M::type, or both. Any ``CXTypeKind`` can be converted to a ``CXString`` using ``clang_getTypeKindSpelling(CXTypeKind)``. A ``CXType`` holds additional necessary opaque type info, such as:. - Which struct was referred to?; - What type is the pointer pointing to?; - Qualifiers (e.g. ``const``, ``volatile``)?. Qualifiers of a ``CXType`` can be queried with:. - ``clang_isConstQualifiedType(CXType)`` to check for ``const``; - ``clang_isRestrictQualifiedType(CXType)`` to check for ``restrict``; - ``clang_isVolatileQualifiedType(CXType)`` to check for ``volatile``. Code example; """"""""""""""""""""""""; .. code-block:: cpp. //structs.cpp; struct A{; int value;; };; struct B{; int value;; A struct_value;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTran",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:595,Deployability,release,release,595,".. role:: raw-html(raw); :format: html. Libclang tutorial; =================; The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, and other facilities that support Clang-based development tools.; This C interface to Clang will never provide all of the information representation stored in Clang's C++ AST, nor should it: the intent is to maintain an API that is relatively stable from one release to the next, providing only the basic functionality needed to support development tools.; The entire C interface of libclang is available in the file `Index.h`_. Essential types overview; -------------------------. All types of libclang are prefixed with ``CX``. CXIndex; ~~~~~~~; An Index that consists of a set of translation units that would typically be linked together into an executable or library. CXTranslationUnit; ~~~~~~~~~~~~~~~~~; A single translation unit, which resides in an index. CXCursor; ~~~~~~~~; A cursor representing a pointer to some element in the abstract syntax tree of a translation unit. Code example; """""""""""""""""""""""". .. code-block:: cpp. // file.cpp; struct foo{; int bar;; int* bar_pointer;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:2485,Energy Efficiency,allocate,allocates,2485," CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-block:: cpp. clang_visitChildren(; cursor, //Root cursor; [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){. CXString current_display_name = clang_getCursorDisplayName(current_cursor);; //Allocate a CXString representing the name of the current cursor. std::cout << ""Visiting element "" << clang_getCString(current_display_name) << ""\n"";; //Print the char* value of current_display_name. clang_disposeString(current_display_name);; //Since clang_getCursorDisplayName allocates a new CXString, it must be freed. This applies; //to all functions returning a CXString. return CXChildVisit_Recurse;. }, //CXCursorVisitor: a function pointer; nullptr //client_data; );. The return value of ``CXCursorVisitor``, the callable argument of ``clang_visitChildren``, can return one of the three:. #. ``CXChildVisit_Break``: Terminates the cursor traversal. #. ``CXChildVisit_Continue``: Continues the cursor traversal with the next sibling of the cursor just visited, without visiting its children. #. ``CXChildVisit_Recurse``: Recursively traverse the children of this cursor, using the same visitor and client data. The expected output of that program is. .. code-block::. Visiting element foo; Visiting element bar; Visiting element bar_pointer. Extracting information from a Cursor; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; .. The following functions take a ``CXCursor`` as an argument and return associated information. Extracting the Cursor kind; """"""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:409,Integrability,interface,interface,409,".. role:: raw-html(raw); :format: html. Libclang tutorial; =================; The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, and other facilities that support Clang-based development tools.; This C interface to Clang will never provide all of the information representation stored in Clang's C++ AST, nor should it: the intent is to maintain an API that is relatively stable from one release to the next, providing only the basic functionality needed to support development tools.; The entire C interface of libclang is available in the file `Index.h`_. Essential types overview; -------------------------. All types of libclang are prefixed with ``CX``. CXIndex; ~~~~~~~; An Index that consists of a set of translation units that would typically be linked together into an executable or library. CXTranslationUnit; ~~~~~~~~~~~~~~~~~; A single translation unit, which resides in an index. CXCursor; ~~~~~~~~; A cursor representing a pointer to some element in the abstract syntax tree of a translation unit. Code example; """""""""""""""""""""""". .. code-block:: cpp. // file.cpp; struct foo{; int bar;; int* bar_pointer;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:706,Integrability,interface,interface,706,".. role:: raw-html(raw); :format: html. Libclang tutorial; =================; The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, and other facilities that support Clang-based development tools.; This C interface to Clang will never provide all of the information representation stored in Clang's C++ AST, nor should it: the intent is to maintain an API that is relatively stable from one release to the next, providing only the basic functionality needed to support development tools.; The entire C interface of libclang is available in the file `Index.h`_. Essential types overview; -------------------------. All types of libclang are prefixed with ``CX``. CXIndex; ~~~~~~~; An Index that consists of a set of translation units that would typically be linked together into an executable or library. CXTranslationUnit; ~~~~~~~~~~~~~~~~~; A single translation unit, which resides in an index. CXCursor; ~~~~~~~~; A cursor representing a pointer to some element in the abstract syntax tree of a translation unit. Code example; """""""""""""""""""""""". .. code-block:: cpp. // file.cpp; struct foo{; int bar;; int* bar_pointer;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:7155,Modifiability,variab,variable,7155," CXType_RValueReference){ // or an RValue Reference (&&),; CXType pointed_to_type = clang_getPointeeType(cursor_type);// retrieve the pointed-to type. CXString pointed_to_type_spelling = clang_getTypeSpelling(pointed_to_type); // Spell out the entire; std::cout << ""pointing to type: "" << clang_getCString(pointed_to_type_spelling);// pointed-to type; clang_disposeString(pointed_to_type_spelling);; }; else if(cursor_type.kind == CXType_Record){; CXString type_spelling = clang_getTypeSpelling(cursor_type);; std::cout << "", namely "" << clang_getCString(type_spelling);; clang_disposeString(type_spelling);; }; std::cout << ""\n"";; return CXChildVisit_Recurse;; },; nullptr; );. The expected output of program is:. .. code-block::. Type Kind: Record, namely A; Type Kind: Int; Type Kind: Record, namely B; Type Kind: Int; Type Kind: Record, namely A; Type Kind: Record, namely A. Reiterating the difference between ``CXType`` and ``CXTypeKind``: For an example. .. code-block:: cpp. const char* __restrict__ variable;. - Type Kind will be: ``CXType_Pointer`` spelled ``""Pointer""``; - Type will be a complex ``CXType`` structure, spelled ``""const char* __restrict__``. Retrieving source locations; """""""""""""""""""""""""""""""""""""""""""""""""""""". ``CXSourceRange clang_getCursorExtent(CXCursor)`` returns a ``CXSourceRange``, representing a half-open range in the source code. Use ``clang_getRangeStart(CXSourceRange)`` and ``clang_getRangeEnd(CXSourceRange)`` to retrieve the starting and end ``CXSourceLocation`` from a source range, respectively. Given a ``CXSourceLocation``, use ``clang_getExpansionLocation`` to retrieve file, line and column of a source location. Code example; """"""""""""""""""""""""; .. code-block:: cpp. // Again, file.cpp; struct foo{; int bar;; int* bar_pointer;; };; .. code-block:: cpp. clang_visitChildren(; cursor,; [](CXCursor current_cursor, CXCursor parent, CXClientData client_data){. CXType cursor_type = clang_getCursorType(current_cursor);; CXString cursor_spelling = clang_getCursorSpelling(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:219,Performance,load,loading,219,".. role:: raw-html(raw); :format: html. Libclang tutorial; =================; The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, and other facilities that support Clang-based development tools.; This C interface to Clang will never provide all of the information representation stored in Clang's C++ AST, nor should it: the intent is to maintain an API that is relatively stable from one release to the next, providing only the basic functionality needed to support development tools.; The entire C interface of libclang is available in the file `Index.h`_. Essential types overview; -------------------------. All types of libclang are prefixed with ``CX``. CXIndex; ~~~~~~~; An Index that consists of a set of translation units that would typically be linked together into an executable or library. CXTranslationUnit; ~~~~~~~~~~~~~~~~~; A single translation unit, which resides in an index. CXCursor; ~~~~~~~~; A cursor representing a pointer to some element in the abstract syntax tree of a translation unit. Code example; """""""""""""""""""""""". .. code-block:: cpp. // file.cpp; struct foo{; int bar;; int* bar_pointer;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst:140,Security,expose,exposes,140,".. role:: raw-html(raw); :format: html. Libclang tutorial; =================; The C Interface to Clang provides a relatively small API that exposes facilities for parsing source code into an abstract syntax tree (AST), loading already-parsed ASTs, traversing the AST, associating physical source locations with elements within the AST, and other facilities that support Clang-based development tools.; This C interface to Clang will never provide all of the information representation stored in Clang's C++ AST, nor should it: the intent is to maintain an API that is relatively stable from one release to the next, providing only the basic functionality needed to support development tools.; The entire C interface of libclang is available in the file `Index.h`_. Essential types overview; -------------------------. All types of libclang are prefixed with ``CX``. CXIndex; ~~~~~~~; An Index that consists of a set of translation units that would typically be linked together into an executable or library. CXTranslationUnit; ~~~~~~~~~~~~~~~~~; A single translation unit, which resides in an index. CXCursor; ~~~~~~~~; A cursor representing a pointer to some element in the abstract syntax tree of a translation unit. Code example; """""""""""""""""""""""". .. code-block:: cpp. // file.cpp; struct foo{; int bar;; int* bar_pointer;; };. .. code-block:: cpp. #include <clang-c/Index.h>; #include <iostream>. int main(){; CXIndex index = clang_createIndex(0, 0); //Create index; CXTranslationUnit unit = clang_parseTranslationUnit(; index,; ""file.cpp"", nullptr, 0,; nullptr, 0,; CXTranslationUnit_None); //Parse ""file.cpp"". if (unit == nullptr){; std::cerr << ""Unable to parse translation unit. Quitting.\n"";; return 0;; }; CXCursor cursor = clang_getTranslationUnitCursor(unit); //Obtain a cursor at the root of the translation unit; }. Visiting elements of an AST; ~~~~~~~~~~~~~~~~~~~~~~~~~~~; The elements of an AST can be recursively visited with pre-order traversal with ``clang_visitChildren``. .. code-bloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibClang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibClang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:276,Deployability,integrat,integrated,276,"=========; LibFormat; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:161,Integrability,interface,interface,161,"=========; LibFormat; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:276,Integrability,integrat,integrated,276,"=========; LibFormat; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:404,Integrability,rout,routine,404,"=========; LibFormat; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:2490,Modifiability,config,configurable,2490,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:2369,Security,expose,exposed,2369,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1081,Usability,guid,guides,1081,"at; =========. LibFormat is a library that implements automatic source code formatting based; on Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1115,Usability,guid,guides,1115,"n Clang. This documents describes the LibFormat interface and design as well; as some basic style discussions. If you just want to use `clang-format` as a tool or integrated into an editor,; checkout :doc:`ClangFormat`. Design; ------. FIXME: Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1369,Usability,guid,guide,1369,"Write up design. Interface; ---------. The core routine of LibFormat is ``reformat()``:. .. code-block:: c++. tooling::Replacements reformat(const FormatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These optio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1536,Usability,guid,guide,1536,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:1882,Usability,guid,guide,1882,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:2060,Usability,guid,guide,2060,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:2102,Usability,guid,guidelines,2102,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:2206,Usability,guid,guide,2206,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibFormat.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:2683,Availability,error,error,2683," that takes the responsibility to parse command-line parameters related to; compilation databases and inputs, so that all tools share the implementation. Parsing common tools options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``CompilationDatabase`` can be read from a build directory or the command line.; Using ``CommonOptionsParser`` allows for explicit specification of a compile; command line, specification of build path using the ``-p`` command-line option,; and automatic location of the compilation database using source files paths. .. code-block:: c++. #include ""clang/Tooling/CommonOptionsParser.h""; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. int main(int argc, const char **argv) {; // CommonOptionsParser constructor will parse arguments and create a; // CompilationDatabase. In case of error it will terminate the program.; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);. // Use OptionsParser.getCompilations() and OptionsParser.getSourcePathList(); // to retrieve CompilationDatabase and the list of input file paths.; }. Creating and running a ClangTool; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Once we have a ``CompilationDatabase``, we can create a ``ClangTool`` and run; our ``FrontendAction`` over some code. For example, to run the; ``SyntaxOnlyAction`` over the files ""a.cc"" and ""b.cc"" one would write:. .. code-block:: c++. // A clang tool can run over a number of sources in the same process...; std::vector<std::string> Sources;; Sources.push_back(""a.cc"");; Sources.push_back(""b.cc"");. // We hand the CompilationDatabase we created and the sources to run over into; // the tool constructor.; ClangTool Tool(OptionsParser.getCompilations(), Sources);. // The ClangTool needs a new FrontendAction for each translation unit we run; // on. Thus, it takes a FrontendActionFactory as",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:5481,Availability,avail,available,5481,"::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS \; -Itools/clang/include -I$BD/include -Iinclude \; -Itools/clang/lib/Headers -c. As an alternative, you can also configure cmake to output a compile command; database into its build directory:. .. code-block:: bash. # Alternatively to calling cmake, use ccmake, toggle to advanced mode and; # set the parameter CMAKE_EXPORT_COMPILE_COMMANDS from the UI.; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON . This creates a file called ``compile_commands.json`` in the build directory.; Now you can run :program:`clang-check` over files in the project by specifying; the build path as first argument and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:6147,Deployability,toggle,toggle,6147,"oolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS \; -Itools/clang/include -I$BD/include -Iinclude \; -Itools/clang/lib/Headers -c. As an alternative, you can also configure cmake to output a compile command; database into its build directory:. .. code-block:: bash. # Alternatively to calling cmake, use ccmake, toggle to advanced mode and; # set the parameter CMAKE_EXPORT_COMPILE_COMMANDS from the UI.; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON . This creates a file called ``compile_commands.json`` in the build directory.; Now you can run :program:`clang-check` over files in the project by specifying; the build path as first argument and some source files as further positional; arguments:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check -p $BD tools/clang/tools/clang-check/ClangCheck.cpp. .. _libtooling_builtin_includes:. Builtin includes; ^^^^^^^^^^^^^^^^. Clang tools need their builtin headers and search for them the same way Clang; does. Thus, the default location to look for builtin headers is in a path; ``$(dirname /path/to/tool)/../lib/clang/3.3/include`` relative to the tool; binary. This works out-of-the-box for tools running from llvm's toplevel; binary directory after building clang-resource-headers, or if the tool is; running from the binary direct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:7184,Deployability,install,install,7184,"n the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS \; -Itools/clang/include -I$BD/include -Iinclude \; -Itools/clang/lib/Headers -c. As an alternative, you can also configure cmake to output a compile command; database into its build directory:. .. code-block:: bash. # Alternatively to calling cmake, use ccmake, toggle to advanced mode and; # set the parameter CMAKE_EXPORT_COMPILE_COMMANDS from the UI.; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON . This creates a file called ``compile_commands.json`` in the build directory.; Now you can run :program:`clang-check` over files in the project by specifying; the build path as first argument and some source files as further positional; arguments:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check -p $BD tools/clang/tools/clang-check/ClangCheck.cpp. .. _libtooling_builtin_includes:. Builtin includes; ^^^^^^^^^^^^^^^^. Clang tools need their builtin headers and search for them the same way Clang; does. Thus, the default location to look for builtin headers is in a path; ``$(dirname /path/to/tool)/../lib/clang/3.3/include`` relative to the tool; binary. This works out-of-the-box for tools running from llvm's toplevel; binary directory after building clang-resource-headers, or if the tool is; running from the binary directory of a clang install next to the clang binary. Tips: if your tool fails to find ``stddef.h`` or similar headers, call the tool; with ``-v`` and look at the search paths it looks through. Linking; ^^^^^^^. For a list of libraries to link, look at one of the tools' CMake files (for; example `clang-check/CMakeList.txt; <https://github.com/llvm/llvm-project/blob/main/clang/tools/clang-check/CMakeLists.txt>`_).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:1618,Integrability,depend,depending,1618,"ck syntax check, over a bunch of code. Parsing a code snippet in memory; --------------------------------. If you ever wanted to run a ``FrontendAction`` over some sample code, for; example to unit test parts of the Clang AST, ``runToolOnCode`` is what you; looked for. Let me give you an example:. .. code-block:: c++. #include ""clang/Tooling/Tooling.h"". TEST(runToolOnCode, CanSyntaxCheckCode) {; // runToolOnCode returns whether the action was correctly run over the; // given code.; EXPECT_TRUE(runToolOnCode(std::make_unique<clang::SyntaxOnlyAction>(), ""class X {};""));; }. Writing a standalone tool; -------------------------. Once you unit tested your ``FrontendAction`` to the point where it cannot; possibly break, it's time to create a standalone tool. For a standalone tool; to run clang, it first needs to figure out what command line arguments to use; for a specified file. To that end we create a ``CompilationDatabase``. There; are different ways to create a compilation database, and we need to support all; of them depending on command-line options. There's the ``CommonOptionsParser``; class that takes the responsibility to parse command-line parameters related to; compilation databases and inputs, so that all tools share the implementation. Parsing common tools options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``CompilationDatabase`` can be read from a build directory or the command line.; Using ``CommonOptionsParser`` allows for explicit specification of a compile; command line, specification of build path using the ``-p`` command-line option,; and automatic location of the compilation database using source files paths. .. code-block:: c++. #include ""clang/Tooling/CommonOptionsParser.h""; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static llvm::cl::OptionCategory MyToolCategory(""my-tool options"");. int main(int argc, const char **argv) {; // Common",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:4864,Integrability,message,message,4864,"Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());. Putting it together --- the first tool; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now we combine the two previous steps into our first real tool. A more advanced; version of this example tool is also checked into the clang tree at; ``tools/clang-check/ClangCheck.cpp``. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MAC",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:4965,Integrability,message,message,4965,"^^^^^^^^^^^^^^^^^^^. Now we combine the two previous steps into our first real tool. A more advanced; version of this example tool is also checked into the clang tree at; ``tools/clang-check/ClangCheck.cpp``. .. code-block:: c++. // Declares clang::SyntaxOnlyAction.; #include ""clang/Frontend/FrontendActions.h""; #include ""clang/Tooling/CommonOptionsParser.h""; #include ""clang/Tooling/Tooling.h""; // Declares llvm::cl::extrahelp.; #include ""llvm/Support/CommandLine.h"". using namespace clang::tooling;; using namespace llvm;. // Apply a custom category to all command-line options so that they are the; // only ones displayed.; static cl::OptionCategory MyToolCategory(""my-tool options"");. // CommonOptionsParser declares HelpMessage with a description of the common; // command-line options related to the compilation database and input files.; // It's nice to have this help message in all tools.; static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);. // A help message for this specific tool can be added afterwards.; static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS \; -Itools/clang/include -I$BD/include -Iinclude \; -Itools/clang/lib/Headers -c. As an alternative, yo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:5998,Modifiability,config,configure,5998," static cl::extrahelp MoreHelp(""\nMore help text...\n"");. int main(int argc, const char **argv) {; CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());; return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());; }. Running the tool on some code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When you check out and build clang, clang-check is already built and available; to you in bin/clang-check inside your build directory. You can run clang-check on a file in the llvm repository by specifying all the; needed parameters after a ""``--``"" separator:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check tools/clang/tools/clang-check/ClangCheck.cpp -- \; clang++ -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS \; -Itools/clang/include -I$BD/include -Iinclude \; -Itools/clang/lib/Headers -c. As an alternative, you can also configure cmake to output a compile command; database into its build directory:. .. code-block:: bash. # Alternatively to calling cmake, use ccmake, toggle to advanced mode and; # set the parameter CMAKE_EXPORT_COMPILE_COMMANDS from the UI.; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON . This creates a file called ``compile_commands.json`` in the build directory.; Now you can run :program:`clang-check` over files in the project by specifying; the build path as first argument and some source files as further positional; arguments:. .. code-block:: bash. $ cd /path/to/source/llvm; $ export BD=/path/to/build/llvm; $ $BD/bin/clang-check -p $BD tools/clang/tools/clang-check/ClangCheck.cpp. .. _libtooling_builtin_includes:. Builtin includes; ^^^^^^^^^^^^^^^^. Clang tools need their builtin headers and search for them the same way Clang; does. Thus, the default location to look for builtin headers is in a path; ``$(dirname /path/to/tool)/../lib/clang/3.3/include`` relative to the tool; binary. This works out-of-the-bo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:784,Testability,test,test,784,"==========; LibTooling; ==========. LibTooling is a library to support writing standalone tools based on Clang.; This document will provide a basic walkthrough of how to write a tool using; LibTooling. For the information on how to setup Clang Tooling for LLVM see; :doc:`HowToSetupToolingForLLVM`. Introduction; ------------. Tools built with LibTooling, like Clang Plugins, run ``FrontendActions`` over; code. .. See FIXME for a tutorial on how to write FrontendActions. In this tutorial, we'll demonstrate the different ways of running Clang's; ``SyntaxOnlyAction``, which runs a quick syntax check, over a bunch of code. Parsing a code snippet in memory; --------------------------------. If you ever wanted to run a ``FrontendAction`` over some sample code, for; example to unit test parts of the Clang AST, ``runToolOnCode`` is what you; looked for. Let me give you an example:. .. code-block:: c++. #include ""clang/Tooling/Tooling.h"". TEST(runToolOnCode, CanSyntaxCheckCode) {; // runToolOnCode returns whether the action was correctly run over the; // given code.; EXPECT_TRUE(runToolOnCode(std::make_unique<clang::SyntaxOnlyAction>(), ""class X {};""));; }. Writing a standalone tool; -------------------------. Once you unit tested your ``FrontendAction`` to the point where it cannot; possibly break, it's time to create a standalone tool. For a standalone tool; to run clang, it first needs to figure out what command line arguments to use; for a specified file. To that end we create a ``CompilationDatabase``. There; are different ways to create a compilation database, and we need to support all; of them depending on command-line options. There's the ``CommonOptionsParser``; class that takes the responsibility to parse command-line parameters related to; compilation databases and inputs, so that all tools share the implementation. Parsing common tools options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``CompilationDatabase`` can be read from a build directory or the command line.; Using ``Com",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst:1233,Testability,test,tested,1233,"oolingForLLVM`. Introduction; ------------. Tools built with LibTooling, like Clang Plugins, run ``FrontendActions`` over; code. .. See FIXME for a tutorial on how to write FrontendActions. In this tutorial, we'll demonstrate the different ways of running Clang's; ``SyntaxOnlyAction``, which runs a quick syntax check, over a bunch of code. Parsing a code snippet in memory; --------------------------------. If you ever wanted to run a ``FrontendAction`` over some sample code, for; example to unit test parts of the Clang AST, ``runToolOnCode`` is what you; looked for. Let me give you an example:. .. code-block:: c++. #include ""clang/Tooling/Tooling.h"". TEST(runToolOnCode, CanSyntaxCheckCode) {; // runToolOnCode returns whether the action was correctly run over the; // given code.; EXPECT_TRUE(runToolOnCode(std::make_unique<clang::SyntaxOnlyAction>(), ""class X {};""));; }. Writing a standalone tool; -------------------------. Once you unit tested your ``FrontendAction`` to the point where it cannot; possibly break, it's time to create a standalone tool. For a standalone tool; to run clang, it first needs to figure out what command line arguments to use; for a specified file. To that end we create a ``CompilationDatabase``. There; are different ways to create a compilation database, and we need to support all; of them depending on command-line options. There's the ``CommonOptionsParser``; class that takes the responsibility to parse command-line parameters related to; compilation databases and inputs, so that all tools share the implementation. Parsing common tools options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``CompilationDatabase`` can be read from a build directory or the command line.; Using ``CommonOptionsParser`` allows for explicit specification of a compile; command line, specification of build path using the ``-p`` command-line option,; and automatic location of the compilation database using source files paths. .. code-block:: c++. #include ""clang/Tooling/CommonOption",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LibTooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibTooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:2916,Deployability,release,release,2916,"n hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive public LTO visibility. All; other classes receive hidden LTO visibility. Classes with internal linkage; (e.g. classes declared in unnamed namespaces) also receive hidden LTO; visibility. During the LTO link, all classes with public LTO visibility but not marked with; ``[[clang::lto_visibility_public]]`` (see below) will be refined to hidden LTO; visibility when the ``--lto-whole-program-visibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and non-LTO object files, any hidden; visibility class defined in both a translation unit built with LTO and; a translation unit built without LTO must be defined with public LTO; visibility in order to avoid an ODR violation. 2. Some ABIs provide the ability to define an abstract base class without; visibility attributes in multiple linkage units and have virtual calls; to derived classes in other linkage units work correctly. One example of; this is COM on Windows platforms. If the ABI allows this, any base class; used in this ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:2434,Modifiability,plugin,plugin-opt,2434,"ses with hidden LTO; visibility. A class's LTO visibility is treated as an ODR-relevant property; of its definition, so it must be consistent between translation units. In translation units built with LTO, LTO visibility is based on the; class's symbol visibility as expressed at the source level (i.e. the; ``__attribute__((visibility(""..."")))`` attribute, or the ``-fvisibility=``; flag) or, on the Windows platform, the dllimport and dllexport attributes. When; targeting non-Windows platforms, classes with a visibility other than hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive public LTO visibility. All; other classes receive hidden LTO visibility. Classes with internal linkage; (e.g. classes declared in unnamed namespaces) also receive hidden LTO; visibility. During the LTO link, all classes with public LTO visibility but not marked with; ``[[clang::lto_visibility_public]]`` (see below) will be refined to hidden LTO; visibility when the ``--lto-whole-program-visibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:371,Performance,optimiz,optimization,371,"==============; LTO Visibility; ==============. *LTO visibility* is a property of an entity that specifies whether it can be; referenced from outside the current LTO unit. A *linkage unit* is a set of; translation units linked together into an executable or DSO, and a linkage; unit's *LTO unit* is the subset of the linkage unit that is linked together; using link-time optimization; in the case where LTO is not being used, the; linkage unit's LTO unit is empty. Each linkage unit has only a single LTO unit. The LTO visibility of a class is used by the compiler to determine which; classes the whole-program devirtualization (``-fwhole-program-vtables``) and; control flow integrity (``-fsanitize=cfi-vcall`` and ``-fsanitize=cfi-mfcall``); features apply to. These features use whole-program information, so they; require the entire class hierarchy to be visible in order to work correctly. If any translation unit in the program uses either of the whole-program; devirtualization or control flow integrity features, it is effectively an ODR; violation to define a class with hidden LTO visibility in multiple linkage; units. A class with public LTO visibility may be defined in multiple linkage; units, but the tradeoff is that the whole-program devirtualization and; control flow integrity features can only be applied to classes with hidden LTO; visibility. A class's LTO visibility is treated as an ODR-relevant property; of its definition, so it must be consistent between translation units. In translation units built with LTO, LTO visibility is based on the; class's symbol visibility as expressed at the source level (i.e. the; ``__attribute__((visibility(""..."")))`` attribute, or the ``-fvisibility=``; flag) or, on the Windows platform, the dllimport and dllexport attributes. When; targeting non-Windows platforms, classes with a visibility other than hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive publ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:2814,Safety,unsafe,unsafe,2814,"n hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive public LTO visibility. All; other classes receive hidden LTO visibility. Classes with internal linkage; (e.g. classes declared in unnamed namespaces) also receive hidden LTO; visibility. During the LTO link, all classes with public LTO visibility but not marked with; ``[[clang::lto_visibility_public]]`` (see below) will be refined to hidden LTO; visibility when the ``--lto-whole-program-visibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and non-LTO object files, any hidden; visibility class defined in both a translation unit built with LTO and; a translation unit built without LTO must be defined with public LTO; visibility in order to avoid an ODR violation. 2. Some ABIs provide the ability to define an abstract base class without; visibility attributes in multiple linkage units and have virtual calls; to derived classes in other linkage units work correctly. One example of; this is COM on Windows platforms. If the ABI allows this, any base class; used in this ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:3533,Safety,avoid,avoid,3533,"ibility`` lld linker option is; applied (``-plugin-opt=whole-program-visibility`` for gold). This flag can be; used to defer specifying whether classes have hidden LTO visibility until link; time, to allow bitcode objects to be shared by different LTO links. Due to an; implementation limitation, symbols associated with classes with hidden LTO; visibility may still be exported from the binary when using this flag. It is; unsafe to refer to these symbols, and their visibility may be relaxed to hidden; in a future compiler release. A class defined in a translation unit built without LTO receives public; LTO visibility regardless of its object file visibility, linkage or other; attributes. This mechanism will produce the correct result in most cases, but there are; two cases where it may wrongly infer hidden LTO visibility. 1. As a corollary of the above rules, if a linkage unit is produced from a; combination of LTO object files and non-LTO object files, any hidden; visibility class defined in both a translation unit built with LTO and; a translation unit built without LTO must be defined with public LTO; visibility in order to avoid an ODR violation. 2. Some ABIs provide the ability to define an abstract base class without; visibility attributes in multiple linkage units and have virtual calls; to derived classes in other linkage units work correctly. One example of; this is COM on Windows platforms. If the ABI allows this, any base class; used in this way must be defined with public LTO visibility. Classes that fall into either of these categories can be marked up with the; ``[[clang::lto_visibility_public]]`` attribute. To specifically handle the; COM case, classes with the ``__declspec(uuid())`` attribute receive public; LTO visibility. On Windows platforms, clang-cl's ``/MT`` and ``/MTd``; flags statically link the program against a prebuilt standard library;; these flags imply public LTO visibility for every class declared in the; ``std`` and ``stdext`` namespace",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:6194,Safety,avoid,avoid,6194,"den): | | dso.so (clang++ -fvisibility=hidden): |; | | | |; | +-----------------------------------------------------+ | | struct __attribute__((visibility(""default""))) C { |; | | LTO unit (clang++ -fvisibility=hidden -flto): | | | virtual void f(); |; | | | | | } |; | | struct A { ... }; | | | void C::f() {} |; | | struct [[clang::lto_visibility_public]] B { ... }; | | | struct D { |; | | struct __attribute__((visibility(""default""))) C { | | | virtual void g() = 0; |; | | virtual void f(); | | | }; |; | | }; | | | struct E : D { |; | | struct [[clang::lto_visibility_public]] D { | | | virtual void g() { ... } |; | | virtual void g() = 0; | | | }; |; | | }; | | | __attribute__((visibility(""default""))) D *mkE() { |; | | | | | return new E; |; | +-----------------------------------------------------+ | | } |; | | | |; | struct B { ... }; | +----------------------------------------------------+; | |; +-----------------------------------------------------------+. We will now describe the LTO visibility of each of the classes defined in; these linkage units. Class ``A`` is not defined outside of ``main``'s LTO unit, so it can have; hidden LTO visibility. This is inferred from the object file visibility; specified on the command line. Class ``B`` is defined in ``main``, both inside and outside its LTO unit. The; definition outside the LTO unit has public LTO visibility, so the definition; inside the LTO unit must also have public LTO visibility in order to avoid; an ODR violation. Class ``C`` is defined in both ``main`` and ``dso.so`` and therefore must; have public LTO visibility. This is correctly inferred from the ``visibility``; attribute. Class ``D`` is an abstract base class with a derived class ``E`` defined; in ``dso.so``. This is an example of the COM scenario; the definition of; ``D`` in ``main``'s LTO unit must have public LTO visibility in order to be; compatible with the definition of ``D`` in ``dso.so``, which is observable; by calling the function ``mkE``.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:676,Security,integrity,integrity,676,"==============; LTO Visibility; ==============. *LTO visibility* is a property of an entity that specifies whether it can be; referenced from outside the current LTO unit. A *linkage unit* is a set of; translation units linked together into an executable or DSO, and a linkage; unit's *LTO unit* is the subset of the linkage unit that is linked together; using link-time optimization; in the case where LTO is not being used, the; linkage unit's LTO unit is empty. Each linkage unit has only a single LTO unit. The LTO visibility of a class is used by the compiler to determine which; classes the whole-program devirtualization (``-fwhole-program-vtables``) and; control flow integrity (``-fsanitize=cfi-vcall`` and ``-fsanitize=cfi-mfcall``); features apply to. These features use whole-program information, so they; require the entire class hierarchy to be visible in order to work correctly. If any translation unit in the program uses either of the whole-program; devirtualization or control flow integrity features, it is effectively an ODR; violation to define a class with hidden LTO visibility in multiple linkage; units. A class with public LTO visibility may be defined in multiple linkage; units, but the tradeoff is that the whole-program devirtualization and; control flow integrity features can only be applied to classes with hidden LTO; visibility. A class's LTO visibility is treated as an ODR-relevant property; of its definition, so it must be consistent between translation units. In translation units built with LTO, LTO visibility is based on the; class's symbol visibility as expressed at the source level (i.e. the; ``__attribute__((visibility(""..."")))`` attribute, or the ``-fvisibility=``; flag) or, on the Windows platform, the dllimport and dllexport attributes. When; targeting non-Windows platforms, classes with a visibility other than hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive publ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:1001,Security,integrity,integrity,1001,"===; LTO Visibility; ==============. *LTO visibility* is a property of an entity that specifies whether it can be; referenced from outside the current LTO unit. A *linkage unit* is a set of; translation units linked together into an executable or DSO, and a linkage; unit's *LTO unit* is the subset of the linkage unit that is linked together; using link-time optimization; in the case where LTO is not being used, the; linkage unit's LTO unit is empty. Each linkage unit has only a single LTO unit. The LTO visibility of a class is used by the compiler to determine which; classes the whole-program devirtualization (``-fwhole-program-vtables``) and; control flow integrity (``-fsanitize=cfi-vcall`` and ``-fsanitize=cfi-mfcall``); features apply to. These features use whole-program information, so they; require the entire class hierarchy to be visible in order to work correctly. If any translation unit in the program uses either of the whole-program; devirtualization or control flow integrity features, it is effectively an ODR; violation to define a class with hidden LTO visibility in multiple linkage; units. A class with public LTO visibility may be defined in multiple linkage; units, but the tradeoff is that the whole-program devirtualization and; control flow integrity features can only be applied to classes with hidden LTO; visibility. A class's LTO visibility is treated as an ODR-relevant property; of its definition, so it must be consistent between translation units. In translation units built with LTO, LTO visibility is based on the; class's symbol visibility as expressed at the source level (i.e. the; ``__attribute__((visibility(""..."")))`` attribute, or the ``-fvisibility=``; flag) or, on the Windows platform, the dllimport and dllexport attributes. When; targeting non-Windows platforms, classes with a visibility other than hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive public LTO visi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst:1286,Security,integrity,integrity,1286,"ecutable or DSO, and a linkage; unit's *LTO unit* is the subset of the linkage unit that is linked together; using link-time optimization; in the case where LTO is not being used, the; linkage unit's LTO unit is empty. Each linkage unit has only a single LTO unit. The LTO visibility of a class is used by the compiler to determine which; classes the whole-program devirtualization (``-fwhole-program-vtables``) and; control flow integrity (``-fsanitize=cfi-vcall`` and ``-fsanitize=cfi-mfcall``); features apply to. These features use whole-program information, so they; require the entire class hierarchy to be visible in order to work correctly. If any translation unit in the program uses either of the whole-program; devirtualization or control flow integrity features, it is effectively an ODR; violation to define a class with hidden LTO visibility in multiple linkage; units. A class with public LTO visibility may be defined in multiple linkage; units, but the tradeoff is that the whole-program devirtualization and; control flow integrity features can only be applied to classes with hidden LTO; visibility. A class's LTO visibility is treated as an ODR-relevant property; of its definition, so it must be consistent between translation units. In translation units built with LTO, LTO visibility is based on the; class's symbol visibility as expressed at the source level (i.e. the; ``__attribute__((visibility(""..."")))`` attribute, or the ``-fvisibility=``; flag) or, on the Windows platform, the dllimport and dllexport attributes. When; targeting non-Windows platforms, classes with a visibility other than hidden; visibility receive public LTO visibility. When targeting Windows, classes; with dllimport or dllexport attributes receive public LTO visibility. All; other classes receive hidden LTO visibility. Classes with internal linkage; (e.g. classes declared in unnamed namespaces) also receive hidden LTO; visibility. During the LTO link, all classes with public LTO visibility but",MatchSource.DOCS,interpreter/llvm-project/clang/docs/LTOVisibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LTOVisibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:5422,Availability,avail,availability,5422,"subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of matrix type, and the; other is of a real type; or; * ``BIN_OP`` is ``/``, ``M1`` is of matrix type, and ``M2`` is of a real type:. * The usual arithmetic conversions are applied to ``M1`` and ``M2``. [ Note: if ``M1`` or; ``M2`` are of a real type, they are broadcast to matrices here. — end note ]; * ``M1`` and ``M2`` shall be of the same matrix type.; * The result is equivalent to Res in the following where col is the number of; columns and row is the number of rows in the matrix type:. .. code-block:: c++. decltype(M1) Res;; for (int C = 0; C < col; ++C); for (int R = 0; R < row; ++R); Res[R][C] = M1[R][C] BIN_OP M2[R][C];. Given the expression ``M1 * M2`` where ``M1`` and ``M2`` are of matrix type:. * ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:4821,Energy Efficiency,efficient,efficiently,4821,"respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:4743,Integrability,depend,depending,4743,"respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:7391,Integrability,contract,contraction,7391,"al arithmetic conversions are applied to ``M1`` and ``M2``.; * The type of ``M1`` shall have the same number of columns as the type of ``M2`` has; rows. The element types of ``M1`` and ``M2`` shall be the same type.; * The resulting type, ``MTy``, is a matrix type with the common element type,; the number of rows of ``M1`` and the number of columns of ``M2``.; * The result is equivalent to ``Res`` in the following where ``EltTy`` is the; element type of ``MTy``, ``col`` is the number of columns, ``row`` is the; number of rows in ``MTy`` and ``inner`` is the number of columns of ``M1``:. .. code-block:: c++. MTy Res;; for (int C = 0; C < col; ++C) {; for (int R = 0; R < row; ++R) {; EltTy Elt = 0;; for (int K = 0; K < inner; ++K) {; Elt += M1[R][K] * M2[K][C];; }; Res[R][C] = Elt;; }. All operations on matrix types match the behavior of the element type with; respect to signed overflows. With respect to floating-point contraction, rounding and environment rules,; operations on matrix types match the behavior of the elementwise operations; in the corresponding expansions provided above. Operations on floating-point matrices have the same rounding and floating-point; environment behavior as ordinary floating-point operations in the expression's; context. For the purposes of floating-point contraction, all calculations done; as part of a matrix operation are considered intermediate operations, and their; results need not be rounded to the format of the element type until the final; result in the containing expression. This is subject to the normal restrictions; on contraction, such as ``#pragma STDC FP_CONTRACT``. For the ``+=``, ``-=`` and ``*=`` operators the semantics match their expanded; variants. Matrix Type Builtin Operations; ------------------------------. Each matrix type supports a collection of builtin expressions that look like; function calls but do not form an overload set. Here they are described as; function declarations with rules for how to construct ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:7767,Integrability,contract,contraction,7767,"he following where ``EltTy`` is the; element type of ``MTy``, ``col`` is the number of columns, ``row`` is the; number of rows in ``MTy`` and ``inner`` is the number of columns of ``M1``:. .. code-block:: c++. MTy Res;; for (int C = 0; C < col; ++C) {; for (int R = 0; R < row; ++R) {; EltTy Elt = 0;; for (int K = 0; K < inner; ++K) {; Elt += M1[R][K] * M2[K][C];; }; Res[R][C] = Elt;; }. All operations on matrix types match the behavior of the element type with; respect to signed overflows. With respect to floating-point contraction, rounding and environment rules,; operations on matrix types match the behavior of the elementwise operations; in the corresponding expansions provided above. Operations on floating-point matrices have the same rounding and floating-point; environment behavior as ordinary floating-point operations in the expression's; context. For the purposes of floating-point contraction, all calculations done; as part of a matrix operation are considered intermediate operations, and their; results need not be rounded to the format of the element type until the final; result in the containing expression. This is subject to the normal restrictions; on contraction, such as ``#pragma STDC FP_CONTRACT``. For the ``+=``, ``-=`` and ``*=`` operators the semantics match their expanded; variants. Matrix Type Builtin Operations; ------------------------------. Each matrix type supports a collection of builtin expressions that look like; function calls but do not form an overload set. Here they are described as; function declarations with rules for how to construct the argument list types; and return type and the library description elements from; [library.description.structure.specifications]/3 in the C++ standard. Definitions:. * *M*, *M1*, *M2*, *M3* - Matrix types; * *T* - Element type; * *row*, *col* - Row and column arguments respectively. ``M2 __builtin_matrix_transpose(M1 matrix)``. **Remarks**: The return type is a cv-unqualified matrix type that has the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:8047,Integrability,contract,contraction,8047,"1``:. .. code-block:: c++. MTy Res;; for (int C = 0; C < col; ++C) {; for (int R = 0; R < row; ++R) {; EltTy Elt = 0;; for (int K = 0; K < inner; ++K) {; Elt += M1[R][K] * M2[K][C];; }; Res[R][C] = Elt;; }. All operations on matrix types match the behavior of the element type with; respect to signed overflows. With respect to floating-point contraction, rounding and environment rules,; operations on matrix types match the behavior of the elementwise operations; in the corresponding expansions provided above. Operations on floating-point matrices have the same rounding and floating-point; environment behavior as ordinary floating-point operations in the expression's; context. For the purposes of floating-point contraction, all calculations done; as part of a matrix operation are considered intermediate operations, and their; results need not be rounded to the format of the element type until the final; result in the containing expression. This is subject to the normal restrictions; on contraction, such as ``#pragma STDC FP_CONTRACT``. For the ``+=``, ``-=`` and ``*=`` operators the semantics match their expanded; variants. Matrix Type Builtin Operations; ------------------------------. Each matrix type supports a collection of builtin expressions that look like; function calls but do not form an overload set. Here they are described as; function declarations with rules for how to construct the argument list types; and return type and the library description elements from; [library.description.structure.specifications]/3 in the C++ standard. Definitions:. * *M*, *M1*, *M2*, *M3* - Matrix types; * *T* - Element type; * *row*, *col* - Row and column arguments respectively. ``M2 __builtin_matrix_transpose(M1 matrix)``. **Remarks**: The return type is a cv-unqualified matrix type that has the same; element type as ``M1`` and has the same number of rows as ``M1`` has columns and; the same number of columns as ``M1`` has rows. **Returns**: A matrix ``Res`` equivalent to the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:11297,Integrability,contract,contraction,11297,"``row`` and ``col`` shall be integral constants greater than 0. **Preconditions**: ``columnStride`` is greater than or equal to ``row``. **Remarks**: The return type is a cv-unqualified matrix type with an element; type of the cv-unqualified version of ``T`` and a number of rows and columns equal; to ``row`` and ``col`` respectively. The parameter ``columnStride`` is optional; and if omitted ``row`` is used as ``columnStride``. **Returns**: A matrix ``Res`` equivalent to:. .. code-block:: c++. M Res;; for (size_t C = 0; C < col; ++C) {; for (size_t R = 0; R < row; ++K); Res[R][C] = ptr[R];; ptr += columnStride; }. ``void __builtin_matrix_column_major_store(M matrix, T *ptr, size_t columnStride)``. **Preconditions**: ``columnStride`` is greater than or equal to the number of rows in ``M``. **Remarks**: The type ``T`` is the const-unqualified version of the matrix; argument’s element type. The parameter ``columnStride`` is optional and if; omitted, the number of rows of ``M`` is used as ``columnStride``. **Effects**: Equivalent to:. .. code-block:: c++. for (size_t C = 0; C < columns in M; ++C) {; for (size_t R = 0; R < rows in M; ++K); ptr[R] = matrix[R][C];; ptr += columnStride; }. TODOs; -----. TODO: Does it make sense to allow M::element_type, M::rows, and M::columns; where M is a matrix type? We don’t support this anywhere else, but it’s; convenient. The alternative is using template deduction to extract this; information. Also add spelling for C. Future Work: Initialization syntax. Decisions for the Implementation in Clang; =========================================. This section details decisions taken for the implementation in Clang and is not; part of the draft specification. The elements of a value of a matrix type are laid out in column-major order; without padding. We propose to provide a Clang option to override this behavior and allow; contraction of those operations (e.g. *-ffp-contract=matrix*). TODO: Specify how matrix values are passed to functions.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:11341,Integrability,contract,contract,11341,"``row`` and ``col`` shall be integral constants greater than 0. **Preconditions**: ``columnStride`` is greater than or equal to ``row``. **Remarks**: The return type is a cv-unqualified matrix type with an element; type of the cv-unqualified version of ``T`` and a number of rows and columns equal; to ``row`` and ``col`` respectively. The parameter ``columnStride`` is optional; and if omitted ``row`` is used as ``columnStride``. **Returns**: A matrix ``Res`` equivalent to:. .. code-block:: c++. M Res;; for (size_t C = 0; C < col; ++C) {; for (size_t R = 0; R < row; ++K); Res[R][C] = ptr[R];; ptr += columnStride; }. ``void __builtin_matrix_column_major_store(M matrix, T *ptr, size_t columnStride)``. **Preconditions**: ``columnStride`` is greater than or equal to the number of rows in ``M``. **Remarks**: The type ``T`` is the const-unqualified version of the matrix; argument’s element type. The parameter ``columnStride`` is optional and if; omitted, the number of rows of ``M`` is used as ``columnStride``. **Effects**: Equivalent to:. .. code-block:: c++. for (size_t C = 0; C < columns in M; ++C) {; for (size_t R = 0; R < rows in M; ++K); ptr[R] = matrix[R][C];; ptr += columnStride; }. TODOs; -----. TODO: Does it make sense to allow M::element_type, M::rows, and M::columns; where M is a matrix type? We don’t support this anywhere else, but it’s; convenient. The alternative is using template deduction to extract this; information. Also add spelling for C. Future Work: Initialization syntax. Decisions for the Implementation in Clang; =========================================. This section details decisions taken for the implementation in Clang and is not; part of the draft specification. The elements of a value of a matrix type are laid out in column-major order; without padding. We propose to provide a Clang option to override this behavior and allow; contraction of those operations (e.g. *-ffp-contract=matrix*). TODO: Specify how matrix values are passed to functions.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:2237,Modifiability,extend,extended,2237,"floating point type, if one is supported on the target. Other types may be supported in the future. Matrix Type Attribute; ---------------------. Matrix types can be declared by adding the ``matrix_type`` attribute to the; declaration of a *typedef* (or a C++ alias declaration). The underlying type; of the *typedef* must be a valid matrix element type. The; attribute takes two arguments, both of which must be integer constant; expressions that evaluate to a value greater than zero. The first specifies the; number of rows, and the second specifies the number of columns. The underlying; type of the *typedef* becomes a matrix type with the given dimensions and an; element type of the former underlying type. If a declaration of a *typedef-name* has a ``matrix_type`` attribute, then all; declaration of that *typedef-name* shall have a matrix_type attribute with the; same element type, number of rows, and number of columns. Standard Conversions; --------------------. The standard conversions are extended as follows. Note that these conversions; are intentionally not listed as satisfying the constraints for assignment,; which is to say, they are only permitted as explicit casts, not as implicit; conversions. A value of matrix type can be converted to another matrix type if the number of; rows and columns are the same and the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithme",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:3140,Modifiability,extend,extended,3140," of rows, and number of columns. Standard Conversions; --------------------. The standard conversions are extended as follows. Note that these conversions; are intentionally not listed as satisfying the constraints for assignment,; which is to say, they are only permitted as explicit casts, not as implicit; conversions. A value of matrix type can be converted to another matrix type if the number of; rows and columns are the same and the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithmetic conversion is performed.; * If one operand is of matrix type and the other operand is of a real type,; convert the real type operand to the matrix type; according to the standard conversion rules. Matrix Type Element Access Operator; -----------------------------------. An expression of the form ``E1 [E2] [E3]``, where ``E1`` has matrix type ``cv; M``, is a matrix element access expression. Let ``T`` be the element type; of ``M``, and let ``R`` and ``C`` be the number of rows and columns in ``M``; respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:234,Performance,perform,perform,234,"==================; Matrix Types; ==================. .. contents::; :local:. .. _matrixtypes:. Clang provides a C/C++ language extension that allows users to directly express; fixed-size 2-dimensional matrices as language values and perform arithmetic on; them. This feature is currently experimental, and both its design and its; implementation are in flux. Draft Specification; ===================. Matrix Type; -----------. A matrix type is a scalar type with an underlying *element type*, a constant; number of *rows*, and a constant number of *columns*. Matrix types with the same; element type, rows, and columns are the same type. A value of a matrix type; includes storage for ``rows * columns`` values of the *element type*. The; internal layout, overall size and alignment are implementation-defined. The maximum of the product of the number of rows and columns is; implementation-defined. If that implementation-defined limit is exceeded, the; program is ill-formed. Currently, the element type of a matrix is only permitted to be one of the; following types:. * an integer type (as in C23 6.2.5p22), but excluding enumerated types and ``bool``; * the standard floating types ``float`` or ``double``; * a half-precision floating point type, if one is supported on the target. Other types may be supported in the future. Matrix Type Attribute; ---------------------. Matrix types can be declared by adding the ``matrix_type`` attribute to the; declaration of a *typedef* (or a C++ alias declaration). The underlying type; of the *typedef* must be a valid matrix element type. The; attribute takes two arguments, both of which must be integer constant; expressions that evaluate to a value greater than zero. The first specifies the; number of rows, and the second specifies the number of columns. The underlying; type of the *typedef* becomes a matrix type with the given dimensions and an; element type of the former underlying type. If a declaration of a *typedef-name* has a ``matrix_typ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:3250,Performance,perform,performed,3250,"conversions are extended as follows. Note that these conversions; are intentionally not listed as satisfying the constraints for assignment,; which is to say, they are only permitted as explicit casts, not as implicit; conversions. A value of matrix type can be converted to another matrix type if the number of; rows and columns are the same and the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithmetic conversion is performed.; * If one operand is of matrix type and the other operand is of a real type,; convert the real type operand to the matrix type; according to the standard conversion rules. Matrix Type Element Access Operator; -----------------------------------. An expression of the form ``E1 [E2] [E3]``, where ``E1`` has matrix type ``cv; M``, is a matrix element access expression. Let ``T`` be the element type; of ``M``, and let ``R`` and ``C`` be the number of rows and columns in ``M``; respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the give",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:5084,Performance,perform,perform,5084,"r. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of matrix type, and the; other is of a real type; or; * ``BIN_OP`` is ``/``, ``M1`` is of matrix type, and ``M2`` is of a real type:. * The usual arithmetic conversions are applied to ``M1`` and ``M2``. [ Note: if ``M1`` or; ``M2`` are of a real type, they are broadcast to matrices here. — end note ]; * ``M1`` and ``M2`` shall be of the same matrix type.; * The result is e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:5157,Performance,perform,performs,5157,"r. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of matrix type, and the; other is of a real type; or; * ``BIN_OP`` is ``/``, ``M1`` is of matrix type, and ``M2`` is of a real type:. * The usual arithmetic conversions are applied to ``M1`` and ``M2``. [ Note: if ``M1`` or; ``M2`` are of a real type, they are broadcast to matrices here. — end note ]; * ``M1`` and ``M2`` shall be of the same matrix type.; * The result is e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:3611,Security,access,access,3611," the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithmetic conversion is performed.; * If one operand is of matrix type and the other operand is of a real type,; convert the real type operand to the matrix type; according to the standard conversion rules. Matrix Type Element Access Operator; -----------------------------------. An expression of the form ``E1 [E2] [E3]``, where ``E1`` has matrix type ``cv; M``, is a matrix element access expression. Let ``T`` be the element type; of ``M``, and let ``R`` and ``C`` be the number of rows and columns in ``M``; respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:4604,Security,access,access,4604," matrix type ``cv; M``, is a matrix element access expression. Let ``T`` be the element type; of ``M``, and let ``R`` and ``C`` be the number of rows and columns in ``M``; respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:4782,Security,access,accessing,4782,"respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:5409,Testability,test,test,5409,"subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of matrix type, and the; other is of a real type; or; * ``BIN_OP`` is ``/``, ``M1`` is of matrix type, and ``M2`` is of a real type:. * The usual arithmetic conversions are applied to ``M1`` and ``M2``. [ Note: if ``M1`` or; ``M2`` are of a real type, they are broadcast to matrices here. — end note ]; * ``M1`` and ``M2`` shall be of the same matrix type.; * The result is equivalent to Res in the following where col is the number of; columns and row is the number of rows in the matrix type:. .. code-block:: c++. decltype(M1) Res;; for (int C = 0; C < col; ++C); for (int R = 0; R < row; ++R); Res[R][C] = M1[R][C] BIN_OP M2[R][C];. Given the expression ``M1 * M2`` where ``M1`` and ``M2`` are of matrix type:. * ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MatrixTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:730,Availability,error,errors,730,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:865,Availability,error,error,865,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1343,Availability,error,error,1343,"<https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; at",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1643,Availability,error,error,1643,"p. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1667,Availability,error,error,1667,"`-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``__has_feature(memory_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:3051,Availability,toler,tolerate,3051,"n be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``__has_feature(memory_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and therefore should be used with care, and only if absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; considered fully initialized. Report symbolization; ====================. MemorySanitizer uses an external symbolizer to print files and line numbers in; reports. Make sure that ``llvm-symbolizer`` binary is in ``PATH``,; or set environment variable ``MSAN_SYMBOLIZER_PATH`` to point to it. .. _msan-origins:. Origin Tracking; ===============. MemorySanitizer can track origins of uninitialized values, similar to; Valgrind's --track-origins option. This feature is enabled by; ``-fsanitize-memory-track-origins=2`` (or sim",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5071,Availability,down,down,5071,"above,. .. code-block:: console. % cat umr2.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; volatile int b = a[argc];; if (b); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fsanitize-memory-track-origins=2 -fno-omit-frame-pointer -g -O2 umr2.cc; % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f7893912f0b in main umr2.cc:7; #1 0x7f789249b76c in __libc_start_main libc-start.c:226. Uninitialized value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized value was created by a heap allocation; #0 0x7f7893901cbd in operator new[](unsigned long) msan_new_delete.cc:44; #1 0x7f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5613,Availability,error,error,5613,"d value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized value was created by a heap allocation; #0 0x7f7893901cbd in operator new[](unsigned long) msan_new_delete.cc:44; #1 0x7f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:871,Integrability,message,messages,871,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1349,Integrability,message,message,1349,"<https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; at",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1881,Integrability,depend,depending,1881,"s add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``__has_feature(memory_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrum",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:6116,Integrability,depend,depends,6116,"ctor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. MemorySanitizer is supported on the following OS:. * Linux; * NetBSD; * FreeBSD. Limitations; ===========. * MemorySanitizer uses 2x more real memory than a native run, 3x with; origin tracking.; * MemorySanitizer maps (but not reserves) 64 Terabytes of virtual; address space. This mean",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:7771,Integrability,depend,dependent,7771,"`MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. MemorySanitizer is supported on the following OS:. * Linux; * NetBSD; * FreeBSD. Limitations; ===========. * MemorySanitizer uses 2x more real memory than a native run, 3x with; origin tracking.; * MemorySanitizer maps (but not reserves) 64 Terabytes of virtual; address space. This means that tools like ``ulimit`` may not work as; usually expected.; * Static linking is not supported.; * Older versions of MSan (LLVM 3.7 and older) didn't work with; non-position-independent executables, and could fail on some Linux; kernel versions with disabled ASLR. Refer to documentation for older versions; for more details.; * MemorySanitizer might be incompatible with position-independent executables; from FreeBSD 13 but there is a check done at runtime and throws a warning; in this case. Current Status; ==============. MemorySanitizer is known to work on large real-world programs; (like Clang/LLVM itself) that can be recompiled from source, including all; dependent libraries. More Information; ================. `<https://github.com/google/sanitizers/wiki/MemorySanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:3716,Modifiability,variab,variable,3716,"on))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and therefore should be used with care, and only if absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; considered fully initialized. Report symbolization; ====================. MemorySanitizer uses an external symbolizer to print files and line numbers in; reports. Make sure that ``llvm-symbolizer`` binary is in ``PATH``,; or set environment variable ``MSAN_SYMBOLIZER_PATH`` to point to it. .. _msan-origins:. Origin Tracking; ===============. MemorySanitizer can track origins of uninitialized values, similar to; Valgrind's --track-origins option. This feature is enabled by; ``-fsanitize-memory-track-origins=2`` (or simply; ``-fsanitize-memory-track-origins``) Clang option. With the code from; the example above,. .. code-block:: console. % cat umr2.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; volatile int b = a[argc];; if (b); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fsanitize-memory-track-origins=2 -fno-omit-frame-pointer -g -O2 umr2.cc; % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f7893912f0b in main umr2.cc:7; #1 0x7f789249b76c in __libc_start_main libc-start.c:226. Uninitialized value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized val",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5883,Modifiability,variab,variable,5883,"and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. MemorySanitizer is supported on the following OS:. * Linux; * NetBSD; * FreeBSD. Limitations; =",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:795,Performance,perform,performance,795,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1030,Performance,optimiz,optimize-sibling-calls,1030,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:3447,Performance,load,loaded,3447,"tion. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``__has_feature(memory_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and therefore should be used with care, and only if absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; considered fully initialized. Report symbolization; ====================. MemorySanitizer uses an external symbolizer to print files and line numbers in; reports. Make sure that ``llvm-symbolizer`` binary is in ``PATH``,; or set environment variable ``MSAN_SYMBOLIZER_PATH`` to point to it. .. _msan-origins:. Origin Tracking; ===============. MemorySanitizer can track origins of uninitialized values, similar to; Valgrind's --track-origins option. This feature is enabled by; ``-fsanitize-memory-track-origins=2`` (or simply; ``-fsanitize-memory-track-origins``) Clang option. With the code from; the example above,. .. code-block:: console. % cat umr2.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; volatile int b = a[argc];; if (b); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fsanitize-memory-track-origins=2 -fno-omit-frame-pointer -g -O2 umr2.cc; % ./a.out; WARNING: MemorySanitizer: use-of-unin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:126,Safety,detect,detector,126,"================; MemorySanitizer; ================. .. contents::; :local:. Introduction; ============. MemorySanitizer is a detector of uninitialized reads. It consists of a; compiler instrumentation module and a run-time library. Typical slowdown introduced by MemorySanitizer is **3x**. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1307,Safety,detect,detected,1307,"<https://llvm.org/docs/CMake.html>`_. Usage; =====. Simply compile and link your program with ``-fsanitize=memory`` flag.; The MemorySanitizer run-time library should be linked to the final; executable, so make sure to use ``clang`` (not ``ld``) for the final; link step. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; at",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:1634,Safety,detect,detected,1634,"p. When linking shared libraries, the MemorySanitizer run-time; is not linked, so ``-Wl,-z,defs`` may cause link errors (don't use it; with MemorySanitizer). To get a reasonable performance add ``-O1`` or; higher. To get meaningful stack traces in error messages add; ``-fno-omit-frame-pointer``. To get perfect stack traces you may need; to disable inlining (just use ``-O1``) and tail call elimination; (``-fno-optimize-sibling-calls``). .. code-block:: console. % cat umr.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; if (a[argc]); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fno-omit-frame-pointer -g -O2 umr.cc. If a bug is detected, the program will print an error message to; stderr and exit with a non-zero exit code. .. code-block:: console. % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:2498,Safety,avoid,avoid,2498,"alized-value; #0 0x7f45944b418a in main umr.cc:6; #1 0x7f45938b676c in __libc_start_main libc-start.c:226. By default, MemorySanitizer exits on the first detected error. If you; find the error report hard to understand, try enabling; :ref:`origin tracking <msan-origins>`. ``__has_feature(memory_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on; whether MemorySanitizer is enabled. :ref:`\_\_has\_feature; <langext-__has_feature-__has_extension>` can be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(memory_sanitizer); // code that builds only under MemorySanitizer; # endif; #endif. ``__attribute__((no_sanitize(""memory"")))``; -----------------------------------------------. Some code should not be checked by MemorySanitizer. One may use the function; attribute ``no_sanitize(""memory"")`` to disable uninitialized checks in a; particular function. MemorySanitizer may still instrument such functions to; avoid false positives. This attribute may not be supported by other compilers,; so we suggest to use it together with ``__has_feature(memory_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and therefore should be used with care, and only if absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; consid",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5382,Safety,detect,detection,5382,"/a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f7893912f0b in main umr2.cc:7; #1 0x7f789249b76c in __libc_start_main libc-start.c:226. Uninitialized value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized value was created by a heap allocation; #0 0x7f7893901cbd in operator new[](unsigned long) msan_new_delete.cc:44; #1 0x7f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it eas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5473,Safety,detect,detection,5473,"#0 0x7f7893912f0b in main umr2.cc:7; #1 0x7f789249b76c in __libc_start_main libc-start.c:226. Uninitialized value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized value was created by a heap allocation; #0 0x7f7893901cbd in operator new[](unsigned long) msan_new_delete.cc:44; #1 0x7f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5809,Security,sanitiz,sanitize-memory-use-after-dtor,5809,"f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. Memo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:7856,Security,sanitiz,sanitizers,7856,"`MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. MemorySanitizer is supported on the following OS:. * Linux; * NetBSD; * FreeBSD. Limitations; ===========. * MemorySanitizer uses 2x more real memory than a native run, 3x with; origin tracking.; * MemorySanitizer maps (but not reserves) 64 Terabytes of virtual; address space. This means that tools like ``ulimit`` may not work as; usually expected.; * Static linking is not supported.; * Older versions of MSan (LLVM 3.7 and older) didn't work with; non-position-independent executables, and could fail on some Linux; kernel versions with disabled ASLR. Refer to documentation for older versions; for more details.; * MemorySanitizer might be incompatible with position-independent executables; from FreeBSD 13 but there is a check done at runtime and throws a warning; in this case. Current Status; ==============. MemorySanitizer is known to work on large real-world programs; (like Clang/LLVM itself) that can be recompiled from source, including all; dependent libraries. More Information; ================. `<https://github.com/google/sanitizers/wiki/MemorySanitizer>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:3995,Usability,simpl,simply,3995,"absolutely; required; for example for certain code that cannot tolerate any instrumentation; and resulting side-effects. This attribute overrides ``no_sanitize(""memory"")``. Ignorelist; ----------. MemorySanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to relax MemorySanitizer; checks for certain source files and functions. All ""Use of uninitialized value""; warnings will be suppressed and all values loaded from memory will be; considered fully initialized. Report symbolization; ====================. MemorySanitizer uses an external symbolizer to print files and line numbers in; reports. Make sure that ``llvm-symbolizer`` binary is in ``PATH``,; or set environment variable ``MSAN_SYMBOLIZER_PATH`` to point to it. .. _msan-origins:. Origin Tracking; ===============. MemorySanitizer can track origins of uninitialized values, similar to; Valgrind's --track-origins option. This feature is enabled by; ``-fsanitize-memory-track-origins=2`` (or simply; ``-fsanitize-memory-track-origins``) Clang option. With the code from; the example above,. .. code-block:: console. % cat umr2.cc; #include <stdio.h>. int main(int argc, char** argv) {; int* a = new int[10];; a[5] = 0;; volatile int b = a[argc];; if (b); printf(""xx\n"");; return 0;; }. % clang -fsanitize=memory -fsanitize-memory-track-origins=2 -fno-omit-frame-pointer -g -O2 umr2.cc; % ./a.out; WARNING: MemorySanitizer: use-of-uninitialized-value; #0 0x7f7893912f0b in main umr2.cc:7; #1 0x7f789249b76c in __libc_start_main libc-start.c:226. Uninitialized value was stored to memory at; #0 0x7f78938b5c25 in __msan_chain_origin msan.cc:484; #1 0x7f7893912ecd in main umr2.cc:6. Uninitialized value was created by a heap allocation; #0 0x7f7893901cbd in operator new[](unsigned long) msan_new_delete.cc:44; #1 0x7f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; track",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1742,Availability,toler,tolerate,1742,"isExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a valu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1823,Availability,toler,tolerance,1823,"t``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. Mi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1962,Availability,toler,tolerance,1962,"ks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+------------------------------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:2150,Availability,avail,available,2150,"for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+--------------------------------------------------------------------------------------+; | Profile Type | Description |; +================+======================================================================================+; | Frontend | Profiling",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:2586,Availability,toler,tolerance,2586,"at can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+--------------------------------------------------------------------------------------+; | Profile Type | Description |; +================+======================================================================================+; | Frontend | Profiling instrumentation added during compilation by the frontend, i.e. ``clang`` |; +----------------+--------------------------------------------------------------------------------------+; | IR | Profiling instrumentation added during by the LLVM backend |; +----------------+--------------------------------------------------------------------------------------+; | CS-IR | Context Sensitiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:2629,Availability,toler,tolerate,2629,"o strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+--------------------------------------------------------------------------------------+; | Profile Type | Description |; +================+======================================================================================+; | Frontend | Profiling instrumentation added during compilation by the frontend, i.e. ``clang`` |; +----------------+--------------------------------------------------------------------------------------+; | IR | Profiling instrumentation added during by the LLVM backend |; +----------------+--------------------------------------------------------------------------------------+; | CS-IR | Context Sensitive IR based profiles |; +----------------+------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:2003,Integrability,message,messages,2003,"ks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+------------------------------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:280,Performance,optimiz,optimizer,280,"===================; Misexpect; ===================; .. contents::. .. toctree::; :maxdepth: 1. When developers use ``llvm.expect`` intrinsics, i.e., through use of; ``__builtin_expect(...)``, they are trying to communicate how their code is; expected to behave at runtime to the optimizer. These annotations, however, can; be incorrect for a variety of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnosti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:650,Performance,optimiz,optimizer,650,"===================; Misexpect; ===================; .. contents::. .. toctree::; :maxdepth: 1. When developers use ``llvm.expect`` intrinsics, i.e., through use of; ``__builtin_expect(...)``, they are trying to communicate how their code is; expected to behave at runtime to the optimizer. These annotations, however, can; be incorrect for a variety of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnosti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1283,Performance,optimiz,optimizer,1283,"ty of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for mi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1343,Performance,perform,performance,1343,"ty of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for mi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:2175,Performance,optimiz,optimization,2175,"for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+--------------------------------------------------------------------------------------+; | Profile Type | Description |; +================+======================================================================================+; | Frontend | Profiling",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:2322,Performance,optimiz,optimization,2322,"dation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for misexpect when profiling data conflicts with; use of ``llvm.expect`` intrinsics. .. option:: -Wmisexpect. Enables misexpect warnings when profiling data conflicts with use of; ``llvm.expect`` intrinsics. .. option:: -fdiagnostic-misexpect-tolerance=N. Relaxes misexpect checking to tolerate profiling values within N% of the; expected branch weight. e.g., a value of ``N=5`` allows misexpect to check against; ``0.95 * Threshold``. LLVM supports 4 types of profile formats: Frontend, IR, CS-IR, and; Sampling. MisExpect Diagnostics are compatible with all Profiling formats. +----------------+--------------------------------------------------------------------------------------+; | Profile Type | Description |; +================+======================================================================================+; | Frontend | Profiling instrumentation added during compilation by the frontend, i.e. ``clang`` |; +----------------+---------------------------------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:613,Safety,detect,detect,613,"===================; Misexpect; ===================; .. contents::. .. toctree::; :maxdepth: 1. When developers use ``llvm.expect`` intrinsics, i.e., through use of; ``__builtin_expect(...)``, they are trying to communicate how their code is; expected to behave at runtime to the optimizer. These annotations, however, can; be incorrect for a variety of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnosti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst:1391,Safety,predict,predictable,1391,"ty of reasons: changes to the code base invalidate them; silently, the developer mis-annotated them (e.g., using ``LIKELY`` instead of; ``UNLIKELY``), or perhaps they assumed something incorrectly when they wrote; the annotation. Regardless of why, it is useful to detect these situations so; that the optimizer can make more useful decisions about the code. MisExpect diagnostics are intended to help developers identify and address; these situations, by comparing the branch weights added by the ``llvm.expect``; intrinsic to those collected through profiling. Whenever these values are; mismatched, a diagnostic is surfaced to the user. Details on how the checks; operate in the LLVM backed can be found in LLVM's documentation. By default MisExpect checking is quite strict, because the use of the; ``llvm.expect`` intrinsic is designed for specialized cases, where the outcome; of a condition is severely skewed. As a result, the optimizer can be extremely; aggressive, which can result in performance degradation if the outcome is less; predictable than the annotation suggests. Even when the annotation is correct; 90% of the time, it may be beneficial to either remove the annotation or to use; a different intrinsic that can communicate the probability more directly. Because this may be too strict, MisExpect diagnostics are not enabled by; default, and support an additional flag to tolerate some deviation from the; exact thresholds. The ``-fdiagnostic-misexpect-tolerance=N`` accepts; deviations when comparing branch weights within ``N%`` of the expected values.; So passing ``-fdiagnostic-misexpect-tolerance=5`` will not report diagnostic messages; if the branch weight from the profile is within 5% of the weight added by; the ``llvm.expect`` intrinsic. MisExpect diagnostics are also available in the form of optimization remarks,; which can be serialized and processed through the ``opt-viewer.py``; scripts in LLVM. .. option:: -Rpass=misexpect. Enables optimization remarks for mi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MisExpect.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MisExpect.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:1379,Availability,redundant,redundant,1379,"oth its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the hea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2043,Availability,failure,failures,2043,"ed by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2224,Availability,failure,failures,2224,"eprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:3991,Availability,robust,robust,3991,"evelopers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresponding ``#include <stdio.h>``: when the compiler sees the module import above, it loads a binary representation of the ``std.io`` module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preproce",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:4502,Availability,avail,available,4502,"ose headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresponding ``#include <stdio.h>``: when the compiler sees the module import above, it loads a binary representation of the ``std.io`` module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preprocessor inclusion model:. * **Compile-time scalability**: The ``std.io`` module is only compiled once, and importing the module into a translation unit is a constant-time operation (independent of module system). Thus, the API of each software library is only parsed once, reducing the *M x N* compilation problem to an *M + N* problem. * **Fragility**: Each module is parsed as a standalone entity, so it has a consistent preprocessor environment. This completely eliminates the need for ``__underscored`` names and similarly defensive tricks. Moreover, the current preprocess",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:7783,Availability,avail,available,7783," version information. Programmers must still rely on the existing versioning mechanisms of the underlying language (if any exist) to version software libraries. * **Namespaces**: Unlike in some languages, modules do not imply any notion of namespaces. Thus, a struct declared in one module will still conflict with a struct of the same name declared in a different module, just as they would if declared in two different headers. This aspect is important for backward compatibility, because (for example) the mangled names of entities in software libraries must not change when introducing modules. * **Binary distribution of modules**: Headers (particularly C++ headers) expose the full complexity of the language. Maintaining a stable binary module format across architectures, compiler versions, and compiler vendors is technically infeasible. Using Modules; =============; To enable modules, pass the command-line flag ``-fmodules``. This will make any modules-enabled software libraries available as modules as well as introducing any modules-specific syntax. Additional `command-line parameters`_ are described in a separate section later. Standard C++ Modules; --------------------; .. note::; Modules are adopted into C++20 Standard. And its semantic and command line interface are very different from the Clang C++ modules. See `StandardCPlusPlusModules <StandardCPlusPlusModules.html>`_ for details. Objective-C Import declaration; ------------------------------; Objective-C provides syntax for importing a module via an *@import declaration*, which imports the named module:. .. parsed-literal::. @import std;. The ``@import`` declaration above imports the entire contents of the ``std`` module (which would contain, e.g., the entire C or C++ standard library) and make its API available within the current translation unit. To import only part of a module, one may use dot syntax to specific a particular submodule, e.g.,. .. parsed-literal::. @import std.io;. Redundant import declaratio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:8581,Availability,avail,available,8581,"iler versions, and compiler vendors is technically infeasible. Using Modules; =============; To enable modules, pass the command-line flag ``-fmodules``. This will make any modules-enabled software libraries available as modules as well as introducing any modules-specific syntax. Additional `command-line parameters`_ are described in a separate section later. Standard C++ Modules; --------------------; .. note::; Modules are adopted into C++20 Standard. And its semantic and command line interface are very different from the Clang C++ modules. See `StandardCPlusPlusModules <StandardCPlusPlusModules.html>`_ for details. Objective-C Import declaration; ------------------------------; Objective-C provides syntax for importing a module via an *@import declaration*, which imports the named module:. .. parsed-literal::. @import std;. The ``@import`` declaration above imports the entire contents of the ``std`` module (which would contain, e.g., the entire C or C++ standard library) and make its API available within the current translation unit. To import only part of a module, one may use dot syntax to specific a particular submodule, e.g.,. .. parsed-literal::. @import std.io;. Redundant import declarations are ignored, and one is free to import modules at any point within the translation unit, so long as the import declaration is at global scope. At present, there is no C or C++ syntax for import declarations. Clang; will track the modules proposal in the C++ committee. See the section; `Includes as imports`_ to see how modules get imported today. Includes as imports; -------------------; The primary user-level feature of modules is the import operation, which provides access to the API of software libraries. However, today's programs make extensive use of ``#include``, and it is unrealistic to assume that all of this code will change overnight. Instead, modules automatically translate ``#include`` directives into the corresponding module import. For example, the include d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:10435,Availability,error,error,10435,"'s programs make extensive use of ``#include``, and it is unrealistic to assume that all of this code will change overnight. Instead, modules automatically translate ``#include`` directives into the corresponding module import. For example, the include directive. .. code-block:: c. #include <stdio.h>. will be automatically mapped to an import of the module ``std.io``. Even with specific ``import`` syntax in the language, this particular feature is important for both adoption and backward compatibility: automatic translation of ``#include`` to ``import`` allows an application to get the benefits of modules (for all modules-enabled libraries) without any changes to the application itself. Thus, users can easily use modules with one compiler while falling back to the preprocessor-inclusion mechanism with other compilers. .. note::. The automatic mapping of ``#include`` to ``import`` also solves an implementation problem: importing a module with a definition of some entity (say, a ``struct Point``) and then parsing a header containing another definition of ``struct Point`` would cause a redefinition error, even if it is the same ``struct Point``. By mapping ``#include`` to ``import``, the compiler can guarantee that it always sees just the already-parsed definition from the module. While building a module, ``#include_next`` is also supported, with one caveat.; The usual behavior of ``#include_next`` is to search for the specified filename; in the list of include paths, starting from the path *after* the one; in which the current file was found.; Because files listed in module maps are not found through include paths, a; different strategy is used for ``#include_next`` directives in such files: the; list of include paths is searched for the specified header name, to find the; first include path that would refer to the current file. ``#include_next`` is; interpreted as if the current file had been found in that path.; If this search finds a file named by a module map, the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13850,Availability,avail,available,13850,"hese module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16755,Availability,error,error,16755,"0 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:30435,Availability,avail,available,30435,"dule-map-file*:; *module-declaration**. Within a module map file, modules are referred to by a *module-id*, which uses periods to separate each part of a module's name:. .. parsed-literal::. *module-id*:; *identifier* ('.' *identifier*)*. Module declaration; ------------------; A module declaration describes a module, including the headers that contribute to that module, its submodules, and other aspects of the module. .. parsed-literal::. *module-declaration*:; ``explicit``:sub:`opt` ``framework``:sub:`opt` ``module`` *module-id* *attributes*:sub:`opt` '{' *module-member** '}'; ``extern`` ``module`` *module-id* *string-literal*. The *module-id* should consist of only a single *identifier*, which provides the name of the module being defined. Each module shall have a single definition. The ``explicit`` qualifier can only be applied to a submodule, i.e., a module that is nested within another module. The contents of explicit submodules are only made available when the submodule itself was explicitly named in an import declaration or was re-exported from an imported module. The ``framework`` qualifier specifies that this module corresponds to a Darwin-style framework. A Darwin-style framework (used primarily on macOS and iOS) is contained entirely in directory ``Name.framework``, where ``Name`` is the name of the framework (and, therefore, the name of the module). That directory has the following layout:. .. parsed-literal::. Name.framework/; Modules/module.modulemap Module map for the framework; Headers/ Subdirectory containing framework headers; PrivateHeaders/ Subdirectory containing framework private headers; Frameworks/ Subdirectory containing embedded frameworks; Resources/ Subdirectory containing additional resources; Name Symbolic link to the shared library for the framework. The ``system`` attribute specifies that the module is a system module. When a system module is rebuilt, all of the module's headers will be considered system headers, which suppresses war",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:33708,Availability,avail,available,33708,"*submodule-declaration*; *export-declaration*; *export-as-declaration*; *use-declaration*; *link-declaration*; *config-macros-declaration*; *conflict-declaration*. An extern module references a module defined by the *module-id* in a file given by the *string-literal*. The file can be referenced either by an absolute path or by a path relative to the current map file. Requires declaration; ~~~~~~~~~~~~~~~~~~~~; A *requires-declaration* specifies the requirements that an importing translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34095,Availability,avail,available,34095,"ve to the current map file. Requires declaration; ~~~~~~~~~~~~~~~~~~~~; A *requires-declaration* specifies the requirements that an importing translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34151,Availability,avail,available,34151,"~~~~~~~~~~~~~~~~; A *requires-declaration* specifies the requirements that an importing translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34188,Availability,avail,available,34188,"cifies the requirements that an importing translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34229,Availability,avail,available,34229,"ng translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34270,Availability,avail,available,34270,"he module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34311,Availability,avail,available,34311,"-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; //",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34352,Availability,avail,available,34352,"t*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34393,Availability,avail,available,34393,"ure*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. mo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34424,Availability,avail,available,34424,"*identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cpluspl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34455,Availability,avail,available,34455,"clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34486,Availability,avail,available,34486,"or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34517,Availability,avail,available,34517,"hey are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaratio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34572,Availability,avail,available,34572,"ge dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is ass",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34615,Availability,avail,available,34615,"pecific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-lite",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34655,Availability,avail,available,34655,"t of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34726,Availability,avail,available,34726," is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-lite",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34755,Availability,avail,available,34755,"t translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``head",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34795,Availability,avail,available,34795," the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:34889,Availability,avail,available,34889,"le features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:35032,Availability,avail,available,35032," features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attrs*:; '{' *header-attr** '}'. *header-attr*:; ``size`` *integer-literal*; ``mtime`` *integer-literal*. A header decl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:35134,Availability,avail,available,35134,"es; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attrs*:; '{' *header-attr** '}'. *header-attr*:; ``size`` *integer-literal*; ``mtime`` *integer-literal*. A header declaration that does not contain ``exclude`` nor ``textual`` specifies a header that contributes to the enclosing module. Spec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:50223,Availability,avail,available,50223," a number of places in the grammar to describe specific behavior of other declarations. The format of attributes is fairly simple. .. parsed-literal::. *attributes*:; *attribute* *attributes*:sub:`opt`. *attribute*:; '[' *identifier* ']'. Any *identifier* can be used as an attribute, and each declaration specifies what attributes can be applied to it. Private Module Map Files; ------------------------; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typically describe all of; the API for the library. However, in some cases, the presence or absence of particular headers; is used to distinguish between the ""public"" and ""private"" APIs of a; particular library. For example, a library may contain the headers; ``Foo.h`` and ``Foo_Private.h``, providing public and private APIs,; respectively. Additionally, ``Foo_Private.h`` may only be available on; some versions of library, and absent in others. One cannot easily; express this with a single module map file in the library:. .. parsed-literal::. module Foo {; header ""Foo.h""; ...; }. module Foo_Private {; header ""Foo_Private.h""; ...; }. because the header ``Foo_Private.h`` won't always be available. The; module map file could be customized based on whether; ``Foo_Private.h`` is available or not, but doing so requires custom; build machinery. Private module map files, which are named ``module.private.modulemap``; (or, for backward compatibility, ``module_private.map``), allow one to; augment the primary module map file with an additional modules. For; example, we would split the module map file above into two module map; files:. .. code-block:: c. /* module.modulemap */; module Foo {; header ""Foo.h""; }. /* module.private.modulemap */; module Foo_Private {; header ""Foo_Private.h""; }. When a ``module.private.modulemap`` file is found alongside a; ``module.modulemap`` file, it is loaded after th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:50530,Availability,avail,available,50530,"ute, and each declaration specifies what attributes can be applied to it. Private Module Map Files; ------------------------; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typically describe all of; the API for the library. However, in some cases, the presence or absence of particular headers; is used to distinguish between the ""public"" and ""private"" APIs of a; particular library. For example, a library may contain the headers; ``Foo.h`` and ``Foo_Private.h``, providing public and private APIs,; respectively. Additionally, ``Foo_Private.h`` may only be available on; some versions of library, and absent in others. One cannot easily; express this with a single module map file in the library:. .. parsed-literal::. module Foo {; header ""Foo.h""; ...; }. module Foo_Private {; header ""Foo_Private.h""; ...; }. because the header ``Foo_Private.h`` won't always be available. The; module map file could be customized based on whether; ``Foo_Private.h`` is available or not, but doing so requires custom; build machinery. Private module map files, which are named ``module.private.modulemap``; (or, for backward compatibility, ``module_private.map``), allow one to; augment the primary module map file with an additional modules. For; example, we would split the module map file above into two module map; files:. .. code-block:: c. /* module.modulemap */; module Foo {; header ""Foo.h""; }. /* module.private.modulemap */; module Foo_Private {; header ""Foo_Private.h""; }. When a ``module.private.modulemap`` file is found alongside a; ``module.modulemap`` file, it is loaded after the ``module.modulemap``; file. In our example library, the ``module.private.modulemap`` file; would be available when ``Foo_Private.h`` is available, making it; easier to split a library's public and private APIs along header; boundaries. When writing a private module as part of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:50621,Availability,avail,available,50621,"; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typically describe all of; the API for the library. However, in some cases, the presence or absence of particular headers; is used to distinguish between the ""public"" and ""private"" APIs of a; particular library. For example, a library may contain the headers; ``Foo.h`` and ``Foo_Private.h``, providing public and private APIs,; respectively. Additionally, ``Foo_Private.h`` may only be available on; some versions of library, and absent in others. One cannot easily; express this with a single module map file in the library:. .. parsed-literal::. module Foo {; header ""Foo.h""; ...; }. module Foo_Private {; header ""Foo_Private.h""; ...; }. because the header ``Foo_Private.h`` won't always be available. The; module map file could be customized based on whether; ``Foo_Private.h`` is available or not, but doing so requires custom; build machinery. Private module map files, which are named ``module.private.modulemap``; (or, for backward compatibility, ``module_private.map``), allow one to; augment the primary module map file with an additional modules. For; example, we would split the module map file above into two module map; files:. .. code-block:: c. /* module.modulemap */; module Foo {; header ""Foo.h""; }. /* module.private.modulemap */; module Foo_Private {; header ""Foo_Private.h""; }. When a ``module.private.modulemap`` file is found alongside a; ``module.modulemap`` file, it is loaded after the ``module.modulemap``; file. In our example library, the ``module.private.modulemap`` file; would be available when ``Foo_Private.h`` is available, making it; easier to split a library's public and private APIs along header; boundaries. When writing a private module as part of a *framework*, it's recommended that:. * Headers for this module are present in the ``PrivateHeaders`` framework; subdirector",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:51348,Availability,avail,available,51348," the library:. .. parsed-literal::. module Foo {; header ""Foo.h""; ...; }. module Foo_Private {; header ""Foo_Private.h""; ...; }. because the header ``Foo_Private.h`` won't always be available. The; module map file could be customized based on whether; ``Foo_Private.h`` is available or not, but doing so requires custom; build machinery. Private module map files, which are named ``module.private.modulemap``; (or, for backward compatibility, ``module_private.map``), allow one to; augment the primary module map file with an additional modules. For; example, we would split the module map file above into two module map; files:. .. code-block:: c. /* module.modulemap */; module Foo {; header ""Foo.h""; }. /* module.private.modulemap */; module Foo_Private {; header ""Foo_Private.h""; }. When a ``module.private.modulemap`` file is found alongside a; ``module.modulemap`` file, it is loaded after the ``module.modulemap``; file. In our example library, the ``module.private.modulemap`` file; would be available when ``Foo_Private.h`` is available, making it; easier to split a library's public and private APIs along header; boundaries. When writing a private module as part of a *framework*, it's recommended that:. * Headers for this module are present in the ``PrivateHeaders`` framework; subdirectory.; * The private module is defined as a *top level module* with the name of the; public framework prefixed, like ``Foo_Private`` above. Clang has extra logic; to work with this naming, using ``FooPrivate`` or ``Foo.Private`` (submodule); trigger warnings and might not work as expected. Modularizing a Platform; =======================; To get any benefit out of modules, one needs to introduce module maps for software libraries starting at the bottom of the stack. This typically means introducing a module map covering the operating system's headers and the C standard library headers (in ``/usr/include``, for a Unix system). The module maps will be written using the `module map language`_, wh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:51384,Availability,avail,available,51384,"Foo_Private {; header ""Foo_Private.h""; ...; }. because the header ``Foo_Private.h`` won't always be available. The; module map file could be customized based on whether; ``Foo_Private.h`` is available or not, but doing so requires custom; build machinery. Private module map files, which are named ``module.private.modulemap``; (or, for backward compatibility, ``module_private.map``), allow one to; augment the primary module map file with an additional modules. For; example, we would split the module map file above into two module map; files:. .. code-block:: c. /* module.modulemap */; module Foo {; header ""Foo.h""; }. /* module.private.modulemap */; module Foo_Private {; header ""Foo_Private.h""; }. When a ``module.private.modulemap`` file is found alongside a; ``module.modulemap`` file, it is loaded after the ``module.modulemap``; file. In our example library, the ``module.private.modulemap`` file; would be available when ``Foo_Private.h`` is available, making it; easier to split a library's public and private APIs along header; boundaries. When writing a private module as part of a *framework*, it's recommended that:. * Headers for this module are present in the ``PrivateHeaders`` framework; subdirectory.; * The private module is defined as a *top level module* with the name of the; public framework prefixed, like ``Foo_Private`` above. Clang has extra logic; to work with this naming, using ``FooPrivate`` or ``Foo.Private`` (submodule); trigger warnings and might not work as expected. Modularizing a Platform; =======================; To get any benefit out of modules, one needs to introduce module maps for software libraries starting at the bottom of the stack. This typically means introducing a module map covering the operating system's headers and the C standard library headers (in ``/usr/include``, for a Unix system). The module maps will be written using the `module map language`_, which provides the tools necessary to describe the mapping between headers and modu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:53999,Availability,error,error,53999,"s fairly common to see a definition such as the following copy-and-pasted throughout the headers:. .. parsed-literal::. #ifndef _SIZE_T; #define _SIZE_T; typedef __SIZE_TYPE__ size_t;; #endif. Unfortunately, when modules compiles all of the C library headers together into a single module, only the first actual type definition of ``size_t`` will be visible, and then only in the submodule corresponding to the lucky first header. Any other headers that have copy-and-pasted versions of this pattern will *not* have a definition of ``size_t``. Importing the submodule corresponding to one of those headers will therefore not yield ``size_t`` as part of the API, because it wasn't there when the header was parsed. The fix for this problem is either to pull the copied declarations into a common header that gets included everywhere ``size_t`` is part of the API, or to eliminate the ``#ifndef`` and redefine the ``size_t`` type. The latter works for C++ headers and C11, but will cause an error for non-modules C90/C99, where redefinition of ``typedefs`` is not permitted. **Conflicting definitions**; Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don't tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply ""don't do that"", such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer). **Missing includes**; Headers are often missing ``#include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:55152,Availability,avail,available,55152,". **Conflicting definitions**; Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don't tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply ""don't do that"", such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer). **Missing includes**; Headers are often missing ``#include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56604,Availability,error,error,56604,"y splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:58106,Availability,avail,available,58106,"oblems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#] Automatic linking against the libraries of modules requires specific linker support, which is not widely available. .. [#] There are certain anti-patterns that occur in headers, particularly system headers, that cause problems for modules. The section `Modularizing a Platform`_ describes some of them. .. [#] The second instance is actually a new thread within the current process, not a separate process. However, the original compiler instance is blocked on the execution of this thread. .. [#] The preprocessing context in which the modules are parsed is actually dependent on the command-line options provided to the compiler, including the language dialect and any ``-D`` options. However, the compiled modules for different command-line options are kept distinct, and any preprocessor directives that occur within the translation unit are ignored. See the section on the `Configuration macros declaration`_ for more information. .. _PCHInternals: PCHInternals.html; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13964,Deployability,configurat,configuration,13964," option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:19246,Deployability,update,updated,19246,"~~~~~~~~~. ``-fmodules-strict-context-hash``; Enables hashing of all compiler options that could impact the semantics of a; module in an implicit build. This includes things such as header search paths; and diagnostics. Using this option may lead to an excessive number of modules; being built if the command line arguments are not homogeneous across your; build. Using Prebuilt Modules; ----------------------. Below are a few examples illustrating uses of prebuilt modules via the different options. First, let's set up files for our examples. .. code-block:: c. /* A.h */; #ifdef ENABLE_A; void a() {}; #endif. .. code-block:: c. /* B.h */; #include ""A.h"". .. code-block:: c. /* use.c */; #include ""B.h""; void use() {; #ifdef ENABLE_A; a();; #endif; }. .. code-block:: c. /* module.modulemap */; module A {; header ""A.h""; }; module B {; header ""B.h""; export *; }. In the examples below, the compilation of ``use.c`` can be done without ``-cc1``, but the commands used to prebuild the modules would need to be updated to take into account the default options passed to ``clang -cc1``. (See ``clang use.c -v``); Note also that, since we use ``-cc1``, we specify the ``-fmodule-map-file=`` or ``-fimplicit-module-maps`` options explicitly. When using the clang driver, ``-fimplicit-module-maps`` is implied by ``-fmodules``. First let us use an explicit mapping from modules to files. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fmodule-file=A=prebuilt/A.pcm; clang -cc1 -emit-obj use.c -fmodules -fmodule-map-file=module.modulemap -fmodule-file=A=prebuilt/A.pcm -fmodule-file=B=prebuilt/B.pcm. Instead of of specifying the mappings manually, it can be convenient to use the ``-fprebuilt-module-path`` option. Let's also use ``-fimplicit-module-maps`` instead of manually pointing to our module map. .. code-block:: sh.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23198,Deployability,configurat,configurations,23198,"s manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:27726,Deployability,release,releases,27726,"s not consistent, the program is ill-formed. Otherwise, the (unique) meaning of the macro name is used. For example, suppose:. * ``<stdio.h>`` defines a macro ``getc`` (and exports its ``#define``); * ``<cstdio>`` imports the ``<stdio.h>`` module and undefines the macro (and exports its ``#undef``). The ``#undef`` overrides the ``#define``, and a source file that imports both modules *in any order* will not see ``getc`` defined as a macro. Module Map Language; ===================. .. warning::. The module map language is not currently guaranteed to be stable between major revisions of Clang. The module map language describes the mapping from header files to the; logical structure of modules. To enable support for using a library as; a module, one must write a ``module.modulemap`` file for that library. The; ``module.modulemap`` file is placed alongside the header files themselves,; and is written in the module map language described below. .. note::; For compatibility with previous releases, if a module map file named; ``module.modulemap`` is not found, Clang will also search for a file named; ``module.map``. This behavior is deprecated and we plan to eventually; remove it. As an example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46312,Deployability,configurat,configuration,46312,"~~~~~~~; A *link-declaration* specifies a library or framework against which a program should be linked if the enclosing module is imported in any translation unit in that program. .. parsed-literal::. *link-declaration*:; ``link`` ``framework``:sub:`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47221,Deployability,configurat,configuration,47221,"eclaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict dec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47412,Deployability,configurat,configuration,47412,"f the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47573,Deployability,configurat,configuration,47573,"tifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id*",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47682,Deployability,configurat,configuration,47682,"rent variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47816,Deployability,configurat,configuration,47816," i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56899,Deployability,deploy,deployment,56899," problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:4004,Energy Efficiency,efficient,efficient,4004,"evelopers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresponding ``#include <stdio.h>``: when the compiler sees the module import above, it loads a binary representation of the ``std.io`` module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preproce",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47338,Energy Efficiency,reduce,reduce,47338,"f the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:338,Integrability,interface,interface,338,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:412,Integrability,interface,interface,412,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2518,Integrability,depend,dependency,2518,"ect with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:5683,Integrability,depend,dependencies,5683,"mport declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preprocessor inclusion model:. * **Compile-time scalability**: The ``std.io`` module is only compiled once, and importing the module into a translation unit is a constant-time operation (independent of module system). Thus, the API of each software library is only parsed once, reducing the *M x N* compilation problem to an *M + N* problem. * **Fragility**: Each module is parsed as a standalone entity, so it has a consistent preprocessor environment. This completely eliminates the need for ``__underscored`` names and similarly defensive tricks. Moreover, the current preprocessor definitions when an import declaration is encountered are ignored, so one software library can not affect how another software library is compiled, eliminating include-order dependencies. * **Tool confusion**: Modules describe the API of software libraries, and tools can reason about and present a module as a representation of that API. Because modules can only be built standalone, tools can rely on the module definition to ensure that they get the complete API for the library. Moreover, modules can specify which languages they work with, so, e.g., one can not accidentally attempt to load a C++ module into a C program. Problems modules do not solve; -----------------------------; Many programming languages have a module or package system, and because of the variety of features provided by these languages it is important to define what modules do *not* do. In particular, all of the following are considered out-of-scope for modules:. * **Rewrite the world's code**: It is not realistic to require applications or software libraries to make drastic or non-backward-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:8067,Integrability,interface,interface,8067,"ule will still conflict with a struct of the same name declared in a different module, just as they would if declared in two different headers. This aspect is important for backward compatibility, because (for example) the mangled names of entities in software libraries must not change when introducing modules. * **Binary distribution of modules**: Headers (particularly C++ headers) expose the full complexity of the language. Maintaining a stable binary module format across architectures, compiler versions, and compiler vendors is technically infeasible. Using Modules; =============; To enable modules, pass the command-line flag ``-fmodules``. This will make any modules-enabled software libraries available as modules as well as introducing any modules-specific syntax. Additional `command-line parameters`_ are described in a separate section later. Standard C++ Modules; --------------------; .. note::; Modules are adopted into C++20 Standard. And its semantic and command line interface are very different from the Clang C++ modules. See `StandardCPlusPlusModules <StandardCPlusPlusModules.html>`_ for details. Objective-C Import declaration; ------------------------------; Objective-C provides syntax for importing a module via an *@import declaration*, which imports the named module:. .. parsed-literal::. @import std;. The ``@import`` declaration above imports the entire contents of the ``std`` module (which would contain, e.g., the entire C or C++ standard library) and make its API available within the current translation unit. To import only part of a module, one may use dot syntax to specific a particular submodule, e.g.,. .. parsed-literal::. @import std.io;. Redundant import declarations are ignored, and one is free to import modules at any point within the translation unit, so long as the import declaration is at global scope. At present, there is no C or C++ syntax for import declarations. Clang; will track the modules proposal in the C++ committee. See the sectio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:12722,Integrability,depend,depends,12722,"ne could imagine a module ``std`` covering the C standard library. Each of the C standard library headers (``<stdio.h>``, ``<stdlib.h>``, ``<math.h>``, etc.) would contribute to the ``std`` module, by placing their respective APIs into the corresponding submodule (``std.io``, ``std.lib``, ``std.math``, etc.). Having a list of the headers that are part of the ``std`` module allows the compiler to build the ``std`` module as a standalone entity, and having the mapping from header names to (sub)modules allows the automatic translation of ``#include`` directives to module imports. Module maps are specified as separate files (each named ``module.modulemap``) alongside the headers they describe, which allows them to be added to existing software libraries without having to change the library headers themselves (in most cases [#]_). The actual `Module map language`_ is described in a later section. .. note::. To actually see any benefits from modules, one first has to introduce module maps for the underlying C standard library and the libraries and headers on which it depends. The section `Modularizing a Platform`_ describes the steps one must take to write these module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:14202,Integrability,depend,depends,14202,"nerated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16761,Integrability,message,message,16761,"0 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:24597,Integrability,depend,depend,24597," -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should not be relied upon. This behavior is subject to change. As an example, in C, this implies that if two structs are defined in different submodules with the same name, those two types are distinct types (but may be *compatible* types if their definitions match). In C++, two structs defined with the same name in different submodules are the *same* type, and must be equivalent under C++'s One Definition Rule. .. note::. Clang currently only performs minimal checking for violations of the One Definition Rule. If any submodule of a module is imported into any part of a program, the entire top-level module is considered to be part of the program. As a consequence of this, Clang may diagnose conflicts between an entity declared in an unimported submodule and an entity declared in the current translation unit, and Clang may inline or devirtualize based on knowledge from unimported submodules. Macros; ------. The C and C++ preprocessor assumes that",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:43661,Integrability,depend,depends,43661," imports the enclosing module. Each imported module that matches the *wildcard-module-id* up to, but not including, the first ``*`` will be re-exported. **Example:** In the following example, importing ``MyLib.Derived`` also provides the API for ``MyLib.Base``:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export Base; }; }. Note that, if ``Derived.h`` includes ``Base.h``, one can simply use a wildcard export to re-export everything ``Derived.h`` includes:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export *; }; }. .. note::. The wildcard export syntax ``export *`` re-exports all of the; modules that were imported in the actual header file. Because; ``#include`` directives are automatically mapped to module imports,; ``export *`` provides the same transitive-inclusion behavior; provided by the C preprocessor, e.g., importing a given module; implicitly imports all of the modules on which it depends.; Therefore, liberal use of ``export *`` provides excellent backward; compatibility for programs that rely on transitive inclusion (i.e.,; all of them). Re-export Declaration; ~~~~~~~~~~~~~~~~~~~~~; An *export-as-declaration* specifies that the current module will have; its interface re-exported by the named module. .. parsed-literal::. *export-as-declaration*:; ``export_as`` *identifier*. The *export-as-declaration* names the module that the current; module will be re-exported through. Only top-level modules; can be re-exported, and any given module may only be re-exported; through a single module. **Example:** In the following example, the module ``MyFrameworkCore``; will be re-exported via the module ``MyFramework``:. .. parsed-literal::. module MyFrameworkCore {; export_as MyFramework; }. Use declaration; ~~~~~~~~~~~~~~~; A *use-declaration* specifies another module that the current top-level module; intends to use. When the option *-fmodu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:43944,Integrability,interface,interface,43944,"ral::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export Base; }; }. Note that, if ``Derived.h`` includes ``Base.h``, one can simply use a wildcard export to re-export everything ``Derived.h`` includes:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export *; }; }. .. note::. The wildcard export syntax ``export *`` re-exports all of the; modules that were imported in the actual header file. Because; ``#include`` directives are automatically mapped to module imports,; ``export *`` provides the same transitive-inclusion behavior; provided by the C preprocessor, e.g., importing a given module; implicitly imports all of the modules on which it depends.; Therefore, liberal use of ``export *`` provides excellent backward; compatibility for programs that rely on transitive inclusion (i.e.,; all of them). Re-export Declaration; ~~~~~~~~~~~~~~~~~~~~~; An *export-as-declaration* specifies that the current module will have; its interface re-exported by the named module. .. parsed-literal::. *export-as-declaration*:; ``export_as`` *identifier*. The *export-as-declaration* names the module that the current; module will be re-exported through. Only top-level modules; can be re-exported, and any given module may only be re-exported; through a single module. **Example:** In the following example, the module ``MyFrameworkCore``; will be re-exported via the module ``MyFramework``:. .. parsed-literal::. module MyFrameworkCore {; export_as MyFramework; }. Use declaration; ~~~~~~~~~~~~~~~; A *use-declaration* specifies another module that the current top-level module; intends to use. When the option *-fmodules-decluse* is specified, a module can; only use other modules that are explicitly specified in this way. .. parsed-literal::. *use-declaration*:; ``use`` *module-id*. **Example:** In the following example, use of A from C is not declared, so will trigger a warning. .. parsed-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:48818,Integrability,message,message,48818,"nged, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part of the compiler diagnostic when two modules conflict. .. note::. Clang emits a warning (under the control of ``-Wmodule-conflict``); when a module conflict is discovered. **Example:**. .. parsed-literal::. module Conflicts {; explicit module A {; header ""conflict_a.h""; conflict B, ""we just don't like B""; }. module B {; header ""conflict_b.h""; }; }. Attributes; ----------; Attributes are used in a number of places in the grammar to describe specific behavior of other declarations. The format of attributes is fairly simple. .. parsed-literal::. *attributes*:; *attribute* *attributes*:sub:`opt`. *attribute*:; '[' *identifier* ']'. Any *identifier* can be used as an attribute, and each declaration specifies what attributes can be applied to it. Private Module Map Files; ------------------------; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typicall",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:54693,Integrability,depend,depend,54693,"e_t`` as part of the API, because it wasn't there when the header was parsed. The fix for this problem is either to pull the copied declarations into a common header that gets included everywhere ``size_t`` is part of the API, or to eliminate the ``#ifndef`` and redefine the ``size_t`` type. The latter works for C++ headers and C11, but will cause an error for non-modules C90/C99, where redefinition of ``typedefs`` is not permitted. **Conflicting definitions**; Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don't tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply ""don't do that"", such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer). **Missing includes**; Headers are often missing ``#include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:58569,Integrability,depend,dependent,58569,"oblems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#] Automatic linking against the libraries of modules requires specific linker support, which is not widely available. .. [#] There are certain anti-patterns that occur in headers, particularly system headers, that cause problems for modules. The section `Modularizing a Platform`_ describes some of them. .. [#] The second instance is actually a new thread within the current process, not a separate process. However, the original compiler instance is blocked on the execution of this thread. .. [#] The preprocessing context in which the modules are parsed is actually dependent on the command-line options provided to the compiler, including the language dialect and any ``-D`` options. However, the compiled modules for different command-line options are kept distinct, and any preprocessor directives that occur within the translation unit are ignored. See the section on the `Configuration macros declaration`_ for more information. .. _PCHInternals: PCHInternals.html; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13964,Modifiability,config,configuration,13964," option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23198,Modifiability,config,configurations,23198,"s manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:24018,Modifiability,config,configuring,24018,"se.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should not be relied upon. This behavior is subject to change. As an example, in C, this implies that if two structs are defined in different submodules with the same name, those two types are distinct types (but may be *compatible* types if their definitions match). In C++, two structs defined with the same name in different submodules are the *same* type, and must be equiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:32849,Modifiability,config,config-macros-declaration,32849,"t for use in C++ code, all of the module's headers will be treated as if they were contained within an implicit ``extern ""C""`` block. An import for a module with this attribute can appear within an ``extern ""C""`` block. No other restrictions are lifted, however: the module currently cannot be imported within an ``extern ""C""`` block in a namespace. The ``no_undeclared_includes`` attribute specifies that the module can only reach non-modular headers and headers from used modules. Since some headers could be present in more than one search path and map to different modules in each path, this mechanism helps clang to find the right header, i.e., prefer the one for the current module or in a submodule instead of the first usual match in the search paths. Modules can have a number of different kinds of members, each of which is described below:. .. parsed-literal::. *module-member*:; *requires-declaration*; *header-declaration*; *umbrella-dir-declaration*; *submodule-declaration*; *export-declaration*; *export-as-declaration*; *use-declaration*; *link-declaration*; *config-macros-declaration*; *conflict-declaration*. An extern module references a module defined by the *module-id* in a file given by the *string-literal*. The file can be referenced either by an absolute path or by a path relative to the current map file. Requires declaration; ~~~~~~~~~~~~~~~~~~~~; A *requires-declaration* specifies the requirements that an importing translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit sha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:35184,Modifiability,extend,extended,35184,"splus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available. freestanding; A freestanding environment is available. gnuinlineasm; GNU inline ASM is available. objc; Objective-C support is available. objc_arc; Objective-C Automatic Reference Counting (ARC) is available. opencl; OpenCL is available. tls; Thread local storage is available. *target feature*; A specific target feature (e.g., ``sse4``, ``avx``, ``neon``) is available. *platform/os*; A os/platform variant (e.g. ``freebsd``, ``win32``, ``windows``, ``linux``, ``ios``, ``macos``, ``iossimulator``) is available. *environment*; A environment variant (e.g. ``gnu``, ``gnueabi``, ``android``, ``msvc``) is available. **Example:** The ``std`` module can be extended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attrs*:; '{' *header-attr** '}'. *header-attr*:; ``size`` *integer-literal*; ``mtime`` *integer-literal*. A header declaration that does not contain ``exclude`` nor ``textual`` specifies a header that contributes to the enclosing module. Specifically, when the module is built, the named header will be parsed and its declarations ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46264,Modifiability,config,config-macros-declaration,46264,"~~~~~~~; A *link-declaration* specifies a library or framework against which a program should be linked if the enclosing module is imported in any translation unit in that program. .. parsed-literal::. *link-declaration*:; ``link`` ``framework``:sub:`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46312,Modifiability,config,configuration,46312,"~~~~~~~; A *link-declaration* specifies a library or framework against which a program should be linked if the enclosing module is imported in any translation unit in that program. .. parsed-literal::. *link-declaration*:; ``link`` ``framework``:sub:`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46411,Modifiability,config,config-macros-declaration,46411," program. .. parsed-literal::. *link-declaration*:; ``link`` ``framework``:sub:`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46482,Modifiability,config,config-macro-list,46482," program. .. parsed-literal::. *link-declaration*:; ``link`` ``framework``:sub:`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46513,Modifiability,config,config-macro-list,46513,"`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46594,Modifiability,config,config-macro-list,46594," the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46777,Modifiability,config,config-macros-declaration,46777,"* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46982,Modifiability,config,config-macros-declaration,46982,"ely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of diff",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47221,Modifiability,config,configuration,47221,"eclaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict dec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47412,Modifiability,config,configuration,47412,"f the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47573,Modifiability,config,configuration,47573,"tifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id*",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47682,Modifiability,config,configuration,47682,"rent variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47816,Modifiability,config,configuration,47816," i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:777,Performance,scalab,scalability,777,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:1112,Performance,scalab,scalability,1112,"form, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library h",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:1504,Performance,perform,performing,1504,"-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:4429,Performance,load,loads,4429,"ot clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresponding ``#include <stdio.h>``: when the compiler sees the module import above, it loads a binary representation of the ``std.io`` module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preprocessor inclusion model:. * **Compile-time scalability**: The ``std.io`` module is only compiled once, and importing the module into a translation unit is a constant-time operation (independent of module system). Thus, the API of each software library is only parsed once, reducing the *M x N* compilation problem to an *M + N* problem. * **Fragility**: Each module is parsed as a standalone entity, so it has a consistent preprocessor environment. This completely eliminates the need for ``__",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:4972,Performance,scalab,scalability,4972,"del with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresponding ``#include <stdio.h>``: when the compiler sees the module import above, it loads a binary representation of the ``std.io`` module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preprocessor inclusion model:. * **Compile-time scalability**: The ``std.io`` module is only compiled once, and importing the module into a translation unit is a constant-time operation (independent of module system). Thus, the API of each software library is only parsed once, reducing the *M x N* compilation problem to an *M + N* problem. * **Fragility**: Each module is parsed as a standalone entity, so it has a consistent preprocessor environment. This completely eliminates the need for ``__underscored`` names and similarly defensive tricks. Moreover, the current preprocessor definitions when an import declaration is encountered are ignored, so one software library can not affect how another software library is compiled, eliminating include-order dependencies. * **Tool confusion**: Modules describe the API of software libraries, and tools can reason about and present a module as a representation of that API. Because modules can only be built standalone, tools can rely on the module definition to ensure that they get the complete API f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:6100,Performance,load,load,6100,"e operation (independent of module system). Thus, the API of each software library is only parsed once, reducing the *M x N* compilation problem to an *M + N* problem. * **Fragility**: Each module is parsed as a standalone entity, so it has a consistent preprocessor environment. This completely eliminates the need for ``__underscored`` names and similarly defensive tricks. Moreover, the current preprocessor definitions when an import declaration is encountered are ignored, so one software library can not affect how another software library is compiled, eliminating include-order dependencies. * **Tool confusion**: Modules describe the API of software libraries, and tools can reason about and present a module as a representation of that API. Because modules can only be built standalone, tools can rely on the module definition to ensure that they get the complete API for the library. Moreover, modules can specify which languages they work with, so, e.g., one can not accidentally attempt to load a C++ module into a C program. Problems modules do not solve; -----------------------------; Many programming languages have a module or package system, and because of the variety of features provided by these languages it is important to define what modules do *not* do. In particular, all of the following are considered out-of-scope for modules:. * **Rewrite the world's code**: It is not realistic to require applications or software libraries to make drastic or non-backward-compatible changes, nor is it feasible to completely eliminate headers. Modules must interoperate with existing software libraries and allow a gradual transition. * **Versioning**: Modules have no notion of version information. Programmers must still rely on the existing versioning mechanisms of the underlying language (if any exist) to version software libraries. * **Namespaces**: Unlike in some languages, modules do not imply any notion of namespaces. Thus, a struct declared in one module will still conflic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13097,Performance,load,load,13097," module allows the compiler to build the ``std`` module as a standalone entity, and having the mapping from header names to (sub)modules allows the automatic translation of ``#include`` directives to module imports. Module maps are specified as separate files (each named ``module.modulemap``) alongside the headers they describe, which allows them to be added to existing software libraries without having to change the library headers themselves (in most cases [#]_). The actual `Module map language`_ is described in a later section. .. note::. To actually see any benefits from modules, one first has to introduce module maps for the underlying C standard library and the libraries and headers on which it depends. The section `Modularizing a Platform`_ describes the steps one must take to write these module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13587,Performance,load,loaded,13587," actually see any benefits from modules, one first has to introduce module maps for the underlying C standard library and the libraries and headers on which it depends. The section `Modularizing a Platform`_ describes the steps one must take to write these module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13722,Performance,cache,cache,13722,"aries and headers on which it depends. The section `Modularizing a Platform`_ describes the steps one must take to write these module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13778,Performance,cache,cache,13778,"hese module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:13866,Performance,load,load,13866,"hese module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:14804,Performance,load,loaded,14804,"f the required module is already available, will load that representation directly. Thus, a module's headers will only be parsed once per language configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:14931,Performance,cache,cache-path,14931,"anguage configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:14989,Performance,cache,cache,14989,"anguage configuration, rather than once per translation unit that uses the module. Modules maintain references to each of the headers that were part of the module build. If any of those headers changes, or if any of the modules on which a module depends change, then the module will be (automatically) recompiled. The process should never require any user intervention. Command-line parameters; -----------------------; ``-fmodules``; Enable the modules feature. ``-fbuiltin-module-map``; Load the Clang builtins module map file. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15537,Performance,cache,cache,15537,"le. (Equivalent to ``-fmodule-map-file=<resource dir>/include/module.modulemap``). ``-fimplicit-module-maps``; Enable implicit search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15551,Performance,cache,cache,15551,"t search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15631,Performance,cache,cache,15631,"t search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15914,Performance,cache,cache,15914,"dule map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16605,Performance,load,loaded,16605,"dule cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:17257,Performance,load,loaded,17257,"ge and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-fprebuilt-implicit-modules``; Enable prebuilt implicit modules. If a prebuilt module is not found in the; prebuilt modules paths (specified via ``-fprebuilt-module-path``), we will; look for a matching implicit module in the prebuilt modules paths. -cc1 Options; ~~~~~~~~~~~~. ``-fmodu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:17466,Performance,load,loaded,17466,"tions. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-fprebuilt-implicit-modules``; Enable prebuilt implicit modules. If a prebuilt module is not found in the; prebuilt modules paths (specified via ``-fprebuilt-module-path``), we will; look for a matching implicit module in the prebuilt modules paths. -cc1 Options; ~~~~~~~~~~~~. ``-fmodules-strict-context-hash``; Enables hashing of all compiler options that could impact the semantics of a; module in an implicit build. This ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:17828,Performance,load,loading,17828,"fore, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-fprebuilt-implicit-modules``; Enable prebuilt implicit modules. If a prebuilt module is not found in the; prebuilt modules paths (specified via ``-fprebuilt-module-path``), we will; look for a matching implicit module in the prebuilt modules paths. -cc1 Options; ~~~~~~~~~~~~. ``-fmodules-strict-context-hash``; Enables hashing of all compiler options that could impact the semantics of a; module in an implicit build. This includes things such as header search paths; and diagnostics. Using this option may lead to an excessive number of modules; being built if the command line arguments are not homogeneous across your; build. Using Prebuilt Modules; ----------------------. Below are a few examples illustrating uses of prebuilt modules via the different options. First, let's set up files for our examples. .. code-block:: c. /* A.h */; #ifdef ENABLE_A; void a() {}; #endif. .. code-block",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:20848,Performance,cache,cache-path,20848,"ile=A=prebuilt/A.pcm; clang -cc1 -emit-obj use.c -fmodules -fmodule-map-file=module.modulemap -fmodule-file=A=prebuilt/A.pcm -fmodule-file=B=prebuilt/B.pcm. Instead of of specifying the mappings manually, it can be convenient to use the ``-fprebuilt-module-path`` option. Let's also use ``-fimplicit-module-maps`` instead of manually pointing to our module map. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt. A trick to prebuild all modules required for our source file in one command is to generate implicit modules while using the ``-fdisable-module-hash`` option. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:21588,Performance,cache,cache,21588,"e-path=prebuilt. A trick to prebuild all modules required for our source file in one command is to generate implicit modules while using the ``-fdisable-module-hash`` option. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:21777,Performance,cache,cache-path,21777," -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:21890,Performance,cache,cache-path,21890,"; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:22246,Performance,cache,cache,22246,"LE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:22276,Performance,cache,cache-path,22276,"LE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:22542,Performance,cache,cache-path,22542," or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:22642,Performance,cache,cache-path,22642,"lt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-pat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23274,Performance,cache,cache,23274,"les-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each su",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23359,Performance,cache,cache-path,23359,"ng ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation un",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23539,Performance,cache,cache-path,23539,"-fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visibl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23550,Performance,cache,cache,23550,"-fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visibl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23696,Performance,cache,cache-path,23696,"; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23707,Performance,cache,cache,23707,"; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23864,Performance,cache,cache-path,23864,"cm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should not be relied upon. This behavior is subject to change. As an example, in C, this implies that if two structs are defined in different submodules with the same n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23875,Performance,cache,cache,23875,"cm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should not be relied upon. This behavior is subject to change. As an example, in C, this implies that if two structs are defined in different submodules with the same n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:24041,Performance,cache,cache,24041,"se.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should not be relied upon. This behavior is subject to change. As an example, in C, this implies that if two structs are defined in different submodules with the same name, those two types are distinct types (but may be *compatible* types if their definitions match). In C++, two structs defined with the same name in different submodules are the *same* type, and must be equiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:25114,Performance,perform,performs,25114,"as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation unit. .. note::. This behavior is currently only approximated when building a module with submodules. Entities within a submodule that has already been built are visible when building later submodules in that module. This can lead to fragile modules that depend on the build order used for the submodules of the module, and should not be relied upon. This behavior is subject to change. As an example, in C, this implies that if two structs are defined in different submodules with the same name, those two types are distinct types (but may be *compatible* types if their definitions match). In C++, two structs defined with the same name in different submodules are the *same* type, and must be equivalent under C++'s One Definition Rule. .. note::. Clang currently only performs minimal checking for violations of the One Definition Rule. If any submodule of a module is imported into any part of a program, the entire top-level module is considered to be part of the program. As a consequence of this, Clang may diagnose conflicts between an entity declared in an unimported submodule and an entity declared in the current translation unit, and Clang may inline or devirtualize based on knowledge from unimported submodules. Macros; ------. The C and C++ preprocessor assumes that the input text is a single linear buffer, but with modules this is not the case. It is possible to import two modules that have conflicting definitions for a macro (or where one ``#define``\s a macro and the other ``#undef``\ines it). The rules for handling macro definitions in the presence of modules are as follows:. * Each definition and undefinition of a macro is considered to be a distinct entity.; * Such entities are *visible* if they are from the current submodule or translation unit, or if they were",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47304,Performance,optimiz,optimization,47304,"f the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47439,Performance,optimiz,optimization,47439,"attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible func",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:51231,Performance,load,loaded,51231," on; some versions of library, and absent in others. One cannot easily; express this with a single module map file in the library:. .. parsed-literal::. module Foo {; header ""Foo.h""; ...; }. module Foo_Private {; header ""Foo_Private.h""; ...; }. because the header ``Foo_Private.h`` won't always be available. The; module map file could be customized based on whether; ``Foo_Private.h`` is available or not, but doing so requires custom; build machinery. Private module map files, which are named ``module.private.modulemap``; (or, for backward compatibility, ``module_private.map``), allow one to; augment the primary module map file with an additional modules. For; example, we would split the module map file above into two module map; files:. .. code-block:: c. /* module.modulemap */; module Foo {; header ""Foo.h""; }. /* module.private.modulemap */; module Foo_Private {; header ""Foo_Private.h""; }. When a ``module.private.modulemap`` file is found alongside a; ``module.modulemap`` file, it is loaded after the ``module.modulemap``; file. In our example library, the ``module.private.modulemap`` file; would be available when ``Foo_Private.h`` is available, making it; easier to split a library's public and private APIs along header; boundaries. When writing a private module as part of a *framework*, it's recommended that:. * Headers for this module are present in the ``PrivateHeaders`` framework; subdirectory.; * The private module is defined as a *top level module* with the name of the; public framework prefixed, like ``Foo_Private`` above. Clang has extra logic; to work with this naming, using ``FooPrivate`` or ``Foo.Private`` (submodule); trigger warnings and might not work as expected. Modularizing a Platform; =======================; To get any benefit out of modules, one needs to introduce module maps for software libraries starting at the bottom of the stack. This typically means introducing a module map covering the operating system's headers and the C standard library h",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:1379,Safety,redund,redundant,1379,"oth its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the hea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2884,Safety,avoid,avoid,2884,"ons happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:2989,Safety,avoid,avoid,2989,"ons happens to collide with a name in the; library, it can break the library API or cause compilation failures; in the library header itself. For an extreme example,; ``#define std ""The C++ Standard""`` and then include a standard; library header: the result is a horrific cascade of failures in the; C++ Standard Library's implementation. More subtle real-world; problems occur when the headers for two different libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16062,Safety,avoid,avoid,16062,"iate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:16988,Safety,avoid,avoid,16988,"module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs to build all the modules. Note that this option doesn't apply in module builds, to avoid the recursion. ``-fno-implicit-modules``; All modules used by the build must be specified with ``-fmodule-file``. ``-fmodule-file=[<name>=]<file>``; Specify the mapping of module names to precompiled module files. If the; name is omitted, then the module file is loaded whether actually required; or not. If the name is specified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:38581,Safety,avoid,avoids,38581," not be included when the module is built, nor will it be considered to be part of the module, even if an ``umbrella`` header or directory would otherwise make it part of the module. **Example:** The C header ``assert.h`` is an excellent candidate for a textual header, because it is meant to be included multiple times (possibly with different ``NDEBUG`` settings). However, declarations within it should typically be split into a separate modular header. .. parsed-literal::. module std [system] {; textual header ""assert.h""; }. A given header shall not be referenced by more than one *header-declaration*. Two *header-declaration*\s, or a *header-declaration* and a ``#include``, are; considered to refer to the same file if the paths resolve to the same file; and the specified *header-attr*\s (if any) match the attributes of that file,; even if the file is named differently (for instance, by a relative path or; via symlinks). .. note::; The use of *header-attr*\s avoids the need for Clang to speculatively; ``stat`` every header referenced by a module map. It is recommended that; *header-attr*\s only be used in machine-generated module maps, to avoid; mismatches between attribute values and the corresponding files. Umbrella directory declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; An umbrella directory declaration specifies that all of the headers in the specified directory should be included within the module. .. parsed-literal::. *umbrella-dir-declaration*:; ``umbrella`` *string-literal*. The *string-literal* refers to a directory. When the module is built, all of the header files in that directory (and its subdirectories) are included in the module. An *umbrella-dir-declaration* shall not refer to the same directory as the location of an umbrella *header-declaration*. In other words, only a single kind of umbrella can be specified for a given directory. .. note::. Umbrella directories are useful for libraries that have a large number of headers but do not have an umbrella h",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:38765,Safety,avoid,avoid,38765,"therwise make it part of the module. **Example:** The C header ``assert.h`` is an excellent candidate for a textual header, because it is meant to be included multiple times (possibly with different ``NDEBUG`` settings). However, declarations within it should typically be split into a separate modular header. .. parsed-literal::. module std [system] {; textual header ""assert.h""; }. A given header shall not be referenced by more than one *header-declaration*. Two *header-declaration*\s, or a *header-declaration* and a ``#include``, are; considered to refer to the same file if the paths resolve to the same file; and the specified *header-attr*\s (if any) match the attributes of that file,; even if the file is named differently (for instance, by a relative path or; via symlinks). .. note::; The use of *header-attr*\s avoids the need for Clang to speculatively; ``stat`` every header referenced by a module map. It is recommended that; *header-attr*\s only be used in machine-generated module maps, to avoid; mismatches between attribute values and the corresponding files. Umbrella directory declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; An umbrella directory declaration specifies that all of the headers in the specified directory should be included within the module. .. parsed-literal::. *umbrella-dir-declaration*:; ``umbrella`` *string-literal*. The *string-literal* refers to a directory. When the module is built, all of the header files in that directory (and its subdirectories) are included in the module. An *umbrella-dir-declaration* shall not refer to the same directory as the location of an umbrella *header-declaration*. In other words, only a single kind of umbrella can be specified for a given directory. .. note::. Umbrella directories are useful for libraries that have a large number of headers but do not have an umbrella header. Submodule declaration; ~~~~~~~~~~~~~~~~~~~~~; Submodule declarations describe modules that are nested within their enclosing module. .. pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:55697,Safety,detect,detect,55697," to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:55864,Safety,detect,detect,55864," to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56720,Safety,detect,detect,56720,"tra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56959,Safety,detect,detection,56959,"ry headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:322,Security,access,access,322,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:438,Security,access,accessed,438,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:865,Security,access,access,865,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:1040,Security,access,access,1040,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:3885,Security,access,access,3885,"evelopers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresponding ``#include <stdio.h>``: when the compiler sees the module import above, it loads a binary representation of the ``std.io`` module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preproce",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:7463,Security,expose,expose,7463,"dules:. * **Rewrite the world's code**: It is not realistic to require applications or software libraries to make drastic or non-backward-compatible changes, nor is it feasible to completely eliminate headers. Modules must interoperate with existing software libraries and allow a gradual transition. * **Versioning**: Modules have no notion of version information. Programmers must still rely on the existing versioning mechanisms of the underlying language (if any exist) to version software libraries. * **Namespaces**: Unlike in some languages, modules do not imply any notion of namespaces. Thus, a struct declared in one module will still conflict with a struct of the same name declared in a different module, just as they would if declared in two different headers. This aspect is important for backward compatibility, because (for example) the mangled names of entities in software libraries must not change when introducing modules. * **Binary distribution of modules**: Headers (particularly C++ headers) expose the full complexity of the language. Maintaining a stable binary module format across architectures, compiler versions, and compiler vendors is technically infeasible. Using Modules; =============; To enable modules, pass the command-line flag ``-fmodules``. This will make any modules-enabled software libraries available as modules as well as introducing any modules-specific syntax. Additional `command-line parameters`_ are described in a separate section later. Standard C++ Modules; --------------------; .. note::; Modules are adopted into C++20 Standard. And its semantic and command line interface are very different from the Clang C++ modules. See `StandardCPlusPlusModules <StandardCPlusPlusModules.html>`_ for details. Objective-C Import declaration; ------------------------------; Objective-C provides syntax for importing a module via an *@import declaration*, which imports the named module:. .. parsed-literal::. @import std;. The ``@import`` declaration above ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:9267,Security,access,access,9267,"aration; ------------------------------; Objective-C provides syntax for importing a module via an *@import declaration*, which imports the named module:. .. parsed-literal::. @import std;. The ``@import`` declaration above imports the entire contents of the ``std`` module (which would contain, e.g., the entire C or C++ standard library) and make its API available within the current translation unit. To import only part of a module, one may use dot syntax to specific a particular submodule, e.g.,. .. parsed-literal::. @import std.io;. Redundant import declarations are ignored, and one is free to import modules at any point within the translation unit, so long as the import declaration is at global scope. At present, there is no C or C++ syntax for import declarations. Clang; will track the modules proposal in the C++ committee. See the section; `Includes as imports`_ to see how modules get imported today. Includes as imports; -------------------; The primary user-level feature of modules is the import operation, which provides access to the API of software libraries. However, today's programs make extensive use of ``#include``, and it is unrealistic to assume that all of this code will change overnight. Instead, modules automatically translate ``#include`` directives into the corresponding module import. For example, the include directive. .. code-block:: c. #include <stdio.h>. will be automatically mapped to an import of the module ``std.io``. Even with specific ``import`` syntax in the language, this particular feature is important for both adoption and backward compatibility: automatic translation of ``#include`` to ``import`` allows an application to get the benefits of modules (for all modules-enabled libraries) without any changes to the application itself. Thus, users can easily use modules with one compiler while falling back to the preprocessor-inclusion mechanism with other compilers. .. note::. The automatic mapping of ``#include`` to ``import`` also solve",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:12885,Security,integrity,integrity,12885,"nto the corresponding submodule (``std.io``, ``std.lib``, ``std.math``, etc.). Having a list of the headers that are part of the ``std`` module allows the compiler to build the ``std`` module as a standalone entity, and having the mapping from header names to (sub)modules allows the automatic translation of ``#include`` directives to module imports. Module maps are specified as separate files (each named ``module.modulemap``) alongside the headers they describe, which allows them to be added to existing software libraries without having to change the library headers themselves (in most cases [#]_). The actual `Module map language`_ is described in a later section. .. note::. To actually see any benefits from modules, one first has to introduce module maps for the underlying C standard library and the libraries and headers on which it depends. The section `Modularizing a Platform`_ describes the steps one must take to write these module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15949,Security,access,access,15949,"dule map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loaded. ``-fmodules-search-all``; If a symbol is not found, search modules referenced in the current module maps but not imported for symbols, so the error message can reference the module by name. Note that if the global module index has not been built before, this might take some time as it needs",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:18272,Security,hash,hash,18272,"pecified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-fprebuilt-implicit-modules``; Enable prebuilt implicit modules. If a prebuilt module is not found in the; prebuilt modules paths (specified via ``-fprebuilt-module-path``), we will; look for a matching implicit module in the prebuilt modules paths. -cc1 Options; ~~~~~~~~~~~~. ``-fmodules-strict-context-hash``; Enables hashing of all compiler options that could impact the semantics of a; module in an implicit build. This includes things such as header search paths; and diagnostics. Using this option may lead to an excessive number of modules; being built if the command line arguments are not homogeneous across your; build. Using Prebuilt Modules; ----------------------. Below are a few examples illustrating uses of prebuilt modules via the different options. First, let's set up files for our examples. .. code-block:: c. /* A.h */; #ifdef ENABLE_A; void a() {}; #endif. .. code-block:: c. /* B.h */; #include ""A.h"". .. code-block:: c. /* use.c */; #include ""B.h""; void use() {; #ifdef ENABLE_A; a();; #endif; }. .. code-block:: c. /* module.modulemap */; module A {; header ""A.h""; }; module B {; header ""B.h""; export *; }. In the examples below, the compilation of ``use.c`` can be done without ``-cc1``, but the commands used to prebuild the modules would need to be updated to take into account the default options passed to ``clang -c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:18288,Security,hash,hashing,18288,"pecified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-fprebuilt-implicit-modules``; Enable prebuilt implicit modules. If a prebuilt module is not found in the; prebuilt modules paths (specified via ``-fprebuilt-module-path``), we will; look for a matching implicit module in the prebuilt modules paths. -cc1 Options; ~~~~~~~~~~~~. ``-fmodules-strict-context-hash``; Enables hashing of all compiler options that could impact the semantics of a; module in an implicit build. This includes things such as header search paths; and diagnostics. Using this option may lead to an excessive number of modules; being built if the command line arguments are not homogeneous across your; build. Using Prebuilt Modules; ----------------------. Below are a few examples illustrating uses of prebuilt modules via the different options. First, let's set up files for our examples. .. code-block:: c. /* A.h */; #ifdef ENABLE_A; void a() {}; #endif. .. code-block:: c. /* B.h */; #include ""A.h"". .. code-block:: c. /* use.c */; #include ""B.h""; void use() {; #ifdef ENABLE_A; a();; #endif; }. .. code-block:: c. /* module.modulemap */; module A {; header ""A.h""; }; module B {; header ""B.h""; export *; }. In the examples below, the compilation of ``use.c`` can be done without ``-cc1``, but the commands used to prebuild the modules would need to be updated to take into account the default options passed to ``clang -c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:20709,Security,hash,hash,20709,"f prebuilt ; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fmodule-file=A=prebuilt/A.pcm; clang -cc1 -emit-obj use.c -fmodules -fmodule-map-file=module.modulemap -fmodule-file=A=prebuilt/A.pcm -fmodule-file=B=prebuilt/B.pcm. Instead of of specifying the mappings manually, it can be convenient to use the ``-fprebuilt-module-path`` option. Let's also use ``-fimplicit-module-maps`` instead of manually pointing to our module map. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt. A trick to prebuild all modules required for our source file in one command is to generate implicit modules while using the ``-fdisable-module-hash`` option. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf pre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:20885,Security,hash,hash,20885,"ile=A=prebuilt/A.pcm; clang -cc1 -emit-obj use.c -fmodules -fmodule-map-file=module.modulemap -fmodule-file=A=prebuilt/A.pcm -fmodule-file=B=prebuilt/B.pcm. Instead of of specifying the mappings manually, it can be convenient to use the ``-fprebuilt-module-path`` option. Let's also use ``-fimplicit-module-maps`` instead of manually pointing to our module map. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt. A trick to prebuild all modules required for our source file in one command is to generate implicit modules while using the ``-fdisable-module-hash`` option. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:21814,Security,hash,hash,21814," -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:21929,Security,hash,hash,21929,"; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt_a -fdisable-module-hash -DENABLE_A; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt_a -DENABLE_A. Instead of managing the different module versions manually, we can build implicit modules in a given cache path (using ``-fmodules-cache-path``), and reuse them as prebuilt implicit modules by passing ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:33524,Security,access,accessible,33524,"paths. Modules can have a number of different kinds of members, each of which is described below:. .. parsed-literal::. *module-member*:; *requires-declaration*; *header-declaration*; *umbrella-dir-declaration*; *submodule-declaration*; *export-declaration*; *export-as-declaration*; *use-declaration*; *link-declaration*; *config-macros-declaration*; *conflict-declaration*. An extern module references a module defined by the *module-id* in a file given by the *string-literal*. The file can be referenced either by an absolute path or by a path relative to the current map file. Requires declaration; ~~~~~~~~~~~~~~~~~~~~; A *requires-declaration* specifies the requirements that an importing translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:36486,Security,access,access,36486,"pe_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attrs*:; '{' *header-attr** '}'. *header-attr*:; ``size`` *integer-literal*; ``mtime`` *integer-literal*. A header declaration that does not contain ``exclude`` nor ``textual`` specifies a header that contributes to the enclosing module. Specifically, when the module is built, the named header will be parsed and its declarations will be (logically) placed into the enclosing submodule. A header with the ``umbrella`` specifier is called an umbrella header. An umbrella header includes all of the headers within its directory (and any subdirectories), and is typically used (in the ``#include`` world) to easily access the full API provided by a particular library. With modules, an umbrella header is a convenient shortcut that eliminates the need to write out ``header`` declarations for every library header. A given directory can only contain a single umbrella header. .. note::; Any headers not included by the umbrella header should have; explicit ``header`` declarations. Use the; ``-Wincomplete-umbrella`` warning option to ask Clang to complain; about headers not covered by the umbrella header or the module map. A header with the ``private`` specifier may not be included from outside the module itself. A header with the ``textual`` specifier will not be compiled when the module is; built, and will be textually included if it is named by a ``#include``; directive. However, it is considered to be part of the module for the purpose; of checking *use-declaration*\s, and must still be a lexically-valid header; file. In the future, we intend to pre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:11598,Testability,log,logical,11598,"ompiler can guarantee that it always sees just the already-parsed definition from the module. While building a module, ``#include_next`` is also supported, with one caveat.; The usual behavior of ``#include_next`` is to search for the specified filename; in the list of include paths, starting from the path *after* the one; in which the current file was found.; Because files listed in module maps are not found through include paths, a; different strategy is used for ``#include_next`` directives in such files: the; list of include paths is searched for the specified header name, to find the; first include path that would refer to the current file. ``#include_next`` is; interpreted as if the current file had been found in that path.; If this search finds a file named by a module map, the ``#include_next``; directive is translated into an import, just like for a ``#include``; directive.``. Module maps; -----------; The crucial link between modules and headers is described by a *module map*, which describes how a collection of existing headers maps on to the (logical) structure of a module. For example, one could imagine a module ``std`` covering the C standard library. Each of the C standard library headers (``<stdio.h>``, ``<stdlib.h>``, ``<math.h>``, etc.) would contribute to the ``std`` module, by placing their respective APIs into the corresponding submodule (``std.io``, ``std.lib``, ``std.math``, etc.). Having a list of the headers that are part of the ``std`` module allows the compiler to build the ``std`` module as a standalone entity, and having the mapping from header names to (sub)modules allows the automatic translation of ``#include`` directives to module imports. Module maps are specified as separate files (each named ``module.modulemap``) alongside the headers they describe, which allows them to be added to existing software libraries without having to change the library headers themselves (in most cases [#]_). The actual `Module map language`_ is describe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:27400,Testability,log,logical,27400,"s visible and no visible directive overrides it.; * A set of macro directives is *consistent* if it consists of only ``#undef`` directives, or if all ``#define`` directives in the set define the macro name to the same sequence of tokens (following the usual rules for macro redefinitions).; * If a macro name is used and the set of active directives is not consistent, the program is ill-formed. Otherwise, the (unique) meaning of the macro name is used. For example, suppose:. * ``<stdio.h>`` defines a macro ``getc`` (and exports its ``#define``); * ``<cstdio>`` imports the ``<stdio.h>`` module and undefines the macro (and exports its ``#undef``). The ``#undef`` overrides the ``#define``, and a source file that imports both modules *in any order* will not see ``getc`` defined as a macro. Module Map Language; ===================. .. warning::. The module map language is not currently guaranteed to be stable between major revisions of Clang. The module map language describes the mapping from header files to the; logical structure of modules. To enable support for using a library as; a module, one must write a ``module.modulemap`` file for that library. The; ``module.modulemap`` file is placed alongside the header files themselves,; and is written in the module map language described below. .. note::; For compatibility with previous releases, if a module map file named; ``module.modulemap`` is not found, Clang will also search for a file named; ``module.map``. This behavior is deprecated and we plan to eventually; remove it. As an example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:28075,Testability,assert,assert,28075,", and a source file that imports both modules *in any order* will not see ``getc`` defined as a macro. Module Map Language; ===================. .. warning::. The module map language is not currently guaranteed to be stable between major revisions of Clang. The module map language describes the mapping from header files to the; logical structure of modules. To enable support for using a library as; a module, one must write a ``module.modulemap`` file for that library. The; ``module.modulemap`` file is placed alongside the header files themselves,; and is written in the module map language described below. .. note::; For compatibility with previous releases, if a module map file named; ``module.modulemap`` is not found, Clang will also search for a file named; ``module.map``. This behavior is deprecated and we plan to eventually; remove it. As an example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the ``export *`` command specifies that anything included by that submodule will be automatically re-exported. Lexical structure; -----------------; Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, ``/* */`` and ``//`` comments. The module map language has the following reserv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:28101,Testability,assert,assert,28101,", and a source file that imports both modules *in any order* will not see ``getc`` defined as a macro. Module Map Language; ===================. .. warning::. The module map language is not currently guaranteed to be stable between major revisions of Clang. The module map language describes the mapping from header files to the; logical structure of modules. To enable support for using a library as; a module, one must write a ``module.modulemap`` file for that library. The; ``module.modulemap`` file is placed alongside the header files themselves,; and is written in the module map language described below. .. note::; For compatibility with previous releases, if a module map file named; ``module.modulemap`` is not found, Clang will also search for a file named; ``module.map``. This behavior is deprecated and we plan to eventually; remove it. As an example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the ``export *`` command specifies that anything included by that submodule will be automatically re-exported. Lexical structure; -----------------; Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, ``/* */`` and ``//`` comments. The module map language has the following reserv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:28125,Testability,assert,assert-decls,28125," order* will not see ``getc`` defined as a macro. Module Map Language; ===================. .. warning::. The module map language is not currently guaranteed to be stable between major revisions of Clang. The module map language describes the mapping from header files to the; logical structure of modules. To enable support for using a library as; a module, one must write a ``module.modulemap`` file for that library. The; ``module.modulemap`` file is placed alongside the header files themselves,; and is written in the module map language described below. .. note::; For compatibility with previous releases, if a module map file named; ``module.modulemap`` is not found, Clang will also search for a file named; ``module.map``. This behavior is deprecated and we plan to eventually; remove it. As an example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the ``export *`` command specifies that anything included by that submodule will be automatically re-exported. Lexical structure; -----------------; Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, ``/* */`` and ``//`` comments. The module map language has the following reserved words; all other C identifiers are valid identifi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:36213,Testability,log,logically,36213,"xtended to also include C++ and C++11 headers using a *requires-declaration*:. .. parsed-literal::. module std {; // C standard library... module vector {; requires cplusplus; header ""vector""; }. module type_traits {; requires cplusplus11; header ""type_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attrs*:; '{' *header-attr** '}'. *header-attr*:; ``size`` *integer-literal*; ``mtime`` *integer-literal*. A header declaration that does not contain ``exclude`` nor ``textual`` specifies a header that contributes to the enclosing module. Specifically, when the module is built, the named header will be parsed and its declarations will be (logically) placed into the enclosing submodule. A header with the ``umbrella`` specifier is called an umbrella header. An umbrella header includes all of the headers within its directory (and any subdirectories), and is typically used (in the ``#include`` world) to easily access the full API provided by a particular library. With modules, an umbrella header is a convenient shortcut that eliminates the need to write out ``header`` declarations for every library header. A given directory can only contain a single umbrella header. .. note::; Any headers not included by the umbrella header should have; explicit ``header`` declarations. Use the; ``-Wincomplete-umbrella`` warning option to ask Clang to complain; about headers not covered by the umbrella header or the module map. A header with the ``private`` specifier may not be included from outside the module itself. A header with the ``textual`` specifier will not be compiled when the module is; built, and will",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:37820,Testability,assert,assert,37820,"uld have; explicit ``header`` declarations. Use the; ``-Wincomplete-umbrella`` warning option to ask Clang to complain; about headers not covered by the umbrella header or the module map. A header with the ``private`` specifier may not be included from outside the module itself. A header with the ``textual`` specifier will not be compiled when the module is; built, and will be textually included if it is named by a ``#include``; directive. However, it is considered to be part of the module for the purpose; of checking *use-declaration*\s, and must still be a lexically-valid header; file. In the future, we intend to pre-tokenize such headers and include the; token sequence within the prebuilt module representation. A header with the ``exclude`` specifier is excluded from the module. It will not be included when the module is built, nor will it be considered to be part of the module, even if an ``umbrella`` header or directory would otherwise make it part of the module. **Example:** The C header ``assert.h`` is an excellent candidate for a textual header, because it is meant to be included multiple times (possibly with different ``NDEBUG`` settings). However, declarations within it should typically be split into a separate modular header. .. parsed-literal::. module std [system] {; textual header ""assert.h""; }. A given header shall not be referenced by more than one *header-declaration*. Two *header-declaration*\s, or a *header-declaration* and a ``#include``, are; considered to refer to the same file if the paths resolve to the same file; and the specified *header-attr*\s (if any) match the attributes of that file,; even if the file is named differently (for instance, by a relative path or; via symlinks). .. note::; The use of *header-attr*\s avoids the need for Clang to speculatively; ``stat`` every header referenced by a module map. It is recommended that; *header-attr*\s only be used in machine-generated module maps, to avoid; mismatches between attribute values a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:38126,Testability,assert,assert,38126,"textual`` specifier will not be compiled when the module is; built, and will be textually included if it is named by a ``#include``; directive. However, it is considered to be part of the module for the purpose; of checking *use-declaration*\s, and must still be a lexically-valid header; file. In the future, we intend to pre-tokenize such headers and include the; token sequence within the prebuilt module representation. A header with the ``exclude`` specifier is excluded from the module. It will not be included when the module is built, nor will it be considered to be part of the module, even if an ``umbrella`` header or directory would otherwise make it part of the module. **Example:** The C header ``assert.h`` is an excellent candidate for a textual header, because it is meant to be included multiple times (possibly with different ``NDEBUG`` settings). However, declarations within it should typically be split into a separate modular header. .. parsed-literal::. module std [system] {; textual header ""assert.h""; }. A given header shall not be referenced by more than one *header-declaration*. Two *header-declaration*\s, or a *header-declaration* and a ``#include``, are; considered to refer to the same file if the paths resolve to the same file; and the specified *header-attr*\s (if any) match the attributes of that file,; even if the file is named differently (for instance, by a relative path or; via symlinks). .. note::; The use of *header-attr*\s avoids the need for Clang to speculatively; ``stat`` every header referenced by a module map. It is recommended that; *header-attr*\s only be used in machine-generated module maps, to avoid; mismatches between attribute values and the corresponding files. Umbrella directory declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; An umbrella directory declaration specifies that all of the headers in the specified directory should be included within the module. .. parsed-literal::. *umbrella-dir-declaration*:; ``umbrella`` *string-liter",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:45144,Testability,log,logically,45144,"ames the module that the current; module will be re-exported through. Only top-level modules; can be re-exported, and any given module may only be re-exported; through a single module. **Example:** In the following example, the module ``MyFrameworkCore``; will be re-exported via the module ``MyFramework``:. .. parsed-literal::. module MyFrameworkCore {; export_as MyFramework; }. Use declaration; ~~~~~~~~~~~~~~~; A *use-declaration* specifies another module that the current top-level module; intends to use. When the option *-fmodules-decluse* is specified, a module can; only use other modules that are explicitly specified in this way. .. parsed-literal::. *use-declaration*:; ``use`` *module-id*. **Example:** In the following example, use of A from C is not declared, so will trigger a warning. .. parsed-literal::. module A {; header ""a.h""; }. module B {; header ""b.h""; }. module C {; header ""c.h""; use B; }. When compiling a source file that implements a module, use the option; ``-fmodule-name=module-id`` to indicate that the source file is logically part; of that module. The compiler at present only applies restrictions to the module directly being built. Link declaration; ~~~~~~~~~~~~~~~~; A *link-declaration* specifies a library or framework against which a program should be linked if the enclosing module is imported in any translation unit in that program. .. parsed-literal::. *link-declaration*:; ``link`` ``framework``:sub:`opt` *string-literal*. The *string-literal* specifies the name of the library or framework against which the program should be linked. For example, specifying ""clangBasic"" would instruct the linker to link with ``-lclangBasic`` for a Unix-style linker. A *link-declaration* with the ``framework`` specifies that the linker should link against the named framework, e.g., with ``-framework MyFramework``. .. note::. Automatic linking with the ``link`` directive is not yet widely; implemented, because it requires support from both the object file; forma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47945,Testability,log,logging,47945,"ist of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part of the compiler diagnostic when two modules conflict. .. note::. Clang emits a warning (under the control of ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:48039,Testability,log,logging,48039,"er macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part of the compiler diagnostic when two modules conflict. .. note::. Clang emits a warning (under the control of ``-Wmodule-conflict``); when a module conflict is discovered. **Example:**. .. parsed-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:51803,Testability,log,logic,51803,"to; augment the primary module map file with an additional modules. For; example, we would split the module map file above into two module map; files:. .. code-block:: c. /* module.modulemap */; module Foo {; header ""Foo.h""; }. /* module.private.modulemap */; module Foo_Private {; header ""Foo_Private.h""; }. When a ``module.private.modulemap`` file is found alongside a; ``module.modulemap`` file, it is loaded after the ``module.modulemap``; file. In our example library, the ``module.private.modulemap`` file; would be available when ``Foo_Private.h`` is available, making it; easier to split a library's public and private APIs along header; boundaries. When writing a private module as part of a *framework*, it's recommended that:. * Headers for this module are present in the ``PrivateHeaders`` framework; subdirectory.; * The private module is defined as a *top level module* with the name of the; public framework prefixed, like ``Foo_Private`` above. Clang has extra logic; to work with this naming, using ``FooPrivate`` or ``Foo.Private`` (submodule); trigger warnings and might not work as expected. Modularizing a Platform; =======================; To get any benefit out of modules, one needs to introduce module maps for software libraries starting at the bottom of the stack. This typically means introducing a module map covering the operating system's headers and the C standard library headers (in ``/usr/include``, for a Unix system). The module maps will be written using the `module map language`_, which provides the tools necessary to describe the mapping between headers and modules. Because the set of headers differs from one system to the next, the module map will likely have to be somewhat customized for, e.g., a particular distribution and version of the operating system. Moreover, the system headers themselves may require some modification, if they exhibit any anti-patterns that break modules. Such common patterns are described below. **Macro-guarded copy-and-pas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:57311,Testability,test,test,57311,"oing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module map for Clang's compiler-specific header files. ``clang/test/Modules/``; Tests specifically related to modules functionality. ``clang/include/clang/Basic/Module.h``; The ``Module`` class in this header describes a module, and is used throughout the compiler to implement modules. ``clang/include/clang/Lex/ModuleMap.h``; The ``ModuleMap`` class in this header describes the full module map, consisting of all of the module map files that have been parsed, and providing facilities for looking up module maps and mapping between modules and headers (in both directions). PCHInternals_; Information about the serialized AST format used for precompiled headers and modules. The actual implementation is in the ``clangSerialization`` library. .. [#] Automatic linking against the libraries of modules requires specific linker support, which is not widely available. .. [#] There are certain anti-patterns that occur in headers, particularly system headers, that cause problems for modules. The section `Modularizing a Platform`_ describes some of them. .. [#] The second instance is actuall",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:705,Usability,simpl,simpler,705,"=======; Modules; =======. .. contents::; :local:. Introduction; ============; Most software is built using a number of software libraries, including libraries supplied by the platform, internal libraries built as part of the software itself to provide structure, and third-party libraries. For each library, one needs to access both its interface (API) and its implementation. In the C family of languages, the interface to a library is accessed by including the appropriate header files(s):. .. code-block:: c. #include <SomeLib.h>. The implementation is handled separately by linking against the appropriate library. For example, by passing ``-lSomeLib`` to the linker. Modules provide an alternative, simpler way to use software libraries that provides better compile-time scalability and eliminates many of the problems inherent to using the C preprocessor to access the API of a library. Problems with the current model; -------------------------------; The ``#include`` mechanism provided by the C preprocessor is a very poor way to access the API of a library, for a number of reasons:. * **Compile-time scalability**: Each time a header is included, the; compiler must preprocess and parse the text in that header and every; header it includes, transitively. This process must be repeated for; every translation unit in the application, which involves a huge; amount of redundant work. In a project with *N* translation units; and *M* headers included in each translation unit, the compiler is; performing *M x N* work even though most of the *M* headers are; shared among multiple translation units. C++ is particularly bad,; because the compilation model for templates forces a huge amount of; code into headers. * **Fragility**: ``#include`` directives are treated as textual; inclusion by the preprocessor, and are therefore subject to any; active macro definitions at the time of inclusion. If any of the; active macro definitions happens to collide with a name in the; library, it can b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:3425,Usability,clear,clear,3425,"ferent libraries interact; due to macro collisions, and users are forced to reorder; ``#include`` directives or introduce ``#undef`` directives to break; the (unintended) dependency. * **Conventional workarounds**: C programmers have; adopted a number of conventions to work around the fragility of the; C preprocessor model. Include guards, for example, are required for; the vast majority of headers to ensure that multiple inclusion; doesn't break the compile. Macro names are written with; ``LONG_PREFIXED_UPPERCASE_IDENTIFIERS`` to avoid collisions, and some; library/framework developers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:15577,Usability,clear,clear,15577,"t search for module map files named ``module.modulemap`` and similar. This option is implied by ``-fmodules``. If this is disabled with ``-fno-implicit-module-maps``, module map files will only be loaded if they are explicitly specified via ``-fmodule-map-file`` or transitively used by another module map file. ``-fmodules-cache-path=<directory>``; Specify the path to the modules cache. If not provided, Clang will select a system-appropriate default. ``-fno-autolink``; Disable automatic linking against the libraries associated with imported modules. ``-fmodules-ignore-macro=macroname``; Instruct modules to ignore the named macro when selecting an appropriate module variant. Use this for macros defined on the command line that don't affect how modules are built, to improve sharing of compiled module files. ``-fmodules-prune-interval=seconds``; Specify the minimum delay (in seconds) between attempts to prune the module cache. Module cache pruning attempts to clear out old, unused module files so that the module cache itself does not grow without bound. The default delay is large (604,800 seconds, or 7 days) because this is an expensive operation. Set this value to 0 to turn off pruning. ``-fmodules-prune-after=seconds``; Specify the minimum time (in seconds) for which a file in the module cache must be unused (according to access time) before module pruning will remove it. The default delay is large (2,678,400 seconds, or 31 days) to avoid excessive module rebuilding. ``-module-file-info <module file name>``; Debugging aid that prints information about a given module file (with a ``.pcm`` extension), including the language and preprocessor options that particular module variant was built with. ``-fmodules-decluse``; Enable checking of module ``use`` declarations. ``-fmodule-name=module-id``; Consider a source file as a part of the given module. ``-fmodule-map-file=<file>``; Load the given module map file if a header from its directory or one of its subdirectories is loa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:23328,Usability,simpl,simply,23328,"ng ``-fprebuilt-module-path`` and ``-fprebuilt-implicit-modules``. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -DENABLE_A; find prebuilt -name ""*.pcm""; # prebuilt/1AYBIGPM8R2GA/A-3L1K4LUA6O31.pcm; # prebuilt/1AYBIGPM8R2GA/B-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/A-3L1K4LUA6O31.pcm; # prebuilt/VH0YZMF1OIRK/B-3L1K4LUA6O31.pcm; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -DENABLE_A. Finally we want to allow implicit modules for configurations that were not prebuilt. When using the clang driver a module cache path is implicitly selected. Using ``-cc1``, we simply add use the ``-fmodules-cache-path`` option. .. code-block:: sh. clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A; clang -cc1 -emit-obj -o use.o use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -fprebuilt-implicit-modules -fmodules-cache-path=cache -DENABLE_A -DOTHER_OPTIONS. This way, a single directory containing multiple variants of modules can be prepared and reused. The options configuring the module cache are independent of other options. Module Semantics; ================. Modules are modeled as if each submodule were a separate translation unit, and a module import makes names from the other translation unit visible. Each submodule starts with a new preprocessor state and an empty translation un",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:28896,Usability,simpl,simplified,28896,"example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the ``export *`` command specifies that anything included by that submodule will be automatically re-exported. Lexical structure; -----------------; Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, ``/* */`` and ``//`` comments. The module map language has the following reserved words; all other C identifiers are valid identifiers. .. parsed-literal::. ``config_macros`` ``export_as`` ``private``; ``conflict`` ``framework`` ``requires``; ``exclude`` ``header`` ``textual``; ``explicit`` ``link`` ``umbrella``; ``extern`` ``module`` ``use``; ``export``. Module map file; ---------------; A module map file consists of a series of module declarations:. .. parsed-literal::. *module-map-file*:; *module-declaration**. Within a module map file, modules are referred to by a *module-id*, which uses periods to separate each part of a module's name:. .. parsed-literal::. *module-id*:; *identifier* ('.' *identifier*)*. Module declaration; ------------------; A module declaration describes a module, including the headers that contribute to that module, its submodules, and other aspects of the module. .. parsed-literal::. *module-decl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:43075,Usability,simpl,simply,43075," module A {; header ""A.h""; export *; }. explicit module B {; header ""B.h""; export *; }; }. Export declaration; ~~~~~~~~~~~~~~~~~~; An *export-declaration* specifies which imported modules will automatically be re-exported as part of a given module's API. .. parsed-literal::. *export-declaration*:; ``export`` *wildcard-module-id*. *wildcard-module-id*:; *identifier*; '*'; *identifier* '.' *wildcard-module-id*. The *export-declaration* names a module or a set of modules that will be re-exported to any translation unit that imports the enclosing module. Each imported module that matches the *wildcard-module-id* up to, but not including, the first ``*`` will be re-exported. **Example:** In the following example, importing ``MyLib.Derived`` also provides the API for ``MyLib.Base``:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export Base; }; }. Note that, if ``Derived.h`` includes ``Base.h``, one can simply use a wildcard export to re-export everything ``Derived.h`` includes:. .. parsed-literal::. module MyLib {; module Base {; header ""Base.h""; }. module Derived {; header ""Derived.h""; export *; }; }. .. note::. The wildcard export syntax ``export *`` re-exports all of the; modules that were imported in the actual header file. Because; ``#include`` directives are automatically mapped to module imports,; ``export *`` provides the same transitive-inclusion behavior; provided by the C preprocessor, e.g., importing a given module; implicitly imports all of the modules on which it depends.; Therefore, liberal use of ``export *`` provides excellent backward; compatibility for programs that rely on transitive inclusion (i.e.,; all of them). Re-export Declaration; ~~~~~~~~~~~~~~~~~~~~~; An *export-as-declaration* specifies that the current module will have; its interface re-exported by the named module. .. parsed-literal::. *export-as-declaration*:; ``export_as`` *identifier*. The *export-as-declaration* names the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:49368,Usability,simpl,simple,49368,"tion unit is likely to cause a problem. For example, two modules may provide similar-but-incompatible functionality. .. parsed-literal::. *conflict-declaration*:; ``conflict`` *module-id* ',' *string-literal*. The *module-id* of the *conflict-declaration* specifies the module with which the enclosing module conflicts. The specified module shall not have been imported in the translation unit when the enclosing module is imported. The *string-literal* provides a message to be provided as part of the compiler diagnostic when two modules conflict. .. note::. Clang emits a warning (under the control of ``-Wmodule-conflict``); when a module conflict is discovered. **Example:**. .. parsed-literal::. module Conflicts {; explicit module A {; header ""conflict_a.h""; conflict B, ""we just don't like B""; }. module B {; header ""conflict_b.h""; }; }. Attributes; ----------; Attributes are used in a number of places in the grammar to describe specific behavior of other declarations. The format of attributes is fairly simple. .. parsed-literal::. *attributes*:; *attribute* *attributes*:sub:`opt`. *attribute*:; '[' *identifier* ']'. Any *identifier* can be used as an attribute, and each declaration specifies what attributes can be applied to it. Private Module Map Files; ------------------------; Module map files are typically named ``module.modulemap`` and live; either alongside the headers they describe or in a parent directory of; the headers they describe. These module maps typically describe all of; the API for the library. However, in some cases, the presence or absence of particular headers; is used to distinguish between the ""public"" and ""private"" APIs of a; particular library. For example, a library may contain the headers; ``Foo.h`` and ``Foo_Private.h``, providing public and private APIs,; respectively. Additionally, ``Foo_Private.h`` may only be available on; some versions of library, and absent in others. One cannot easily; express this with a single module map file in the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:54391,Usability,simpl,simply,54391,"rresponding to the lucky first header. Any other headers that have copy-and-pasted versions of this pattern will *not* have a definition of ``size_t``. Importing the submodule corresponding to one of those headers will therefore not yield ``size_t`` as part of the API, because it wasn't there when the header was parsed. The fix for this problem is either to pull the copied declarations into a common header that gets included everywhere ``size_t`` is part of the API, or to eliminate the ``#ifndef`` and redefine the ``size_t`` type. The latter works for C++ headers and C11, but will cause an error for non-modules C90/C99, where redefinition of ``typedefs`` is not permitted. **Conflicting definitions**; Different system headers may provide conflicting definitions for various macros, functions, or types. These conflicting definitions don't tend to cause problems in a pre-modules world unless someone happens to include both headers in one translation unit. Since the fix is often simply ""don't do that"", such problems persist. Modules requires that the conflicting definitions be eliminated or that they be placed in separate modules (the former is generally the better answer). **Missing includes**; Headers are often missing ``#include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:55653,Usability,simpl,simply,55653,"include`` directives for headers that they actually depend on. As with the problem of conflicting definitions, this only affects unlucky users who don't happen to include headers in the right order. With modules, the headers of a particular module will be parsed in isolation, so the module may fail to build if there are missing includes. **Headers that vend multiple APIs at different times**; Some systems have headers that contain a number of different kinds of API definitions, only some of which are made available with a given include. For example, the header may vend ``size_t`` only when the macro ``__need_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no fun",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:56266,Usability,simpl,simple,56266,"d_size_t`` is defined before that header is included, and also vend ``wchar_t`` only when the macro ``__need_wchar_t`` is defined. Such headers are often included many times in a single translation unit, and will have no include guards. There is no sane way to map this header to a submodule. One can either eliminate the header (e.g., by splitting it into separate headers, one per actual API) or simply ``exclude`` it in the module map. To detect and help address some of these problems, the ``clang-tools-extra`` repository contains a ``modularize`` tool that parses a set of given headers and attempts to detect these problems and produce a report. See the tool's in-source documentation for information on how to check your system or library headers. Future Directions; =================; Modules support is under active development, and there are many opportunities remaining to improve it. Here are a few ideas:. **Detect unused module imports**; Unlike with ``#include`` directives, it should be fairly simple to track whether a directly-imported module has ever been used. By doing so, Clang can emit ``unused import`` or ``unused #include`` diagnostics, including Fix-Its to remove the useless imports/includes. **Fix-Its for missing imports**; It's fairly common for one to make use of some API while writing code, only to get a compiler error about ""unknown type"" or ""no function named"" because the corresponding header has not been included. Clang can detect such cases and auto-import the required module, but should provide a Fix-It to add the import. **Improve modularize**; The modularize tool is both extremely important (for deployment) and extremely crude. It needs better UI, better detection of problems (especially for C++), and perhaps an assistant mode to help write module maps for you. Where To Learn More About Modules; =================================; The Clang source code provides additional information about modules:. ``clang/lib/Headers/module.modulemap``; Module ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Modules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1174,Availability,recover,recover,1174,"</style>. .. role:: none; .. role:: partial; .. role:: good. ==================; MSVC compatibility; ==================. When Clang compiles C++ code for Windows, it attempts to be compatible with; MSVC. There are multiple dimensions to compatibility. First, Clang attempts to be ABI-compatible, meaning that Clang-compiled code; should be able to link against MSVC-compiled code successfully. However, C++; ABIs are particularly large and complicated, and Clang's support for MSVC's C++; ABI is a work in progress. If you don't require MSVC ABI compatibility or don't; want to use Microsoft's C and C++ runtimes, the mingw32 toolchain might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:2251,Availability,error,errors,2251,"ram. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Both `#pragma; pointers_to_members`_ and the `/vm`_ flags are supported. However, MSVC; supports an extension to allow creating a `pointer to a member of a virtual; base class`_. Clang does not yet support this. .. _#pragma pointers_to_members:; https://msdn.microsoft.com/en-us/library/83cch5a6.aspx; .. _/vm: https://msdn.microsoft.com/en-us/library/yad46a6z.aspx; .. _pointer to a member of a virtual base class: https://llvm.org/PR15713. * Debug info: :good:`Mostly complete`. Clang emits relatively complete CodeView; debu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:2329,Availability,error,errors,2329,"nd ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Both `#pragma; pointers_to_members`_ and the `/vm`_ flags are supported. However, MSVC; supports an extension to allow creating a `pointer to a member of a virtual; base class`_. Clang does not yet support this. .. _#pragma pointers_to_members:; https://msdn.microsoft.com/en-us/library/83cch5a6.aspx; .. _/vm: https://msdn.microsoft.com/en-us/library/yad46a6z.aspx; .. _pointer to a member of a virtual base class: https://llvm.org/PR15713. * Debug info: :good:`Mostly complete`. Clang emits relatively complete CodeView; debug information if ``/Z7`` or ``/Zi`` is passed. Microsoft's link.exe will; transform the CodeView",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6374,Availability,recover,recover,6374,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6666,Availability,recover,recovery,6666,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:5778,Integrability,depend,dependent,5778,"ling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:5893,Integrability,depend,dependent,5893,"ny invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:5935,Integrability,depend,depends,5935,"ny invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6023,Integrability,depend,dependent,6023,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6309,Integrability,depend,dependent,6309,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1683,Modifiability,inherit,inheritance,1683,"BI compatibility or don't; want to use Microsoft's C and C++ runtimes, the mingw32 toolchain might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Bot",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1799,Modifiability,inherit,inheritance,1799," might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Both `#pragma; pointers_to_members`_ and the `/vm`_ flags are supported. However, MSVC; supports",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1822,Modifiability,inherit,inheritance,1822," might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Both `#pragma; pointers_to_members`_ and the `/vm`_ flags are supported. However, MSVC; supports",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1847,Modifiability,inherit,inheritance,1847," might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Both `#pragma; pointers_to_members`_ and the `/vm`_ flags are supported. However, MSVC; supports",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4464,Modifiability,variab,variables,4464,"about CodeView and PDBs is ongoing. * RTTI: :good:`Complete`. Generation of RTTI data structures has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behav",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4577,Modifiability,variab,variables,4577,"es has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:5194,Modifiability,extend,extended,5194,"`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1174,Safety,recover,recover,1174,"</style>. .. role:: none; .. role:: partial; .. role:: good. ==================; MSVC compatibility; ==================. When Clang compiles C++ code for Windows, it attempts to be compatible with; MSVC. There are multiple dimensions to compatibility. First, Clang attempts to be ABI-compatible, meaning that Clang-compiled code; should be able to link against MSVC-compiled code successfully. However, C++; ABIs are particularly large and complicated, and Clang's support for MSVC's C++; ABI is a work in progress. If you don't require MSVC ABI compatibility or don't; want to use Microsoft's C and C++ runtimes, the mingw32 toolchain might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4344,Safety,safe,safe,4344,"ws; debuggers and other tools that consume PDB files like ETW. Work to teach lld; about CodeView and PDBs is ongoing. * RTTI: :good:`Complete`. Generation of RTTI data structures has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until ins",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4436,Safety,safe,safe,4436,"about CodeView and PDBs is ongoing. * RTTI: :good:`Complete`. Generation of RTTI data structures has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behav",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6374,Safety,recover,recover,6374,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6666,Safety,recover,recovery,6666,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1617,Testability,test,tested,1617," ABI is a work in progress. If you don't require MSVC ABI compatibility or don't; want to use Microsoft's C and C++ runtimes, the mingw32 toolchain might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1994,Testability,test,tested,1994,"by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers are; fully implemented and should be ABI compatible. Both `#pragma; pointers_to_members`_ and the `/vm`_ flags are supported. However, MSVC; supports an extension to allow creating a `pointer to a member of a virtual; base class`_. Clang does not yet support this. .. _#pragma pointers_to_members:; https://msdn.microsoft.com/en-us/library/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:3784,Testability,test,tested,3784,"tension to allow creating a `pointer to a member of a virtual; base class`_. Clang does not yet support this. .. _#pragma pointers_to_members:; https://msdn.microsoft.com/en-us/library/83cch5a6.aspx; .. _/vm: https://msdn.microsoft.com/en-us/library/yad46a6z.aspx; .. _pointer to a member of a virtual base class: https://llvm.org/PR15713. * Debug info: :good:`Mostly complete`. Clang emits relatively complete CodeView; debug information if ``/Z7`` or ``/Zi`` is passed. Microsoft's link.exe will; transform the CodeView debug information into a PDB that works in Windows; debuggers and other tools that consume PDB files like ETW. Work to teach lld; about CodeView and PDBs is ongoing. * RTTI: :good:`Complete`. Generation of RTTI data structures has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. Howeve",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:6829,Usability,simpl,simple,6829,"es that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of method bodies, it still parses the bodies *before* template argument; substitution, which is not what MSVC does. The following compatibility tweaks; are necessary to parse the template in those cases. MSVC allows some name lookup into dependent base classes. Even on other; platforms, this has been a `frequently asked question`_ for Clang users. A; dependent base class is a base class that depends on the value of a template; parameter. Clang cannot see any of the names inside dependent bases while it; is parsing your template, so the user is sometimes required to use the; ``typename`` keyword to assist the parser. On Windows, Clang attempts to; follow the normal lookup rules, but if lookup fails, it will assume that the; user intended to find the name in a dependent base. While parsing the; following program, Clang will recover as if the user had written the; commented-out code:. .. _frequently asked question:; https://clang.llvm.org/compatibility.html#dep_lookup. .. code-block:: c++. template <typename T>; struct Foo : T {; void f() {; /*typename*/ T::UnknownType x = /*this->*/unknownMember;; }; };. After recovery, Clang warns the user that this code is non-standard and issues; a hint suggesting how to fix the problem. As of this writing, Clang is able to compile a simple ATL hello world; application. There are still issues parsing WRL headers for modern Windows 8; apps, but they should be addressed soon.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1584,Availability,avail,available,1584,"e ability to; pick a suitable directory automatically, based on the options the user provides; to Clang. For example, if the user specifies; ``--target=arm-none-eabi -mcpu=cortex-m4`` the toolchain can choose a directory; containing headers and libraries suitable for Armv7E-M, because it knows that's; a suitable architecture for Arm Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2171,Availability,avail,available,2171,"the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:5488,Availability,mask,mask,5488,"r option is chosen then ``-isystem`` and ``-L`` options will be; generated for each matching multilib variant, in reverse order. This means that the compiler or linker will find files in the last matching; multilib variant that has the given file.; This behaviour permits multilib variants with only a partial set of files.; This means a toolchain can be distributed with one base multilib variant; containing all system headers and includes, and more specialised multilib; variants containing only files that are different to those in the base variant. For example, a multilib variant could be compiled with ``-fno-exceptions``.; This option doesn't affect the content of header files, nor does it affect the; C libraries. Therefore if multilib layering is supported by the ToolChain; subclass and a suitable base multilib variant is present then the; ``-fno-exceptions`` multilib variant need only contain C++ libraries. It is the responsibility of layered multilib authors to ensure that headers and; libraries in each layer are complete enough to mask any incompatibilities. Stability; =========. Multilib via configuration file shall be considered an experimental feature; until LLVM 18, at which point ``-print-multi-flags-experimental``; should be renamed to ``-print-multi-flags``.; A toolchain can opt in to using this feature by including a ``multilib.yaml``; file in its distribution, once support for it is added in relevant ToolChain; subclasses.; Once stability is reached, flags emitted by ``-print-multi-flags``; should not be removed or changed, although new flags may be added. Restrictions; ============. Despite the name, multilib is used to locate both ``include`` and ``lib``; directories. Therefore it is important that consistent options are passed to; the Clang driver when both compiling and linking. Otherwise inconsistent; ``include`` and ``lib`` directories may be used, and the results will be; undefined. EXPERIMENTAL multilib.yaml; ==========================. The belo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:6508,Availability,avail,available,6508," enough to mask any incompatibilities. Stability; =========. Multilib via configuration file shall be considered an experimental feature; until LLVM 18, at which point ``-print-multi-flags-experimental``; should be renamed to ``-print-multi-flags``.; A toolchain can opt in to using this feature by including a ``multilib.yaml``; file in its distribution, once support for it is added in relevant ToolChain; subclasses.; Once stability is reached, flags emitted by ``-print-multi-flags``; should not be removed or changed, although new flags may be added. Restrictions; ============. Despite the name, multilib is used to locate both ``include`` and ``lib``; directories. Therefore it is important that consistent options are passed to; the Clang driver when both compiling and linking. Otherwise inconsistent; ``include`` and ``lib`` directories may be used, and the results will be; undefined. EXPERIMENTAL multilib.yaml; ==========================. The below example serves as a small of a possible multilib, and documents; the available options. For a more comprehensive example see; ``clang/test/Driver/baremetal-multilib.yaml`` in the ``llvm-project`` sources. .. code-block:: yaml. # multilib.yaml. # This format is experimental and is likely to change!. # Syntax is YAML 1.2. # This required field defines the version of the multilib.yaml format.; # Clang will emit an error if this number is greater than its current multilib; # version or if its major version differs, but will accept lesser minor; # versions.; MultilibVersion: 1.0. # The rest of this file is in two parts:; # 1. A list of multilib variants.; # 2. A list of regular expressions that may match flags generated from; # command line options, and further flags that shall be added if the; # regular expression matches.; # It is acceptable for the file to contain properties not documented here,; # and these will be ignored by Clang. # List of multilib variants. Required.; # The ordering of items in the variants list is impo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:6854,Availability,error,error,6854,"s reached, flags emitted by ``-print-multi-flags``; should not be removed or changed, although new flags may be added. Restrictions; ============. Despite the name, multilib is used to locate both ``include`` and ``lib``; directories. Therefore it is important that consistent options are passed to; the Clang driver when both compiling and linking. Otherwise inconsistent; ``include`` and ``lib`` directories may be used, and the results will be; undefined. EXPERIMENTAL multilib.yaml; ==========================. The below example serves as a small of a possible multilib, and documents; the available options. For a more comprehensive example see; ``clang/test/Driver/baremetal-multilib.yaml`` in the ``llvm-project`` sources. .. code-block:: yaml. # multilib.yaml. # This format is experimental and is likely to change!. # Syntax is YAML 1.2. # This required field defines the version of the multilib.yaml format.; # Clang will emit an error if this number is greater than its current multilib; # version or if its major version differs, but will accept lesser minor; # versions.; MultilibVersion: 1.0. # The rest of this file is in two parts:; # 1. A list of multilib variants.; # 2. A list of regular expressions that may match flags generated from; # command line options, and further flags that shall be added if the; # regular expression matches.; # It is acceptable for the file to contain properties not documented here,; # and these will be ignored by Clang. # List of multilib variants. Required.; # The ordering of items in the variants list is important if more than one; # variant can match the same set of flags. See the docs on multilib layering; # for more info.; Variants:. # Example of a multilib variant targeting Arm v6-M.; # Dir is the relative location of the directory containing the headers; # and/or libraries.; # Exactly how Dir is used is left up to the ToolChain subclass to define, but; # typically it will be joined to the sysroot.; - Dir: thumb/v6-m; # List of one o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11080,Availability,error,error,11080,"``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12249,Availability,avail,available,12249,"ration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12512,Availability,mainten,maintenance,12512,"e possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have a negligible impact on; overall compile time.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1518,Deployability,configurat,configuration,1518,"s not; necessarily obvious which one to pick.; Multilib allows a toolchain designer to imbue the toolchain with the ability to; pick a suitable directory automatically, based on the options the user provides; to Clang. For example, if the user specifies; ``--target=arm-none-eabi -mcpu=cortex-m4`` the toolchain can choose a directory; containing headers and libraries suitable for Armv7E-M, because it knows that's; a suitable architecture for Arm Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1920,Deployability,configurat,configuration,1920," Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2033,Deployability,configurat,configuration,2033,"d on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2073,Deployability,configurat,configuration,2073," ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags bas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2113,Deployability,configurat,configuration,2113,"the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2407,Deployability,configurat,configuration,2407,"nu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions shall use the POSIX extended regular expression; syntax.; #. Match flags against multilib variants. If the generated flags are a superset; of the flags specified for a multilib varian",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:5551,Deployability,configurat,configuration,5551,"t matching; multilib variant that has the given file.; This behaviour permits multilib variants with only a partial set of files.; This means a toolchain can be distributed with one base multilib variant; containing all system headers and includes, and more specialised multilib; variants containing only files that are different to those in the base variant. For example, a multilib variant could be compiled with ``-fno-exceptions``.; This option doesn't affect the content of header files, nor does it affect the; C libraries. Therefore if multilib layering is supported by the ToolChain; subclass and a suitable base multilib variant is present then the; ``-fno-exceptions`` multilib variant need only contain C++ libraries. It is the responsibility of layered multilib authors to ensure that headers and; libraries in each layer are complete enough to mask any incompatibilities. Stability; =========. Multilib via configuration file shall be considered an experimental feature; until LLVM 18, at which point ``-print-multi-flags-experimental``; should be renamed to ``-print-multi-flags``.; A toolchain can opt in to using this feature by including a ``multilib.yaml``; file in its distribution, once support for it is added in relevant ToolChain; subclasses.; Once stability is reached, flags emitted by ``-print-multi-flags``; should not be removed or changed, although new flags may be added. Restrictions; ============. Despite the name, multilib is used to locate both ``include`` and ``lib``; directories. Therefore it is important that consistent options are passed to; the Clang driver when both compiling and linking. Otherwise inconsistent; ``include`` and ``lib`` directories may be used, and the results will be; undefined. EXPERIMENTAL multilib.yaml; ==========================. The below example serves as a small of a possible multilib, and documents; the available options. For a more comprehensive example see; ``clang/test/Driver/baremetal-multilib.yaml`` in the ``llvm-project",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9740,Deployability,release,released,9740,"whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9846,Deployability,release,release,9846," regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang sh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10594,Deployability,configurat,configuration,10594,"portant to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10895,Deployability,configurat,configuration,10895,"he flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11043,Deployability,configurat,configuration,11043,"``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11162,Deployability,configurat,configuration,11162,". The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11214,Deployability,configurat,configuration,11214,". The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11582,Deployability,configurat,configuration,11582,"ter LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12071,Deployability,configurat,configuration,12071,". Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12378,Deployability,configurat,configuration,12378,"s likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12405,Deployability,configurat,configuration,12405,"gned for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10649,Energy Efficiency,adapt,adapt,10649,"portant to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1686,Integrability,interface,interface,1686,"r provides; to Clang. For example, if the user specifies; ``--target=arm-none-eabi -mcpu=cortex-m4`` the toolchain can choose a directory; containing headers and libraries suitable for Armv7E-M, because it knows that's; a suitable architecture for Arm Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9276,Integrability,interface,interface,9276,"; # point unit).; - Dir: thumb/v7-m; # Here, the flags generated by Clang must be a superset of; # {--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16} for this multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a lim",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9372,Integrability,interface,interfaces,9372,"Clang must be a superset of; # {--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16} for this multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be use",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9466,Integrability,interface,interfaces,9466,"multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10186,Integrability,interface,interface,10186,"gs: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10434,Integrability,interface,interface,10434,"o be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1468,Modifiability,config,configure,1468,"s not; necessarily obvious which one to pick.; Multilib allows a toolchain designer to imbue the toolchain with the ability to; pick a suitable directory automatically, based on the options the user provides; to Clang. For example, if the user specifies; ``--target=arm-none-eabi -mcpu=cortex-m4`` the toolchain can choose a directory; containing headers and libraries suitable for Armv7E-M, because it knows that's; a suitable architecture for Arm Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1518,Modifiability,config,configuration,1518,"s not; necessarily obvious which one to pick.; Multilib allows a toolchain designer to imbue the toolchain with the ability to; pick a suitable directory automatically, based on the options the user provides; to Clang. For example, if the user specifies; ``--target=arm-none-eabi -mcpu=cortex-m4`` the toolchain can choose a directory; containing headers and libraries suitable for Armv7E-M, because it knows that's; a suitable architecture for Arm Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:1920,Modifiability,config,configuration,1920," Cortex-M4.; Multilib can also choose between libraries for the same architecture based on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2033,Modifiability,config,configuration,2033,"d on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2073,Modifiability,config,configuration,2073," ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags bas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2113,Modifiability,config,configuration,2113,"the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2407,Modifiability,config,configuration,2407,"nu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions shall use the POSIX extended regular expression; syntax.; #. Match flags against multilib variants. If the generated flags are a superset; of the flags specified for a multilib varian",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:3223,Modifiability,extend,extended,3223,"lation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,; which specifies how to generate additional flags based on the flags derived; from command line options. Flags are matched using regular expressions.; These regular expressions shall use the POSIX extended regular expression; syntax.; #. Match flags against multilib variants. If the generated flags are a superset; of the flags specified for a multilib variant then the variant is considered; a match.; If more than one variant matches then a toolchain may opt to either use only; the *last* matching multilib variant, or may use all matching variants,; thereby :ref:`layering<multilib-layering>` them.; #. Generate ``-isystem`` and ``-L`` options. Iterate in reverse order over; the matching multilib variants, and generate ``-isystem`` and ``-L``; options based on the multilib variant's directory. .. _multilib-layering:. Multilib layering; =================. When Clang selects multilib variants, it may find that more than one variant; matches. It is up to the ToolChain subclass to decide what to do in this case.; There are two options permitted:. #. Use only the *last* matching multilib variant. This option exists primarily; for compatibility with the previous multilib design.; #",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:5551,Modifiability,config,configuration,5551,"t matching; multilib variant that has the given file.; This behaviour permits multilib variants with only a partial set of files.; This means a toolchain can be distributed with one base multilib variant; containing all system headers and includes, and more specialised multilib; variants containing only files that are different to those in the base variant. For example, a multilib variant could be compiled with ``-fno-exceptions``.; This option doesn't affect the content of header files, nor does it affect the; C libraries. Therefore if multilib layering is supported by the ToolChain; subclass and a suitable base multilib variant is present then the; ``-fno-exceptions`` multilib variant need only contain C++ libraries. It is the responsibility of layered multilib authors to ensure that headers and; libraries in each layer are complete enough to mask any incompatibilities. Stability; =========. Multilib via configuration file shall be considered an experimental feature; until LLVM 18, at which point ``-print-multi-flags-experimental``; should be renamed to ``-print-multi-flags``.; A toolchain can opt in to using this feature by including a ``multilib.yaml``; file in its distribution, once support for it is added in relevant ToolChain; subclasses.; Once stability is reached, flags emitted by ``-print-multi-flags``; should not be removed or changed, although new flags may be added. Restrictions; ============. Despite the name, multilib is used to locate both ``include`` and ``lib``; directories. Therefore it is important that consistent options are passed to; the Clang driver when both compiling and linking. Otherwise inconsistent; ``include`` and ``lib`` directories may be used, and the results will be; undefined. EXPERIMENTAL multilib.yaml; ==========================. The below example serves as a small of a possible multilib, and documents; the available options. For a more comprehensive example see; ``clang/test/Driver/baremetal-multilib.yaml`` in the ``llvm-project",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9066,Modifiability,extend,extended,9066,"{target=thumbv6m-none-unknown-eabi}; # then this multilib variant will be considered a match.; Flags: [--target=thumbv6m-none-unknown-eabi]. # Similarly, a multilib variant targeting Arm v7-M with an FPU (floating; # point unit).; - Dir: thumb/v7-m; # Here, the flags generated by Clang must be a superset of; # {--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16} for this multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10594,Modifiability,config,configuration,10594,"portant to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10628,Modifiability,evolve,evolve,10628,"portant to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10649,Modifiability,adapt,adapt,10649,"portant to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10895,Modifiability,config,configuration,10895,"he flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11043,Modifiability,config,configuration,11043,"``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11162,Modifiability,config,configuration,11162,". The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11214,Modifiability,config,configuration,11214,". The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11582,Modifiability,config,configuration,11582,"ter LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12071,Modifiability,config,configuration,12071,". Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12378,Modifiability,config,configuration,12378,"s likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12405,Modifiability,config,configuration,12405,"gned for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2016,Performance,load,loading,2016,"d on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9947,Safety,avoid,avoided,9947," regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang sh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10401,Safety,avoid,avoid,10401,"o be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10950,Safety,avoid,avoid,10950,"``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11029,Safety,detect,detect,11029,"``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12054,Safety,detect,detection,12054,". Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12491,Safety,detect,detect,12491,"gned for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:6573,Testability,test,test,6573,"file shall be considered an experimental feature; until LLVM 18, at which point ``-print-multi-flags-experimental``; should be renamed to ``-print-multi-flags``.; A toolchain can opt in to using this feature by including a ``multilib.yaml``; file in its distribution, once support for it is added in relevant ToolChain; subclasses.; Once stability is reached, flags emitted by ``-print-multi-flags``; should not be removed or changed, although new flags may be added. Restrictions; ============. Despite the name, multilib is used to locate both ``include`` and ``lib``; directories. Therefore it is important that consistent options are passed to; the Clang driver when both compiling and linking. Otherwise inconsistent; ``include`` and ``lib`` directories may be used, and the results will be; undefined. EXPERIMENTAL multilib.yaml; ==========================. The below example serves as a small of a possible multilib, and documents; the available options. For a more comprehensive example see; ``clang/test/Driver/baremetal-multilib.yaml`` in the ``llvm-project`` sources. .. code-block:: yaml. # multilib.yaml. # This format is experimental and is likely to change!. # Syntax is YAML 1.2. # This required field defines the version of the multilib.yaml format.; # Clang will emit an error if this number is greater than its current multilib; # version or if its major version differs, but will accept lesser minor; # versions.; MultilibVersion: 1.0. # The rest of this file is in two parts:; # 1. A list of multilib variants.; # 2. A list of regular expressions that may match flags generated from; # command line options, and further flags that shall be added if the; # regular expression matches.; # It is acceptable for the file to contain properties not documented here,; # and these will be ignored by Clang. # List of multilib variants. Required.; # The ordering of items in the variants list is important if more than one; # variant can match the same set of flags. See the docs on multi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:11883,Testability,log,logic,11883,"----------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12163,Testability,log,logic,12163,"ration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12354,Testability,log,logic,12354,"s likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:9417,Usability,usab,usable,9417,"multilib variant; # to be a match.; Flags: [--target=thumbv7m-none-eabi, -mfpu=fpv4-sp-d16]. # The second section of the file is a list of regular expressions that are; # used to map from flags generated from command line options to custom flags.; # This is optional.; # Each regular expression must match a whole flag string.; # Flags in the ""Flags"" list will be added if any flag generated from command; # line options matches the regular expression.; Mappings:. # Set a ""--target=thumbv7m-none-eabi"" flag if the regular expression matches; # any of the flags generated from the command line options.; # Match is a POSIX extended regular expression string.; - Match: --target=thumbv([7-9]|[1-9][0-9]+).*; # Flags is a list of one or more strings.; Flags: [--target=thumbv7m-none-eabi]. Design principles; =================. Stable interface; ----------------. ``multilib.yaml`` and ``-print-multi-flags-experimental`` are new; interfaces to Clang. In order for them to be usable over time and across LLVM; versions their interfaces should be stable.; The new multilib system will be considered experimental in LLVM 17, but in; LLVM 18 it will be stable. In particular this is important to which multilib; selection flags Clang generates from command line options. Once a flag is; generated by a released version of Clang it may be used in ``multilib.yaml``; files that exist independently of the LLVM release cycle, and therefore; ceasing to generate the flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:13055,Usability,simpl,simple,13055,"e possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have a negligible impact on; overall compile time.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Multilib.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:6022,Availability,error,error,6022,"SeparatedByString:@"":""];. // structs.; NSValue *center = @(view.center); // Point p = view.center;; // [NSValue valueWithBytes:&p objCType:@encode(Point)];; NSValue *frame = @(view.frame); // Rect r = view.frame;; // [NSValue valueWithBytes:&r objCType:@encode(Rect)];. Boxed Enums; -----------. Cocoa frameworks frequently define constant values using *enums.*; Although enum values are integral, they may not be used directly as; boxed literals (this avoids conflicts with future ``'@'``-prefixed; Objective-C keywords). Instead, an enum value must be placed inside a; boxed expression. The following example demonstrates configuring an; ``AVAudioRecorder`` using a dictionary that contains a boxed enumeration; value:. .. code-block:: objc. enum {; AVAudioQualityMin = 0,; AVAudioQualityLow = 0x20,; AVAudioQualityMedium = 0x40,; AVAudioQualityHigh = 0x60,; AVAudioQualityMax = 0x7F; };. - (AVAudioRecorder *)recordToFile:(NSURL *)fileURL {; NSDictionary *settings = @{ AVEncoderAudioQualityKey : @(AVAudioQualityMax) };; return [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:NULL];; }. The expression ``@(AVAudioQualityMax)`` converts ``AVAudioQualityMax``; to an integer type, and boxes the value accordingly. If the enum has a; :ref:`fixed underlying type <objc-fixed-enum>` as in:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; NSNumber *red = @(Red), *green = @(Green), *blue = @(Blue); // => [NSNumber numberWithUnsignedChar:]. then the fixed underlying type will be used to select the correct; ``NSNumber`` creation method. Boxing a value of enum type will result in a ``NSNumber`` pointer with a; creation method according to the underlying type of the enum, which can; be a :ref:`fixed underlying type <objc-fixed-enum>`; or a compiler-defined integer type capable of representing the values of; all the members of the enumeration:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; Color col = Red;; NS",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:8958,Availability,error,error,8958,"rgument; }; }. As with all C pointers, character pointer expressions can involve; arbitrary pointer arithmetic, therefore programmers must ensure that the; character data is valid. Passing ``NULL`` as the character pointer will; raise an exception at runtime. When possible, the compiler will reject; ``NULL`` character pointers used in boxed expressions. Boxed C Structures; ------------------. Boxed expressions support construction of NSValue objects.; It said that C structures can be used, the only requirement is:; structure should be marked with ``objc_boxable`` attribute.; To support older version of frameworks and/or third-party libraries; you may need to add the attribute via ``typedef``. .. code-block:: objc. struct __attribute__((objc_boxable)) Point {; // ...; };. typedef struct __attribute__((objc_boxable)) _Size {; // ...; } Size;. typedef struct _Rect {; // ...; } Rect;. struct Point p;; NSValue *point = @(p); // ok; Size s;; NSValue *size = @(s); // ok. Rect r;; NSValue *bad_rect = @(r); // error. typedef struct __attribute__((objc_boxable)) _Rect Rect;. NSValue *good_rect = @(r); // ok. Container Literals; ==================. Objective-C now supports a new expression syntax for creating immutable; array and dictionary container objects. Examples; --------. Immutable array expression:. .. code-block:: objc. NSArray *array = @[ @""Hello"", NSApp, [NSNumber numberWithInt:42] ];. This creates an ``NSArray`` with 3 elements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that impl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:10199,Availability,error,error,10199,"iner objects. Examples; --------. Immutable array expression:. .. code-block:: objc. NSArray *array = @[ @""Hello"", NSApp, [NSNumber numberWithInt:42] ];. This creates an ``NSArray`` with 3 elements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:16726,Availability,error,error,16726,"the modern Objective-C runtime,; which categorically forbids such arithmetic. Currently, only subscripts of integral or Objective-C object pointer; type are supported. In C++, a class type can be used if it has a single; conversion function to an integral or Objective-C pointer type, in which; case that conversion is applied and analysis continues as appropriate.; Otherwise, the expression is ill-formed. An Objective-C object subscript expression is always an l-value. If the; expression appears on the left-hand side of a simple assignment operator; (=), the element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:20944,Availability,avail,availability,20944,"; NSArray *elements = [NSArray arrayWithObjects:objects count:4];; #endif. #if __has_feature(objc_dictionary_literals); // new way.; NSDictionary *masses = @{ @""H"" : @1.0078, @""He"" : @4.0026, @""O"" : @15.9990, @""C"" : @12.0096 };; #else; // old way (equivalent).; id keys[] = { @""H"", @""He"", @""O"", @""C"" };; id values[] = { [NSNumber numberWithDouble:1.0078], [NSNumber numberWithDouble:4.0026],; [NSNumber numberWithDouble:15.9990], [NSNumber numberWithDouble:12.0096] };; NSDictionary *masses = [NSDictionary dictionaryWithObjects:objects forKeys:keys count:4];; #endif. #if __has_feature(objc_subscripting); NSUInteger i, count = elements.count;; for (i = 0; i < count; ++i) {; NSString *element = elements[i];; NSNumber *mass = masses[element];; NSLog(@""the mass of %@ is %@"", element, mass);; }; #else; NSUInteger i, count = [elements count];; for (i = 0; i < count; ++i) {; NSString *element = [elements objectAtIndex:i];; NSNumber *mass = [masses objectForKey:element];; NSLog(@""the mass of %@ is %@"", element, mass);; }; #endif. #if __has_attribute(objc_boxable); typedef struct __attribute__((objc_boxable)) _Rect Rect;; #endif. #if __has_feature(objc_boxed_nsvalue_expressions); CABasicAnimation animation = [CABasicAnimation animationWithKeyPath:@""position""];; animation.fromValue = @(layer.position);; animation.toValue = @(newPosition);; [layer addAnimation:animation forKey:@""move""];; #else; CABasicAnimation animation = [CABasicAnimation animationWithKeyPath:@""position""];; animation.fromValue = [NSValue valueWithCGPoint:layer.position];; animation.toValue = [NSValue valueWithCGPoint:newPosition];; [layer addAnimation:animation forKey:@""move""];; #endif. Code can use also ``__has_feature(objc_bool)`` to check for the; availability of numeric literals support. This checks for the new; ``__objc_yes / __objc_no`` keywords, which enable the use of; ``@YES / @NO`` literals. To check whether boxed expressions are supported, use; ``__has_feature(objc_boxed_expressions)`` feature macro.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:447,Deployability,release,releases,447,"====================; Objective-C Literals; ====================. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:562,Deployability,release,releases,562,"====================; Objective-C Literals; ====================. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:6343,Energy Efficiency,green,green,6343,"e used directly as; boxed literals (this avoids conflicts with future ``'@'``-prefixed; Objective-C keywords). Instead, an enum value must be placed inside a; boxed expression. The following example demonstrates configuring an; ``AVAudioRecorder`` using a dictionary that contains a boxed enumeration; value:. .. code-block:: objc. enum {; AVAudioQualityMin = 0,; AVAudioQualityLow = 0x20,; AVAudioQualityMedium = 0x40,; AVAudioQualityHigh = 0x60,; AVAudioQualityMax = 0x7F; };. - (AVAudioRecorder *)recordToFile:(NSURL *)fileURL {; NSDictionary *settings = @{ AVEncoderAudioQualityKey : @(AVAudioQualityMax) };; return [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:NULL];; }. The expression ``@(AVAudioQualityMax)`` converts ``AVAudioQualityMax``; to an integer type, and boxes the value accordingly. If the enum has a; :ref:`fixed underlying type <objc-fixed-enum>` as in:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; NSNumber *red = @(Red), *green = @(Green), *blue = @(Blue); // => [NSNumber numberWithUnsignedChar:]. then the fixed underlying type will be used to select the correct; ``NSNumber`` creation method. Boxing a value of enum type will result in a ``NSNumber`` pointer with a; creation method according to the underlying type of the enum, which can; be a :ref:`fixed underlying type <objc-fixed-enum>`; or a compiler-defined integer type capable of representing the values of; all the members of the enumeration:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; Color col = Red;; NSNumber *nsCol = @(col); // => [NSNumber numberWithUnsignedChar:]. Boxed C Strings; ---------------. A C string literal prefixed by the ``'@'`` token denotes an ``NSString``; literal in the same way a numeric literal prefixed by the ``'@'`` token; denotes an ``NSNumber`` literal. When the type of the parenthesized; expression is ``(char *)`` or ``(const char *)``, the result of the; boxed expression is a poin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:17232,Energy Efficiency,allocate,allocated,17232,"is ill-formed. An Objective-C object subscript expression is always an l-value. If the; expression appears on the left-hand side of a simple assignment operator; (=), the element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:964,Integrability,wrap,wrap,964,"===============. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber numberWithLong:42L]; NSNumber *fortyTwoLongLong = ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:1196,Integrability,wrap,wrapped,1196,"umber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber numberWithLong:42L]; NSNumber *fortyTwoLongLong = @42LL; // equivalent to [NSNumber numberWithLongLong:42LL]. // floating point literals.; NSNumber *piFloat = @3.141592654F; // equivalent to [NSNumber numberWithFlo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3314,Integrability,wrap,wrapping,3314,"OOL literals.; NSNumber *yesNumber = @YES; // equivalent to [NSNumber numberWithBool:YES]; NSNumber *noNumber = @NO; // equivalent to [NSNumber numberWithBool:NO]. #ifdef __cplusplus; NSNumber *trueNumber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Objective-C++ also supports ``@true`` and ``@false`` expressions, which; are equivalent to ``@YES`` and ``@NO``. Boxed Expressions; =================. Objective-C provides a new syntax for boxing C expressions:. .. code-block:: objc. @( <expression> ). Expressio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:9970,Integrability,protocol,protocol,9970,"ct r;; NSValue *bad_rect = @(r); // error. typedef struct __attribute__((objc_boxable)) _Rect Rect;. NSValue *good_rect = @(r); // ok. Container Literals; ==================. Objective-C now supports a new expression syntax for creating immutable; array and dictionary container objects. Examples; --------. Immutable array expression:. .. code-block:: objc. NSArray *array = @[ @""Hello"", NSApp, [NSNumber numberWithInt:42] ];. This creates an ``NSArray`` with 3 elements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:11881,Integrability,message,message,11881," Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subscripts; *dictionary-style*; subscript expressions use Objective-C object pointer typed subscripts.; Each type of subscript expression is mapped to a message send using a; predefined selector. The advantage of this design is flexibility: class; designers are free to introduce subscripting by declaring methods or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:12058,Integrability,protocol,protocols,12058,"Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subscripts; *dictionary-style*; subscript expressions use Objective-C object pointer typed subscripts.; Each type of subscript expression is mapped to a message send using a; predefined selector. The advantage of this design is flexibility: class; designers are free to introduce subscripting by declaring methods or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a call to ``setObject:atIndexedSubscript:``. .. code-block:: objc. [object setObject:newValue atIndexedSubscript:idx];. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:12387,Integrability,depend,depending,12387,"tionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subscripts; *dictionary-style*; subscript expressions use Objective-C object pointer typed subscripts.; Each type of subscript expression is mapped to a message send using a; predefined selector. The advantage of this design is flexibility: class; designers are free to introduce subscripting by declaring methods or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a call to ``setObject:atIndexedSubscript:``. .. code-block:: objc. [object setObject:newValue atIndexedSubscript:idx];. These message sends are then type-checked and performed just like; explicit message sends. The method used for objectAtIndexedSubscript:; must be declared with an argument of integral type and a return value of; some Objective-C object pointer type. The method used for; setObject:atIndexedSubscript: must be declared with its first argument; having some Objectiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:13001,Integrability,message,message,13001,"ds or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a call to ``setObject:atIndexedSubscript:``. .. code-block:: objc. [object setObject:newValue atIndexedSubscript:idx];. These message sends are then type-checked and performed just like; explicit message sends. The method used for objectAtIndexedSubscript:; must be declared with an argument of integral type and a return value of; some Objective-C object pointer type. The method used for; setObject:atIndexedSubscript: must be declared with its first argument; having some Objective-C pointer type and its second argument having; integral type. The meaning of indexes is left up to the declaring class. The compiler; will coerce the index to the appropriate argument type of the method it; uses for type-checking. For an instance of ``NSArray``, reading an; element using an index outside the range ``[0, array.count)`` will raise; an exception. For an instance of ``NSMutableArray``, assigning to an; element using an index within this range will replace that element, but; assigning to an element using an index outside this range will raise an; exception; no syntax is provided for inserting, appending, or removing; elements for mutable arrays. A class need n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:13071,Integrability,message,message,13071,"ds or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a call to ``setObject:atIndexedSubscript:``. .. code-block:: objc. [object setObject:newValue atIndexedSubscript:idx];. These message sends are then type-checked and performed just like; explicit message sends. The method used for objectAtIndexedSubscript:; must be declared with an argument of integral type and a return value of; some Objective-C object pointer type. The method used for; setObject:atIndexedSubscript: must be declared with its first argument; having some Objective-C pointer type and its second argument having; integral type. The meaning of indexes is left up to the declaring class. The compiler; will coerce the index to the appropriate argument type of the method it; uses for type-checking. For an instance of ``NSArray``, reading an; element using an index outside the range ``[0, array.count)`` will raise; an exception. For an instance of ``NSMutableArray``, assigning to an; element using an index within this range will replace that element, but; assigning to an element using an index outside this range will raise an; exception; no syntax is provided for inserting, appending, or removing; elements for mutable arrays. A class need n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:14541,Integrability,depend,depending,14541,"the index to the appropriate argument type of the method it; uses for type-checking. For an instance of ``NSArray``, reading an; element using an index outside the range ``[0, array.count)`` will raise; an exception. For an instance of ``NSMutableArray``, assigning to an; element using an index within this range will replace that element, but; assigning to an element using an index outside this range will raise an; exception; no syntax is provided for inserting, appending, or removing; elements for mutable arrays. A class need not declare both methods in order to take advantage of this; language feature. For example, the class ``NSArray`` declares only; ``objectAtIndexedSubscript:``, so that assignments to elements will fail; to type-check; moreover, its subclass ``NSMutableArray`` declares; ``setObject:atIndexedSubscript:``. Dictionary-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an Objective-C object pointer type, the; expression is rewritten to use one of two different selectors, depending; on whether the element is being read from or written to. When an; expression reads an element using an Objective-C object pointer; subscript operand, as in the following example:. .. code-block:: objc. id key = ...;; id value = object[key];. it is translated into a call to the ``objectForKeyedSubscript:`` method:. .. code-block:: objc. id value = [object objectForKeyedSubscript:key];. When an expression writes an element using an Objective-C object pointer; subscript:. .. code-block:: objc. object[key] = newValue;. it is translated to a call to ``setObject:forKeyedSubscript:``. .. code-block:: objc. [object setObject:newValue forKeyedSubscript:key];. The behavior of ``setObject:forKeyedSubscript:`` is class-specific; but; in general it should replace an existing value if one is already; associated with a key, otherwise it should add a new value for the key.; No syntax is provided for removing elements from mutable dictionaries. Discussion; -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:16922,Integrability,message,message,16922,"gle; conversion function to an integral or Objective-C pointer type, in which; case that conversion is applied and analysis continues as appropriate.; Otherwise, the expression is ill-formed. An Objective-C object subscript expression is always an l-value. If the; expression appears on the left-hand side of a simple assignment operator; (=), the element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:18175,Integrability,protocol,protocol-literal,18175,"anteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selector-literal | protocol-literal | object-literal); ;. object-literal : ('+' | '-')? numeric-constant; | character-constant; | boolean-constant; | array-literal; | dictionary-literal; ;. boolean-constant : '__objc_yes' | '__objc_no' | 'true' | 'false' /* boolean keywords. */; ;. array-literal : '[' assignment-expression-list ']'; ;. assignment-expression-list : assignment-expression (',' assignment-expression-list)?; | /* empty */; ;. dictionary-literal : '{' key-value-list '}'; ;. key-value-list : key-value-pair (',' key-value-list)?; | /* empty */; ;. key-value-pair : assignment-expression ':' assignment-expression; ;. Note: ``@true`` and ``@false`` are only supported in Objective-C++. Availability Checks; ===================. Programs test for the new features by using clang's \_\_has\_feature; checks. Here are examples of their use:. .. code-block:: objc. #if __has_feature(objc_array_literals); // new way.; NSArray *elements = @[ @""H"", @""He"", @""O"", @""C"" ];; #else; // old way (",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:5551,Modifiability,config,configuring,5551,"o = @(M_PI / 2); // [NSNumber numberWithDouble:(M_PI / 2)]. // enumerated types.; typedef enum { Red, Green, Blue } Color;; NSNumber *favoriteColor = @(Green); // [NSNumber numberWithInt:((int)Green)]. // strings.; NSString *path = @(getenv(""PATH"")); // [NSString stringWithUTF8String:(getenv(""PATH""))]; NSArray *pathComponents = [path componentsSeparatedByString:@"":""];. // structs.; NSValue *center = @(view.center); // Point p = view.center;; // [NSValue valueWithBytes:&p objCType:@encode(Point)];; NSValue *frame = @(view.frame); // Rect r = view.frame;; // [NSValue valueWithBytes:&r objCType:@encode(Rect)];. Boxed Enums; -----------. Cocoa frameworks frequently define constant values using *enums.*; Although enum values are integral, they may not be used directly as; boxed literals (this avoids conflicts with future ``'@'``-prefixed; Objective-C keywords). Instead, an enum value must be placed inside a; boxed expression. The following example demonstrates configuring an; ``AVAudioRecorder`` using a dictionary that contains a boxed enumeration; value:. .. code-block:: objc. enum {; AVAudioQualityMin = 0,; AVAudioQualityLow = 0x20,; AVAudioQualityMedium = 0x40,; AVAudioQualityHigh = 0x60,; AVAudioQualityMax = 0x7F; };. - (AVAudioRecorder *)recordToFile:(NSURL *)fileURL {; NSDictionary *settings = @{ AVEncoderAudioQualityKey : @(AVAudioQualityMax) };; return [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:NULL];; }. The expression ``@(AVAudioQualityMax)`` converts ``AVAudioQualityMax``; to an integer type, and boxes the value accordingly. If the enum has a; :ref:`fixed underlying type <objc-fixed-enum>` as in:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; NSNumber *red = @(Red), *green = @(Green), *blue = @(Blue); // => [NSNumber numberWithUnsignedChar:]. then the fixed underlying type will be used to select the correct; ``NSNumber`` creation method. Boxing a value of enum type will result in a ``NSNumber`` pointer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:13041,Performance,perform,performed,13041,"ds or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following example:. .. code-block:: objc. NSUInteger idx = ...;; id value = object[idx];. it is translated into a call to ``objectAtIndexedSubscript:``. .. code-block:: objc. id value = [object objectAtIndexedSubscript:idx];. When an expression writes an element using an integral index:. .. code-block:: objc. object[idx] = newValue;. it is translated to a call to ``setObject:atIndexedSubscript:``. .. code-block:: objc. [object setObject:newValue atIndexedSubscript:idx];. These message sends are then type-checked and performed just like; explicit message sends. The method used for objectAtIndexedSubscript:; must be declared with an argument of integral type and a return value of; some Objective-C object pointer type. The method used for; setObject:atIndexedSubscript: must be declared with its first argument; having some Objective-C pointer type and its second argument having; integral type. The meaning of indexes is left up to the declaring class. The compiler; will coerce the index to the appropriate argument type of the method it; uses for type-checking. For an instance of ``NSArray``, reading an; element using an index outside the range ``[0, array.count)`` will raise; an exception. For an instance of ``NSMutableArray``, assigning to an; element using an index within this range will replace that element, but; assigning to an element using an index outside this range will raise an; exception; no syntax is provided for inserting, appending, or removing; elements for mutable arrays. A class need n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:17266,Performance,perform,performing,17266,"e element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selector-literal | protocol-literal | object-literal); ;. object-literal : ('+' | '-')? numeric-constant; | character-constant; | boolean-constant; | array-literal; | dictio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:741,Safety,safe,safety,741,"====================; Objective-C Literals; ====================. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:5380,Safety,avoid,avoids,5380,"OL), C string pointer; and some C structures (via NSValue) are supported:. .. code-block:: objc. // numbers.; NSNumber *smallestInt = @(-INT_MAX - 1); // [NSNumber numberWithInt:(-INT_MAX - 1)]; NSNumber *piOverTwo = @(M_PI / 2); // [NSNumber numberWithDouble:(M_PI / 2)]. // enumerated types.; typedef enum { Red, Green, Blue } Color;; NSNumber *favoriteColor = @(Green); // [NSNumber numberWithInt:((int)Green)]. // strings.; NSString *path = @(getenv(""PATH"")); // [NSString stringWithUTF8String:(getenv(""PATH""))]; NSArray *pathComponents = [path componentsSeparatedByString:@"":""];. // structs.; NSValue *center = @(view.center); // Point p = view.center;; // [NSValue valueWithBytes:&p objCType:@encode(Point)];; NSValue *frame = @(view.frame); // Rect r = view.frame;; // [NSValue valueWithBytes:&r objCType:@encode(Rect)];. Boxed Enums; -----------. Cocoa frameworks frequently define constant values using *enums.*; Although enum values are integral, they may not be used directly as; boxed literals (this avoids conflicts with future ``'@'``-prefixed; Objective-C keywords). Instead, an enum value must be placed inside a; boxed expression. The following example demonstrates configuring an; ``AVAudioRecorder`` using a dictionary that contains a boxed enumeration; value:. .. code-block:: objc. enum {; AVAudioQualityMin = 0,; AVAudioQualityLow = 0x20,; AVAudioQualityMedium = 0x40,; AVAudioQualityHigh = 0x60,; AVAudioQualityMax = 0x7F; };. - (AVAudioRecorder *)recordToFile:(NSURL *)fileURL {; NSDictionary *settings = @{ AVEncoderAudioQualityKey : @(AVAudioQualityMax) };; return [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:NULL];; }. The expression ``@(AVAudioQualityMax)`` converts ``AVAudioQualityMax``; to an integer type, and boxes the value accordingly. If the enum has a; :ref:`fixed underlying type <objc-fixed-enum>` as in:. .. code-block:: objc. typedef enum : unsigned char { Red, Green, Blue } Color;; NSNumber *red = @(Red), *green = @(Green), *blue =",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:10256,Safety,safe,safer,10256,"block:: objc. NSArray *array = @[ @""Hello"", NSApp, [NSNumber numberWithInt:42] ];. This creates an ``NSArray`` with 3 elements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[id",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:10411,Security,validat,validates,10411,"lements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:10710,Security,validat,validates,10710,"h 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subsc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:11553,Security,access,accessor,11553,"gument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subscripts; *dictionary-style*; subscript expressions use Objective-C object pointer typed subscripts.; Each type of subscript expression is mapped to a message send using a; predefined selector. The advantage of this design is flexibility: class; designers are free to introduce subscripting by declaring methods or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:18907,Testability,test,test,18907,"mmar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selector-literal | protocol-literal | object-literal); ;. object-literal : ('+' | '-')? numeric-constant; | character-constant; | boolean-constant; | array-literal; | dictionary-literal; ;. boolean-constant : '__objc_yes' | '__objc_no' | 'true' | 'false' /* boolean keywords. */; ;. array-literal : '[' assignment-expression-list ']'; ;. assignment-expression-list : assignment-expression (',' assignment-expression-list)?; | /* empty */; ;. dictionary-literal : '{' key-value-list '}'; ;. key-value-list : key-value-pair (',' key-value-list)?; | /* empty */; ;. key-value-pair : assignment-expression ':' assignment-expression; ;. Note: ``@true`` and ``@false`` are only supported in Objective-C++. Availability Checks; ===================. Programs test for the new features by using clang's \_\_has\_feature; checks. Here are examples of their use:. .. code-block:: objc. #if __has_feature(objc_array_literals); // new way.; NSArray *elements = @[ @""H"", @""He"", @""O"", @""C"" ];; #else; // old way (equivalent).; id objects[] = { @""H"", @""He"", @""O"", @""C"" };; NSArray *elements = [NSArray arrayWithObjects:objects count:4];; #endif. #if __has_feature(objc_dictionary_literals); // new way.; NSDictionary *masses = @{ @""H"" : @1.0078, @""He"" : @4.0026, @""O"" : @15.9990, @""C"" : @12.0096 };; #else; // old way (equivalent).; id keys[] = { @""H"", @""He"", @""O"", @""C"" };; id values[] = { [NSNumber numberWithDouble:1.0078], [NSNumber numberWithDouble:4.0026],; [NSNumber numberWithDouble:15.9990], [NSNumber numberWithDouble:12.0096] };; NSDictionary *masses = [NSDictionary dictionaryWithObjects:objects forKeys:keys count:4];; #endif. #if __has_feature(objc_subscripting); NSUInteger i, count = elements.count;; for (i = 0; i < count; ++i) {; NSString *element = elements[i];; NSNumber *mass",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:646,Usability,simpl,simplify,646,"====================; Objective-C Literals; ====================. Introduction; ============. Three new features were introduced into clang at the same time:; *NSNumber Literals* provide a syntax for creating ``NSNumber`` from; scalar literal expressions; *Collection Literals* provide a short-hand; for creating arrays and dictionaries; *Object Subscripting* provides a; way to use subscripting with Objective-C objects. Users of Apple; compiler releases can use these features starting with the Apple LLVM; Compiler 4.0. Users of open-source LLVM.org compiler releases can use; these features starting with clang v3.1. These language additions simplify common Objective-C programming; patterns, make programs more concise, and improve the safety of; container creation. This document describes how the features are implemented in clang, and; how to use them in your own programs. NSNumber Literals; =================. The framework class ``NSNumber`` is used to wrap scalar values inside; objects: signed and unsigned integers (``char``, ``short``, ``int``,; ``long``, ``long long``), floating point numbers (``float``,; ``double``), and boolean values (``BOOL``, C++ ``bool``). Scalar values; wrapped in objects are also known as *boxed* values. In Objective-C, any character, numeric or boolean literal prefixed with; the ``'@'`` character will evaluate to a pointer to an ``NSNumber``; object initialized with that value. C's type suffixes may be used to; control the size of numeric literals. Examples; --------. The following program illustrates the rules for ``NSNumber`` literals:. .. code-block:: objc. void main(int argc, const char *argv[]) {; // character literals.; NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z']. // integral literals.; NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42]; NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U]; NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3071,Usability,simpl,simple,3071,"NSNumber numberWithLongLong:42LL]. // floating point literals.; NSNumber *piFloat = @3.141592654F; // equivalent to [NSNumber numberWithFloat:3.141592654F]; NSNumber *piDouble = @3.1415926535; // equivalent to [NSNumber numberWithDouble:3.1415926535]. // BOOL literals.; NSNumber *yesNumber = @YES; // equivalent to [NSNumber numberWithBool:YES]; NSNumber *noNumber = @NO; // equivalent to [NSNumber numberWithBool:NO]. #ifdef __cplusplus; NSNumber *trueNumber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Object",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:3483,Usability,simpl,simply,3483,"mber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true]; NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false]; #endif; }. Discussion; ----------. NSNumber literals only support literal scalar values after the ``'@'``.; Consequently, ``@INT_MAX`` works, but ``@INT_MIN`` does not, because; they are defined like this:. .. code-block:: objc. #define INT_MAX 2147483647 /* max value for an int */; #define INT_MIN (-2147483647-1) /* min value for an int */. The definition of ``INT_MIN`` is not a simple literal, but a; parenthesized expression. Parenthesized expressions are supported using; the `boxed expression <#objc_boxed_expressions>`_ syntax, which is; described in the next section. Because ``NSNumber`` does not currently support wrapping ``long double``; values, the use of a ``long double NSNumber`` literal (e.g.; ``@123.23L``) will be rejected by the compiler. Previously, the ``BOOL`` type was simply a typedef for ``signed char``,; and ``YES`` and ``NO`` were macros that expand to ``(BOOL)1`` and; ``(BOOL)0`` respectively. To support ``@YES`` and ``@NO`` expressions,; these macros are now defined using new language keywords in; ``<objc/objc.h>``:. .. code-block:: objc. #if __has_feature(objc_bool); #define YES __objc_yes; #define NO __objc_no; #else; #define YES ((BOOL)1); #define NO ((BOOL)0); #endif. The compiler implicitly converts ``__objc_yes`` and ``__objc_no`` to; ``(BOOL)1`` and ``(BOOL)0``. The keywords are used to disambiguate; ``BOOL`` and integer literals. Objective-C++ also supports ``@true`` and ``@false`` expressions, which; are equivalent to ``@YES`` and ``@NO``. Boxed Expressions; =================. Objective-C provides a new syntax for boxing C expressions:. .. code-block:: objc. @( <expression> ). Expressions of scalar (numeric, enumerated, BOOL), C string pointer; and some C structures (via NSValue) are supported:. .. code-block:: objc. // numbers.; NSNumber *smallestInt = @(-INT_MAX - 1); // [NSNumber",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:16294,Usability,simpl,simple,16294," replace an existing value if one is already; associated with a key, otherwise it should add a new value for the key.; No syntax is provided for removing elements from mutable dictionaries. Discussion; ----------. An Objective-C subscript expression occurs when the base operand of the; C subscript operator has an Objective-C object pointer type. Since this; potentially collides with pointer arithmetic on the value, these; expressions are only supported under the modern Objective-C runtime,; which categorically forbids such arithmetic. Currently, only subscripts of integral or Objective-C object pointer; type are supported. In C++, a class type can be used if it has a single; conversion function to an integral or Objective-C pointer type, in which; case that conversion is applied and analysis continues as appropriate.; Otherwise, the expression is ill-formed. An Objective-C object subscript expression is always an l-value. If the; expression appears on the left-hand side of a simple assignment operator; (=), the element is written as described below. If the expression; appears on the left-hand side of a compound assignment operator (e.g.; +=), the program is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:17435,Usability,simpl,simple,17435,"m is ill-formed, because the result of reading an element; is always an Objective-C object pointer and no binary operators are; legal on such pointers. If the expression appears in any other position,; the element is read as described below. It is an error to take the; address of a subscript expression, or (in C++) to bind a reference to; it. Programs can use object subscripting with Objective-C object pointers of; type ``id``. Normal dynamic message send rules apply; the compiler must; see *some* declaration of the subscripting methods, and will pick the; declaration seen first. Caveats; =======. Objects created using the literal or boxed expression syntax are not; guaranteed to be uniqued by the runtime, but nor are they guaranteed to; be newly-allocated. As such, the result of performing direct comparisons; against the location of an object literal (using ``==``, ``!=``, ``<``,; ``<=``, ``>``, or ``>=``) is not well-defined. This is usually a simple; mistake in code that intended to call the ``isEqual:`` method (or the; ``compare:`` method). This caveat applies to compile-time string literals as well.; Historically, string literals (using the ``@""...""`` syntax) have been; uniqued across translation units during linking. This is an; implementation detail of the compiler and should not be relied upon. If; you are using such code, please use global string constants instead; (``NSString * const MyConst = @""...""``) or use ``isEqual:``. Grammar Additions; =================. To support the new syntax described above, the Objective-C; ``@``-expression grammar has the following new productions:. ::. objc-at-expression : '@' (string-literal | encode-literal | selector-literal | protocol-literal | object-literal); ;. object-literal : ('+' | '-')? numeric-constant; | character-constant; | boolean-constant; | array-literal; | dictionary-literal; ;. boolean-constant : '__objc_yes' | '__objc_no' | 'true' | 'false' /* boolean keywords. */; ;. array-literal : '[' assignment-expres",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:8351,Availability,error,error,8351,"ad.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+=============================================================================+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | flags | Flags used to indicate some features, mostly unused. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:10877,Availability,error,errors,10877,"of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance and prevents a; class of errors where a symbol in the target device could preempt a host; library. The OpenMP runtime library is linked in during compilation to provide the; implementations for standard OpenMP functionality. For GPU targets this is done; by linking in a special bitcode library during compilation, (e.g.; ``libomptarget-nvptx64-sm_70.bc``) using the ``-mlink-builtin-bitcode`` flag.; Other device libraries, such as CUDA's libdevice, are also linked this way. If; the target is a standard architecture with an existing ``libomp``; implementation, that will be linked instead. Finally, device tools are used to; create a relocatable device object file that can be embedded in the host. .. _Creating Fat Objects:. Creating Fat Objects; --------------------. A fat binary is a binary file that contains information intended for another; device. We create a fat object by embedding the output of the device compilation; stage into the host as a named section. The output from the device compilation; is passed to the host b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:20100,Availability,avail,available,20100,"-----------------------------------+; | .omp_offloading.device_image.N | __tgt_device_image | .omp_offloading_entries | ELF device code object of the (N+1)th image. |; +--------------------------------+---------------------+-------------------------+---------------------------------------------------------+; | .omp_offloading.device_images | __tgt_device_image | .omp_offloading_entries | Array of images. |; +--------------------------------+---------------------+-------------------------+---------------------------------------------------------+; | .omp_offloading.descriptor | __tgt_bin_desc | .omp_offloading_entries | Binary descriptor object (see :ref:`binary_descriptor`) |; +--------------------------------+---------------------+-------------------------+---------------------------------------------------------+. .. _binary_descriptor:. Binary Descriptor for Device Images; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This object is passed to the offloading runtime at program startup and it; describes all device images available in the executable or shared library. It; is defined as follows:. .. code-block:: c. __attribute__((visibility(""hidden""))); extern __tgt_offload_entry *__start_omp_offloading_entries;; __attribute__((visibility(""hidden""))); extern __tgt_offload_entry *__stop_omp_offloading_entries;; static const char Image0[] = { <Bufs.front() contents> };; ...; static const char ImageN[] = { <Bufs.back() contents> };; static const __tgt_device_image Images[] = {; {; Image0, /*ImageStart*/; Image0 + sizeof(Image0), /*ImageEnd*/; __start_omp_offloading_entries, /*EntriesBegin*/; __stop_omp_offloading_entries /*EntriesEnd*/; },; ...; {; ImageN, /*ImageStart*/; ImageN + sizeof(ImageN), /*ImageEnd*/; __start_omp_offloading_entries, /*EntriesBegin*/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesB",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:2514,Integrability,wrap,wrapper,2514,"bjects, run the device linking step, and embed the final image in a symbol the; host runtime library can use to register the library and access the symbols on; the device. Compilation Process; ^^^^^^^^^^^^^^^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and create metadata to indicate which entries are on the device.; * Compile the input file for the target :ref:`device <Device Compilation>` using; the :ref:`offloading entry <Generating Offloading Entries>` metadata created; by the host.; * Link the OpenMP device runtime library and run the backend to create a device; object file.; * Run the backend on the host bitcode file and create a :ref:`fat object file; <Creating Fat Objects>` using the device object file.; * Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>`; and extract the device objects. Run the device linking action on the extracted; objects.; * :ref:`Wrap <Device Binary Wrapping>` the :ref:`device images <Device linking>`; and :ref:`offload entries <Generating Offloading Entries>` in a symbol that; can be accessed by the host.; * Add the :ref:`wrapped binary <Device Binary Wrapping>` to the linker input and; run the host linking action. Link with ``libomptarget`` to register and; execute the images. .. _Generating Offloading Entries:. Generating Offloading Entries; -----------------------------. The first step in compilation is to generate offloading entries for the host.; This information is used to identify function kernels or global values that will; be provided by the device. Blocks contained in a ``#pragma omp target`` or; symbols inside a ``#pragma omp declare target`` directive will have offloading; entries generated. The following table shows the :ref:`offload entry structure; <table-tgt_offload_entry_s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:2841,Integrability,wrap,wrapped,2841,bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and create metadata to indicate which entries are on the device.; * Compile the input file for the target :ref:`device <Device Compilation>` using; the :ref:`offloading entry <Generating Offloading Entries>` metadata created; by the host.; * Link the OpenMP device runtime library and run the backend to create a device; object file.; * Run the backend on the host bitcode file and create a :ref:`fat object file; <Creating Fat Objects>` using the device object file.; * Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>`; and extract the device objects. Run the device linking action on the extracted; objects.; * :ref:`Wrap <Device Binary Wrapping>` the :ref:`device images <Device linking>`; and :ref:`offload entries <Generating Offloading Entries>` in a symbol that; can be accessed by the host.; * Add the :ref:`wrapped binary <Device Binary Wrapping>` to the linker input and; run the host linking action. Link with ``libomptarget`` to register and; execute the images. .. _Generating Offloading Entries:. Generating Offloading Entries; -----------------------------. The first step in compilation is to generate offloading entries for the host.; This information is used to identify function kernels or global values that will; be provided by the device. Blocks contained in a ``#pragma omp target`` or; symbols inside a ``#pragma omp declare target`` directive will have offloading; entries generated. The following table shows the :ref:`offload entry structure; <table-tgt_offload_entry_structure>`. .. table:: __tgt_offload_entry Structure; :name: table-tgt_offload_entry_structure. +---------+------------+------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+========================================================================+; | void* | addr | Address of,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:8357,Integrability,message,messages,8357,"ad.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+=============================================================================+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | flags | Flags used to indicate some features, mostly unused. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:13817,Integrability,wrap,wrapper,13817,". +----------------------------------+------------------------------------------------------------------------------+; | Section | Description |; +==================================+==============================================================================+; | omp_offloading_entries | Offloading entry information (see :ref:`table-tgt_offload_entry_structure`) |; +----------------------------------+------------------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding off",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:14077,Integrability,wrap,wrapped,14077,"Offloading entry information (see :ref:`table-tgt_offload_entry_structure`) |; +----------------------------------+------------------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding offloading entries to create the symbols; necessary to load and execute the device image. Structure Types; ^^^^^^^^^^^^^^^. Several different structures are used to store offloading information. The; :ref:`device image structure <table-device_image_structure>` stores a single; linked device i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:14202,Integrability,wrap,wrapper,14202,"---------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding offloading entries to create the symbols; necessary to load and execute the device image. Structure Types; ^^^^^^^^^^^^^^^. Several different structures are used to store offloading information. The; :ref:`device image structure <table-device_image_structure>` stores a single; linked device image and its associated offloading entries. The offloading; entries are stored using the ``__start_omp_offloading_entries``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21860,Integrability,rout,routine,21860,"/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00 A 0 0 1;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:22978,Integrability,wrap,wrapper,22978,"D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00 A 0 0 1; [12] .llvm.offloading PROGBITS 0000000000000000 000260 030950 00 E 0 0 8. Compiling this file again will invoke the ``clang-linker-wrapper`` utility to; extract and link the device code stored at the section named; ``.llvm.offloading`` and then use entries stored in; the section named ``omp_offloading_entries`` to create the symbols necessary for; ``libomptarget`` to register the device image and call the entry function. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 zaxpy.o -o zaxpy; $ ./zaxpy. We can see the steps created by clang to generate the offloading code using the; ``-ccc-print-phases`` option in Clang. This matches the description in; :ref:`Offloading Overview`. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -ccc-print-phases zaxpy.cpp; # ""x86_64-unknown-linux-gnu"" - ""clang"", inputs: [""zaxpy.cpp""], output: ""/tmp/zaxpy-host.bc""; # ""nvptx64-nvidia-cuda"" - ""clang"", inputs: [""zaxpy.cpp"", ""/tmp/zaxpy-e6a41b.bc""], output: ""/tmp/zaxpy-07f434.s""; # ""nvptx64-nvidia-cuda"" - ""NVPTX::Assembler"", inputs: [""/tmp/zaxpy-07f434.s""], output: ""/tmp/zaxpy-0af7b7.o""; # ""x86_64-unknown-linux-gnu""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:748,Modifiability,plugin,plugin,748,"=============================; Offloading Design & Internals; =============================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver and code generation steps for creating; offloading applications. Clang supports offloading to various architectures; using programming models like CUDA, HIP, and OpenMP. The purpose of this; document is to illustrate the steps necessary to create an offloading; application using Clang. OpenMP Offloading; =================. Clang supports OpenMP target offloading to several different architectures such; as NVPTX, AMDGPU, X86_64, Arm, and PowerPC. Offloading code is generated by; Clang and then executed using the ``libomptarget`` runtime and the associated; plugin for the target architecture, e.g. ``libomptarget.rtl.cuda``. This section; describes the steps necessary to create a functioning device image that can be; loaded by the OpenMP runtime. More information on the OpenMP runtimes can be; found at the `OpenMP documentation page <https://openmp.llvm.org>`__. .. _Offloading Overview:. Offloading Overview; -------------------. The goal of offloading compilation is to create an executable device image that; can be run on the target device. OpenMP offloading creates executable images by; compiling the input file for both the host and the target device. The output; from the device phase then needs to be embedded into the host to create a fat; object. A special tool then needs to extract the device code from the fat; objects, run the device linking step, and embed the final image in a symbol the; host runtime library can use to register the library and access the symbols on; the device. Compilation Process; ^^^^^^^^^^^^^^^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:5866,Modifiability,variab,variable,5866,"ffloading entry is an entry; to a target region it can have one of the following :ref:`entry flags; <table-offload_entry_flags>`. .. table:: Target Region Entry Flags; :name: table-offload_entry_flags. +----------------------------------+-------+-----------------------------------------+; | Name | Value | Description |; +==================================+=======+=========================================+; | OMPTargetRegionEntryTargetRegion | 0x00 | Mark the entry as generic target region |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryCtor | 0x02 | Mark the entry as a global constructor |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryDtor | 0x04 | Mark the entry as a global destructor |; +----------------------------------+-------+-----------------------------------------+. If the offloading entry is a global variable, indicated by a non-zero size, it; will instead have one of the following :ref:`global; <table-offload_global_flags>` flags. .. table:: Target Region Global; :name: table-offload_global_flags. +-----------------------------+-------+---------------------------------------------------------------+; | Name | Value | Description |; +=============================+=======+===============================================================+; | OMPTargetGlobalVarEntryTo | 0x00 | Mark the entry as a 'to' attribute (w.r.t. the to clause) |; +-----------------------------+-------+---------------------------------------------------------------+; | OMPTargetGlobalVarEntryLink | 0x01 | Mark the entry as a 'link' attribute (w.r.t. the link clause) |; +-----------------------------+-------+---------------------------------------------------------------+. The target offload entries are used by the runtime to access the device kernels; and globals that will be provided by the final device image. Each offloading; entry is set to use the ``omp_off",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:7805,Modifiability,variab,variables,7805,"final device image. Each offloading; entry is set to use the ``omp_offloading_entries`` section. When the final; application is created the linker will provide the; ``__start_omp_offloading_entries`` and ``__stop_omp_offloading_entries`` symbols; which are used to create the :ref:`final image <Device Binary Wrapping>`. This information is used by the device compilation stage to determine which; symbols need to be exported from the device. We use the ``omp_offload.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+==================================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:7896,Modifiability,variab,variables,7896," the final; application is created the linker will provide the; ``__start_omp_offloading_entries`` and ``__stop_omp_offloading_entries`` symbols; which are used to create the :ref:`final image <Device Binary Wrapping>`. This information is used by the device compilation stage to determine which; symbols need to be exported from the device. We use the ``omp_offload.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+=============================================================================+; | int32_t | reserved | Reserved, to be used by the runtime library. |; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:9890,Modifiability,variab,variables,9890,"==================+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | flags | Flags used to indicate some features, mostly unused. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | char* | psource | Program source information, stored as "";filename;function;line;column;;\\0"" |; +---------+------------+-----------------------------------------------------------------------------+. If debugging information is enabled, we will also create strings to indicate the; names and declarations of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:10083,Modifiability,variab,variable,10083,"-----------------------------------+; | int32_t | flags | Flags used to indicate some features, mostly unused. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | char* | psource | Program source information, stored as "";filename;function;line;column;;\\0"" |; +---------+------------+-----------------------------------------------------------------------------+. If debugging information is enabled, we will also create strings to indicate the; names and declarations of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance and prevents a; class of errors where a symbol in the target device could preempt a host; library. The OpenMP runtime library is linked in during compilation to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:17418,Modifiability,variab,variables,17418,"or. +----------------------+------------------+------------------------------------------+; | Type | Identifier | Description |; +======================+==================+==========================================+; | int32_t | NumDeviceImages | Number of device types supported |; +----------------------+------------------+------------------------------------------+; | __tgt_device_image* | DeviceImages | Array of device images (1 per dev. type) |; +----------------------+------------------+------------------------------------------+; | __tgt_offload_entry* | HostEntriesBegin | Begin of table with all host entries |; +----------------------+------------------+------------------------------------------+; | __tgt_offload_entry* | HostEntriesEnd | End of table (non inclusive) |; +----------------------+------------------+------------------------------------------+. Global Variables; ----------------. :ref:`table-global_variables` lists various global variables, along with their; type and their explicit ELF sections, which are used to store device images and; related symbols. .. table:: Global Variables; :name: table-global_variables. +--------------------------------+---------------------+-------------------------+---------------------------------------------------------+; | Variable | Type | ELF Section | Description |; +================================+=====================+=========================+=========================================================+; | __start_omp_offloading_entries | __tgt_offload_entry | .omp_offloading_entries | Begin symbol for the offload entries table. |; +--------------------------------+---------------------+-------------------------+---------------------------------------------------------+; | __stop_omp_offloading_entries | __tgt_offload_entry | .omp_offloading_entries | End symbol for the offload entries table. |; +--------------------------------+---------------------+-------------------------+------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:910,Performance,load,loaded,910,"=============================; Offloading Design & Internals; =============================. .. contents::; :local:. Introduction; ============. This document describes the Clang driver and code generation steps for creating; offloading applications. Clang supports offloading to various architectures; using programming models like CUDA, HIP, and OpenMP. The purpose of this; document is to illustrate the steps necessary to create an offloading; application using Clang. OpenMP Offloading; =================. Clang supports OpenMP target offloading to several different architectures such; as NVPTX, AMDGPU, X86_64, Arm, and PowerPC. Offloading code is generated by; Clang and then executed using the ``libomptarget`` runtime and the associated; plugin for the target architecture, e.g. ``libomptarget.rtl.cuda``. This section; describes the steps necessary to create a functioning device image that can be; loaded by the OpenMP runtime. More information on the OpenMP runtimes can be; found at the `OpenMP documentation page <https://openmp.llvm.org>`__. .. _Offloading Overview:. Offloading Overview; -------------------. The goal of offloading compilation is to create an executable device image that; can be run on the target device. OpenMP offloading creates executable images by; compiling the input file for both the host and the target device. The output; from the device phase then needs to be embedded into the host to create a fat; object. A special tool then needs to extract the device code from the fat; objects, run the device linking step, and embed the final image in a symbol the; host runtime library can use to register the library and access the symbols on; the device. Compilation Process; ^^^^^^^^^^^^^^^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:1748,Performance,perform,performs,1748,"re, e.g. ``libomptarget.rtl.cuda``. This section; describes the steps necessary to create a functioning device image that can be; loaded by the OpenMP runtime. More information on the OpenMP runtimes can be; found at the `OpenMP documentation page <https://openmp.llvm.org>`__. .. _Offloading Overview:. Offloading Overview; -------------------. The goal of offloading compilation is to create an executable device image that; can be run on the target device. OpenMP offloading creates executable images by; compiling the input file for both the host and the target device. The output; from the device phase then needs to be embedded into the host to create a fat; object. A special tool then needs to extract the device code from the fat; objects, run the device linking step, and embed the final image in a symbol the; host runtime library can use to register the library and access the symbols on; the device. Compilation Process; ^^^^^^^^^^^^^^^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and create metadata to indicate which entries are on the device.; * Compile the input file for the target :ref:`device <Device Compilation>` using; the :ref:`offloading entry <Generating Offloading Entries>` metadata created; by the host.; * Link the OpenMP device runtime library and run the backend to create a device; object file.; * Run the backend on the host bitcode file and create a :ref:`fat object file; <Creating Fat Objects>` using the device object file.; * Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>`; and extract the device objects. Run the device linking action on the extracted; objects.; * :ref:`Wrap <Device Binary Wrapping>` the :ref:`device images <Device linking>`; and :ref:`offload entries <Generating Offloading Entries>` in a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:4819,Performance,load,loaded,4819,"===========+========================================================================+; | void* | addr | Address of global symbol within device image (function or global) |; +---------+------------+------------------------------------------------------------------------+; | char* | name | Name of the symbol |; +---------+------------+------------------------------------------------------------------------+; | size_t | size | Size of the entry info (0 if it is a function) |; +---------+------------+------------------------------------------------------------------------+; | int32_t | flags | Flags associated with the entry (see :ref:`table-offload_entry_flags`) |; +---------+------------+------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+------------------------------------------------------------------------+. The address of the global symbol will be set to the device pointer value by the; runtime once the device image is loaded. The flags are set to indicate the; handling required for the offloading entry. If the offloading entry is an entry; to a target region it can have one of the following :ref:`entry flags; <table-offload_entry_flags>`. .. table:: Target Region Entry Flags; :name: table-offload_entry_flags. +----------------------------------+-------+-----------------------------------------+; | Name | Value | Description |; +==================================+=======+=========================================+; | OMPTargetRegionEntryTargetRegion | 0x00 | Mark the entry as generic target region |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryCtor | 0x02 | Mark the entry as a global constructor |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryDtor | 0x04 | Mark the entry as a global destructor |; +----------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:10274,Performance,perform,performed,10274,"e runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | int32_t | reserved | Reserved, to be used by the runtime library. |; +---------+------------+-----------------------------------------------------------------------------+; | char* | psource | Program source information, stored as "";filename;function;line;column;;\\0"" |; +---------+------------+-----------------------------------------------------------------------------+. If debugging information is enabled, we will also create strings to indicate the; names and declarations of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance and prevents a; class of errors where a symbol in the target device could preempt a host; library. The OpenMP runtime library is linked in during compilation to provide the; implementations for standard OpenMP functionality. For GPU targets this is done; by linking in a special bitcode library during compilation, (e.g.; ``libomptarget-nvptx64-sm_70.bc``) using the ``-mlink-builtin-bitcode`` flag.; Other device libraries, s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:10657,Performance,perform,performed,10657,"\\0"" |; +---------+------------+-----------------------------------------------------------------------------+. If debugging information is enabled, we will also create strings to indicate the; names and declarations of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance and prevents a; class of errors where a symbol in the target device could preempt a host; library. The OpenMP runtime library is linked in during compilation to provide the; implementations for standard OpenMP functionality. For GPU targets this is done; by linking in a special bitcode library during compilation, (e.g.; ``libomptarget-nvptx64-sm_70.bc``) using the ``-mlink-builtin-bitcode`` flag.; Other device libraries, such as CUDA's libdevice, are also linked this way. If; the target is a standard architecture with an existing ``libomp``; implementation, that will be linked instead. Finally, device tools are used to; create a relocatable device object file that can be embedded in the host. .. _Creating Fat Objects:. Creating Fat Objects; --------------------. A fat binary is a binary file that contains i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:10840,Performance,perform,performance,10840,"of variables mapped in target regions. These have the; same format as the source location in the :ref:`identifier structure; <table-ident_t_structure>`, but the function name is replaced with the variable; name. .. _Device Compilation:. Offload Device Compilation; --------------------------. The input file is compiled for each active device toolchain. The device; compilation stage is performed differently from the host stage. Namely, we do; not generate any offloading entries. This is set by passing the; ``-fopenmp-is-target-device`` flag to the front-end. We use the host bitcode to; determine which symbols to export from the device. The bitcode file is passed in; from the previous stage using the ``-fopenmp-host-ir-file-path`` flag.; Compilation is otherwise performed as it would be for any other target triple. When compiling for the OpenMP device, we set the visibility of all device; symbols to be ``protected`` by default. This improves performance and prevents a; class of errors where a symbol in the target device could preempt a host; library. The OpenMP runtime library is linked in during compilation to provide the; implementations for standard OpenMP functionality. For GPU targets this is done; by linking in a special bitcode library during compilation, (e.g.; ``libomptarget-nvptx64-sm_70.bc``) using the ``-mlink-builtin-bitcode`` flag.; Other device libraries, such as CUDA's libdevice, are also linked this way. If; the target is a standard architecture with an existing ``libomp``; implementation, that will be linked instead. Finally, device tools are used to; create a relocatable device object file that can be embedded in the host. .. _Creating Fat Objects:. Creating Fat Objects; --------------------. A fat binary is a binary file that contains information intended for another; device. We create a fat object by embedding the output of the device compilation; stage into the host as a named section. The output from the device compilation; is passed to the host b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:14141,Performance,load,load,14141,"Offloading entry information (see :ref:`table-tgt_offload_entry_structure`) |; +----------------------------------+------------------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding offloading entries to create the symbols; necessary to load and execute the device image. Structure Types; ^^^^^^^^^^^^^^^. Several different structures are used to store offloading information. The; :ref:`device image structure <table-device_image_structure>` stores a single; linked device i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:14265,Performance,optimiz,optimization,14265,"---------------------------------------------------------------------+; | .llvm.offloading | Embedded device object file for the target device and architecture |; +----------------------------------+------------------------------------------------------------------------------+. .. _Device Linking:. Linking Target Device Code; --------------------------. Objects containing :ref:`table-offloading_sections` require special handling to; create an executable device image. This is done using a Clang tool, see; :doc:`ClangLinkerWrapper` for more information. This tool works as a wrapper; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding offloading entries to create the symbols; necessary to load and execute the device image. Structure Types; ^^^^^^^^^^^^^^^. Several different structures are used to store offloading information. The; :ref:`device image structure <table-device_image_structure>` stores a single; linked device image and its associated offloading entries. The offloading; entries are stored using the ``__start_omp_offloading_entries``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:14876,Performance,load,load,14876,"r; over the host linking job. It scans the input object files for the offloading; section ``.llvm.offloading``. The device files stored in this section are then; extracted and passed to the appropriate linking job. The linked device image is; then :ref:`wrapped <Device Binary Wrapping>` to create the symbols used to load; the device image and link it with the host. The linker wrapper tool supports linking bitcode files through link time; optimization (LTO). This is used whenever the object files embedded in the host; contain LLVM bitcode. Bitcode will be embedded for architectures that do not; support a relocatable object format, such as AMDGPU or SPIR-V, or if the user; requested it using the ``-foffload-lto`` flag. .. _Device Binary Wrapping:. Device Binary Wrapping; ----------------------. Various structures and functions are used to create the information necessary to; offload code on the device. We use the :ref:`linked device executable <Device; Linking>` with the corresponding offloading entries to create the symbols; necessary to load and execute the device image. Structure Types; ^^^^^^^^^^^^^^^. Several different structures are used to store offloading information. The; :ref:`device image structure <table-device_image_structure>` stores a single; linked device image and its associated offloading entries. The offloading; entries are stored using the ``__start_omp_offloading_entries`` and; ``__stop_omp_offloading_entries`` symbols generated by the linker using the; :ref:`table-tgt_offload_entry_structure`. .. table:: __tgt_device_image Structure; :name: table-device_image_structure. +----------------------+--------------+----------------------------------------+; | Type | Identifier | Description |; +======================+==============+========================================+; | void* | ImageStart | Pointer to the target code start |; +----------------------+--------------+----------------------------------------+; | void* | ImageEnd | Pointer to the targe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:1658,Security,access,access,1658,"architectures such; as NVPTX, AMDGPU, X86_64, Arm, and PowerPC. Offloading code is generated by; Clang and then executed using the ``libomptarget`` runtime and the associated; plugin for the target architecture, e.g. ``libomptarget.rtl.cuda``. This section; describes the steps necessary to create a functioning device image that can be; loaded by the OpenMP runtime. More information on the OpenMP runtimes can be; found at the `OpenMP documentation page <https://openmp.llvm.org>`__. .. _Offloading Overview:. Offloading Overview; -------------------. The goal of offloading compilation is to create an executable device image that; can be run on the target device. OpenMP offloading creates executable images by; compiling the input file for both the host and the target device. The output; from the device phase then needs to be embedded into the host to create a fat; object. A special tool then needs to extract the device code from the fat; objects, run the device linking step, and embed the final image in a symbol the; host runtime library can use to register the library and access the symbols on; the device. Compilation Process; ^^^^^^^^^^^^^^^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and create metadata to indicate which entries are on the device.; * Compile the input file for the target :ref:`device <Device Compilation>` using; the :ref:`offloading entry <Generating Offloading Entries>` metadata created; by the host.; * Link the OpenMP device runtime library and run the backend to create a device; object file.; * Run the backend on the host bitcode file and create a :ref:`fat object file; <Creating Fat Objects>` using the device object file.; * Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>`; and extract the device obj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:2802,Security,access,accessed,2802,^^^^^. The compiler performs the following high-level actions to generate OpenMP; offloading code:. * Compile the input file for the host to produce a bitcode file. Lower ``#pragma; omp target`` declarations to :ref:`offloading entries <Generating Offloading; Entries>` and create metadata to indicate which entries are on the device.; * Compile the input file for the target :ref:`device <Device Compilation>` using; the :ref:`offloading entry <Generating Offloading Entries>` metadata created; by the host.; * Link the OpenMP device runtime library and run the backend to create a device; object file.; * Run the backend on the host bitcode file and create a :ref:`fat object file; <Creating Fat Objects>` using the device object file.; * Pass the fat object file to the :ref:`linker wrapper tool <Device Linking>`; and extract the device objects. Run the device linking action on the extracted; objects.; * :ref:`Wrap <Device Binary Wrapping>` the :ref:`device images <Device linking>`; and :ref:`offload entries <Generating Offloading Entries>` in a symbol that; can be accessed by the host.; * Add the :ref:`wrapped binary <Device Binary Wrapping>` to the linker input and; run the host linking action. Link with ``libomptarget`` to register and; execute the images. .. _Generating Offloading Entries:. Generating Offloading Entries; -----------------------------. The first step in compilation is to generate offloading entries for the host.; This information is used to identify function kernels or global values that will; be provided by the device. Blocks contained in a ``#pragma omp target`` or; symbols inside a ``#pragma omp declare target`` directive will have offloading; entries generated. The following table shows the :ref:`offload entry structure; <table-tgt_offload_entry_structure>`. .. table:: __tgt_offload_entry Structure; :name: table-tgt_offload_entry_structure. +---------+------------+------------------------------------------------------------------------+; | Type | Iden,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:6776,Security,access,access,6776,"-----------------------------------+. If the offloading entry is a global variable, indicated by a non-zero size, it; will instead have one of the following :ref:`global; <table-offload_global_flags>` flags. .. table:: Target Region Global; :name: table-offload_global_flags. +-----------------------------+-------+---------------------------------------------------------------+; | Name | Value | Description |; +=============================+=======+===============================================================+; | OMPTargetGlobalVarEntryTo | 0x00 | Mark the entry as a 'to' attribute (w.r.t. the to clause) |; +-----------------------------+-------+---------------------------------------------------------------+; | OMPTargetGlobalVarEntryLink | 0x01 | Mark the entry as a 'link' attribute (w.r.t. the link clause) |; +-----------------------------+-------+---------------------------------------------------------------+. The target offload entries are used by the runtime to access the device kernels; and globals that will be provided by the final device image. Each offloading; entry is set to use the ``omp_offloading_entries`` section. When the final; application is created the linker will provide the; ``__start_omp_offloading_entries`` and ``__stop_omp_offloading_entries`` symbols; which are used to create the :ref:`final image <Device Binary Wrapping>`. This information is used by the device compilation stage to determine which; symbols need to be exported from the device. We use the ``omp_offload.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21753,Usability,simpl,simple,21753,"ImageN), /*ImageEnd*/; __start_omp_offloading_entries, /*EntriesBegin*/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:21838,Usability,simpl,simple,21838,"/; __stop_omp_offloading_entries /*EntriesEnd*/; }; };; static const __tgt_bin_desc BinDesc = {; sizeof(Images) / sizeof(Images[0]), /*NumDeviceImages*/; Images, /*DeviceImages*/; __start_omp_offloading_entries, /*HostEntriesBegin*/; __stop_omp_offloading_entries /*HostEntriesEnd*/; };. Global Constructor and Destructor; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The global constructor (``.omp_offloading.descriptor_reg()``) registers the; device images with the runtime by calling the ``__tgt_register_lib()`` runtime; function. The constructor is explicitly defined in ``.text.startup`` section and; is run once when the program starts. Similarly, the global destructor; (``.omp_offloading.descriptor_unreg()``) calls ``__tgt_unregister_lib()`` for; the destructor and is also defined in ``.text.startup`` section and run when the; program exits. Offloading Example; ------------------. This section contains a simple example of generating offloading code using; OpenMP offloading. We will use a simple ``ZAXPY`` BLAS routine. .. code-block:: c++. #include <complex>. using complex = std::complex<double>;. void zaxpy(complex *X, complex *Y, complex D, std::size_t N) {; #pragma omp target teams distribute parallel for; for (std::size_t i = 0; i < N; ++i); Y[i] = D * X[i] + Y[i];; }. int main() {; const std::size_t N = 1024;; complex X[N], Y[N], D;; #pragma omp target data map(to:X[0 : N]) map(tofrom:Y[0 : N]); zaxpy(X, Y, D, N);; }. This code is compiled using the following Clang flags. .. code-block:: console. $ clang++ -fopenmp -fopenmp-targets=nvptx64 -O3 zaxpy.cpp -c. The output section in the object file can be seen using the ``readelf`` utility.; The ``.llvm.offloading`` section has the ``SHF_EXCLUDE`` flag so it will be; removed from the final executable or shared library by the linker. .. code-block:: text. $ llvm-readelf -WS zaxpy.o; Section Headers:; [Nr] Name Type Address Off Size ES Flg Lk Inf Al; [11] omp_offloading_entries PROGBITS 0000000000000000 0001f0 000040 00 A 0 0 1;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:602,Availability,avail,available,602,".. raw:: html. <style type=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. ==================; OpenCL Support; ==================. Clang has complete support of OpenCL C versions from 1.0 to 3.0.; Support for OpenCL 3.0 is in experimental phase (:ref:`OpenCL 3.0 <opencl_300>`). Clang also supports :ref:`the C++ for OpenCL kernel language <cxx_for_opencl_impl>`. There are also other :ref:`new and experimental features <opencl_experimenal>`; available. Details about usage of clang for OpenCL can be found in :doc:`UsersManual`. Missing features or with limited support; ========================================. - For general issues and bugs with OpenCL in clang refer to `the GitHub issue; list; <https://github.com/llvm/llvm-project/issues?q=is%3Aopen+is%3Aissue+label%3Aopencl>`__. - Command-line flag :option:`-cl-ext` (used to override extensions/; features supported by a target) is missing support of some functionality i.e. that is; implemented fully through libraries (see :ref:`library-based features and; extensions <opencl_ext_libs>`). Internals Manual; ================. This section acts as internal documentation for OpenCL features design; as well as some important implementation aspects. It is primarily targeted; at the advanced users and the toolchain developers integrating frontend; functionality as a component. OpenCL Metadata; ---------------. Clang uses metadata to provide additional OpenCL semantics in IR needed for; backends and OpenCL runtime. Each kernel will have function metadata attached to it, specifying the arguments.; Kernel argument metadata is used to provide source level information for querying; at runtime, for example using the `clGetKernelArgInfo; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#167>`_; call. Note that ``-cl-kernel-arg-info`` enables more information about the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:4389,Availability,avail,available,4389,"be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fast mechanism to declare builtin functions with; ``-fdeclare-opencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target address space map with a fake map.; This allows adding explicit address space IDs to the bitcode for non-segmented; memory architectures that do not have separate IDs for each of the OpenCL; logical address spac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:6647,Availability,avail,available,6647,".. code-block:: console. $ clang -cc1 -ffake-address-space-map test.cl. .. _opencl_builtins:. OpenCL builtins; ---------------. **Clang builtins**. There are some standard OpenCL functions that are implemented as Clang builtins:. - All pipe functions from `section 6.13.16.2/6.13.16.3; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#160>`_ of; the OpenCL v2.0 kernel language specification. - Address space qualifier conversion functions ``to_global``/``to_local``/``to_private``; from `section 6.13.9; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#101>`_. - All the ``enqueue_kernel`` functions from `section 6.13.17.1; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#164>`_ and; enqueue query functions from `section 6.13.17.5; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#171>`_. **Fast builtin function declarations**. The implementation of the fast builtin function declarations (available via the; :ref:`-fdeclare-opencl-builtins option <opencl_fdeclare_opencl_builtins>`) consists; of the following main components:. - A TableGen definitions file ``OpenCLBuiltins.td``. This contains a compact; representation of the supported builtin functions. When adding new builtin; function declarations, this is normally the only file that needs modifying. - A Clang TableGen emitter defined in ``ClangOpenCLBuiltinEmitter.cpp``. During; Clang build time, the emitter reads the TableGen definition file and; generates ``OpenCLBuiltins.inc``. This generated file contains various tables; and functions that capture the builtin function data from the TableGen; definitions in a compact manner. - OpenCL specific code in ``SemaLookup.cpp``. When ``Sema::LookupBuiltin``; encounters a potential builtin function, it will check if the name corresponds; to a valid OpenCL builtin function. If so, all overloads of the function are; inserted using ``InsertOCLBuiltinDeclarationsFromTable`` and overload; resolution takes place. OpenC",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:11142,Availability,redundant,redundant,11142,"get specific predefined macros or/and language version; predefined macros (see `feature/extension preprocessor macros defined in; opencl-c-base.h; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Headers/opencl-c-base.h>`__). **Pragmas**. Some extensions alter standard parsing dynamically via pragmas. Clang provides a mechanism to add the standard extension pragma; ``OPENCL EXTENSION`` by setting a dedicated flag in the extension list entry of; ``OpenCLExtensions.def``. Note that there is no default behavior for the; standard extension pragmas as it is not specified (for the standards up to and; including version 3.0) in a sufficient level of detail and, therefore,; there is no default functionality provided by clang. Pragmas without detailed information of their behavior (e.g. an explanation of; changes it triggers in the parsing) should not be added to clang. Moreover, the; pragmas should provide useful functionality to the user. For example, such; functionality should address a practical use case and not be redundant i.e.; cannot be achieved using existing features. Note that some legacy extensions (published prior to OpenCL 3.0) still; provide some non-conformant functionality for pragmas e.g. add diagnostics on; the use of types or functions. This functionality is not guaranteed to remain in; future releases. However, any future changes should not affect backward; compatibility. .. _opencl_addrsp:. Address spaces attribute; ------------------------. Clang has arbitrary address space support using the ``address_space(N)``; attribute, where ``N`` is an integer number in the range specified in the; Clang source code. This addresses spaces can be used along with the OpenCL; address spaces however when such addresses spaces converted to/from OpenCL; address spaces the behavior is not governed by OpenCL specification. An OpenCL implementation provides a list of standard address spaces using; keywords: ``private``, ``local``, ``global``, and ``generic``. In th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:24723,Availability,avail,available,24723,"s for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is required. See full example; in `Compiler Explorer <https://godbolt.org/z/5WbnTfb65>`_. More OpenCL specific C++ library implementations built on top of libcxx; are available in `libclcxx <https://github.com/KhronosGroup/libclcxx>`_; project.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:1444,Deployability,integrat,integrating,1444,"00>`). Clang also supports :ref:`the C++ for OpenCL kernel language <cxx_for_opencl_impl>`. There are also other :ref:`new and experimental features <opencl_experimenal>`; available. Details about usage of clang for OpenCL can be found in :doc:`UsersManual`. Missing features or with limited support; ========================================. - For general issues and bugs with OpenCL in clang refer to `the GitHub issue; list; <https://github.com/llvm/llvm-project/issues?q=is%3Aopen+is%3Aissue+label%3Aopencl>`__. - Command-line flag :option:`-cl-ext` (used to override extensions/; features supported by a target) is missing support of some functionality i.e. that is; implemented fully through libraries (see :ref:`library-based features and; extensions <opencl_ext_libs>`). Internals Manual; ================. This section acts as internal documentation for OpenCL features design; as well as some important implementation aspects. It is primarily targeted; at the advanced users and the toolchain developers integrating frontend; functionality as a component. OpenCL Metadata; ---------------. Clang uses metadata to provide additional OpenCL semantics in IR needed for; backends and OpenCL runtime. Each kernel will have function metadata attached to it, specifying the arguments.; Kernel argument metadata is used to provide source level information for querying; at runtime, for example using the `clGetKernelArgInfo; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#167>`_; call. Note that ``-cl-kernel-arg-info`` enables more information about the original; kernel code to be added e.g. kernel parameter names will appear in the OpenCL; metadata along with other information. The IDs used to encode the OpenCL's logical address spaces in the argument info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:3458,Deployability,install,installation,3458," to the options described in :doc:`UsersManual` there are the; following options specific to the OpenCL frontend. All the options in this section are frontend-only and therefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdecl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:3598,Deployability,install,installation,3598,"herefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-heade",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:9187,Deployability,configurat,configuration,9187,"ring the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; with :option:`-cl-ext` command-line flags. .. _opencl_ext_libs:. **Library functionality**. If an extension adds functionality that does not modify standard language; parsing it should not require modifying anything other than header files and; ``OpenCLBuiltins.td`` detailed in :ref:`OpenCL builtins <opencl_builtins>`.; Most commonly such extensions add functionality via libraries (by adding; non-native types or functions) parsed regularly. Similar to other languages this; is the most common way to add new functionality. Clang has standard headers where new types and functions are being added,; for more details refer to; :ref:`the section on the OpenCL Header <opencl_header>`. The macros indicating; the presence of such extensions can be added in the standard header files; conditioned on target specific predefined macros or/and language version; predefined macros (see `feature",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:11442,Deployability,release,releases,11442,". Clang provides a mechanism to add the standard extension pragma; ``OPENCL EXTENSION`` by setting a dedicated flag in the extension list entry of; ``OpenCLExtensions.def``. Note that there is no default behavior for the; standard extension pragmas as it is not specified (for the standards up to and; including version 3.0) in a sufficient level of detail and, therefore,; there is no default functionality provided by clang. Pragmas without detailed information of their behavior (e.g. an explanation of; changes it triggers in the parsing) should not be added to clang. Moreover, the; pragmas should provide useful functionality to the user. For example, such; functionality should address a practical use case and not be redundant i.e.; cannot be achieved using existing features. Note that some legacy extensions (published prior to OpenCL 3.0) still; provide some non-conformant functionality for pragmas e.g. add diagnostics on; the use of types or functions. This functionality is not guaranteed to remain in; future releases. However, any future changes should not affect backward; compatibility. .. _opencl_addrsp:. Address spaces attribute; ------------------------. Clang has arbitrary address space support using the ``address_space(N)``; attribute, where ``N`` is an integer number in the range specified in the; Clang source code. This addresses spaces can be used along with the OpenCL; address spaces however when such addresses spaces converted to/from OpenCL; address spaces the behavior is not governed by OpenCL specification. An OpenCL implementation provides a list of standard address spaces using; keywords: ``private``, ``local``, ``global``, and ``generic``. In the AST and; in the IR each of the address spaces will be represented by unique number; provided in the Clang source code. The specific IDs for an address space do not; have to match between the AST and the IR. Typically in the AST address space; numbers represent logical segments while in the IR they represen",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:13112,Deployability,release,release,13112," the IR each of the address spaces will be represented by unique number; provided in the Clang source code. The specific IDs for an address space do not; have to match between the AST and the IR. Typically in the AST address space; numbers represent logical segments while in the IR they represent physical; segments.; Therefore, machines with flat memory segments can map all AST address space; numbers to the same physical segment ID or skip address space attribute; completely while generating the IR. However, if the address space information; is needed by the IR passes e.g. to improve alias analysis, it is recommended; to keep it and only lower to reflect physical memory segments in the late; machine passes. The mapping between logical and target address spaces is; specified in the Clang's source code. .. _cxx_for_opencl_impl:. C++ for OpenCL Implementation Status; ====================================. Clang implements language versions 1.0 and 2021 published in `the official; release of C++ for OpenCL Documentation; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. Limited support of experimental C++ libraries is described in the :ref:`experimental features <opencl_experimenal>`. GitHub issues for this functionality are typically prefixed; with '[C++4OpenCL]' - click `here; <https://github.com/llvm/llvm-project/issues?q=is%3Aissue+is%3Aopen+%5BC%2B%2B4OpenCL%5D>`__; to view the full bug list. Missing features or with limited support; ----------------------------------------. - Support of C++ for OpenCL 2021 is currently in experimental phase. Refer to; :ref:`OpenCL 3.0 status <opencl_300>` for details of common missing; functionality from OpenCL 3.0. - IR generation for non-trivial global destructors is incomplete (See:; `PR48047 <https://llvm.org/PR48047>`_). - Support of `destructors with non-default address spaces; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#_construction_initialization_and_destruction>`_; is ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:13198,Deployability,release,releases,13198," in the Clang source code. The specific IDs for an address space do not; have to match between the AST and the IR. Typically in the AST address space; numbers represent logical segments while in the IR they represent physical; segments.; Therefore, machines with flat memory segments can map all AST address space; numbers to the same physical segment ID or skip address space attribute; completely while generating the IR. However, if the address space information; is needed by the IR passes e.g. to improve alias analysis, it is recommended; to keep it and only lower to reflect physical memory segments in the late; machine passes. The mapping between logical and target address spaces is; specified in the Clang's source code. .. _cxx_for_opencl_impl:. C++ for OpenCL Implementation Status; ====================================. Clang implements language versions 1.0 and 2021 published in `the official; release of C++ for OpenCL Documentation; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. Limited support of experimental C++ libraries is described in the :ref:`experimental features <opencl_experimenal>`. GitHub issues for this functionality are typically prefixed; with '[C++4OpenCL]' - click `here; <https://github.com/llvm/llvm-project/issues?q=is%3Aissue+is%3Aopen+%5BC%2B%2B4OpenCL%5D>`__; to view the full bug list. Missing features or with limited support; ----------------------------------------. - Support of C++ for OpenCL 2021 is currently in experimental phase. Refer to; :ref:`OpenCL 3.0 status <opencl_300>` for details of common missing; functionality from OpenCL 3.0. - IR generation for non-trivial global destructors is incomplete (See:; `PR48047 <https://llvm.org/PR48047>`_). - Support of `destructors with non-default address spaces; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#_construction_initialization_and_destruction>`_; is incomplete (See: `D109609 <https://reviews.llvm.org/D109609>`_). .. _opencl_300:.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:24405,Deployability,install,installation,24405,"s for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is required. See full example; in `Compiler Explorer <https://godbolt.org/z/5WbnTfb65>`_. More OpenCL specific C++ library implementations built on top of libcxx; are available in `libclcxx <https://github.com/KhronosGroup/libclcxx>`_; project.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:1444,Integrability,integrat,integrating,1444,"00>`). Clang also supports :ref:`the C++ for OpenCL kernel language <cxx_for_opencl_impl>`. There are also other :ref:`new and experimental features <opencl_experimenal>`; available. Details about usage of clang for OpenCL can be found in :doc:`UsersManual`. Missing features or with limited support; ========================================. - For general issues and bugs with OpenCL in clang refer to `the GitHub issue; list; <https://github.com/llvm/llvm-project/issues?q=is%3Aopen+is%3Aissue+label%3Aopencl>`__. - Command-line flag :option:`-cl-ext` (used to override extensions/; features supported by a target) is missing support of some functionality i.e. that is; implemented fully through libraries (see :ref:`library-based features and; extensions <opencl_ext_libs>`). Internals Manual; ================. This section acts as internal documentation for OpenCL features design; as well as some important implementation aspects. It is primarily targeted; at the advanced users and the toolchain developers integrating frontend; functionality as a component. OpenCL Metadata; ---------------. Clang uses metadata to provide additional OpenCL semantics in IR needed for; backends and OpenCL runtime. Each kernel will have function metadata attached to it, specifying the arguments.; Kernel argument metadata is used to provide source level information for querying; at runtime, for example using the `clGetKernelArgInfo; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#167>`_; call. Note that ``-cl-kernel-arg-info`` enables more information about the original; kernel code to be added e.g. kernel parameter names will appear in the OpenCL; metadata along with other information. The IDs used to encode the OpenCL's logical address spaces in the argument info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:15702,Integrability,interface,interface,15702,"://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#features>`__).; Command-line flag :option:`-cl-ext` can be used to override features supported by a target. For cases when there is an associated extension for a specific feature (fp64 and 3d image writes); user should specify both (extension and feature) in command-line flag:. .. code-block:: console. $ clang -cl-std=CL3.0 -cl-ext=+cl_khr_fp64,+__opencl_c_fp64 ...; $ clang -cl-std=CL3.0 -cl-ext=-cl_khr_fp64,-__opencl_c_fp64 ... OpenCL C 3.0 Implementation Status; ----------------------------------. The following table provides an overview of features in OpenCL C 3.0 and their; implementation status. +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Category | Feature | Status | Reviews |; +==============================+=========================+=========================================+======================+================================================================================================================================+; | Command line interface | New value for ``-cl-std`` flag | :good:`done` | https://reviews.llvm.org/D88300 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Predefined macros | New version macro | :good:`done` | https://reviews.llvm.org/D88300 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Predefined macros | Feature macros | :good:`done` | https:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:8301,Modifiability,extend,extend,8301,"e TableGen; definitions in a compact manner. - OpenCL specific code in ``SemaLookup.cpp``. When ``Sema::LookupBuiltin``; encounters a potential builtin function, it will check if the name corresponds; to a valid OpenCL builtin function. If so, all overloads of the function are; inserted using ``InsertOCLBuiltinDeclarationsFromTable`` and overload; resolution takes place. OpenCL Extensions and Features; ------------------------------. Clang implements various extensions to OpenCL kernel languages. New functionality is accepted as soon as the documentation is detailed to the; level sufficient to be implemented. There should be an evidence that the; extension is designed with implementation feasibility in consideration and; assessment of complexity for C/C++ based compilers. Alternatively, the; documentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:9187,Modifiability,config,configuration,9187,"ring the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; with :option:`-cl-ext` command-line flags. .. _opencl_ext_libs:. **Library functionality**. If an extension adds functionality that does not modify standard language; parsing it should not require modifying anything other than header files and; ``OpenCLBuiltins.td`` detailed in :ref:`OpenCL builtins <opencl_builtins>`.; Most commonly such extensions add functionality via libraries (by adding; non-native types or functions) parsed regularly. Similar to other languages this; is the most common way to add new functionality. Clang has standard headers where new types and functions are being added,; for more details refer to; :ref:`the section on the OpenCL Header <opencl_header>`. The macros indicating; the presence of such extensions can be added in the standard header files; conditioned on target specific predefined macros or/and language version; predefined macros (see `feature",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:17586,Modifiability,variab,variables,17586,"iews.llvm.org/D95776 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Generic address space | :good:`done` | https://reviews.llvm.org/D95778 and https://reviews.llvm.org/D103401 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Builtin function overloads with generic address space | :good:`done` | https://reviews.llvm.org/D105526, https://reviews.llvm.org/D107769 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Program scope variables in global memory | :good:`done` | https://reviews.llvm.org/D103191 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | 3D image writes including builtin functions | :good:`done` | https://reviews.llvm.org/D106260 (frontend) |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | read_write images including builtin functions | :good:`done` | https://reviews.llvm.org/D104915 (frontend) and https://reviews.llvm.o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23595,Modifiability,portab,portability,23595,"free to contact us on `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is require",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:2908,Performance,load,loaded,2908,"t ``-cl-kernel-arg-info`` enables more information about the original; kernel code to be added e.g. kernel parameter names will appear in the OpenCL; metadata along with other information. The IDs used to encode the OpenCL's logical address spaces in the argument info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. In addition to the options described in :doc:`UsersManual` there are the; following options specific to the OpenCL frontend. All the options in this section are frontend-only and therefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the comp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:3019,Performance,load,load,3019,"penCL; metadata along with other information. The IDs used to encode the OpenCL's logical address spaces in the argument info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. In addition to the options described in :doc:`UsersManual` there are the; following options specific to the OpenCL frontend. All the options in this section are frontend-only and therefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:4142,Performance,cache,cache-path,4142,"he; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fast mechanism to declare builtin functions with; ``-fdeclare-opencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target add",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:4232,Performance,latency,latency,4232,"be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fast mechanism to declare builtin functions with; ``-fdeclare-opencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target address space map with a fake map.; This allows adding explicit address space IDs to the bitcode for non-segmented; memory architectures that do not have separate IDs for each of the OpenCL; logical address spac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:9267,Performance,perform,performed,9267,"plains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; with :option:`-cl-ext` command-line flags. .. _opencl_ext_libs:. **Library functionality**. If an extension adds functionality that does not modify standard language; parsing it should not require modifying anything other than header files and; ``OpenCLBuiltins.td`` detailed in :ref:`OpenCL builtins <opencl_builtins>`.; Most commonly such extensions add functionality via libraries (by adding; non-native types or functions) parsed regularly. Similar to other languages this; is the most common way to add new functionality. Clang has standard headers where new types and functions are being added,; for more details refer to; :ref:`the section on the OpenCL Header <opencl_header>`. The macros indicating; the presence of such extensions can be added in the standard header files; conditioned on target specific predefined macros or/and language version; predefined macros (see `feature/extension preprocessor macros defined in; opencl-c-base.h; <https://github.com/llvm/llvm-pro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:11142,Safety,redund,redundant,11142,"get specific predefined macros or/and language version; predefined macros (see `feature/extension preprocessor macros defined in; opencl-c-base.h; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Headers/opencl-c-base.h>`__). **Pragmas**. Some extensions alter standard parsing dynamically via pragmas. Clang provides a mechanism to add the standard extension pragma; ``OPENCL EXTENSION`` by setting a dedicated flag in the extension list entry of; ``OpenCLExtensions.def``. Note that there is no default behavior for the; standard extension pragmas as it is not specified (for the standards up to and; including version 3.0) in a sufficient level of detail and, therefore,; there is no default functionality provided by clang. Pragmas without detailed information of their behavior (e.g. an explanation of; changes it triggers in the parsing) should not be added to clang. Moreover, the; pragmas should provide useful functionality to the user. For example, such; functionality should address a practical use case and not be redundant i.e.; cannot be achieved using existing features. Note that some legacy extensions (published prior to OpenCL 3.0) still; provide some non-conformant functionality for pragmas e.g. add diagnostics on; the use of types or functions. This functionality is not guaranteed to remain in; future releases. However, any future changes should not affect backward; compatibility. .. _opencl_addrsp:. Address spaces attribute; ------------------------. Clang has arbitrary address space support using the ``address_space(N)``; attribute, where ``N`` is an integer number in the range specified in the; Clang source code. This addresses spaces can be used along with the OpenCL; address spaces however when such addresses spaces converted to/from OpenCL; address spaces the behavior is not governed by OpenCL specification. An OpenCL implementation provides a list of standard address spaces using; keywords: ``private``, ``local``, ``global``, and ``generic``. In th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23611,Safety,avoid,avoid,23611,"ng/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is required. See full example; in `Compiler Explorer <https://godbolt.org/z/5WbnTfb65>`_. More OpenCL specific C++",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23617,Safety,unsafe,unsafe,23617,"ng/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is required. See full example; in `Compiler Explorer <https://godbolt.org/z/5WbnTfb65>`_. More OpenCL specific C++",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:9126,Security,expose,expose,9126,"umentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; with :option:`-cl-ext` command-line flags. .. _opencl_ext_libs:. **Library functionality**. If an extension adds functionality that does not modify standard language; parsing it should not require modifying anything other than header files and; ``OpenCLBuiltins.td`` detailed in :ref:`OpenCL builtins <opencl_builtins>`.; Most commonly such extensions add functionality via libraries (by adding; non-native types or functions) parsed regularly. Similar to other languages this; is the most common way to add new functionality. Clang has standard headers where new types and functions are being added,; for more details refer to; :ref:`the section on the OpenCL Header <opencl_header>`. The macros indicating; the presence of such extensions can be added in the standard header files; conditioned on target sp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23322,Security,expose,expose,23322,"------------------------+. .. _opencl_experimenal:. Experimental features; =====================. Clang provides the following new WIP features for the developers to experiment; and provide early feedback or contribute with further improvements.; Feel free to contact us on `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:2166,Testability,log,logical,2166," Manual; ================. This section acts as internal documentation for OpenCL features design; as well as some important implementation aspects. It is primarily targeted; at the advanced users and the toolchain developers integrating frontend; functionality as a component. OpenCL Metadata; ---------------. Clang uses metadata to provide additional OpenCL semantics in IR needed for; backends and OpenCL runtime. Each kernel will have function metadata attached to it, specifying the arguments.; Kernel argument metadata is used to provide source level information for querying; at runtime, for example using the `clGetKernelArgInfo; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#167>`_; call. Note that ``-cl-kernel-arg-info`` enables more information about the original; kernel code to be added e.g. kernel parameter names will appear in the OpenCL; metadata along with other information. The IDs used to encode the OpenCL's logical address spaces in the argument info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. In addition to the options described in :doc:`UsersManual` there are the; following options specific to the OpenCL frontend. All the options in this section are frontend-only and therefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:3220,Testability,test,test,3220,"ent info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. In addition to the options described in :doc:`UsersManual` there are the; following options specific to the OpenCL frontend. All the options in this section are frontend-only and therefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:3564,Testability,test,test,3564,"ptions in this section are frontend-only and therefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:3667,Testability,test,test,3667,"frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:4184,Testability,test,test,4184,"he; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header test.cl. Alternatively the internal header `opencl-c.h` containing the declarations; can be included manually using ``-include`` or ``-I`` followed by the path; to the header location. The header can be found in the clang source tree or; installation directory. .. code-block:: console. $ clang -I<path to clang sources>/lib/Headers/opencl-c.h test.cl; $ clang -I<path to clang installation>/lib/clang/<llvm version>/include/opencl-c.h/opencl-c.h test.cl. In this example it is assumed that the kernel code contains; ``#include <opencl-c.h>`` just as a regular C include. Because the header is very large and long to parse, PCH (:doc:`PCHInternals`); and modules (:doc:`Modules`) can be used internally to improve the compilation; speed. To enable modules for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fast mechanism to declare builtin functions with; ``-fdeclare-opencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target add",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:4994,Testability,test,test,4994," for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fast mechanism to declare builtin functions with; ``-fdeclare-opencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target address space map with a fake map.; This allows adding explicit address space IDs to the bitcode for non-segmented; memory architectures that do not have separate IDs for each of the OpenCL; logical address spaces by default. Passing ``-ffake-address-space-map`` will; add/override address spaces of the target compiled for with the following values:; ``1-global``, ``2-constant``, ``3-local``, ``4-generic``. The private address; space is represented by the absence of an address space attribute in the IR (see; also :ref:`the section on the address space attribute <opencl_addrsp>`). .. code-block:: console. $ clang -cc1 -ffake-address-space-map test.cl. .. _opencl_builtins:. OpenCL builtins; ---------------. **Clang builtins**. There are some standard OpenCL functions that are implemented as Clang builtins:. - All pipe functions from `section 6.13.16.2/6.13.16.3; <http",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:5289,Testability,log,logical,5289,"sing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fast mechanism to declare builtin functions with; ``-fdeclare-opencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target address space map with a fake map.; This allows adding explicit address space IDs to the bitcode for non-segmented; memory architectures that do not have separate IDs for each of the OpenCL; logical address spaces by default. Passing ``-ffake-address-space-map`` will; add/override address spaces of the target compiled for with the following values:; ``1-global``, ``2-constant``, ``3-local``, ``4-generic``. The private address; space is represented by the absence of an address space attribute in the IR (see; also :ref:`the section on the address space attribute <opencl_addrsp>`). .. code-block:: console. $ clang -cc1 -ffake-address-space-map test.cl. .. _opencl_builtins:. OpenCL builtins; ---------------. **Clang builtins**. There are some standard OpenCL functions that are implemented as Clang builtins:. - All pipe functions from `section 6.13.16.2/6.13.16.3; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#160>`_ of; the OpenCL v2.0 kernel language specification. - Address space qualifier conversion functions ``to_global``/``to_local``/``to_private``; from `section 6.13.9; <https://www.khronos.o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:5747,Testability,test,test,5747,"pencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target address space map with a fake map.; This allows adding explicit address space IDs to the bitcode for non-segmented; memory architectures that do not have separate IDs for each of the OpenCL; logical address spaces by default. Passing ``-ffake-address-space-map`` will; add/override address spaces of the target compiled for with the following values:; ``1-global``, ``2-constant``, ``3-local``, ``4-generic``. The private address; space is represented by the absence of an address space attribute in the IR (see; also :ref:`the section on the address space attribute <opencl_addrsp>`). .. code-block:: console. $ clang -cc1 -ffake-address-space-map test.cl. .. _opencl_builtins:. OpenCL builtins; ---------------. **Clang builtins**. There are some standard OpenCL functions that are implemented as Clang builtins:. - All pipe functions from `section 6.13.16.2/6.13.16.3; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#160>`_ of; the OpenCL v2.0 kernel language specification. - Address space qualifier conversion functions ``to_global``/``to_local``/``to_private``; from `section 6.13.9; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#101>`_. - All the ``enqueue_kernel`` functions from `section 6.13.17.1; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#164>`_ and; enqueue query functions from `section 6.13.17.5; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#171>`_. **Fast builtin function declarations**. The implementation of the fast builtin function declarations (available via the; :ref:`-fdeclare-opencl-builtins option <opencl_fdeclare_opencl_b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:12371,Testability,log,logical,12371,"tions. This functionality is not guaranteed to remain in; future releases. However, any future changes should not affect backward; compatibility. .. _opencl_addrsp:. Address spaces attribute; ------------------------. Clang has arbitrary address space support using the ``address_space(N)``; attribute, where ``N`` is an integer number in the range specified in the; Clang source code. This addresses spaces can be used along with the OpenCL; address spaces however when such addresses spaces converted to/from OpenCL; address spaces the behavior is not governed by OpenCL specification. An OpenCL implementation provides a list of standard address spaces using; keywords: ``private``, ``local``, ``global``, and ``generic``. In the AST and; in the IR each of the address spaces will be represented by unique number; provided in the Clang source code. The specific IDs for an address space do not; have to match between the AST and the IR. Typically in the AST address space; numbers represent logical segments while in the IR they represent physical; segments.; Therefore, machines with flat memory segments can map all AST address space; numbers to the same physical segment ID or skip address space attribute; completely while generating the IR. However, if the address space information; is needed by the IR passes e.g. to improve alias analysis, it is recommended; to keep it and only lower to reflect physical memory segments in the late; machine passes. The mapping between logical and target address spaces is; specified in the Clang's source code. .. _cxx_for_opencl_impl:. C++ for OpenCL Implementation Status; ====================================. Clang implements language versions 1.0 and 2021 published in `the official; release of C++ for OpenCL Documentation; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. Limited support of experimental C++ libraries is described in the :ref:`experimental features <opencl_experimenal>`. GitHub issues for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:12858,Testability,log,logical,12858,"om OpenCL; address spaces the behavior is not governed by OpenCL specification. An OpenCL implementation provides a list of standard address spaces using; keywords: ``private``, ``local``, ``global``, and ``generic``. In the AST and; in the IR each of the address spaces will be represented by unique number; provided in the Clang source code. The specific IDs for an address space do not; have to match between the AST and the IR. Typically in the AST address space; numbers represent logical segments while in the IR they represent physical; segments.; Therefore, machines with flat memory segments can map all AST address space; numbers to the same physical segment ID or skip address space attribute; completely while generating the IR. However, if the address space information; is needed by the IR passes e.g. to improve alias analysis, it is recommended; to keep it and only lower to reflect physical memory segments in the late; machine passes. The mapping between logical and target address spaces is; specified in the Clang's source code. .. _cxx_for_opencl_impl:. C++ for OpenCL Implementation Status; ====================================. Clang implements language versions 1.0 and 2021 published in `the official; release of C++ for OpenCL Documentation; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. Limited support of experimental C++ libraries is described in the :ref:`experimental features <opencl_experimenal>`. GitHub issues for this functionality are typically prefixed; with '[C++4OpenCL]' - click `here; <https://github.com/llvm/llvm-project/issues?q=is%3Aissue+is%3Aopen+%5BC%2B%2B4OpenCL%5D>`__; to view the full bug list. Missing features or with limited support; ----------------------------------------. - Support of C++ for OpenCL 2021 is currently in experimental phase. Refer to; :ref:`OpenCL 3.0 status <opencl_300>` for details of common missing; functionality from OpenCL 3.0. - IR generation for non-trivial global destruc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:14399,Testability,test,test,14399," prefixed; with '[C++4OpenCL]' - click `here; <https://github.com/llvm/llvm-project/issues?q=is%3Aissue+is%3Aopen+%5BC%2B%2B4OpenCL%5D>`__; to view the full bug list. Missing features or with limited support; ----------------------------------------. - Support of C++ for OpenCL 2021 is currently in experimental phase. Refer to; :ref:`OpenCL 3.0 status <opencl_300>` for details of common missing; functionality from OpenCL 3.0. - IR generation for non-trivial global destructors is incomplete (See:; `PR48047 <https://llvm.org/PR48047>`_). - Support of `destructors with non-default address spaces; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#_construction_initialization_and_destruction>`_; is incomplete (See: `D109609 <https://reviews.llvm.org/D109609>`_). .. _opencl_300:. OpenCL C 3.0 Usage; ==================. OpenCL C 3.0 language standard makes most OpenCL C 2.0 features optional. Optional; functionality in OpenCL C 3.0 is indicated with the presence of feature-test macros; (list of feature-test macros is `here <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#features>`__).; Command-line flag :option:`-cl-ext` can be used to override features supported by a target. For cases when there is an associated extension for a specific feature (fp64 and 3d image writes); user should specify both (extension and feature) in command-line flag:. .. code-block:: console. $ clang -cl-std=CL3.0 -cl-ext=+cl_khr_fp64,+__opencl_c_fp64 ...; $ clang -cl-std=CL3.0 -cl-ext=-cl_khr_fp64,-__opencl_c_fp64 ... OpenCL C 3.0 Implementation Status; ----------------------------------. The following table provides an overview of features in OpenCL C 3.0 and their; implementation status. +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Category | Featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:14429,Testability,test,test,14429," prefixed; with '[C++4OpenCL]' - click `here; <https://github.com/llvm/llvm-project/issues?q=is%3Aissue+is%3Aopen+%5BC%2B%2B4OpenCL%5D>`__; to view the full bug list. Missing features or with limited support; ----------------------------------------. - Support of C++ for OpenCL 2021 is currently in experimental phase. Refer to; :ref:`OpenCL 3.0 status <opencl_300>` for details of common missing; functionality from OpenCL 3.0. - IR generation for non-trivial global destructors is incomplete (See:; `PR48047 <https://llvm.org/PR48047>`_). - Support of `destructors with non-default address spaces; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#_construction_initialization_and_destruction>`_; is incomplete (See: `D109609 <https://reviews.llvm.org/D109609>`_). .. _opencl_300:. OpenCL C 3.0 Usage; ==================. OpenCL C 3.0 language standard makes most OpenCL C 2.0 features optional. Optional; functionality in OpenCL C 3.0 is indicated with the presence of feature-test macros; (list of feature-test macros is `here <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#features>`__).; Command-line flag :option:`-cl-ext` can be used to override features supported by a target. For cases when there is an associated extension for a specific feature (fp64 and 3d image writes); user should specify both (extension and feature) in command-line flag:. .. code-block:: console. $ clang -cl-std=CL3.0 -cl-ext=+cl_khr_fp64,+__opencl_c_fp64 ...; $ clang -cl-std=CL3.0 -cl-ext=-cl_khr_fp64,-__opencl_c_fp64 ... OpenCL C 3.0 Implementation Status; ----------------------------------. The following table provides an overview of features in OpenCL C 3.0 and their; implementation status. +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Category | Featur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:24427,Testability,test,test,24427,"s for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is required. See full example; in `Compiler Explorer <https://godbolt.org/z/5WbnTfb65>`_. More OpenCL specific C++ library implementations built on top of libcxx; are available in `libclcxx <https://github.com/KhronosGroup/libclcxx>`_; project.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:8233,Usability,guid,guidelines,8233,"; and functions that capture the builtin function data from the TableGen; definitions in a compact manner. - OpenCL specific code in ``SemaLookup.cpp``. When ``Sema::LookupBuiltin``; encounters a potential builtin function, it will check if the name corresponds; to a valid OpenCL builtin function. If so, all overloads of the function are; inserted using ``InsertOCLBuiltinDeclarationsFromTable`` and overload; resolution takes place. OpenCL Extensions and Features; ------------------------------. Clang implements various extensions to OpenCL kernel languages. New functionality is accepted as soon as the documentation is detailed to the; level sufficient to be implemented. There should be an evidence that the; extension is designed with implementation feasibility in consideration and; assessment of complexity for C/C++ based compilers. Alternatively, the; documentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the ta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:22510,Usability,feedback,feedback,22510,"---------------------------------------------------------------------------------+; | New functionality | Subgroup functions | :good:`done` | https://reviews.llvm.org/D105858, https://reviews.llvm.org/D118999 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | New functionality | Atomic mem scopes: subgroup, all devices including functions | :good:`done` | https://reviews.llvm.org/D103241 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+. .. _opencl_experimenal:. Experimental features; =====================. Clang provides the following new WIP features for the developers to experiment; and provide early feedback or contribute with further improvements.; Feel free to contact us on `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to ide",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:29260,Availability,error,error,29260,"------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | changes to omp_alloctrait_key enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | seq_cst clause on flush construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'omp_all_memory' keyword and use in 'depend' clause | :good:`done` | D125828, D126321 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | error directive | :good:`done` | D139166 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | scope construct | :none:`worked on` | D157933 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | changes to ompt_scope_endpoint_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+---------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:32477,Availability,mask,masked,32477,"-------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | dispatch construct and function variant argument adjustment | :part:`worked on` | D99537, D99679 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | assume and assumes directives | :part:`worked on` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | nothing directive | :good:`done` | D123286 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | masked construct and related combined constructs | :part:`worked on` | D99995, D100514 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | default(firstprivate) & default(private) | :good:`done` | D75591 (firstprivate), D125912 (private) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | other | deprecating master construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier types added to ompt_sync_region_t enum | :none:`unclaimed` | |; +------------------------------+----------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:16981,Deployability,update,update,16981,"--------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: use_device_addr for target data | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support close modifier on map clause | :good:`done` | D55719,D55892 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | teams construct on the host device | :good:`done` | r371553 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support non-contiguous array sections for target update | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | pointer attachment | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | atomic | hints for the atomic construct | :good:`done` | D51233 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | base language | C11 support | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | base language | C++11/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:20902,Deployability,update,update,20902," iterator and multidependences | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | depobj directive and depobj dependency kind | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | user-defined function variants | :good:`done`. | D67294, D64095, D71847, D71830, D109635 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | pointer/reference to pointer based array reductions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | prevent new type definitions in clauses | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | memory model update (seq_cst, acq_rel, release, acquire,...) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+. .. _OpenMP 51 implementation details:. OpenMP 5.1 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.1 features; and their implementation status.; Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; impl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:20928,Deployability,release,release,20928," iterator and multidependences | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | depobj directive and depobj dependency kind | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | user-defined function variants | :good:`done`. | D67294, D64095, D71847, D71830, D109635 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | pointer/reference to pointer based array reductions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | prevent new type definitions in clauses | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | memory model update (seq_cst, acq_rel, release, acquire,...) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+. .. _OpenMP 51 implementation details:. OpenMP 5.1 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.1 features; and their implementation status.; Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; impl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2067,Energy Efficiency,reduce,reduce,2067,"on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP cate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2762,Energy Efficiency,allocate,allocated,2762,"l variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; implementation. +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+==============================================================+==========================+=======================================================================+; | loop | support != in the canonical loop form | :good:`done` | D54441 |; +------------------------------+--------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:6039,Energy Efficiency,allocate,allocate,6039,"----------------+-----------------------------------------------------------------------+; | loop | collapse imperfectly nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | collapse non-rectangular nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | C++ range-base for loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | clause: if for SIMD directives | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | inclusive scan (matching C++17 PSTL) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | memory allocators | :good:`done` | r341687,r357929 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | allocate directive and allocate clause | :good:`done` | r355614,r335952 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPD | OMPD interfaces | :good:`done` | https://reviews.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:6062,Energy Efficiency,allocate,allocate,6062,"----------------+-----------------------------------------------------------------------+; | loop | collapse imperfectly nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | collapse non-rectangular nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | C++ range-base for loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | clause: if for SIMD directives | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | inclusive scan (matching C++17 PSTL) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | memory allocators | :good:`done` | r341687,r357929 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | allocate directive and allocate clause | :good:`done` | r355614,r335952 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPD | OMPD interfaces | :good:`done` | https://reviews.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:27879,Energy Efficiency,allocate,allocate,27879,------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop tiling transformation | :good:`done` | D76342 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop unrolling transformation | :good:`done` | D99459 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | 'reproducible'/'unconstrained' modifiers in 'order' clause | :part:`partial` | D127855 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | alignment for allocate directive and clause | :good:`done` | D115683 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | new memory management routines | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | changes to omp_alloctrait_key enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | seq_cst clause on flush construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:34222,Energy Efficiency,monitor,monitoring,34222,"-+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier types added to ompt_sync_region_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | async data transfers added to ompt_target_data_op_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier state values added to ompt_state_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new 'emi' callbacks for external monitoring interfaces | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | device tracing interface | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | 'strict' modifier for taskloop construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+-------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:6324,Integrability,interface,interfaces,6324,"----------------+-----------------------------------------------------------------------+; | loop | collapse imperfectly nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | collapse non-rectangular nested loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | C++ range-base for loop | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | clause: if for SIMD directives | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | inclusive scan (matching C++17 PSTL) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | memory allocators | :good:`done` | r341687,r357929 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | allocate directive and allocate clause | :good:`done` | r355614,r335952 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPD | OMPD interfaces | :good:`done` | https://reviews.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:6632,Integrability,interface,interfaces,6632,"----------+--------------------------+-----------------------------------------------------------------------+; | memory management | allocate directive and allocate clause | :good:`done` | r355614,r335952 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPD | OMPD interfaces | :good:`done` | https://reviews.llvm.org/D99914 (Supports only HOST(CPU) and Linux |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | OMPT interfaces (callback support) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | thread affinity | thread affinity | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | taskloop reduction | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | task affinity | :part:`not upstream` | https://github.com/jklinkenberg/openmp/tree/task-affinity |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | clause: depend on the taskwait construct | :good:`done` | D113540 (regular codegen only) |; +------------------------------+--------------------------------------------------------------+--------------------------+---",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:7696,Integrability,depend,depend,7696,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:7985,Integrability,depend,depend,7985,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:8260,Integrability,depend,dependence-type,8260,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:19801,Integrability,depend,dependency,19801,--------------------------+--------------------------+-----------------------------------------------------------------------+; | base language | lambda support | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | array shaping | :good:`done` | D74144 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | library shutdown (omp_pause_resource[_all]) | :good:`done` | D55078 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | metadirectives | :part:`mostly done` | D91944 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | conditional modifier for lastprivate clause | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | iterator and multidependences | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | depobj directive and depobj dependency kind | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | user-defined function variants | :good:`done`.,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:24249,Integrability,rout,routine,24249,"-----------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | 'present' in defaultmap clause | :good:`done` | D92427 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | map clause reordering based on 'present' modifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | thread_limit clause on target construct | :part:`partial` | D141540 (offload), D152054 (host, in progress) |; +------------------------------+--------------------------------------------------------------+------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:24508,Integrability,rout,routine,24508,"-----------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | map clause reordering based on 'present' modifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | thread_limit clause on target construct | :part:`partial` | D141540 (offload), D152054 (host, in progress) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | has_device_addr clause on target construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:24780,Integrability,rout,routines,24780,"---------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | thread_limit clause on target construct | :part:`partial` | D141540 (offload), D152054 (host, in progress) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | has_device_addr clause on target construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | iterators in map clause or motion clauses | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+-------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:26753,Integrability,rout,routines,26753,"--------------------+--------------------------+-----------------------------------------------------------------------+; | device | indirect clause on declare target directive | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | allow virtual functions calls for mapped object on device | :part:`partial` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | interop construct | :part:`partial` | parsing/sema done: D98558, D98834, D98815 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | assorted routines for querying interoperable properties | :part:`partial` | D106674 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop tiling transformation | :good:`done` | D76342 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop unrolling transformation | :good:`done` | D99459 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | 'reproducible'/'unconstrained' modifiers in 'order' clause | :part:`partial` | D127855 |; +------------------------------+--------------------------------------------------------------+----------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:26775,Integrability,interoperab,interoperable,26775,"----------------------+-----------------------------------------------------------------------+; | device | indirect clause on declare target directive | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | allow virtual functions calls for mapped object on device | :part:`partial` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | interop construct | :part:`partial` | parsing/sema done: D98558, D98834, D98815 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | assorted routines for querying interoperable properties | :part:`partial` | D106674 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop tiling transformation | :good:`done` | D76342 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | Loop unrolling transformation | :good:`done` | D99459 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | 'reproducible'/'unconstrained' modifiers in 'order' clause | :part:`partial` | D127855 |; +------------------------------+--------------------------------------------------------------+--------------------------+-------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:28177,Integrability,rout,routines,28177,"---+--------------------------+-----------------------------------------------------------------------+; | loop | Loop unrolling transformation | :good:`done` | D99459 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | loop | 'reproducible'/'unconstrained' modifiers in 'order' clause | :part:`partial` | D127855 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | alignment for allocate directive and clause | :good:`done` | D115683 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | new memory management routines | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | changes to omp_alloctrait_key enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | seq_cst clause on flush construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'omp_all_memory' keyword and use in 'depend' clause | :good:`done` | D125828, D126321 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:29003,Integrability,depend,depend,29003,"-------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | new memory management routines | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory management | changes to omp_alloctrait_key enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | memory model | seq_cst clause on flush construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'omp_all_memory' keyword and use in 'depend' clause | :good:`done` | D125828, D126321 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | error directive | :good:`done` | D139166 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | scope construct | :none:`worked on` | D157933 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+---------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:29763,Integrability,rout,routines,29763,"-------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'omp_all_memory' keyword and use in 'depend' clause | :good:`done` | D125828, D126321 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | error directive | :good:`done` | D139166 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | scope construct | :none:`worked on` | D157933 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | changes to ompt_scope_endpoint_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | omp_display_env routine | :good:`done` | D74956 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | extended OMP_PLACES syntax | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:30347,Integrability,rout,routine,30347,-----------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | scope construct | :none:`worked on` | D157933 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | changes to ompt_scope_endpoint_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | omp_display_env routine | :good:`done` | D74956 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | extended OMP_PLACES syntax | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | OMP_NUM_TEAMS and OMP_TEAMS_THREAD_LIMIT env vars | :good:`done` | D138769 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'target_device' selector in context specifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-------------------------------,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:34233,Integrability,interface,interfaces,34233,"-----------------+-----------------------------------------------------------------------+; | OMPT | new barrier types added to ompt_sync_region_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | async data transfers added to ompt_target_data_op_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier state values added to ompt_state_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new 'emi' callbacks for external monitoring interfaces | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | device tracing interface | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | 'strict' modifier for taskloop construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+------------------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:34484,Integrability,interface,interface,34484,"--------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | async data transfers added to ompt_target_data_op_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier state values added to ompt_state_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new 'emi' callbacks for external monitoring interfaces | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | device tracing interface | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | 'strict' modifier for taskloop construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | nowait clause on taskwait | :part:`partial` | parsing/sema done: D131830, D141531 |; +------------------------------+--------------------------------------------------------------+--------------------------+--------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:35007,Integrability,depend,depend,35007,"-------------------------------------------------------------------+; | OMPT | async data transfers added to ompt_target_data_op_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new barrier state values added to ompt_state_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | new 'emi' callbacks for external monitoring interfaces | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | OMPT | device tracing interface | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | 'strict' modifier for taskloop construct | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | nowait clause on taskwait | :part:`partial` | parsing/sema done: D131830, D141531 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:937,Modifiability,variab,variables,937,".. raw:: html. <style type=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. ==============; OpenMP Support; ==============. Clang fully supports OpenMP 4.5, almost all of 5.0 and most of 5.1/2.; Clang supports offloading to X86_64, AArch64, PPC64[LE], NVIDIA GPUs (all models) and AMD GPUs (all models). In addition, the LLVM OpenMP runtime `libomp` supports the OpenMP Tools; Interface (OMPT) on x86, x86_64, AArch64, and PPC64 on Linux, Windows, and macOS.; OMPT is also supported for NVIDIA and AMD GPUs. For the list of supported features from OpenMP 5.0 and 5.1; see `OpenMP implementation details`_ and `OpenMP 51 implementation details`_. General improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1175,Modifiability,extend,extend,1175,":: good. .. contents::; :local:. ==============; OpenMP Support; ==============. Clang fully supports OpenMP 4.5, almost all of 5.0 and most of 5.1/2.; Clang supports offloading to X86_64, AArch64, PPC64[LE], NVIDIA GPUs (all models) and AMD GPUs (all models). In addition, the LLVM OpenMP runtime `libomp` supports the OpenMP Tools; Interface (OMPT) on x86, x86_64, AArch64, and PPC64 on Linux, Windows, and macOS.; OMPT is also supported for NVIDIA and AMD GPUs. For the list of supported features from OpenMP 5.0 and 5.1; see `OpenMP implementation details`_ and `OpenMP 51 implementation details`_. General improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tunin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1777,Modifiability,variab,variables,1777,"neral improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1885,Modifiability,variab,variables,1885,"fter collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2703,Modifiability,variab,variables,2703,"eneric`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; implementation. +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+==============================================================+==========================+=======================================================================+; | ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2739,Modifiability,variab,variables,2739,"l variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; implementation. +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+==============================================================+==========================+=======================================================================+; | loop | support != in the canonical loop form | :good:`done` | D54441 |; +------------------------------+--------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:10570,Modifiability,variab,variables,10570,----------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | SIMD | atomic and simd constructs inside SIMD code | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | SIMD | SIMD nontemporal | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target functions from initializers | :part:`worked on` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target variables from initializers | :good:`done` | D146418 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | OMP_TARGET_OFFLOAD environment variable | :good:`done` | D50522 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support full 'defaultmap' functionality | :good:`done` | D69204 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device specific functions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+--------------------------,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:10864,Modifiability,variab,variable,10864,-------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | SIMD | SIMD nontemporal | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target functions from initializers | :part:`worked on` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | infer target variables from initializers | :good:`done` | D146418 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | OMP_TARGET_OFFLOAD environment variable | :good:`done` | D50522 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support full 'defaultmap' functionality | :good:`done` | D69204 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device specific functions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: device_type | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+;,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:11889,Modifiability,extend,extended,11889,"522 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | support full 'defaultmap' functionality | :good:`done` | D69204 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device specific functions | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: device_type | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: extended device | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: uses_allocators clause | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: in_reduction | :part:`worked on` | r308768 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_device_num() | :good:`done` | D54342,D128347 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:23982,Modifiability,variab,variables,23982,"---------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | 'present' motion modifier | :good:`done` | D84711, D84712 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | 'present' in defaultmap clause | :good:`done` | D92427 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | map clause reordering based on 'present' modifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | device-specific environment variables | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_target_is_accessible routine | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | omp_get_mapped_ptr routine | :good:`done` | D141545 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | new async target memory copy routines | :good:`done` | D136103 |; +------------------------------+--------------------------------------------------------------+--------------------------+------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:30587,Modifiability,extend,extended,30587,-------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | routines for controlling and querying team regions | :part:`partial` | D95003 (libomp only) |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | changes to ompt_scope_endpoint_t enum | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | omp_display_env routine | :good:`done` | D74956 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | extended OMP_PLACES syntax | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | OMP_NUM_TEAMS and OMP_TEAMS_THREAD_LIMIT env vars | :good:`done` | D138769 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | 'target_device' selector in context specifier | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | misc | begin/end declare variant | :good:`done` | D71179 |; +------------------------------+--------------------------------------------------------------+--------------------------+--------------,MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1678,Performance,perform,performance,1678,"tures from OpenMP 5.0 and 5.1; see `OpenMP implementation details`_ and `OpenMP 51 implementation details`_. General improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2045,Performance,optimiz,optimizer,2045,"on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP cate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:879,Safety,avoid,avoid,879,".. raw:: html. <style type=""text/css"">; .none { background-color: #FFCCCC }; .part { background-color: #FFFF99 }; .good { background-color: #CCFF99 }; </style>. .. role:: none; .. role:: part; .. role:: good. .. contents::; :local:. ==============; OpenMP Support; ==============. Clang fully supports OpenMP 4.5, almost all of 5.0 and most of 5.1/2.; Clang supports offloading to X86_64, AArch64, PPC64[LE], NVIDIA GPUs (all models) and AMD GPUs (all models). In addition, the LLVM OpenMP runtime `libomp` supports the OpenMP Tools; Interface (OMPT) on x86, x86_64, AArch64, and PPC64 on Linux, Windows, and macOS.; OMPT is also supported for NVIDIA and AMD GPUs. For the list of supported features from OpenMP 5.0 and 5.1; see `OpenMP implementation details`_ and `OpenMP 51 implementation details`_. General improvements; ====================; - New collapse clause scheme to avoid expensive remainder operations.; Compute loop index variables after collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:13707,Security,access,access,13707,"----------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | structure mapping of references | :none:`unclaimed` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | nested target declare | :good:`done` | D51378 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | implicitly map 'this' (this[:1]) | :good:`done` | D55982 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | allow access to the reference count (omp_target_is_present) | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | requires directive | :good:`done` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: unified_shared_memory | :good:`done` | D52625,D52359 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | device | clause: unified_address | :part:`partial` | |; +------------------------------+--------------------------------------------------------------+--------------------------+-------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:35964,Usability,feedback,feedback,35964,"-------------------------------------------------------+; | task | inoutset in depend clause | :good:`done` | D97085, D118383 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; | task | nowait clause on taskwait | :part:`partial` | parsing/sema done: D131830, D141531 |; +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+. OpenMP Extensions; =================. The following table provides a quick overview over various OpenMP; extensions and their implementation status. These extensions are not; currently defined by any standard, so links to associated LLVM; documentation are provided. As these extensions mature, they will be; considered for standardization. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ to provide feedback. +------------------------------+-----------------------------------------------------------------------------------+--------------------------+--------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+===================================================================================+==========================+========================================================+; | atomic extension | `'atomic' strictly nested within 'teams' | :good:`prototyped` | D126323 |; | | <https://openmp.llvm.org/docs/openacc/OpenMPExtensions.html#atomicWithinTeams>`_ | | |; +------------------------------+-----------------------------------------------------------------------------------+--------------------------+--------------------------------------------------------+; | device extension | `'ompx_hold' map type modifier | :good:`prototyped` | D106509, D106510 |; | | <https://openmp.llv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:25876,Availability,avail,available,25876,"f dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup table",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:28905,Availability,error,error,28905,"ed to the entities; in those modules, as well as which ID numbers it took for its own new; entities. The AST reader then maps these ""local"" ID numbers into a ""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; compilation error, due to an ambiguity in name lookup. Therefore, the AST; reader performs declaration merging according to the appropriate language; semantics, ensuring that the two disjoint declarations are merged into a; single redeclaration chain (with a common canonical declaration), so that it; is as if one of the headers had been included before the other. Name Visibility; Modules allow certain names that occur during module creation to be ""hidden"",; so that they are not part of the public interface of the module and are not; visible to its clients. The AST reader maintains a ""visible"" bit on various; AST nodes (declarations, macros, etc.) to indicate whether that particular; AST node is currently visible; the various name lookup mechanisms in Clang; inspect the visible bit to determine whether that entity, which is still in; the AST (because other, visible AST nodes may depend on it), can actually be; found by name lookup. When a new (sub)module is imported, it may make; existing, non-visible",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21566,Deployability,integrat,integration,21566,"tors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:26920,Deployability,update,updates,26920,"tity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:26947,Deployability,update,update,26947,"tity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:27389,Deployability,update,update,27389,", lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for its own new; entities. The AST reader then maps these ""local"" ID numbers into a ""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Dec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:30006,Deployability,update,update,30006,"""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; compilation error, due to an ambiguity in name lookup. Therefore, the AST; reader performs declaration merging according to the appropriate language; semantics, ensuring that the two disjoint declarations are merged into a; single redeclaration chain (with a common canonical declaration), so that it; is as if one of the headers had been included before the other. Name Visibility; Modules allow certain names that occur during module creation to be ""hidden"",; so that they are not part of the public interface of the module and are not; visible to its clients. The AST reader maintains a ""visible"" bit on various; AST nodes (declarations, macros, etc.) to indicate whether that particular; AST node is currently visible; the various name lookup mechanisms in Clang; inspect the visible bit to determine whether that entity, which is still in; the AST (because other, visible AST nodes may depend on it), can actually be; found by name lookup. When a new (sub)module is imported, it may make; existing, non-visible, already-deserialized AST nodes visible; it is the; responsibility of the AST reader to find and update these AST nodes when it; is notified of the import. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:10433,Energy Efficiency,allocate,allocated,10433,"of those files will be; loaded along with this AST file. For chained precompiled headers, the language options, target architecture and; predefines buffer data is taken from the end of the chain, since they have to; match anyway. .. _pchinternals-sourcemgr:. Source Manager Block; ^^^^^^^^^^^^^^^^^^^^. The source manager block contains the serialized representation of Clang's; :ref:`SourceManager <SourceManager>` class, which handles the mapping from; source locations (as represented in Clang's abstract syntax tree) into actual; column/line positions within a source file or macro instantiation. The AST; file's representation of the source manager also includes information about all; of the headers that were (transitively) included when building the AST file. The bulk of the source manager block is dedicated to information about the; various files, buffers, and macro instantiations into which a source location; can refer. Each of these is referenced by a numeric ""file ID"", which is a; unique number (allocated starting at 1) stored in the source location. Clang; serializes the information for each kind of file ID, along with an index that; maps file IDs to the position within the AST file where the information about; that file ID is stored. The data associated with a file ID is loaded only when; required by the front end, e.g., to emit a diagnostic that includes a macro; instantiation history inside the header itself. The source manager block also contains information about all of the headers; that were included when building the AST file. This includes information about; the controlling macro for the header (e.g., when the preprocessor identified; that the contents of the header dependent on a macro like; ``LLVM_CLANG_SOURCEMANAGER_H``). .. _pchinternals-preprocessor:. Preprocessor Block; ^^^^^^^^^^^^^^^^^^. The preprocessor block contains the serialized representation of the; preprocessor. Specifically, it contains all of the macros that have been; defined by the end ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24592,Energy Efficiency,reduce,reduces,24592,"intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3966,Integrability,depend,depends,3966,"he section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read (0.000000%); 0/30842 statements read (0.000000%); 4/8400 macros read (0.047619%); 1/4995 lexical declcontexts read (0.020020%);",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:9403,Integrability,depend,depends,9403,"rmat. Changes in the; minor version number should not affect backward compatibility, while changes; in the major version number imply that a newer compiler cannot read an older; precompiled header (and vice-versa). Original file name; The full path of the header that was used to generate the AST file. Predefines buffer; Although not explicitly stored as part of the metadata, the predefines buffer; is used in the validation of the AST file. The predefines buffer itself; contains code generated by the compiler to initialize the preprocessor state; according to the current target, platform, and command-line options. For; example, the predefines buffer will contain ""``#define __STDC__ 1``"" when we; are compiling C without Microsoft extensions. The predefines buffer itself; is stored within the :ref:`pchinternals-sourcemgr`, but its contents are; verified along with the rest of the metadata. A chained PCH file (that is, one that references another PCH) and a module; (which may import other modules) have additional metadata containing the list; of all AST files that this AST file depends on. Each of those files will be; loaded along with this AST file. For chained precompiled headers, the language options, target architecture and; predefines buffer data is taken from the end of the chain, since they have to; match anyway. .. _pchinternals-sourcemgr:. Source Manager Block; ^^^^^^^^^^^^^^^^^^^^. The source manager block contains the serialized representation of Clang's; :ref:`SourceManager <SourceManager>` class, which handles the mapping from; source locations (as represented in Clang's abstract syntax tree) into actual; column/line positions within a source file or macro instantiation. The AST; file's representation of the source manager also includes information about all; of the headers that were (transitively) included when building the AST file. The bulk of the source manager block is dedicated to information about the; various files, buffers, and macro instantiations ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:11126,Integrability,depend,dependent,11126,"ders that were (transitively) included when building the AST file. The bulk of the source manager block is dedicated to information about the; various files, buffers, and macro instantiations into which a source location; can refer. Each of these is referenced by a numeric ""file ID"", which is a; unique number (allocated starting at 1) stored in the source location. Clang; serializes the information for each kind of file ID, along with an index that; maps file IDs to the position within the AST file where the information about; that file ID is stored. The data associated with a file ID is loaded only when; required by the front end, e.g., to emit a diagnostic that includes a macro; instantiation history inside the header itself. The source manager block also contains information about all of the headers; that were included when building the AST file. This includes information about; the controlling macro for the header (e.g., when the preprocessor identified; that the contents of the header dependent on a macro like; ``LLVM_CLANG_SOURCEMANAGER_H``). .. _pchinternals-preprocessor:. Preprocessor Block; ^^^^^^^^^^^^^^^^^^. The preprocessor block contains the serialized representation of the; preprocessor. Specifically, it contains all of the macros that have been; defined by the end of the header used to build the AST file, along with the; token sequences that comprise each macro. The macro definitions are only read; from the AST file when the name of the macro first occurs in the program. This; lazy loading of macro definitions is triggered by lookups into the; :ref:`identifier table <pchinternals-ident-table>`. .. _pchinternals-types:. Types Block; ^^^^^^^^^^^. The types block contains the serialized representation of all of the types; referenced in the translation unit. Each Clang type node (``PointerType``,; ``FunctionProtoType``, etc.) has a corresponding record type in the AST file.; When types are deserialized from the AST file, the data within the record is; used",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21566,Integrability,integrat,integration,21566,"tors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21736,Integrability,rout,routines,21736," the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21942,Integrability,interface,interface,21942," the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22253,Integrability,interface,interface,22253,"erializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22494,Integrability,interface,interface,22494," requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22885,Integrability,interface,interface,22885," the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:23317,Integrability,interface,interface,23317,"eds to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that transla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24125,Integrability,depend,depends,24125,"ed within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just li",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24757,Integrability,depend,depend,24757,"ar source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24816,Integrability,depend,dependencies,24816,"ar source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24929,Integrability,depend,depends,24929,"ble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:24963,Integrability,depend,dependencies,24963,"ile changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; informa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:25184,Integrability,depend,depends,25184,"ile changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained precompiled headers get their name because each precompiled header can; depend on one other precompiled header, forming a chain of dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; informa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:25789,Integrability,depend,depends,25789,"f dependencies. A; translation unit will then include the precompiled header that starts the chain; (i.e., nothing depends on it). This linearity of dependencies is important for; the semantic model of chained precompiled headers, because the most-recent; precompiled header can provide information that overrides the information; provided by the precompiled headers it depends on, just like a header file; ``B.h`` that includes another header ``A.h`` can modify the state produced by; parsing ``A.h``, e.g., by ``#undef``'ing a macro defined in ``A.h``. There are several ways in which chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup table",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:26436,Integrability,depend,depends,26436,"ch chained precompiled headers generalize the AST; file model:. Numbering of IDs; Many different kinds of entities --- identifiers, declarations, types, etc.; --- have ID numbers that start at 1 or some other predefined constant and; grow upward. Each precompiled header records the maximum ID number it has; assigned in each category. Then, when a new precompiled header is generated; that depends on (chains to) another precompiled header, it will start; counting at the next available ID number. This way, one can determine, given; an ID number, which AST file actually contains the entity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update rec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:27866,Integrability,depend,depends,27866,"e-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for its own new; entities. The AST reader then maps these ""local"" ID numbers into a ""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:29395,Integrability,interface,interface,29395,"""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; compilation error, due to an ambiguity in name lookup. Therefore, the AST; reader performs declaration merging according to the appropriate language; semantics, ensuring that the two disjoint declarations are merged into a; single redeclaration chain (with a common canonical declaration), so that it; is as if one of the headers had been included before the other. Name Visibility; Modules allow certain names that occur during module creation to be ""hidden"",; so that they are not part of the public interface of the module and are not; visible to its clients. The AST reader maintains a ""visible"" bit on various; AST nodes (declarations, macros, etc.) to indicate whether that particular; AST node is currently visible; the various name lookup mechanisms in Clang; inspect the visible bit to determine whether that entity, which is still in; the AST (because other, visible AST nodes may depend on it), can actually be; found by name lookup. When a new (sub)module is imported, it may make; existing, non-visible, already-deserialized AST nodes visible; it is the; responsibility of the AST reader to find and update these AST nodes when it; is notified of the import. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:29784,Integrability,depend,depend,29784,"""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; compilation error, due to an ambiguity in name lookup. Therefore, the AST; reader performs declaration merging according to the appropriate language; semantics, ensuring that the two disjoint declarations are merged into a; single redeclaration chain (with a common canonical declaration), so that it; is as if one of the headers had been included before the other. Name Visibility; Modules allow certain names that occur during module creation to be ""hidden"",; so that they are not part of the public interface of the module and are not; visible to its clients. The AST reader maintains a ""visible"" bit on various; AST nodes (declarations, macros, etc.) to indicate whether that particular; AST node is currently visible; the various name lookup mechanisms in Clang; inspect the visible bit to determine whether that entity, which is still in; the AST (because other, visible AST nodes may depend on it), can actually be; found by name lookup. When a new (sub)module is imported, it may make; existing, non-visible, already-deserialized AST nodes visible; it is the; responsibility of the AST reader to find and update these AST nodes when it; is notified of the import. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3823,Modifiability,variab,variables,3823,"cluded at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22046,Modifiability,inherit,inherits,22046,"tance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1271,Performance,perform,performance,1271,"'s precompiled; headers (PCH) and modules. If you are interested in the end-user view, please; see the :ref:`User's Manual <usersmanual-precompiled-headers>`. Using Precompiled Headers with ``clang``; ----------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH file initially is not so large that it; counters the per-source-file performance improvement due to eliminating the; need to parse th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1597,Performance,load,load,1597,"e the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH file initially is not so large that it; counters the per-source-file performance improvement due to eliminating the; need to parse the bundled headers in the first place. This is particularly; important on multi-core systems, because PCH file generation serializes the; build when all compilations require the PCH file to be up-to-date. Modules, as implemented in Clang, use the same mechanisms as precompiled; headers to save a serialized AST file (one per module) and use those AST; modules. From an implementation standpoint, modules ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1742,Performance,perform,performance,1742,"ansparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH file initially is not so large that it; counters the per-source-file performance improvement due to eliminating the; need to parse the bundled headers in the first place. This is particularly; important on multi-core systems, because PCH file generation serializes the; build when all compilations require the PCH file to be up-to-date. Modules, as implemented in Clang, use the same mechanisms as precompiled; headers to save a serialized AST file (one per module) and use those AST; modules. From an implementation standpoint, modules are a generalization of; precompiled headers, lifting a number of restrictions placed on precompiled; headers. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:2149,Performance,perform,performance,2149,"aders are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH file initially is not so large that it; counters the per-source-file performance improvement due to eliminating the; need to parse the bundled headers in the first place. This is particularly; important on multi-core systems, because PCH file generation serializes the; build when all compilations require the PCH file to be up-to-date. Modules, as implemented in Clang, use the same mechanisms as precompiled; headers to save a serialized AST file (one per module) and use those AST; modules. From an implementation standpoint, modules are a generalization of; precompiled headers, lifting a number of restrictions placed on precompiled; headers. In particular, there can only be one precompiled header and it must; be included at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3124,Performance,load,load,3124,"enerating the PCH file initially is not so large that it; counters the per-source-file performance improvement due to eliminating the; need to parse the bundled headers in the first place. This is particularly; important on multi-core systems, because PCH file generation serializes the; build when all compilations require the PCH file to be up-to-date. Modules, as implemented in Clang, use the same mechanisms as precompiled; headers to save a serialized AST file (one per module) and use those AST; modules. From an implementation standpoint, modules are a generalization of; precompiled headers, lifting a number of restrictions placed on precompiled; headers. In particular, there can only be one precompiled header and it must; be included at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3411,Performance,load,loaded,3411,"ate. Modules, as implemented in Clang, use the same mechanisms as precompiled; headers to save a serialized AST file (one per module) and use those AST; modules. From an implementation standpoint, modules are a generalization of; precompiled headers, lifting a number of restrictions placed on precompiled; headers. In particular, there can only be one precompiled header and it must; be included at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3469,Performance,load,loaded,3469,"d AST file (one per module) and use those AST; modules. From an implementation standpoint, modules are a generalization of; precompiled headers, lifting a number of restrictions placed on precompiled; headers. In particular, there can only be one precompiled header and it must; be included at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3642,Performance,load,load,3642," of restrictions placed on precompiled; headers. In particular, there can only be one precompiled header and it must; be included at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3748,Performance,load,load,3748," of restrictions placed on precompiled; headers. In particular, there can only be one precompiled header and it must; be included at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3853,Performance,load,loaded,3853,"he section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read (0.000000%); 0/30842 statements read (0.000000%); 4/8400 macros read (0.047619%); 1/4995 lexical declcontexts read (0.020020%);",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:4342,Performance,load,loaded,4342,"pressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read (0.000000%); 0/30842 statements read (0.000000%); 4/8400 macros read (0.047619%); 1/4995 lexical declcontexts read (0.020020%); 0/4413 visible declcontexts read (0.000000%); 0/7230 method pool entries read (0.000000%); 0 method pool misses. For this small program, only a tiny fraction of the source locations, types,; declarations, identifiers, and macros were actually deserialized from the; precompiled header. These statistics can be useful to determine whether the; AST file implementat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:7376,Performance,optimiz,optimized,7376," debug information for the data types defined in the AST. Tools built on top of; libclang that do not need debug information may also produce raw AST files that; only contain the serialized AST. The ``clangast`` section is organized into several different blocks, each of; which contains the serialized representation of a part of Clang's internal; representation. Each of the blocks corresponds to either a block or a record; within `LLVM's bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_.; The contents of each of these logical blocks are described below. .. image:: PCHLayout.png. The ``llvm-objdump`` utility provides a ``-raw-clang-ast`` option to extract the; binary contents of the AST section from an object file container. The `llvm-bcanalyzer <https://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html>`_; utility can be used to examine the actual structure of the bitstream for the AST; section. This information can be used both to help understand the structure of; the AST section and to isolate areas where the AST representation can still be; optimized, e.g., through the introduction of abbreviations. Metadata Block; ^^^^^^^^^^^^^^. The metadata block contains several records that provide information about how; the AST file was built. This metadata is primarily used to validate the use of; an AST file. For example, a precompiled header built for a 32-bit x86 target; cannot be used when compiling for a 64-bit x86 target. The metadata block; contains information about:. Language options; Describes the particular language dialect used to compile the AST file,; including major options (e.g., Objective-C support) and more minor options; (e.g., support for ""``//``"" comments). The contents of this record correspond to; the ``LangOptions`` class. Target architecture; The target triple that describes the architecture, platform, and ABI for; which the AST file was generated, e.g., ``i386-apple-darwin9``. AST version; The major and minor version numbers of the AST fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:9444,Performance,load,loaded,9444," that a newer compiler cannot read an older; precompiled header (and vice-versa). Original file name; The full path of the header that was used to generate the AST file. Predefines buffer; Although not explicitly stored as part of the metadata, the predefines buffer; is used in the validation of the AST file. The predefines buffer itself; contains code generated by the compiler to initialize the preprocessor state; according to the current target, platform, and command-line options. For; example, the predefines buffer will contain ""``#define __STDC__ 1``"" when we; are compiling C without Microsoft extensions. The predefines buffer itself; is stored within the :ref:`pchinternals-sourcemgr`, but its contents are; verified along with the rest of the metadata. A chained PCH file (that is, one that references another PCH) and a module; (which may import other modules) have additional metadata containing the list; of all AST files that this AST file depends on. Each of those files will be; loaded along with this AST file. For chained precompiled headers, the language options, target architecture and; predefines buffer data is taken from the end of the chain, since they have to; match anyway. .. _pchinternals-sourcemgr:. Source Manager Block; ^^^^^^^^^^^^^^^^^^^^. The source manager block contains the serialized representation of Clang's; :ref:`SourceManager <SourceManager>` class, which handles the mapping from; source locations (as represented in Clang's abstract syntax tree) into actual; column/line positions within a source file or macro instantiation. The AST; file's representation of the source manager also includes information about all; of the headers that were (transitively) included when building the AST file. The bulk of the source manager block is dedicated to information about the; various files, buffers, and macro instantiations into which a source location; can refer. Each of these is referenced by a numeric ""file ID"", which is a; unique number (allocated st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:10716,Performance,load,loaded,10716,"^. The source manager block contains the serialized representation of Clang's; :ref:`SourceManager <SourceManager>` class, which handles the mapping from; source locations (as represented in Clang's abstract syntax tree) into actual; column/line positions within a source file or macro instantiation. The AST; file's representation of the source manager also includes information about all; of the headers that were (transitively) included when building the AST file. The bulk of the source manager block is dedicated to information about the; various files, buffers, and macro instantiations into which a source location; can refer. Each of these is referenced by a numeric ""file ID"", which is a; unique number (allocated starting at 1) stored in the source location. Clang; serializes the information for each kind of file ID, along with an index that; maps file IDs to the position within the AST file where the information about; that file ID is stored. The data associated with a file ID is loaded only when; required by the front end, e.g., to emit a diagnostic that includes a macro; instantiation history inside the header itself. The source manager block also contains information about all of the headers; that were included when building the AST file. This includes information about; the controlling macro for the header (e.g., when the preprocessor identified; that the contents of the header dependent on a macro like; ``LLVM_CLANG_SOURCEMANAGER_H``). .. _pchinternals-preprocessor:. Preprocessor Block; ^^^^^^^^^^^^^^^^^^. The preprocessor block contains the serialized representation of the; preprocessor. Specifically, it contains all of the macros that have been; defined by the end of the header used to build the AST file, along with the; token sequences that comprise each macro. The macro definitions are only read; from the AST file when the name of the macro first occurs in the program. This; lazy loading of macro definitions is triggered by lookups into the; :ref:`identifi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:11643,Performance,load,loading,11643,"ted with a file ID is loaded only when; required by the front end, e.g., to emit a diagnostic that includes a macro; instantiation history inside the header itself. The source manager block also contains information about all of the headers; that were included when building the AST file. This includes information about; the controlling macro for the header (e.g., when the preprocessor identified; that the contents of the header dependent on a macro like; ``LLVM_CLANG_SOURCEMANAGER_H``). .. _pchinternals-preprocessor:. Preprocessor Block; ^^^^^^^^^^^^^^^^^^. The preprocessor block contains the serialized representation of the; preprocessor. Specifically, it contains all of the macros that have been; defined by the end of the header used to build the AST file, along with the; token sequences that comprise each macro. The macro definitions are only read; from the AST file when the name of the macro first occurs in the program. This; lazy loading of macro definitions is triggered by lookups into the; :ref:`identifier table <pchinternals-ident-table>`. .. _pchinternals-types:. Types Block; ^^^^^^^^^^^. The types block contains the serialized representation of all of the types; referenced in the translation unit. Each Clang type node (``PointerType``,; ``FunctionProtoType``, etc.) has a corresponding record type in the AST file.; When types are deserialized from the AST file, the data within the record is; used to reconstruct the appropriate type node using the AST context. Each type has a unique type ID, which is an integer that uniquely identifies; that type. Type ID 0 represents the NULL type, type IDs less than; ``NUM_PREDEF_TYPE_IDS`` represent predefined types (``void``, ``float``, etc.),; while other ""user-defined"" type IDs are assigned consecutively from; ``NUM_PREDEF_TYPE_IDS`` upward as the types are encountered. The AST file has; an associated mapping from the user-defined types block to the location within; the types block where the serialized representation o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:14353,Performance,perform,perform,14353,"are deserialized from the AST file, the data; within the record is used to build and populate a new instance of the; corresponding ``Decl`` node. As with types, each declaration node has a; numeric ID that is used to refer to that declaration within the AST file. In; addition, a lookup table provides a mapping from that numeric ID to the offset; within the precompiled header where that declaration is described. Declarations in Clang's abstract syntax trees are stored hierarchically. At; the top of the hierarchy is the translation unit (``TranslationUnitDecl``),; which contains all of the declarations in the translation unit but is not; actually written as a specific declaration node. Its child declarations (such; as functions or struct types) may also contain other declarations inside them,; and so on. Within Clang, each declaration is stored within a :ref:`declaration; context <DeclContext>`, as represented by the ``DeclContext`` class.; Declaration contexts provide the mechanism to perform name lookup within a; given declaration (e.g., find the member named ``x`` in a structure) and; iterate over the declarations stored within a context (e.g., iterate over all; of the fields of a structure for structure layout). In Clang's AST file format, deserializing a declaration that is a; ``DeclContext`` is a separate operation from deserializing all of the; declarations stored within that declaration context. Therefore, Clang will; deserialize the translation unit declaration without deserializing the; declarations within that translation unit. When required, the declarations; stored within a declaration context will be deserialized. There are two; representations of the declarations within a declaration context, which; correspond to the name-lookup and iteration behavior described above:. * When the front end performs name lookup to find a name ``x`` within a given; declaration context (for example, during semantic analysis of the expression; ``p->x``, where ``p``'s type is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:15188,Performance,perform,performs,15188,"ookup within a; given declaration (e.g., find the member named ``x`` in a structure) and; iterate over the declarations stored within a context (e.g., iterate over all; of the fields of a structure for structure layout). In Clang's AST file format, deserializing a declaration that is a; ``DeclContext`` is a separate operation from deserializing all of the; declarations stored within that declaration context. Therefore, Clang will; deserialize the translation unit declaration without deserializing the; declarations within that translation unit. When required, the declarations; stored within a declaration context will be deserialized. There are two; representations of the declarations within a declaration context, which; correspond to the name-lookup and iteration behavior described above:. * When the front end performs name lookup to find a name ``x`` within a given; declaration context (for example, during semantic analysis of the expression; ``p->x``, where ``p``'s type is defined in the precompiled header), Clang; refers to an on-disk hash table that maps from the names within that; declaration context to the declaration IDs that represent each visible; declaration with that name. The actual declarations will then be; deserialized to provide the results of name lookup.; * When the front end performs iteration over all of the declarations within a; declaration context, all of those declarations are immediately; de-serialized. For large declaration contexts (e.g., the translation unit),; this operation is expensive; however, large declaration contexts are not; traversed in normal compilation, since such a traversal is unnecessary.; However, it is common for the code generator and semantic analysis to; traverse declaration contexts for structs, classes, unions, and; enumerations, although those contexts contain relatively few declarations in; the common case. Statements and Expressions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Statements and expressions are stored in the AST file",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:15681,Performance,perform,performs,15681,"s stored within that declaration context. Therefore, Clang will; deserialize the translation unit declaration without deserializing the; declarations within that translation unit. When required, the declarations; stored within a declaration context will be deserialized. There are two; representations of the declarations within a declaration context, which; correspond to the name-lookup and iteration behavior described above:. * When the front end performs name lookup to find a name ``x`` within a given; declaration context (for example, during semantic analysis of the expression; ``p->x``, where ``p``'s type is defined in the precompiled header), Clang; refers to an on-disk hash table that maps from the names within that; declaration context to the declaration IDs that represent each visible; declaration with that name. The actual declarations will then be; deserialized to provide the results of name lookup.; * When the front end performs iteration over all of the declarations within a; declaration context, all of those declarations are immediately; de-serialized. For large declaration contexts (e.g., the translation unit),; this operation is expensive; however, large declaration contexts are not; traversed in normal compilation, since such a traversal is unnecessary.; However, it is common for the code generator and semantic analysis to; traverse declaration contexts for structs, classes, unions, and; enumerations, although those contexts contain relatively few declarations in; the common case. Statements and Expressions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Statements and expressions are stored in the AST file in both the :ref:`types; <pchinternals-types>` and the :ref:`declarations <pchinternals-decls>` blocks,; because every statement or expression will be associated with either a type or; declaration. The actual statement and expression records are stored; immediately following the declaration or type that owns the statement or; expression. For example, the statement rep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:19224,Performance,load,loaded,19224,"ched the end; of a serialized expression or statement; other expression or statement records; may follow, but they are part of a different expression. .. _pchinternals-ident-table:. Identifier Table Block; ^^^^^^^^^^^^^^^^^^^^^^. The identifier table block contains an on-disk hash table that maps each; identifier mentioned within the AST file to the serialized representation of; the identifier's information (e.g, the ``IdentifierInfo`` structure). The; serialized representation contains:. * The actual identifier string.; * Flags that describe whether this identifier is the name of a built-in, a; poisoned identifier, an extension token, or a macro.; * If the identifier names a macro, the offset of the macro definition within; the :ref:`pchinternals-preprocessor`.; * If the identifier names one or more declarations visible from translation; unit scope, the :ref:`declaration IDs <pchinternals-decls>` of these; declarations. When an AST file is loaded, the AST file reader mechanism introduces itself; into the identifier table as an external lookup source. Thus, when the user; program refers to an identifier that has not yet been seen, Clang will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialized,; at which point the corresponding ``IdentifierInfo`` structure will have the; same contents it would have after parsing the headers in the AST file. Within the AST file, the identifiers used to name declarations are represented; with an integral value. A separate table provides a mapping from this integral; value (the identifier ID) to the location within the on-disk hash table where; that identifier is stored. This mapping is used when deserializing the name of; a declaration, the identifier of a token, or any other construct in the AST; file that refers to a name. .. _pchinternals-method-pool:. Method Pool Block; ^^^^^^^^^^^^^^^^^. The method pool block is represent",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:19429,Performance,perform,perform,19429,"ent expression. .. _pchinternals-ident-table:. Identifier Table Block; ^^^^^^^^^^^^^^^^^^^^^^. The identifier table block contains an on-disk hash table that maps each; identifier mentioned within the AST file to the serialized representation of; the identifier's information (e.g, the ``IdentifierInfo`` structure). The; serialized representation contains:. * The actual identifier string.; * Flags that describe whether this identifier is the name of a built-in, a; poisoned identifier, an extension token, or a macro.; * If the identifier names a macro, the offset of the macro definition within; the :ref:`pchinternals-preprocessor`.; * If the identifier names one or more declarations visible from translation; unit scope, the :ref:`declaration IDs <pchinternals-decls>` of these; declarations. When an AST file is loaded, the AST file reader mechanism introduces itself; into the identifier table as an external lookup source. Thus, when the user; program refers to an identifier that has not yet been seen, Clang will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialized,; at which point the corresponding ``IdentifierInfo`` structure will have the; same contents it would have after parsing the headers in the AST file. Within the AST file, the identifiers used to name declarations are represented; with an integral value. A separate table provides a mapping from this integral; value (the identifier ID) to the location within the on-disk hash table where; that identifier is stored. This mapping is used when deserializing the name of; a declaration, the identifier of a token, or any other construct in the AST; file that refers to a name. .. _pchinternals-method-pool:. Method Pool Block; ^^^^^^^^^^^^^^^^^. The method pool block is represented as an on-disk hash table that serves two; purposes: it provides a mapping from the names of Objective-C selectors to the; set of Obj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22021,Performance,load,loading,22021,"tance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serial",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22394,Performance,load,load,22394,"erializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:22772,Performance,load,load,22772," able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:23001,Performance,load,loaded,23001," the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:23648,Performance,perform,performance,23648,"or this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interface is associated with the ``ASTContext`` class, and is; used whenever the abstract syntax tree nodes need to loaded from the AST; file. It provides the ability to de-serialize declarations and types; identified by their numeric values, read the bodies of functions when; required, and read the declarations stored within a declaration context; (either for iteration or for name lookup). ``ExternalSemaSource``; This abstract interface is associated with the ``Sema`` class, and is used; whenever semantic analysis needs to read information from the :ref:`global; method pool <pchinternals-method-pool>`. .. _pchinternals-chained:. Chained precompiled headers; ---------------------------. Chained precompiled headers were initially intended to improve the performance; of IDE-centric operations such as syntax highlighting and code completion while; a particular source file is being edited by the user. To minimize the amount; of reparsing required after a change to the file, a form of precompiled header; --- called a precompiled *preamble* --- is automatically generated by parsing; all of the headers in the source file, up to and including the last; ``#include``. When only the source file changes (and none of the headers it; depends on), reparsing of that source file can use the precompiled preamble and; start parsing after the ``#include``\ s, so parsing time is proportional to the; size of the source file (rather than all of its includes). However, the; compilation of that translation unit may already use a precompiled header: in; this case, Clang will create the precompiled preamble as a chained precompiled; header that refers to the original precompiled header. This drastically; reduces the time needed to serialize the precompiled preamble for use in; reparsing. Chained pre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:27029,Performance,load,loaded,27029,"tity. Name lookup; When writing a chained precompiled header, Clang attempts to write only; information that has changed from the precompiled header on which it is; based. This changes the lookup algorithm for the various tables, such as the; :ref:`identifier table <pchinternals-ident-table>`: the search starts at the; most-recent precompiled header. If no entry is found, lookup then proceeds; to the identifier table in the precompiled header it depends on, and so one.; Once a lookup succeeds, that result is considered definitive, overriding any; results from earlier precompiled headers. Update records; There are various ways in which a later precompiled header can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:28975,Performance,perform,performs,28975,"""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a module, and some; third party imports both of those modules, there is a potentially serious; problem: name lookup for ``printf`` or ``struct stat`` will find both; declarations, but the AST nodes are unrelated. This would result in a; compilation error, due to an ambiguity in name lookup. Therefore, the AST; reader performs declaration merging according to the appropriate language; semantics, ensuring that the two disjoint declarations are merged into a; single redeclaration chain (with a common canonical declaration), so that it; is as if one of the headers had been included before the other. Name Visibility; Modules allow certain names that occur during module creation to be ""hidden"",; so that they are not part of the public interface of the module and are not; visible to its clients. The AST reader maintains a ""visible"" bit on various; AST nodes (declarations, macros, etc.) to indicate whether that particular; AST node is currently visible; the various name lookup mechanisms in Clang; inspect the visible bit to determine whether that entity, which is still in; the AST (because other, visible AST nodes may depend on it), can actually be; found by name lookup. When a new (sub)module is imported, it may make; existing, non-visible, already-deserialized AST nodes visible; it is the; responsibility of the AST reader to find and update these AST nodes when it; is notified of the import. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:7607,Security,validat,validate,7607,"zed representation of a part of Clang's internal; representation. Each of the blocks corresponds to either a block or a record; within `LLVM's bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_.; The contents of each of these logical blocks are described below. .. image:: PCHLayout.png. The ``llvm-objdump`` utility provides a ``-raw-clang-ast`` option to extract the; binary contents of the AST section from an object file container. The `llvm-bcanalyzer <https://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html>`_; utility can be used to examine the actual structure of the bitstream for the AST; section. This information can be used both to help understand the structure of; the AST section and to isolate areas where the AST representation can still be; optimized, e.g., through the introduction of abbreviations. Metadata Block; ^^^^^^^^^^^^^^. The metadata block contains several records that provide information about how; the AST file was built. This metadata is primarily used to validate the use of; an AST file. For example, a precompiled header built for a 32-bit x86 target; cannot be used when compiling for a 64-bit x86 target. The metadata block; contains information about:. Language options; Describes the particular language dialect used to compile the AST file,; including major options (e.g., Objective-C support) and more minor options; (e.g., support for ""``//``"" comments). The contents of this record correspond to; the ``LangOptions`` class. Target architecture; The target triple that describes the architecture, platform, and ABI for; which the AST file was generated, e.g., ``i386-apple-darwin9``. AST version; The major and minor version numbers of the AST file format. Changes in the; minor version number should not affect backward compatibility, while changes; in the major version number imply that a newer compiler cannot read an older; precompiled header (and vice-versa). Original file name; The full path of the header that was used to generate the A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:8728,Security,validat,validation,8728," a 32-bit x86 target; cannot be used when compiling for a 64-bit x86 target. The metadata block; contains information about:. Language options; Describes the particular language dialect used to compile the AST file,; including major options (e.g., Objective-C support) and more minor options; (e.g., support for ""``//``"" comments). The contents of this record correspond to; the ``LangOptions`` class. Target architecture; The target triple that describes the architecture, platform, and ABI for; which the AST file was generated, e.g., ``i386-apple-darwin9``. AST version; The major and minor version numbers of the AST file format. Changes in the; minor version number should not affect backward compatibility, while changes; in the major version number imply that a newer compiler cannot read an older; precompiled header (and vice-versa). Original file name; The full path of the header that was used to generate the AST file. Predefines buffer; Although not explicitly stored as part of the metadata, the predefines buffer; is used in the validation of the AST file. The predefines buffer itself; contains code generated by the compiler to initialize the preprocessor state; according to the current target, platform, and command-line options. For; example, the predefines buffer will contain ""``#define __STDC__ 1``"" when we; are compiling C without Microsoft extensions. The predefines buffer itself; is stored within the :ref:`pchinternals-sourcemgr`, but its contents are; verified along with the rest of the metadata. A chained PCH file (that is, one that references another PCH) and a module; (which may import other modules) have additional metadata containing the list; of all AST files that this AST file depends on. Each of those files will be; loaded along with this AST file. For chained precompiled headers, the language options, target architecture and; predefines buffer data is taken from the end of the chain, since they have to; match anyway. .. _pchinternals-sourcemgr:. Source",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:15420,Security,hash,hash,15420,"ookup within a; given declaration (e.g., find the member named ``x`` in a structure) and; iterate over the declarations stored within a context (e.g., iterate over all; of the fields of a structure for structure layout). In Clang's AST file format, deserializing a declaration that is a; ``DeclContext`` is a separate operation from deserializing all of the; declarations stored within that declaration context. Therefore, Clang will; deserialize the translation unit declaration without deserializing the; declarations within that translation unit. When required, the declarations; stored within a declaration context will be deserialized. There are two; representations of the declarations within a declaration context, which; correspond to the name-lookup and iteration behavior described above:. * When the front end performs name lookup to find a name ``x`` within a given; declaration context (for example, during semantic analysis of the expression; ``p->x``, where ``p``'s type is defined in the precompiled header), Clang; refers to an on-disk hash table that maps from the names within that; declaration context to the declaration IDs that represent each visible; declaration with that name. The actual declarations will then be; deserialized to provide the results of name lookup.; * When the front end performs iteration over all of the declarations within a; declaration context, all of those declarations are immediately; de-serialized. For large declaration contexts (e.g., the translation unit),; this operation is expensive; however, large declaration contexts are not; traversed in normal compilation, since such a traversal is unnecessary.; However, it is common for the code generator and semantic analysis to; traverse declaration contexts for structs, classes, unions, and; enumerations, although those contexts contain relatively few declarations in; the common case. Statements and Expressions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Statements and expressions are stored in the AST file",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:18546,Security,hash,hash,18546,"rLiteral(5)`` |; +-----------------------+; | ``IntegerLiteral(4)`` |; +-----------------------+; | ``IntegerLiteral(3)`` |; +-----------------------+; | ``IntegerLiteral(-)`` |; +-----------------------+; | ``IntegerLiteral(+)`` |; +-----------------------+; | ``STOP`` |; +-----------------------+. When reading this representation, Clang evaluates each expression record it; encounters, builds the appropriate abstract syntax tree node, and then pushes; that expression on to a stack. When a record contains *N* subexpressions ---; ``BinaryOperator`` has two of them --- those expressions are popped from the; top of the stack. The special STOP code indicates that we have reached the end; of a serialized expression or statement; other expression or statement records; may follow, but they are part of a different expression. .. _pchinternals-ident-table:. Identifier Table Block; ^^^^^^^^^^^^^^^^^^^^^^. The identifier table block contains an on-disk hash table that maps each; identifier mentioned within the AST file to the serialized representation of; the identifier's information (e.g, the ``IdentifierInfo`` structure). The; serialized representation contains:. * The actual identifier string.; * Flags that describe whether this identifier is the name of a built-in, a; poisoned identifier, an extension token, or a macro.; * If the identifier names a macro, the offset of the macro definition within; the :ref:`pchinternals-preprocessor`.; * If the identifier names one or more declarations visible from translation; unit scope, the :ref:`declaration IDs <pchinternals-decls>` of these; declarations. When an AST file is loaded, the AST file reader mechanism introduces itself; into the identifier table as an external lookup source. Thus, when the user; program refers to an identifier that has not yet been seen, Clang will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:19964,Security,hash,hash,19964," If the identifier names a macro, the offset of the macro definition within; the :ref:`pchinternals-preprocessor`.; * If the identifier names one or more declarations visible from translation; unit scope, the :ref:`declaration IDs <pchinternals-decls>` of these; declarations. When an AST file is loaded, the AST file reader mechanism introduces itself; into the identifier table as an external lookup source. Thus, when the user; program refers to an identifier that has not yet been seen, Clang will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialized,; at which point the corresponding ``IdentifierInfo`` structure will have the; same contents it would have after parsing the headers in the AST file. Within the AST file, the identifiers used to name declarations are represented; with an integral value. A separate table provides a mapping from this integral; value (the identifier ID) to the location within the on-disk hash table where; that identifier is stored. This mapping is used when deserializing the name of; a declaration, the identifier of a token, or any other construct in the AST; file that refers to a name. .. _pchinternals-method-pool:. Method Pool Block; ^^^^^^^^^^^^^^^^^. The method pool block is represented as an on-disk hash table that serves two; purposes: it provides a mapping from the names of Objective-C selectors to the; set of Objective-C instance and class methods that have that particular; selector (which is required for semantic analysis in Objective-C) and also; stores all of the selectors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:20287,Security,hash,hash,20287,"g will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialized,; at which point the corresponding ``IdentifierInfo`` structure will have the; same contents it would have after parsing the headers in the AST file. Within the AST file, the identifiers used to name declarations are represented; with an integral value. A separate table provides a mapping from this integral; value (the identifier ID) to the location within the on-disk hash table where; that identifier is stored. This mapping is used when deserializing the name of; a declaration, the identifier of a token, or any other construct in the AST; file that refers to a name. .. _pchinternals-method-pool:. Method Pool Block; ^^^^^^^^^^^^^^^^^. The method pool block is represented as an on-disk hash table that serves two; purposes: it provides a mapping from the names of Objective-C selectors to the; set of Objective-C instance and class methods that have that particular; selector (which is required for semantic analysis in Objective-C) and also; stores all of the selectors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:20840,Security,hash,hash,20840,"e table provides a mapping from this integral; value (the identifier ID) to the location within the on-disk hash table where; that identifier is stored. This mapping is used when deserializing the name of; a declaration, the identifier of a token, or any other construct in the AST; file that refers to a name. .. _pchinternals-method-pool:. Method Pool Block; ^^^^^^^^^^^^^^^^^. The method pool block is represented as an on-disk hash table that serves two; purposes: it provides a mapping from the names of Objective-C selectors to the; set of Objective-C instance and class methods that have that particular; selector (which is required for semantic analysis in Objective-C) and also; stores all of the selectors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21293,Security,hash,hash,21293," purposes: it provides a mapping from the names of Objective-C selectors to the; set of Objective-C instance and class methods that have that particular; selector (which is required for semantic analysis in Objective-C) and also; stores all of the selectors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:679,Testability,test,test,679,"========================================; Precompiled Header and Modules Internals; ========================================. .. contents::; :local:. This document describes the design and implementation of Clang's precompiled; headers (PCH) and modules. If you are interested in the end-user view, please; see the :ref:`User's Manual <usersmanual-precompiled-headers>`. Using Precompiled Headers with ``clang``; ----------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:699,Testability,test,test,699,"========================================; Precompiled Header and Modules Internals; ========================================. .. contents::; :local:. This document describes the design and implementation of Clang's precompiled; headers (PCH) and modules. If you are interested in the end-user view, please; see the :ref:`User's Manual <usersmanual-precompiled-headers>`. Using Precompiled Headers with ``clang``; ----------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1067,Testability,test,test,1067,"ader and Modules Internals; ========================================. .. contents::; :local:. This document describes the design and implementation of Clang's precompiled; headers (PCH) and modules. If you are interested in the end-user view, please; see the :ref:`User's Manual <usersmanual-precompiled-headers>`. Using Precompiled Headers with ``clang``; ----------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cos",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1078,Testability,test,test,1078,"nals; ========================================. .. contents::; :local:. This document describes the design and implementation of Clang's precompiled; headers (PCH) and modules. If you are interested in the end-user view, please; see the :ref:`User's Manual <usersmanual-precompiled-headers>`. Using Precompiled Headers with ``clang``; ----------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1088,Testability,test,test,1088,"====================================. .. contents::; :local:. This document describes the design and implementation of Clang's precompiled; headers (PCH) and modules. If you are interested in the end-user view, please; see the :ref:`User's Manual <usersmanual-precompiled-headers>`. Using Precompiled Headers with ``clang``; ----------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH file ini",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:6842,Testability,log,logical,6842,", without duplicating the data from the common headers for every file. The; mechanisms behind chained precompiled headers are discussed in a :ref:`later; section <pchinternals-chained>`. AST File Contents; -----------------. An AST file produced by clang is an object file container with a ``clangast``; (COFF) or ``__clangast`` (ELF and Mach-O) section containing the serialized AST.; Other target-specific sections in the object file container are used to hold; debug information for the data types defined in the AST. Tools built on top of; libclang that do not need debug information may also produce raw AST files that; only contain the serialized AST. The ``clangast`` section is organized into several different blocks, each of; which contains the serialized representation of a part of Clang's internal; representation. Each of the blocks corresponds to either a block or a record; within `LLVM's bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_.; The contents of each of these logical blocks are described below. .. image:: PCHLayout.png. The ``llvm-objdump`` utility provides a ``-raw-clang-ast`` option to extract the; binary contents of the AST section from an object file container. The `llvm-bcanalyzer <https://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html>`_; utility can be used to examine the actual structure of the bitstream for the AST; section. This information can be used both to help understand the structure of; the AST section and to isolate areas where the AST representation can still be; optimized, e.g., through the introduction of abbreviations. Metadata Block; ^^^^^^^^^^^^^^. The metadata block contains several records that provide information about how; the AST file was built. This metadata is primarily used to validate the use of; an AST file. For example, a precompiled header built for a 32-bit x86 target; cannot be used when compiling for a 64-bit x86 target. The metadata block; contains information about:. Language options; Describes the pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21890,Testability,log,logic,21890," the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:1345,Usability,simpl,simple,1345,"--------------------------------------. The Clang compiler frontend, ``clang -cc1``, supports two command line options; for generating and using PCH files. To generate PCH files using ``clang -cc1``, use the option `-emit-pch`:. .. code-block:: bash. $ clang -cc1 test.h -emit-pch -o test.h.pch. This option is transparently used by ``clang`` when generating PCH files. The; resulting PCH file contains the serialized form of the compiler's internal; representation after it has completed parsing and semantic analysis. The PCH; file can then be used as a prefix header with the `-include-pch`; option:. .. code-block:: bash. $ clang -cc1 -include-pch test.h.pch test.c -o test.s. Design Philosophy; -----------------. Precompiled headers are meant to improve overall compile times for projects, so; the design of precompiled headers is entirely driven by performance concerns.; The use case for precompiled headers is relatively simple: when there is a; common set of headers that is included in nearly every source file in the; project, we *precompile* that bundle of headers into a single precompiled; header (PCH file). Then, when compiling the source files in the project, we; load the PCH file first (as a prefix header), which acts as a stand-in for that; bundle of headers. A precompiled header implementation improves performance when:. * Loading the PCH file is significantly faster than re-parsing the bundle of; headers stored within the PCH file. Thus, a precompiled header design; attempts to minimize the cost of reading the PCH file. Ideally, this cost; should not vary with the size of the precompiled header file. * The cost of generating the PCH file initially is not so large that it; counters the per-source-file performance improvement due to eliminating the; need to parse the bundled headers in the first place. This is particularly; important on multi-core systems, because PCH file generation serializes the; build when all compilations require the PCH file to be up-to-date",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:4367,Usability,simpl,simple,4367,"'s AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read (0.000000%); 0/30842 statements read (0.000000%); 4/8400 macros read (0.047619%); 1/4995 lexical declcontexts read (0.020020%); 0/4413 visible declcontexts read (0.000000%); 0/7230 method pool entries read (0.000000%); 0 method pool misses. For this small program, only a tiny fraction of the source locations, types,; declarations, identifiers, and macros were actually deserialized from the; precompiled header. These statistics can be useful to determine whether the; AST file implementation can be improved by making more of the implementation; lazy. Precompiled headers can be chained. Wh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:27554,Usability,simpl,simple,27554,"can modify the; entities described in an earlier precompiled header. For example, later; precompiled headers can add entries into the various name-lookup tables for; the translation unit or namespaces, or add new categories to an Objective-C; class. Each of these updates is captured in an ""update record"" that is; stored in the chained precompiled header file and will be loaded along with; the original entity. .. _pchinternals-modules:. Modules; -------. Modules generalize the chained precompiled header model yet further, from a; linear chain of precompiled headers to an arbitrary directed acyclic graph; (DAG) of AST files. All of the same techniques used to make chained; precompiled headers work --- ID number, name lookup, update records --- are; shared with modules. However, the DAG nature of modules introduce a number of; additional complications to the model:. Numbering of IDs; The simple, linear numbering scheme used in chained precompiled headers falls; apart with the module DAG, because different modules may end up with; different numbering schemes for entities they imported from common shared; modules. To account for this, each module file provides information about; which modules it depends on and which ID numbers it assigned to the entities; in those modules, as well as which ID numbers it took for its own new; entities. The AST reader then maps these ""local"" ID numbers into a ""global""; ID number space for the current translation unit, providing a 1-1 mapping; between entities (in whatever AST file they inhabit) and global ID numbers.; If that translation unit is then serialized into an AST file, this mapping; will be stored for use when the AST file is imported. Declaration merging; It is possible for a given entity (from the language's perspective) to be; declared multiple times in different places. For example, two different; headers can have the declaration of ``printf`` or could forward-declare; ``struct stat``. If each of those headers is included in a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/PCHInternals.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:3645,Availability,avail,available,3645,"->dump();. // The return value indicates whether we want the visitation to proceed.; // Return false to stop the traversal of the AST.; return true;; }; };. In the methods of our RecursiveASTVisitor we can now use the full power; of the Clang AST to drill through to the parts that are interesting for; us. For example, to find all class declaration with a certain name, we; can check for a specific qualified name:. ::. bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {; if (Declaration->getQualifiedNameAsString() == ""n::m::C""); Declaration->dump();; return true;; }. Accessing the SourceManager and ASTContext; ==========================================. Some of the information about the AST, like source locations and global; identifier information, are not stored in the AST nodes themselves, but; in the ASTContext and its associated source manager. To retrieve them we; need to hand the ASTContext into our RecursiveASTVisitor implementation. The ASTContext is available from the CompilerInstance during the call to; CreateASTConsumer. We can thus extract it there and hand it into our; freshly created FindNamedClassConsumer:. ::. virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>(&Compiler.getASTContext());; }. Now that the ASTContext is available in the RecursiveASTVisitor, we can; do more interesting things with AST nodes, like looking up their source; locations:. ::. bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {; if (Declaration->getQualifiedNameAsString() == ""n::m::C"") {; // getFullLoc uses the ASTContext's SourceManager to resolve the source; // location and break it up into its line and column parts.; FullSourceLoc FullLocation = Context->getFullLoc(Declaration->getBeginLoc());; if (FullLocation.isValid()); llvm::outs() << ""Found declaration at ""; << FullLocation.getSpellingLineNumber() << "":""; << FullLocation.getSpellingColumnNumber() ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:4049,Availability,avail,available,4049,"sitCXXRecordDecl(CXXRecordDecl *Declaration) {; if (Declaration->getQualifiedNameAsString() == ""n::m::C""); Declaration->dump();; return true;; }. Accessing the SourceManager and ASTContext; ==========================================. Some of the information about the AST, like source locations and global; identifier information, are not stored in the AST nodes themselves, but; in the ASTContext and its associated source manager. To retrieve them we; need to hand the ASTContext into our RecursiveASTVisitor implementation. The ASTContext is available from the CompilerInstance during the call to; CreateASTConsumer. We can thus extract it there and hand it into our; freshly created FindNamedClassConsumer:. ::. virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>(&Compiler.getASTContext());; }. Now that the ASTContext is available in the RecursiveASTVisitor, we can; do more interesting things with AST nodes, like looking up their source; locations:. ::. bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {; if (Declaration->getQualifiedNameAsString() == ""n::m::C"") {; // getFullLoc uses the ASTContext's SourceManager to resolve the source; // location and break it up into its line and column parts.; FullSourceLoc FullLocation = Context->getFullLoc(Declaration->getBeginLoc());; if (FullLocation.isValid()); llvm::outs() << ""Found declaration at ""; << FullLocation.getSpellingLineNumber() << "":""; << FullLocation.getSpellingColumnNumber() << ""\n"";; }; return true;; }. Putting it all together; =======================. Now we can combine all of the above into a small example program:. ::. #include ""clang/AST/ASTConsumer.h""; #include ""clang/AST/RecursiveASTVisitor.h""; #include ""clang/Frontend/CompilerInstance.h""; #include ""clang/Frontend/FrontendAction.h""; #include ""clang/Tooling/Tooling.h"". using namespace clang;. class FindNamedClassVisitor; : public Recursiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:2895,Energy Efficiency,power,power,2895," Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, the next step is to implement a; RecursiveASTVisitor to extract the relevant information from the AST. The RecursiveASTVisitor provides hooks of the form bool; VisitNodeType(NodeType \*) for most AST nodes; the exception are TypeLoc; nodes, which are passed by-value. We only need to implement the methods; for the relevant node types. Let's start by writing a RecursiveASTVisitor that visits all; CXXRecordDecl's. ::. class FindNamedClassVisitor; : public RecursiveASTVisitor<FindNamedClassVisitor> {; public:; bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {; // For debugging, dumping the AST nodes will show which nodes are already; // being visited.; Declaration->dump();. // The return value indicates whether we want the visitation to proceed.; // Return false to stop the traversal of the AST.; return true;; }; };. In the methods of our RecursiveASTVisitor we can now use the full power; of the Clang AST to drill through to the parts that are interesting for; us. For example, to find all class declaration with a certain name, we; can check for a specific qualified name:. ::. bool VisitCXXRecordDecl(CXXRecordDecl *Declaration) {; if (Declaration->getQualifiedNameAsString() == ""n::m::C""); Declaration->dump();; return true;; }. Accessing the SourceManager and ASTContext; ==========================================. Some of the information about the AST, like source locations and global; identifier information, are not stored in the AST nodes themselves, but; in the ASTContext and its associated source manager. To retrieve them we; need to hand the ASTContext into our RecursiveASTVisitor implementation. The ASTContext is available from the CompilerInstance during the call to; CreateASTConsumer. We can thus extract it there and hand it into our; freshly created FindNamedClassConsumer:. ::. virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:577,Integrability,interface,interface,577,"==========================================================; How to write RecursiveASTVisitor based ASTFrontendActions.; ==========================================================. Introduction; ============. In this tutorial you will learn how to create a FrontendAction that uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:721,Integrability,interface,interface,721,"==========================================================; How to write RecursiveASTVisitor based ASTFrontendActions.; ==========================================================. Introduction; ============. In this tutorial you will learn how to create a FrontendAction that uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:1239,Integrability,interface,interface,1239," uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, the next step is to implement a; RecursiveASTVisitor to extract the relevant information from the AST. The RecursiveASTVisitor provides hooks of the form bool; VisitNodeType(NodeType \*) for most AST nodes; the exception are TypeLoc; nodes, which are passed by-value. We only",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst:234,Usability,learn,learn,234,"==========================================================; How to write RecursiveASTVisitor based ASTFrontendActions.; ==========================================================. Introduction; ============. In this tutorial you will learn how to create a FrontendAction that uses; a RecursiveASTVisitor to find CXXRecordDecl AST nodes with a specified; name. Creating a FrontendAction; =========================. When writing a clang based tool like a Clang Plugin or a standalone tool; based on LibTooling, the common entry point is the FrontendAction.; FrontendAction is an interface that allows execution of user specific; actions as part of the compilation. To run tools over the AST clang; provides the convenience interface ASTFrontendAction, which takes care; of executing the action. The only part left is to implement the; CreateASTConsumer method that returns an ASTConsumer per translation; unit. ::. class FindNamedClassAction : public clang::ASTFrontendAction {; public:; virtual std::unique_ptr<clang::ASTConsumer> CreateASTConsumer(; clang::CompilerInstance &Compiler, llvm::StringRef InFile) {; return std::make_unique<FindNamedClassConsumer>();; }; };. Creating an ASTConsumer; =======================. ASTConsumer is an interface used to write generic actions on an AST,; regardless of how the AST was produced. ASTConsumer provides many; different entry points, but for our use case the only one needed is; HandleTranslationUnit, which is called with the ASTContext for the; translation unit. ::. class FindNamedClassConsumer : public clang::ASTConsumer {; public:; virtual void HandleTranslationUnit(clang::ASTContext &Context) {; // Traversing the translation unit decl via a RecursiveASTVisitor; // will visit all nodes in the AST.; Visitor.TraverseDecl(Context.getTranslationUnitDecl());; }; private:; // A RecursiveASTVisitor implementation.; FindNamedClassVisitor Visitor;; };. Using the RecursiveASTVisitor; =============================. Now that everything is hooked up, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RAVFrontendAction.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RAVFrontendAction.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1270,Availability,avail,available,1270,"toring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:7372,Availability,error,error,7372,"electedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:7686,Availability,error,error,7686,"re evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refacto",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:7725,Availability,error,error,7725,"re evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refacto",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:7805,Availability,error,error,7805,"t a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed belo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8237,Availability,error,error,8237,"onRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2966,Deployability,update,update,2966,") const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``create",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1683,Integrability,interface,interface,1683,"mselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5148,Integrability,interface,interface,5148,"ly. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8565,Integrability,interface,interface,8565,"ber function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; afore",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:36,Modifiability,refactor,refactoring,36,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:130,Modifiability,refactor,refactoring,130,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:224,Modifiability,refactor,refactoring,224,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:276,Modifiability,refactor,refactoring,276,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:389,Modifiability,refactor,refactoring,389,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:459,Modifiability,refactor,refactorings,459,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:595,Modifiability,refactor,refactoring,595,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:628,Modifiability,refactor,refactorings,628,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:949,Modifiability,refactor,refactoring,949,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1039,Modifiability,refactor,refactoring,1039,"cument describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1072,Modifiability,refactor,refactoring,1072,"cument describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1166,Modifiability,refactor,refactor,1166,"ow various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1225,Modifiability,refactor,refactorings,1225,"ow various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1248,Modifiability,refactor,refactorings,1248,"toring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1327,Modifiability,refactor,refactoring,1327,"en developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1388,Modifiability,refactor,refactoring,1388,"en developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1489,Modifiability,refactor,refactor,1489,"torings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1535,Modifiability,refactor,refactoring,1535,"s<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1617,Modifiability,refactor,refactor,1617,"s<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2150,Modifiability,refactor,refactoring,2150,"o perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2217,Modifiability,refactor,refactoring,2217,"o perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2261,Modifiability,refactor,refactoring,2261,"o perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2462,Modifiability,refactor,refactoring,2462,"lang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2522,Modifiability,refactor,refactoring,2522,"lang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2743,Modifiability,refactor,refactoring,2743,": c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:2859,Modifiability,refactor,refactoring,2859,") const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``create",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3098,Modifiability,refactor,refactor,3098,"{; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3382,Modifiability,refactor,refactor,3382,"of different implementations,; they should strive to produce a similar result. It should be easy for users to; identify which refactoring action produced the result regardless of which; refactoring action rule was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3459,Modifiability,refactor,refactor,3459,"e was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks mig",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3538,Modifiability,refactor,refactoring,3538,"e was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks mig",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3674,Modifiability,refactor,refactoring,3674,"example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't nee",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3720,Modifiability,refactor,refactoring,3720,"example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't nee",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:4013,Modifiability,refactor,refactorings,4013," To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:4147,Modifiability,refactor,refactoring,4147,"local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; inter",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:4383,Modifiability,refactor,refactoring,4383,"s and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5090,Modifiability,refactor,refactoring,5090,"ly. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5252,Modifiability,refactor,refactoring,5252,"ular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the followi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6005,Modifiability,refactor,refactoring,6005,"e of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6446,Modifiability,refactor,refactoring,6446,"cepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule tha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6575,Modifiability,refactor,refactoring,6575,"lection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6797,Modifiability,refactor,refactoring,6797," Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6900,Modifiability,refactor,refactoring,6900,"le's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type must define an; ``evaluate`` member function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8075,Modifiability,refactor,refactoring,8075,"r function that returns a value of type ``Expected<...>``.; When a requirement value is used as an argument to; ``createRefactoringActionRule``, that value is evaluated during the initiation; of the action rule. The evaluated result is then passed to the rule's; constructor unless the evaluation produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range wi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8369,Modifiability,refactor,refactoring,8369,"produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``Refacto",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8404,Modifiability,refactor,refactoring,8404,"produced an error. For example, the; ``DeleteSelectedRange`` sample rule that's defined in the previous section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``Refacto",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8439,Modifiability,refactor,refactoring,8439,"section; will be evaluated using the following steps:. #. ``SourceRangeSelectionRequirement``'s ``evaluate`` member function will be; called first. It will return an ``Expected<SourceRange>``. #. If the return value is an error the initiation will fail and the error; will be reported to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements work",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8704,Modifiability,refactor,refactoring,8704,"d to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when cr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8965,Modifiability,refactor,refactoring,8965,"ated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derive",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9326,Modifiability,refactor,refactoring,9326," separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : publi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9695,Modifiability,refactor,refactoring,9695,"ring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used to create; a requirement for a refactoring rule using a requirement like; ``OptionRequirement``:. .. code-block:: c++. createRefactoringActio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9850,Modifiability,refactor,refactoring,9850,"nRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used to create; a requirement for a refactoring rule using a requirement like; ``OptionRequirement``:. .. code-block:: c++. createRefactoringActionRule<RenameOccurrences>(; ...,; OptionRequirement<NewNameOption>()); );. .. FIXME: Editor Bindings section; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:10237,Modifiability,refactor,refactor,10237,"nRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used to create; a requirement for a refactoring rule using a requirement like; ``OptionRequirement``:. .. code-block:: c++. createRefactoringActionRule<RenameOccurrences>(; ...,; OptionRequirement<NewNameOption>()); );. .. FIXME: Editor Bindings section; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:10601,Modifiability,refactor,refactoring,10601,"nRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used to create; a requirement for a refactoring rule using a requirement like; ``OptionRequirement``:. .. code-block:: c++. createRefactoringActionRule<RenameOccurrences>(; ...,; OptionRequirement<NewNameOption>()); );. .. FIXME: Editor Bindings section; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1211,Performance,perform,perform,1211,"ow various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5240,Performance,perform,perform,5240,"ular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the followi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:883,Usability,learn,learn,883,"==========================; Clang's refactoring engine; ==========================. This document describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:5316,Usability,simpl,simply,5316,"renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't need any cross-TU information, then the; ``SourceChangeRefactoringRule`` should work for you. #. If you would like to implement a rename-like operation with potential; interactive components, then ``FindSymbolOccurrencesRefactoringRule`` might; work for you. How to Create a Rule; ^^^^^^^^^^^^^^^^^^^^. Once you determine which type of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:9541,Usability,simpl,simple,9541,"ace; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when creating a rule. Refactoring Options; -------------------. Refactoring options are values that affect a refactoring operation and are; specified either using command-line options or another client-specific; mechanism. Options should be created using a class that derives either from; the ``OptionalRequiredOption`` or ``RequiredRefactoringOption``. The following; example shows how one can created a required string option that corresponds to; the ``-new-name`` command-line option in clang-refactor:. .. code-block:: c++. class NewNameOption : public RequiredRefactoringOption<std::string> {; public:; StringRef getName() const override { return ""new-name""; }; StringRef getDescription() const override {; return ""The new name to change the symbol to"";; }; };. The option that's shown in the example above can then be used t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:957,Availability,down,downloaded,957,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:5902,Availability,down,downgradable,5902," template parameter list. This fixes a number of issues where valid programs would be rejected due to; mangling collisions, or would in some cases be silently miscompiled. Clang; will use the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit function template specializations now use; `DependentFunctionTemplateSpecializationInfo` to store candidate primary; templates and explicit template arguments. This should not impact users of; Clang as a compiler, but it may break assumptions in Clang-based tools; iterating over the AST. - The warning `-Wenum-constexpr-conversion` is now also enabled by default on; system headers and macros. It will be turned into a hard (non-downgradable); error in the next Clang release. - The flag `-fdelayed-template-parsing` won't be enabled by default with C++20; when targetting MSVC to match the behavior of MSVC.; (`MSVC Docs <https://learn.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170>`_). - Remove the hardcoded path to the imported modules for C++20 named modules. Now we; require all the dependent modules to specified from the command line.; See (`#62707 <https://github.com/llvm/llvm-project/issues/62707>`_). - Forbid `import XXX;` in C++ to find module `XXX` comes from explicit clang modules.; See (`#64755 <https://github.com/llvm/llvm-project/issues/64755>`_). ABI Changes in This Version; ---------------------------; - Following the SystemV ABI for x86-64, ``__int128`` arguments will no longer; be split between a register and a stack slot. - Fixed Microsoft calling convention for returning certain classes with a; templated constructor. If a class has a templated constructor, it s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:5917,Availability,error,error,5917," template parameter list. This fixes a number of issues where valid programs would be rejected due to; mangling collisions, or would in some cases be silently miscompiled. Clang; will use the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit function template specializations now use; `DependentFunctionTemplateSpecializationInfo` to store candidate primary; templates and explicit template arguments. This should not impact users of; Clang as a compiler, but it may break assumptions in Clang-based tools; iterating over the AST. - The warning `-Wenum-constexpr-conversion` is now also enabled by default on; system headers and macros. It will be turned into a hard (non-downgradable); error in the next Clang release. - The flag `-fdelayed-template-parsing` won't be enabled by default with C++20; when targetting MSVC to match the behavior of MSVC.; (`MSVC Docs <https://learn.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170>`_). - Remove the hardcoded path to the imported modules for C++20 named modules. Now we; require all the dependent modules to specified from the command line.; See (`#62707 <https://github.com/llvm/llvm-project/issues/62707>`_). - Forbid `import XXX;` in C++ to find module `XXX` comes from explicit clang modules.; See (`#64755 <https://github.com/llvm/llvm-project/issues/64755>`_). ABI Changes in This Version; ---------------------------; - Following the SystemV ABI for x86-64, ``__int128`` arguments will no longer; be split between a register and a stack slot. - Fixed Microsoft calling convention for returning certain classes with a; templated constructor. If a class has a templated constructor, it s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:16343,Availability,error,error,16343,"-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directives for ""system"" headers instead of copying; the preprocessed text to the output. This can greatly reduce the size of the; preprocessed output, which can be helpful when trying to reduce a test case.; * ``-fassume-nothrow-exception-dtor`` is added to assume that the destructor of; a thrown exception object will not throw. The generated code for catch; handlers will be smaller. A throw expression of a type with a; potentially-throwing destructor will lead to an error. * ``-fopenacc`` was added as a part of the effort to support OpenACC in Clang. * ``-fcx-limited-range`` enables the naive mathematical formulas for complex; division and multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by ``-ffast-math``. * ``-fcx-fortran-rules`` enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun. ACM 5, 8; (1962). The default is ``-fno-cx-fortran-rules``. * ``-fvisibility-global-new-delete=<value>`` gives more freedom to users to; control how and if Clang forces a visibility for the replaceable new and; delete declarations. The option takes 4 values: ``force-hidden``,; ``force-protected``, ``force-default`` and ``source``; ``force-default`` is; the default. Option values with prefix ``force-`` assign such declarati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:22983,Availability,error,error,22983,"initialization expression indicating the; number of bytes for the minimum alignment boundary. Its value must be a power; of 2, between 1 and 4096(inclusive). .. code-block:: c++. void Array(int *array, size_t n) {; [[clang::code_align(64)]] for (int i = 0; i < n; ++i) array[i] = 0;; }. template<int A>; void func() {; [[clang::code_align(A)]] for(;;) { }; }. - Clang now introduced ``[[clang::coro_lifetimebound]]`` attribute.; All parameters of a function are considered to be lifetime bound if the function; returns a type annotated with ``[[clang::coro_lifetimebound]]`` and ``[[clang::coro_return_type]]``.; This analysis can be disabled for a function by annotating the function with ``[[clang::coro_disable_lifetimebound]]``. Improvements to Clang's diagnostics; -----------------------------------; - Clang constexpr evaluator now prints template arguments when displaying; template-specialization function calls.; - Clang contexpr evaluator now displays notes as well as an error when a constructor; of a base class is not called in the constructor of its derived class.; - Clang no longer emits ``-Wmissing-variable-declarations`` for variables declared; with the ``register`` storage class.; - Clang's ``-Wswitch-default`` flag now diagnoses whenever a ``switch`` statement; does not have a ``default`` label.; - Clang's ``-Wtautological-negation-compare`` flag now diagnoses logical; tautologies like ``x && !x`` and ``!x || x`` in expressions. This also; makes ``-Winfinite-recursion`` diagnose more cases.; (`#56035 <https://github.com/llvm/llvm-project/issues/56035>`_).; - Clang constexpr evaluator now diagnoses compound assignment operators against; uninitialized variables as a read of uninitialized object.; (`#51536 <https://github.com/llvm/llvm-project/issues/51536>`_); - Clang's ``-Wformat-truncation`` now diagnoses ``snprintf`` call that is known to; result in string truncation.; (`#64871 <https://github.com/llvm/llvm-project/issues/64871>`_).; Existing warnings that simi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:25728,Availability,failure,failure,25728,"ag.; - Clang now emits ``-Wcast-qual`` for functional-style cast expressions.; - Clang no longer emits irrelevant notes about unsatisfied constraint expressions; on the left-hand side of ``||`` when the right-hand side constraint is satisfied.; (`#54678 <https://github.com/llvm/llvm-project/issues/54678>`_).; - Clang now prints its 'note' diagnostic in cyan instead of black, to be more compatible; with terminals with dark background colors. This is also more consistent with GCC.; - Clang now displays an improved diagnostic and a note when a defaulted special; member is marked ``constexpr`` in a class with a virtual base class; (`#64843 <https://github.com/llvm/llvm-project/issues/64843>`_).; - ``-Wfixed-enum-extension`` and ``-Wmicrosoft-fixed-enum`` diagnostics are no longer; emitted when building as C23, since C23 standardizes support for enums with a; fixed underlying type.; - When describing the failure of static assertion of `==` expression, clang prints the integer; representation of the value as well as its character representation when; the user-provided expression is of character type. If the character is; non-printable, clang now shows the escpaed character.; Clang also prints multi-byte characters if the user-provided expression; is of multi-byte character type. *Example Code*:. .. code-block:: c++. static_assert(""A\n""[1] == U'🌍');. *BEFORE*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:26227,Availability,error,error,26227,"a note when a defaulted special; member is marked ``constexpr`` in a class with a virtual base class; (`#64843 <https://github.com/llvm/llvm-project/issues/64843>`_).; - ``-Wfixed-enum-extension`` and ``-Wmicrosoft-fixed-enum`` diagnostics are no longer; emitted when building as C23, since C23 standardizes support for enums with a; fixed underlying type.; - When describing the failure of static assertion of `==` expression, clang prints the integer; representation of the value as well as its character representation when; the user-provided expression is of character type. If the character is; non-printable, clang now shows the escpaed character.; Clang also prints multi-byte characters if the user-provided expression; is of multi-byte character type. *Example Code*:. .. code-block:: c++. static_assert(""A\n""[1] == U'🌍');. *BEFORE*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:26530,Availability,error,error,26530," When describing the failure of static assertion of `==` expression, clang prints the integer; representation of the value as well as its character representation when; the user-provided expression is of character type. If the character is; non-printable, clang now shows the escpaed character.; Clang also prints multi-byte characters if the user-provided expression; is of multi-byte character type. *Example Code*:. .. code-block:: c++. static_assert(""A\n""[1] == U'🌍');. *BEFORE*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use without realizing it's a; nonportable construct that has different semantics from a constant-sized; array. (`#62836 <https://github.com/llvm/llvm-project/issues/62836>`_). - Clang changed the order in which it displays candidate functions on overloading failures.; Previously, Clang used definition of ordering from the C++ Standard. The order defined in; t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:27604,Availability,failure,failures,27604," requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use without realizing it's a; nonportable construct that has different semantics from a constant-sized; array. (`#62836 <https://github.com/llvm/llvm-project/issues/62836>`_). - Clang changed the order in which it displays candidate functions on overloading failures.; Previously, Clang used definition of ordering from the C++ Standard. The order defined in; the Standard is partial and is not suited for sorting. Instead, Clang now uses a strict; order that still attempts to push more relevant functions to the top by comparing their; corresponding conversions. In some cases, this results in better order. E.g., for the; following code. .. code-block:: cpp. struct Foo {; operator int();; operator const char*();; };. void test() { Foo() - Foo(); }. Clang now produces a list with two most relevant builtin operators at the top,; i.e. ``operator-(int, int)`` and ``operator-(const char*, const char*)``.; Previously ``operator-(const char*, const char*)`` was the first element,; but ``operator-(int, int)`` was only the 13th element in the output.; However, new implementation does not take into account some aspects of; C++ semantics, e.g. which function template is more specialized. This; can sometimes lead to wo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:28609,Availability,error,error,28609," ordering from the C++ Standard. The order defined in; the Standard is partial and is not suited for sorting. Instead, Clang now uses a strict; order that still attempts to push more relevant functions to the top by comparing their; corresponding conversions. In some cases, this results in better order. E.g., for the; following code. .. code-block:: cpp. struct Foo {; operator int();; operator const char*();; };. void test() { Foo() - Foo(); }. Clang now produces a list with two most relevant builtin operators at the top,; i.e. ``operator-(int, int)`` and ``operator-(const char*, const char*)``.; Previously ``operator-(const char*, const char*)`` was the first element,; but ``operator-(int, int)`` was only the 13th element in the output.; However, new implementation does not take into account some aspects of; C++ semantics, e.g. which function template is more specialized. This; can sometimes lead to worse ordering. - When describing a warning/error in a function-style type conversion Clang underlines only until; the end of the expression we convert from. Now Clang underlines until the closing parenthesis. Before:. .. code-block:: text. warning: cast from 'long (*)(const int &)' to 'decltype(fun_ptr)' (aka 'long (*)(int &)') converts to incompatible function type [-Wcast-function-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~. After:. .. code-block:: text. warning: cast from 'long (*)(const int &)' to 'decltype(fun_ptr)' (aka 'long (*)(int &)') converts to incompatible function type [-Wcast-function-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. - ``-Wzero-as-null-pointer-constant`` diagnostic is no longer emitted when using ``__null``; (or, more commonly, ``NULL`` when the platform defines it as ``__null``) to be more consistent; with GCC.; - Clang will warn on deprecated specializations used in system headers when their instantiation; is caused by user code.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:29692,Availability,failure,failure,29692," expression we convert from. Now Clang underlines until the closing parenthesis. Before:. .. code-block:: text. warning: cast from 'long (*)(const int &)' to 'decltype(fun_ptr)' (aka 'long (*)(int &)') converts to incompatible function type [-Wcast-function-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~. After:. .. code-block:: text. warning: cast from 'long (*)(const int &)' to 'decltype(fun_ptr)' (aka 'long (*)(int &)') converts to incompatible function type [-Wcast-function-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. - ``-Wzero-as-null-pointer-constant`` diagnostic is no longer emitted when using ``__null``; (or, more commonly, ``NULL`` when the platform defines it as ``__null``) to be more consistent; with GCC.; - Clang will warn on deprecated specializations used in system headers when their instantiation; is caused by user code.; - Clang will now print ``static_assert`` failure details for arithmetic binary operators.; Example:. .. code-block:: cpp. static_assert(1 << 4 == 15);. will now print:. .. code-block:: text. error: static assertion failed due to requirement '1 << 4 == 15'; 48 | static_assert(1 << 4 == 15);; | ^~~~~~~~~~~~; note: expression evaluates to '16 == 15'; 48 | static_assert(1 << 4 == 15);; | ~~~~~~~^~~~~. - Clang now diagnoses definitions of friend function specializations, e.g. ``friend void f<>(int) {}``.; - Clang now diagnoses narrowing conversions involving const references.; (`#63151 <https://github.com/llvm/llvm-project/issues/63151>`_).; - Clang now diagnoses unexpanded packs within the template argument lists of function template specializations.; - The warning `-Wnan-infinity-disabled` is now emitted when ``INFINITY``; or ``NAN`` are used in arithmetic operations or function arguments in; floating-point mode where ``INFINITY`` or ``NAN`` don't have the expected; values. - Clang now diagnoses attempts to bind a bitfield to an NT",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:29842,Availability,error,error,29842,"ction-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~. After:. .. code-block:: text. warning: cast from 'long (*)(const int &)' to 'decltype(fun_ptr)' (aka 'long (*)(int &)') converts to incompatible function type [-Wcast-function-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. - ``-Wzero-as-null-pointer-constant`` diagnostic is no longer emitted when using ``__null``; (or, more commonly, ``NULL`` when the platform defines it as ``__null``) to be more consistent; with GCC.; - Clang will warn on deprecated specializations used in system headers when their instantiation; is caused by user code.; - Clang will now print ``static_assert`` failure details for arithmetic binary operators.; Example:. .. code-block:: cpp. static_assert(1 << 4 == 15);. will now print:. .. code-block:: text. error: static assertion failed due to requirement '1 << 4 == 15'; 48 | static_assert(1 << 4 == 15);; | ^~~~~~~~~~~~; note: expression evaluates to '16 == 15'; 48 | static_assert(1 << 4 == 15);; | ~~~~~~~^~~~~. - Clang now diagnoses definitions of friend function specializations, e.g. ``friend void f<>(int) {}``.; - Clang now diagnoses narrowing conversions involving const references.; (`#63151 <https://github.com/llvm/llvm-project/issues/63151>`_).; - Clang now diagnoses unexpanded packs within the template argument lists of function template specializations.; - The warning `-Wnan-infinity-disabled` is now emitted when ``INFINITY``; or ``NAN`` are used in arithmetic operations or function arguments in; floating-point mode where ``INFINITY`` or ``NAN`` don't have the expected; values. - Clang now diagnoses attempts to bind a bitfield to an NTTP of a reference type as erroneous; converted constant expression and not as a reference to subobject.; - Clang now diagnoses ``auto`` and ``decltype(auto)`` in declarations of conversion function template; (`CWG1878 <https://cplusplus.github.io/CWG/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:31575,Availability,error,error,31575,"lues. - Clang now diagnoses attempts to bind a bitfield to an NTTP of a reference type as erroneous; converted constant expression and not as a reference to subobject.; - Clang now diagnoses ``auto`` and ``decltype(auto)`` in declarations of conversion function template; (`CWG1878 <https://cplusplus.github.io/CWG/issues/1878.html>`_); - Clang now diagnoses the requirement that non-template friend declarations with requires clauses; and template friend declarations with a constraint that depends on a template parameter from an; enclosing template must be a definition.; - Clang now diagnoses incorrect usage of ``const`` and ``pure`` attributes, so ``-Wignored-attributes`` diagnoses more cases.; - Clang now emits more descriptive diagnostics for 'unusual' expressions (e.g. incomplete index; expressions on matrix types or builtin functions without an argument list) as placement-args; to new-expressions. Before:. .. code-block:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:31879,Availability,error,error,31879,"plusplus.github.io/CWG/issues/1878.html>`_); - Clang now diagnoses the requirement that non-template friend declarations with requires clauses; and template friend declarations with a constraint that depends on a template parameter from an; enclosing template must be a definition.; - Clang now diagnoses incorrect usage of ``const`` and ``pure`` attributes, so ``-Wignored-attributes`` diagnoses more cases.; - Clang now emits more descriptive diagnostics for 'unusual' expressions (e.g. incomplete index; expressions on matrix types or builtin functions without an argument list) as placement-args; to new-expressions. Before:. .. code-block:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:34905,Availability,error,error,34905,"tps://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm-project/issues/37257>`_); - Clang's ``-Wunused-private-field`` no longer warns on fields whose type is; declared with ``[[maybe_unused]]``.; (`#61334 <https://github.com/llvm/llvm-project/issues/61334>`_); - For function multi-versioning using the ``target``, ``target_clones``, or; ``target_version`` attributes, remove comdat for internal linkage functions.; (`#65114 <https://github.com/llvm/llvm-project/issues/65114>`_); - Clang now reports ``-Wformat`` for bool value and char specifier confusion; in scanf. Fixes; (`#64987 <https://github.com/llvm/llvm-project/issues/64987>`_); - Support MSVC predefined macro expressions in constant expressions and in; local structs.; - Correctly parse non-ascii identifiers that appear immediately after a line splicing; (`#65156 <https://github.com/llvm/llvm-project/issues/65156>`_); - Clang no longer considers the loss of ``__unaligned",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:38310,Availability,error,error,38310,"<https://github.com/llvm/llvm-project/issues/63898>`_).; - Fix a crash when evaluating value-dependent structured binding; variables at compile time.; Fixes (`#67690 <https://github.com/llvm/llvm-project/issues/67690>`_); - Fixes a ``clang-17`` regression where ``LLVM_UNREACHABLE_OPTIMIZE=OFF``; cannot be used with ``Release`` mode builds. (`#68237 <https://github.com/llvm/llvm-project/issues/68237>`_).; - Fix crash in evaluating ``constexpr`` value for invalid template function.; Fixes (`#68542 <https://github.com/llvm/llvm-project/issues/68542>`_); - Clang will correctly evaluate ``noexcept`` expression for template functions; of template classes. Fixes; (`#68543 <https://github.com/llvm/llvm-project/issues/68543>`_,; `#42496 <https://github.com/llvm/llvm-project/issues/42496>`_,; `#77071 <https://github.com/llvm/llvm-project/issues/77071>`_,; `#77411 <https://github.com/llvm/llvm-project/issues/77411>`_); - Fixed an issue when a shift count larger than ``__INT64_MAX__``, in a right; shift operation, could result in missing warnings about; ``shift count >= width of type`` or internal compiler error.; - Fixed an issue with computing the common type for the LHS and RHS of a `?:`; operator in C. No longer issuing a confusing diagnostic along the lines of; ""incompatible operand types ('foo' and 'foo')"" with extensions such as matrix; types. Fixes (`#69008 <https://github.com/llvm/llvm-project/issues/69008>`_); - Clang no longer permits using the `_BitInt` types as an underlying type for an; enumeration as specified in the C23 Standard.; Fixes (`#69619 <https://github.com/llvm/llvm-project/issues/69619>`_); - Fixed an issue when a shift count specified by a small constant ``_BitInt()``,; in a left shift operation, could result in a faulty warnings about; ``shift count >= width of type``.; - Clang now accepts anonymous members initialized with designated initializers; inside templates.; Fixes (`#65143 <https://github.com/llvm/llvm-project/issues/65143>`_); - Fix crash i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:38957,Availability,fault,faulty,38957,"-project/issues/68543>`_,; `#42496 <https://github.com/llvm/llvm-project/issues/42496>`_,; `#77071 <https://github.com/llvm/llvm-project/issues/77071>`_,; `#77411 <https://github.com/llvm/llvm-project/issues/77411>`_); - Fixed an issue when a shift count larger than ``__INT64_MAX__``, in a right; shift operation, could result in missing warnings about; ``shift count >= width of type`` or internal compiler error.; - Fixed an issue with computing the common type for the LHS and RHS of a `?:`; operator in C. No longer issuing a confusing diagnostic along the lines of; ""incompatible operand types ('foo' and 'foo')"" with extensions such as matrix; types. Fixes (`#69008 <https://github.com/llvm/llvm-project/issues/69008>`_); - Clang no longer permits using the `_BitInt` types as an underlying type for an; enumeration as specified in the C23 Standard.; Fixes (`#69619 <https://github.com/llvm/llvm-project/issues/69619>`_); - Fixed an issue when a shift count specified by a small constant ``_BitInt()``,; in a left shift operation, could result in a faulty warnings about; ``shift count >= width of type``.; - Clang now accepts anonymous members initialized with designated initializers; inside templates.; Fixes (`#65143 <https://github.com/llvm/llvm-project/issues/65143>`_); - Fix crash in formatting the real/imaginary part of a complex lvalue.; Fixes (`#69218 <https://github.com/llvm/llvm-project/issues/69218>`_); - No longer use C++ ``thread_local`` semantics in C23 when using; ``thread_local`` instead of ``_Thread_local``.; Fixes (`#70068 <https://github.com/llvm/llvm-project/issues/70068>`_) and; (`#69167 <https://github.com/llvm/llvm-project/issues/69167>`_); - Fix crash in evaluating invalid lambda expression which forget capture this.; Fixes (`#67687 <https://github.com/llvm/llvm-project/issues/67687>`_); - Fix crash from constexpr evaluator evaluating uninitialized arrays as rvalue.; Fixes (`#67317 <https://github.com/llvm/llvm-project/issues/67317>`_); - Clang now prope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:40287,Availability,error,error,40287,roject/issues/69218>`_); - No longer use C++ ``thread_local`` semantics in C23 when using; ``thread_local`` instead of ``_Thread_local``.; Fixes (`#70068 <https://github.com/llvm/llvm-project/issues/70068>`_) and; (`#69167 <https://github.com/llvm/llvm-project/issues/69167>`_); - Fix crash in evaluating invalid lambda expression which forget capture this.; Fixes (`#67687 <https://github.com/llvm/llvm-project/issues/67687>`_); - Fix crash from constexpr evaluator evaluating uninitialized arrays as rvalue.; Fixes (`#67317 <https://github.com/llvm/llvm-project/issues/67317>`_); - Clang now properly diagnoses use of stand-alone OpenMP directives after a; label (including ``case`` or ``default`` labels).; - Fix compiler memory leak for enums with underlying type larger than 64 bits.; Fixes (`#78311 <https://github.com/llvm/llvm-project/pull/78311>`_). Before:. .. code-block:: c++. label:; #pragma omp barrier // ok. After:. .. code-block:: c++. label:; #pragma omp barrier // error: '#pragma omp barrier' cannot be an immediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by cla,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41284,Availability,error,error,41284,mmediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.com/llvm/llvm-project/issues/18763>`_); - Fix crash due to incorrectly allowing conversion functi,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41851,Availability,error,error,41851,/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.com/llvm/llvm-project/issues/18763>`_); - Fix crash due to incorrectly allowing conversion functions in copy elision.; Fixes (`#39319 <https://github.com/llvm/llvm-project/issues/39319>`_) and; (`#60182 <https://github.com/llvm/llvm-project/issues/60182>`_) and; (`#62157 <https://github.com/llvm/llvm-project/issues/62157>`_) and; (`#64885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41954,Availability,error,error,41954,ch as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.com/llvm/llvm-project/issues/18763>`_); - Fix crash due to incorrectly allowing conversion functions in copy elision.; Fixes (`#39319 <https://github.com/llvm/llvm-project/issues/39319>`_) and; (`#60182 <https://github.com/llvm/llvm-project/issues/60182>`_) and; (`#62157 <https://github.com/llvm/llvm-project/issues/62157>`_) and; (`#64885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues/69987>`_); - Fix an issue where CTAD fails for explicit type conversion.; Fixes (`#64347 <https://g,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43349,Availability,failure,failure,43349,://github.com/llvm/llvm-project/issues/39319>`_) and; (`#60182 <https://github.com/llvm/llvm-project/issues/60182>`_) and; (`#62157 <https://github.com/llvm/llvm-project/issues/62157>`_) and; (`#64885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues/69987>`_); - Fix an issue where CTAD fails for explicit type conversion.; Fixes (`#64347 <https://github.com/llvm/llvm-project/issues/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issue,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43962,Availability,failure,failure,43962,es/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expr,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:44767,Availability,failure,failure,44767,"-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagno",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45547,Availability,failure,failure,45547,"hes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can capture this.; Fixes (`#71976 <https://github.com/llvm/llvm-project/issues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:47186,Availability,error,error,47186,"sues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified by `-fconstexpr-steps`.; (`#63562 <https://github.com/llvm/llvm-project/issues/63562>`_). - Fix a crash caused by some named unicode escape sequences designating; a Unicode character whose name contains a ``-``.; (Fixes `#64161 <https://github.com/llvm/llvm-project/issues/64161>`_). - Fix cases where we ignore ambiguous name lookup when looking up members.; (`#22413 <https://github.com/llvm/llvm-project/issues/22413>`_),; (`#29942 <https://github.com/llvm/llvm-project/issues/29942>`_),; (`#35574 <https://github.com/llvm/llvm-project/issues/35574>`_) and; (`#27224 <https://github.com/llvm/llvm-project/issues/27224>`_). - Clang emits an error on substitution failure within lambda body inside a; requires-expression. This fixes:; (`#64138 <https://github.com/llvm/llvm-project/issues/64138>`_) and; (`#71684 <https://github.com/llvm/llvm-project/issues/71684>`_). - Update ``FunctionDeclBitfields.NumFunctionDeclBits``. This fixes:; (`#64171 <https://github.com/llvm/llvm-project/issues/64171>`_). - Expressions producing ``nullptr`` are correctly evaluated; by the constant interpreter when appearing as the operand; of a binary comparison.; (`#64923 <https://github.com/llvm/llvm-project/issues/64923>`_). - Fix a crash when an immediate invocation is not a constant expression; and appear in an implicit cast.; (`#64949 <https://github.com/llvm/llvm-project/issues/64949>`_). - Fix crash when parsing ill-formed lambda trailing return type. Fixes:; (`#64962 <https://github.com/llvm/llvm-project/issues/64962>`_) and; (`#28679 <https://github.com/llvm/llvm-project/issues/28679>`_). - Fix a crash caused by substitution failure in expression requirements.; (`#64172",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:47208,Availability,failure,failure,47208,"sues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified by `-fconstexpr-steps`.; (`#63562 <https://github.com/llvm/llvm-project/issues/63562>`_). - Fix a crash caused by some named unicode escape sequences designating; a Unicode character whose name contains a ``-``.; (Fixes `#64161 <https://github.com/llvm/llvm-project/issues/64161>`_). - Fix cases where we ignore ambiguous name lookup when looking up members.; (`#22413 <https://github.com/llvm/llvm-project/issues/22413>`_),; (`#29942 <https://github.com/llvm/llvm-project/issues/29942>`_),; (`#35574 <https://github.com/llvm/llvm-project/issues/35574>`_) and; (`#27224 <https://github.com/llvm/llvm-project/issues/27224>`_). - Clang emits an error on substitution failure within lambda body inside a; requires-expression. This fixes:; (`#64138 <https://github.com/llvm/llvm-project/issues/64138>`_) and; (`#71684 <https://github.com/llvm/llvm-project/issues/71684>`_). - Update ``FunctionDeclBitfields.NumFunctionDeclBits``. This fixes:; (`#64171 <https://github.com/llvm/llvm-project/issues/64171>`_). - Expressions producing ``nullptr`` are correctly evaluated; by the constant interpreter when appearing as the operand; of a binary comparison.; (`#64923 <https://github.com/llvm/llvm-project/issues/64923>`_). - Fix a crash when an immediate invocation is not a constant expression; and appear in an implicit cast.; (`#64949 <https://github.com/llvm/llvm-project/issues/64949>`_). - Fix crash when parsing ill-formed lambda trailing return type. Fixes:; (`#64962 <https://github.com/llvm/llvm-project/issues/64962>`_) and; (`#28679 <https://github.com/llvm/llvm-project/issues/28679>`_). - Fix a crash caused by substitution failure in expression requirements.; (`#64172",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:48172,Availability,failure,failure,48172, Clang emits an error on substitution failure within lambda body inside a; requires-expression. This fixes:; (`#64138 <https://github.com/llvm/llvm-project/issues/64138>`_) and; (`#71684 <https://github.com/llvm/llvm-project/issues/71684>`_). - Update ``FunctionDeclBitfields.NumFunctionDeclBits``. This fixes:; (`#64171 <https://github.com/llvm/llvm-project/issues/64171>`_). - Expressions producing ``nullptr`` are correctly evaluated; by the constant interpreter when appearing as the operand; of a binary comparison.; (`#64923 <https://github.com/llvm/llvm-project/issues/64923>`_). - Fix a crash when an immediate invocation is not a constant expression; and appear in an implicit cast.; (`#64949 <https://github.com/llvm/llvm-project/issues/64949>`_). - Fix crash when parsing ill-formed lambda trailing return type. Fixes:; (`#64962 <https://github.com/llvm/llvm-project/issues/64962>`_) and; (`#28679 <https://github.com/llvm/llvm-project/issues/28679>`_). - Fix a crash caused by substitution failure in expression requirements.; (`#64172 <https://github.com/llvm/llvm-project/issues/64172>`_) and; (`#64723 <https://github.com/llvm/llvm-project/issues/64723>`_). - Fix crash when parsing the requires clause of some generic lambdas.; (`#64689 <https://github.com/llvm/llvm-project/issues/64689>`_). - Fix crash when the trailing return type of a generic and dependent; lambda refers to an init-capture.; (`#65067 <https://github.com/llvm/llvm-project/issues/65067>`_ and; `#63675 <https://github.com/llvm/llvm-project/issues/63675>`_). - Clang now properly handles out of line template specializations when there is; a non-template inner-class between the function and the class template.; (`#65810 <https://github.com/llvm/llvm-project/issues/65810>`_). - Fix a crash when calling a non-constant immediate function; in the initializer of a static data member.; (`#65985 <https://github.com/llvm/llvm-project/issues/65985>`_).; - Clang now properly converts static lambda call operator to fu,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:56313,Availability,failure,failure,56313,"re not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed an import failure of recursive friend class template.; `Issue 64169 <https://github.com/llvm/llvm-project/issues/64169>`_; - Remove unnecessary RecordLayout computation when importing UnaryOperator. The; computed RecordLayout is incorrect if fields are not completely imported and; should not be cached.; `Issue 64170 <https://github.com/llvm/llvm-project/issues/64170>`_; - Fixed ``hasAnyBase`` not binding nodes in its submatcher.; (`#65421 <https://github.com/llvm/llvm-project/issues/65421>`_); - Fixed a bug where RecursiveASTVisitor fails to visit the; initializer of a bitfield.; `Issue 64916 <https://github.com/llvm/llvm-project/issues/64916>`_; - Fixed a bug where range-loop-analysis checks for trivial copyability,; rather than trivial copy-constructibility; `Issue 47355 <https://github.com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:57549,Availability,recover,recover,57549,"etely imported and; should not be cached.; `Issue 64170 <https://github.com/llvm/llvm-project/issues/64170>`_; - Fixed ``hasAnyBase`` not binding nodes in its submatcher.; (`#65421 <https://github.com/llvm/llvm-project/issues/65421>`_); - Fixed a bug where RecursiveASTVisitor fails to visit the; initializer of a bitfield.; `Issue 64916 <https://github.com/llvm/llvm-project/issues/64916>`_; - Fixed a bug where range-loop-analysis checks for trivial copyability,; rather than trivial copy-constructibility; `Issue 47355 <https://github.com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is begin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:59739,Availability,mask,mask,59739,"ro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-reference (byref) in stead of pass-by-value (byval) for struct; arguments in C ABI. Callee is responsible for allocating stack memory and; copying the value of the struct if modified. Note that AMDGPU backend still; supports byval for struct arguments.; - The default value for ``-mcode-object-version`` is now 5.; See `AMDHSA Code Object V5 Metadata <https://llvm.org/docs/AMDGPUUsage.html#code-object-v5-metadata>`_; for more details. X86 Support; ^^^^^^^^^^^. - Added option ``-m[no-]evex512`` to disable ZMM and 64-bit mask instructions; for AVX512 features.; - Support ISA of ``USER_MSR``.; * Support intrinsic of ``_urdmsr``.; * Support intrinsic of ``_uwrmsr``.; - Support ISA of ``AVX10.1``.; - ``-march=pantherlake`` and ``-march=clearwaterforest`` are now supported.; - Added ABI handling for ``__float128`` to match with GCC.; - Emit warnings for options to enable knl/knm specific ISAs: AVX512PF, AVX512ER; and PREFETCHWT1. From next version (LLVM 19), these ISAs' intrinsic supports; will be deprecated:; * intrinsic series of *_exp2a23_*; * intrinsic series of *_rsqrt28_*; * intrinsic series of *_rcp28_*; * intrinsic series of *_prefetch_i[3|6][2|4]gather_*; * intrinsic series of *_prefetch_i[3|6][2|4]scatter_*. Arm and AArch64 Support; ^^^^^^^^^^^^^^^^^^^^^^^. - C++ function name mangling has been changed to align with the specification; (https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst).; This affects C++ functions with SVE ACLE parameters. Clang will use the old; man",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:62630,Availability,failure,failure,62630," target-specific runtime and standard libraries in directories named after the; target (e.g. if you're building with ``--target=aarch64-none-linux-android21``,; Clang will look for ``lib/aarch64-none-linux-android21`` under its resource; directory to find runtime libraries). If an exact match isn't found, Clang; would previously fall back to a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:62661,Availability,failure,failure,62661," target-specific runtime and standard libraries in directories named after the; target (e.g. if you're building with ``--target=aarch64-none-linux-android21``,; Clang will look for ``lib/aarch64-none-linux-android21`` under its resource; directory to find runtime libraries). If an exact match isn't found, Clang; would previously fall back to a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63085,Availability,error,error,63085,"o a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77696,Availability,avail,available,77696,"ules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:52,Deployability,release,release,52,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:308,Deployability,release,release,308,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:345,Deployability,release,releases,345,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:408,Deployability,release,releases,408,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:477,Deployability,release,release,477,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:576,Deployability,release,release,576,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:585,Deployability,release,release,585,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:697,Deployability,release,release,697,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:749,Deployability,release,release,749,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:853,Deployability,release,release,853,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:940,Deployability,release,releases,940,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:983,Deployability,release,releases,983,"===========================================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:1019,Deployability,release,releases,1019,"====================; Clang |release| |ReleaseNotesTitle|; ===========================================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:1115,Deployability,release,release,1115,"========================. .. contents::; :local:; :depth: 2. Written by the `LLVM Team <https://llvm.org/>`_. .. only:: PreRelease. .. warning::; These are in-progress notes for the upcoming Clang |version| release.; Release notes for previous releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:1370,Deployability,release,release,1370,"ious releases can be found on; `the Releases Page <https://llvm.org/releases/>`_. Introduction; ============. This document contains the release notes for the Clang C/C++/Objective-C; frontend, part of the LLVM Compiler Infrastructure, release |release|. Here we; describe the status of Clang in some detail, including major; improvements from the previous release and new feature work. For the; general LLVM release notes, see `the LLVM; documentation <https://llvm.org/docs/ReleaseNotes.html>`_. For the libc++ release notes,; see `this page <https://libcxx.llvm.org/ReleaseNotes.html>`_. All LLVM releases; may be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_. For more information about Clang or LLVM, including information about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2384,Deployability,install,install-dir,2384,"se for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes. Below is a complete; list of behavior changes. .. csv-table::; :header: Test, Old value, New value. ``__has_cpp_attribute(unused)``, 201603, 0; ``__has_cpp_attribute(gnu::unused)``, 201603, 1; ``__has_c_attribute(unused)``, 202106, 0; ``__has_cpp_attribute(clang::fallthrough)``, 201603, 1; ``__has_cpp_attribute(gn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2426,Deployability,configurat,configuration,2426,"se for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes. Below is a complete; list of behavior changes. .. csv-table::; :header: Test, Old value, New value. ``__has_cpp_attribute(unused)``, 201603, 0; ``__has_cpp_attribute(gnu::unused)``, 201603, 1; ``__has_c_attribute(unused)``, 202106, 0; ``__has_cpp_attribute(clang::fallthrough)``, 201603, 1; ``__has_cpp_attribute(gn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2492,Deployability,configurat,configuration-files,2492,"rs.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes. Below is a complete; list of behavior changes. .. csv-table::; :header: Test, Old value, New value. ``__has_cpp_attribute(unused)``, 201603, 0; ``__has_cpp_attribute(gnu::unused)``, 201603, 1; ``__has_c_attribute(unused)``, 202106, 0; ``__has_cpp_attribute(clang::fallthrough)``, 201603, 1; ``__has_cpp_attribute(gnu::fallthrough)``, 201603, 1; ``__has_c_attribute(gnu::fallthrough)``, 201910, 1; ``__has_cpp_at",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:5941,Deployability,release,release,5941," template parameter list. This fixes a number of issues where valid programs would be rejected due to; mangling collisions, or would in some cases be silently miscompiled. Clang; will use the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit function template specializations now use; `DependentFunctionTemplateSpecializationInfo` to store candidate primary; templates and explicit template arguments. This should not impact users of; Clang as a compiler, but it may break assumptions in Clang-based tools; iterating over the AST. - The warning `-Wenum-constexpr-conversion` is now also enabled by default on; system headers and macros. It will be turned into a hard (non-downgradable); error in the next Clang release. - The flag `-fdelayed-template-parsing` won't be enabled by default with C++20; when targetting MSVC to match the behavior of MSVC.; (`MSVC Docs <https://learn.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170>`_). - Remove the hardcoded path to the imported modules for C++20 named modules. Now we; require all the dependent modules to specified from the command line.; See (`#62707 <https://github.com/llvm/llvm-project/issues/62707>`_). - Forbid `import XXX;` in C++ to find module `XXX` comes from explicit clang modules.; See (`#64755 <https://github.com/llvm/llvm-project/issues/64755>`_). ABI Changes in This Version; ---------------------------; - Following the SystemV ABI for x86-64, ``__int128`` arguments will no longer; be split between a register and a stack slot. - Fixed Microsoft calling convention for returning certain classes with a; templated constructor. If a class has a templated constructor, it s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:8389,Deployability,release,release,8389,"-block:: json. ""type"": {; ""qualType"": ""foo"",; ""desugaredQualType"": ""foo""; }. which will now be dumped as just:. .. code-block:: json. ""type"": {; ""qualType"": ""foo""; }. Clang Frontend Potentially Breaking Changes; -------------------------------------------; - Target OS macros extension; A new Clang extension (see :ref:`here <target_os_detail>`) is enabled for; Darwin (Apple platform) targets. Clang now defines ``TARGET_OS_*`` macros for; these targets, which could break existing code bases with improper checks for; the ``TARGET_OS_`` macros. For example, existing checks might fail to include; the ``TargetConditionals.h`` header from Apple SDKs and therefore leaving the; macros undefined and guarded code unexercised. Affected code should be checked to see if it's still intended for the specific; target and fixed accordingly. The extension can be turned off by the option ``-fno-define-target-os-macros``; as a workaround. What's New in Clang |release|?; ==============================; Some of the major new features and improvements to Clang are listed; here. Generic improvements to Clang as a whole or to its underlying; infrastructure are described first, followed by language-specific; sections with improvements to Clang's support for those languages. C++ Language Changes; --------------------. C++20 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P1907R1 <https://wg21.link/P1907R1>`_ which extends allowed non-type template argument; kinds with e.g. floating point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:9068,Deployability,update,updated,9068,"etConditionals.h`` header from Apple SDKs and therefore leaving the; macros undefined and guarded code unexercised. Affected code should be checked to see if it's still intended for the specific; target and fixed accordingly. The extension can be turned off by the option ``-fno-define-target-os-macros``; as a workaround. What's New in Clang |release|?; ==============================; Some of the major new features and improvements to Clang are listed; here. Generic improvements to Clang as a whole or to its underlying; infrastructure are described first, followed by language-specific; sections with improvements to Clang's support for those languages. C++ Language Changes; --------------------. C++20 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P1907R1 <https://wg21.link/P1907R1>`_ which extends allowed non-type template argument; kinds with e.g. floating point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:13949,Deployability,release,release,13949,"equires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now we've implemented allowing a label to be followed by a declaration; instead of a statement.; - Implemented; `N2940 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2940.pdf>`_ which; removes support for trigraphs in C23 and later. In earlier language modes,; trigraphs remain enabled by default in conforming modes (e.g. ``-std=c17``); and disabled by default in GNU and Microsoft modes (e.g., ``-std=gnu17`` or; ``-fms-compatibility``). If needed, you can enable trigraphs by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM NEON's vector types; (e.g., ``uint16x8_t``), this returns the constant number of elements at compile-time.; For scalable vectors, e.g., SVE or RISC-V V, the number of elements is not known at compile-time and is; determined at runtime.; * The ``__datasizeof`` keyword has been added. It is similar to ``sizeof``; except that it returns the size of a type ignoring tail padding.; * ``__builtin_classify_type()`` now classifies ``_BitInt`` values as the return value ``18``; and vector types as return value ``19``, to match GCC 14's behavior.; * The default value of `_MSC_VER` was raised from 1920 to 1933.; * Since MSVC 19.33 added undocumented attribute ``[[msvc::constexpr]]``, this release adds the attribute as well. * Added ``#pragma clang fp re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:14892,Deployability,release,release,14892,"by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM NEON's vector types; (e.g., ``uint16x8_t``), this returns the constant number of elements at compile-time.; For scalable vectors, e.g., SVE or RISC-V V, the number of elements is not known at compile-time and is; determined at runtime.; * The ``__datasizeof`` keyword has been added. It is similar to ``sizeof``; except that it returns the size of a type ignoring tail padding.; * ``__builtin_classify_type()`` now classifies ``_BitInt`` values as the return value ``18``; and vector types as return value ``19``, to match GCC 14's behavior.; * The default value of `_MSC_VER` was raised from 1920 to 1933.; * Since MSVC 19.33 added undocumented attribute ``[[msvc::constexpr]]``, this release adds the attribute as well. * Added ``#pragma clang fp reciprocal``. * The version of Unicode used by Clang (primarily to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:15050,Deployability,update,updated,15050," now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM NEON's vector types; (e.g., ``uint16x8_t``), this returns the constant number of elements at compile-time.; For scalable vectors, e.g., SVE or RISC-V V, the number of elements is not known at compile-time and is; determined at runtime.; * The ``__datasizeof`` keyword has been added. It is similar to ``sizeof``; except that it returns the size of a type ignoring tail padding.; * ``__builtin_classify_type()`` now classifies ``_BitInt`` values as the return value ``18``; and vector types as return value ``19``, to match GCC 14's behavior.; * The default value of `_MSC_VER` was raised from 1920 to 1933.; * Since MSVC 19.33 added undocumented attribute ``[[msvc::constexpr]]``, this release adds the attribute as well. * Added ``#pragma clang fp reciprocal``. * The version of Unicode used by Clang (primarily to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directives for ""system"" headers instead of copying; the preprocessed text to the output. This can greatly reduce the size of the; preprocessed ou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:18996,Deployability,release,release,18996,"g extension to; provide built-in definitions of a list of ``TARGET_OS_*`` macros based on the; target triple. The extension is enabled by default for Darwin (Apple platform) targets. Deprecated Compiler Flags; -------------------------. Modified Compiler Flags; -----------------------. * ``-Woverriding-t-option`` is renamed to ``-Woverriding-option``.; * ``-Winterrupt-service-routine`` is renamed to ``-Wexcessive-regsave`` as a generalization; * ``-frewrite-includes`` now guards the original #include directives with; ``__CLANG_REWRITTEN_INCLUDES``, and ``__CLANG_REWRITTEN_SYSTEM_INCLUDES`` as; appropriate.; * Introducing a new default calling convention for ``-fdefault-calling-conv``:; ``rtdcall``. This new default CC only works for M68k and will use the new; ``m68k_rtdcc`` CC on every functions that are not variadic. The ``-mrtd``; driver/frontend flag has the same effect when targeting M68k.; * ``-fvisibility-global-new-delete-hidden`` is now a deprecated spelling of; ``-fvisibility-global-new-delete=force-hidden`` (``-fvisibility-global-new-delete=``; is new in this release).; * ``-fprofile-update`` is enabled for ``-fprofile-generate``. Removed Compiler Flags; -------------------------. * ``-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang`` has been removed.; It has not been needed to enable ``-ftrivial-auto-var-init=zero`` since Clang 16. Attribute Changes in Clang; --------------------------; - On X86, a warning is now emitted if a function with ``__attribute__((no_caller_saved_registers))``; calls a function without ``__attribute__((no_caller_saved_registers))``, and is not compiled with; ``-mgeneral-regs-only``; - On X86, a function with ``__attribute__((interrupt))`` can now call a function without; ``__attribute__((no_caller_saved_registers))`` provided that it is compiled with ``-mgeneral-regs-only``. - When a non-variadic function is decorated with the ``format`` attribute,; Clang now checks that the format string would match the f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:19021,Deployability,update,update,19021," enabled by default for Darwin (Apple platform) targets. Deprecated Compiler Flags; -------------------------. Modified Compiler Flags; -----------------------. * ``-Woverriding-t-option`` is renamed to ``-Woverriding-option``.; * ``-Winterrupt-service-routine`` is renamed to ``-Wexcessive-regsave`` as a generalization; * ``-frewrite-includes`` now guards the original #include directives with; ``__CLANG_REWRITTEN_INCLUDES``, and ``__CLANG_REWRITTEN_SYSTEM_INCLUDES`` as; appropriate.; * Introducing a new default calling convention for ``-fdefault-calling-conv``:; ``rtdcall``. This new default CC only works for M68k and will use the new; ``m68k_rtdcc`` CC on every functions that are not variadic. The ``-mrtd``; driver/frontend flag has the same effect when targeting M68k.; * ``-fvisibility-global-new-delete-hidden`` is now a deprecated spelling of; ``-fvisibility-global-new-delete=force-hidden`` (``-fvisibility-global-new-delete=``; is new in this release).; * ``-fprofile-update`` is enabled for ``-fprofile-generate``. Removed Compiler Flags; -------------------------. * ``-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang`` has been removed.; It has not been needed to enable ``-ftrivial-auto-var-init=zero`` since Clang 16. Attribute Changes in Clang; --------------------------; - On X86, a warning is now emitted if a function with ``__attribute__((no_caller_saved_registers))``; calls a function without ``__attribute__((no_caller_saved_registers))``, and is not compiled with; ``-mgeneral-regs-only``; - On X86, a function with ``__attribute__((interrupt))`` can now call a function without; ``__attribute__((no_caller_saved_registers))`` provided that it is compiled with ``-mgeneral-regs-only``. - When a non-variadic function is decorated with the ``format`` attribute,; Clang now checks that the format string would match the function's parameters'; types after default argument promotion. As a result, it's no longer an; automatic diagnostic to use par",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:58795,Deployability,update,update,58795,"om/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albeit incomplete changes. The ``_OPENACC`` macro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-reference (byref) in stead of pass-by-value (byval) for struct; arguments in C ABI. Callee is responsible for allocating stack memory and; copying the value of the struct if modified. Note that AMDGPU backend still; supports byval for struct arguments.; - The default value for ``-mcode-object-version`` is now 5.; See `AMDHSA Code Object V5 Metadata <https://llvm.org/docs/AMDGPUUsage.html#code-object-v5-metadata>`_; for more details. X86 Support; ^^^^^^^^^^^. - Added option ``-m[no-]evex512`` to disable ZMM and 64-bit mask instructions; for AVX512 f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:64238,Deployability,toggle,toggled,64238,"se issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introdu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70449,Deployability,configurat,configuration,70449,"behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary object fields.; (`#66221 <https://github.com/llvm/llvm-project/issues/66221>`_). - A few crashes have been found and fixed using randomized testing related; to the use of ``_BitInt()`` in tidy checks and in clang analysis.; (`#67212 <https://github.com/llvm/llvm-project/pull/67212>`_,; `#66782 <https://github.com/llvm/llvm-project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-proj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:75602,Deployability,configurat,configuration,75602," Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https://github.com/llvm/llvm-project/pull/74296>`_,; `#73335 <https://github.com/llvm/llvm-project/pull/73335>`_,; `#72627 <https://github.com/llvm/llvm-project/pull/72627>`_,; `#71518 <https://github.com/llvm/llvm-project/pull/71518>`_,; `#72016 <https://github.com/llvm/llvm-project/pull/72016>`_,; `#70540 <https://github.com/llvm/llvm-project/pull/70540>`_,; `#73638 <https://github.com/llvm/llvm-project/pull/73638>`_,; `#77331 <https://github.com/llvm/llvm-project/pull/77331>`_). - The ``alpha.security.taint.TaintPropagation`` checker no longer propagates; taint on ``strlen`` and ``strnlen`` calls, unless these are marked; explicitly propagators in the user-provided taint configuration file.; This removal empirically reduces the number of false positive reports.; Read the PR for the details.; (`#66086 <https://github.com/llvm/llvm-project/pull/66086>`_). - Other taint-related improvements.; (`#66358 <https://github.com/llvm/llvm-project/pull/66358>`_,; `#66074 <https://github.com/llvm/llvm-project/pull/66074>`_,; `#66358 <https://github.com/llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77940,Deployability,release,release,77940,"ules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2027,Energy Efficiency,reduce,reduce,2027," about the; latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the; `LLVM Web Site <https://llvm.org>`_. Potentially Breaking Changes; ============================; These changes are ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:15977,Energy Efficiency,reduce,reduce,15977," to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directives for ""system"" headers instead of copying; the preprocessed text to the output. This can greatly reduce the size of the; preprocessed output, which can be helpful when trying to reduce a test case.; * ``-fassume-nothrow-exception-dtor`` is added to assume that the destructor of; a thrown exception object will not throw. The generated code for catch; handlers will be smaller. A throw expression of a type with a; potentially-throwing destructor will lead to an error. * ``-fopenacc`` was added as a part of the effort to support OpenACC in Clang. * ``-fcx-limited-range`` enables the naive mathematical formulas for complex; division and multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by ``-ffast-math``. * ``-fcx-fortran-rules`` enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun. ACM 5, 8; (1962). The default is ``-fno-cx-fortran-rules``. * ``-fvisibility-global-new-delete=<value>`` gives more freedom to users to; cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:16058,Energy Efficiency,reduce,reduce,16058," to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directives for ""system"" headers instead of copying; the preprocessed text to the output. This can greatly reduce the size of the; preprocessed output, which can be helpful when trying to reduce a test case.; * ``-fassume-nothrow-exception-dtor`` is added to assume that the destructor of; a thrown exception object will not throw. The generated code for catch; handlers will be smaller. A throw expression of a type with a; potentially-throwing destructor will lead to an error. * ``-fopenacc`` was added as a part of the effort to support OpenACC in Clang. * ``-fcx-limited-range`` enables the naive mathematical formulas for complex; division and multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by ``-ffast-math``. * ``-fcx-fortran-rules`` enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun. ACM 5, 8; (1962). The default is ``-fno-cx-fortran-rules``. * ``-fvisibility-global-new-delete=<value>`` gives more freedom to users to; cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:21280,Energy Efficiency,reduce,reduce,21280,"ibute; which can be applied to a bit-field. This attribute helps to map a bit-field; back to a particular type that may be better-suited to representing the bit-; field but cannot be used for other reasons and will impact the debug; information generated for the bit-field. This is most useful when mapping a; bit-field of basic integer type back to a ``bool`` or an enumeration type,; e.g.,. .. code-block:: c++. enum E { Apple, Orange, Pear };; struct S {; [[clang::preferred_type(E)]] unsigned FruitKind : 2;; };. When viewing ``S::FruitKind`` in a debugger, it will behave as if the member; was declared as type ``E`` rather than ``unsigned``. - Clang now warns you that the ``_Alignas`` attribute on declaration specifiers; is ignored, changed from the former incorrect suggestion to move it past; declaration specifiers. (`#58637 <https://github.com/llvm/llvm-project/issues/58637>`_). - Clang now introduced ``[[clang::coro_only_destroy_when_complete]]`` attribute; to reduce the size of the destroy functions for coroutines which are known to; be destroyed after having reached the final suspend point. - Clang now introduced ``[[clang::coro_return_type]]`` and ``[[clang::coro_wrapper]]``; attributes. A function returning a type marked with ``[[clang::coro_return_type]]``; should be a coroutine. A non-coroutine function marked with ``[[clang::coro_wrapper]]``; is still allowed to return the such a type. This is helpful for analyzers to recognize coroutines from the function signatures. - Clang now supports ``[[clang::code_align(N)]]`` as an attribute which can be; applied to a loop and specifies the byte alignment for a loop. This attribute; accepts a positive integer constant initialization expression indicating the; number of bytes for the minimum alignment boundary. Its value must be a power; of 2, between 1 and 4096(inclusive). .. code-block:: c++. void Array(int *array, size_t n) {; [[clang::code_align(64)]] for (int i = 0; i < n; ++i) array[i] = 0;; }. template<int A>; v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:22114,Energy Efficiency,power,power,22114,"iers. (`#58637 <https://github.com/llvm/llvm-project/issues/58637>`_). - Clang now introduced ``[[clang::coro_only_destroy_when_complete]]`` attribute; to reduce the size of the destroy functions for coroutines which are known to; be destroyed after having reached the final suspend point. - Clang now introduced ``[[clang::coro_return_type]]`` and ``[[clang::coro_wrapper]]``; attributes. A function returning a type marked with ``[[clang::coro_return_type]]``; should be a coroutine. A non-coroutine function marked with ``[[clang::coro_wrapper]]``; is still allowed to return the such a type. This is helpful for analyzers to recognize coroutines from the function signatures. - Clang now supports ``[[clang::code_align(N)]]`` as an attribute which can be; applied to a loop and specifies the byte alignment for a loop. This attribute; accepts a positive integer constant initialization expression indicating the; number of bytes for the minimum alignment boundary. Its value must be a power; of 2, between 1 and 4096(inclusive). .. code-block:: c++. void Array(int *array, size_t n) {; [[clang::code_align(64)]] for (int i = 0; i < n; ++i) array[i] = 0;; }. template<int A>; void func() {; [[clang::code_align(A)]] for(;;) { }; }. - Clang now introduced ``[[clang::coro_lifetimebound]]`` attribute.; All parameters of a function are considered to be lifetime bound if the function; returns a type annotated with ``[[clang::coro_lifetimebound]]`` and ``[[clang::coro_return_type]]``.; This analysis can be disabled for a function by annotating the function with ``[[clang::coro_disable_lifetimebound]]``. Improvements to Clang's diagnostics; -----------------------------------; - Clang constexpr evaluator now prints template arguments when displaying; template-specialization function calls.; - Clang contexpr evaluator now displays notes as well as an error when a constructor; of a base class is not called in the constructor of its derived class.; - Clang no longer emits ``-Wmissing-variable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63038,Energy Efficiency,efficient,efficient,63038,"o a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:75648,Energy Efficiency,reduce,reduces,75648,"`ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https://github.com/llvm/llvm-project/pull/74296>`_,; `#73335 <https://github.com/llvm/llvm-project/pull/73335>`_,; `#72627 <https://github.com/llvm/llvm-project/pull/72627>`_,; `#71518 <https://github.com/llvm/llvm-project/pull/71518>`_,; `#72016 <https://github.com/llvm/llvm-project/pull/72016>`_,; `#70540 <https://github.com/llvm/llvm-project/pull/70540>`_,; `#73638 <https://github.com/llvm/llvm-project/pull/73638>`_,; `#77331 <https://github.com/llvm/llvm-project/pull/77331>`_). - The ``alpha.security.taint.TaintPropagation`` checker no longer propagates; taint on ``strlen`` and ``strnlen`` calls, unless these are marked; explicitly propagators in the user-provided taint configuration file.; This removal empirically reduces the number of false positive reports.; Read the PR for the details.; (`#66086 <https://github.com/llvm/llvm-project/pull/66086>`_). - Other taint-related improvements.; (`#66358 <https://github.com/llvm/llvm-project/pull/66358>`_,; `#66074 <https://github.com/llvm/llvm-project/pull/66074>`_,; `#66358 <https://github.com/llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Docume",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:4459,Integrability,depend,depends,4459,"gh)``, 201910, 1; ``__has_cpp_attribute(warn_unused_result)``, 201907, 0; ``__has_cpp_attribute(clang::warn_unused_result)``, 201907, 1; ``__has_cpp_attribute(gnu::warn_unused_result)``, 201907, 1; ``__has_c_attribute(warn_unused_result)``, 202003, 0; ``__has_c_attribute(gnu::warn_unused_result)``, 202003, 1. - Fixed a bug in finding matching `operator!=` while adding reversed `operator==` as; outlined in ""The Equality Operator You Are Looking For"" (`P2468 <http://wg21.link/p2468r2>`_).; Fixes (`#68901 <https://github.com/llvm/llvm-project/issues/68901>`_). C++ Specific Potentially Breaking Changes; -----------------------------------------; - The name mangling rules for function templates has been changed to take into; account the possibility that functions could be overloaded on their template; parameter lists or requires-clauses. This causes mangled names to change for; function templates in the following cases:. - When a template parameter in a function template depends on a previous; template parameter, such as ``template<typename T, T V> void f()``.; - When the function has any constraints, whether from constrained template; parameters or requires-clauses.; - When the template parameter list includes a deduced type -- either; ``auto``, ``decltype(auto)``, or a deduced class template specialization; type.; - When a template template parameter is given a template template argument; that has a different template parameter list. This fixes a number of issues where valid programs would be rejected due to; mangling collisions, or would in some cases be silently miscompiled. Clang; will use the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit functi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:6303,Integrability,depend,dependent,6303,"s://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit function template specializations now use; `DependentFunctionTemplateSpecializationInfo` to store candidate primary; templates and explicit template arguments. This should not impact users of; Clang as a compiler, but it may break assumptions in Clang-based tools; iterating over the AST. - The warning `-Wenum-constexpr-conversion` is now also enabled by default on; system headers and macros. It will be turned into a hard (non-downgradable); error in the next Clang release. - The flag `-fdelayed-template-parsing` won't be enabled by default with C++20; when targetting MSVC to match the behavior of MSVC.; (`MSVC Docs <https://learn.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170>`_). - Remove the hardcoded path to the imported modules for C++20 named modules. Now we; require all the dependent modules to specified from the command line.; See (`#62707 <https://github.com/llvm/llvm-project/issues/62707>`_). - Forbid `import XXX;` in C++ to find module `XXX` comes from explicit clang modules.; See (`#64755 <https://github.com/llvm/llvm-project/issues/64755>`_). ABI Changes in This Version; ---------------------------; - Following the SystemV ABI for x86-64, ``__int128`` arguments will no longer; be split between a register and a stack slot. - Fixed Microsoft calling convention for returning certain classes with a; templated constructor. If a class has a templated constructor, it should; be returned indirectly even if it meets all the other requirements for; returning a class in a register. This affects some uses of std::pair.; (#GH86384). AST Dumping Potentially Breaking Changes; ----------------------------------------; - When dumping a sugared type, Clang will no longer print the desugared type if; its textual representation is the same as the sugared one. This applies to; both t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:18289,Integrability,rout,routine,18289,"of ``source`` implies that no implicit attribute is added. Without the; attribute the replaceable global new and delete operators behave normally; (like other functions) with respect to visibility attributes, pragmas and; options (e.g ``--fvisibility=``).; * Full register names can be used when printing assembly via ``-mregnames``.; This option now matches the one used by GCC. .. _target_os_detail:. * ``-fdefine-target-os-macros`` and its complement; ``-fno-define-target-os-macros``. Enables or disables the Clang extension to; provide built-in definitions of a list of ``TARGET_OS_*`` macros based on the; target triple. The extension is enabled by default for Darwin (Apple platform) targets. Deprecated Compiler Flags; -------------------------. Modified Compiler Flags; -----------------------. * ``-Woverriding-t-option`` is renamed to ``-Woverriding-option``.; * ``-Winterrupt-service-routine`` is renamed to ``-Wexcessive-regsave`` as a generalization; * ``-frewrite-includes`` now guards the original #include directives with; ``__CLANG_REWRITTEN_INCLUDES``, and ``__CLANG_REWRITTEN_SYSTEM_INCLUDES`` as; appropriate.; * Introducing a new default calling convention for ``-fdefault-calling-conv``:; ``rtdcall``. This new default CC only works for M68k and will use the new; ``m68k_rtdcc`` CC on every functions that are not variadic. The ``-mrtd``; driver/frontend flag has the same effect when targeting M68k.; * ``-fvisibility-global-new-delete-hidden`` is now a deprecated spelling of; ``-fvisibility-global-new-delete=force-hidden`` (``-fvisibility-global-new-delete=``; is new in this release).; * ``-fprofile-update`` is enabled for ``-fprofile-generate``. Removed Compiler Flags; -------------------------. * ``-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang`` has been removed.; It has not been needed to enable ``-ftrivial-auto-var-init=zero`` since Clang 16. Attribute Changes in Clang; --------------------------; - On X86, a warning is now emitted if",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:31123,Integrability,depend,depends,31123,"ions of friend function specializations, e.g. ``friend void f<>(int) {}``.; - Clang now diagnoses narrowing conversions involving const references.; (`#63151 <https://github.com/llvm/llvm-project/issues/63151>`_).; - Clang now diagnoses unexpanded packs within the template argument lists of function template specializations.; - The warning `-Wnan-infinity-disabled` is now emitted when ``INFINITY``; or ``NAN`` are used in arithmetic operations or function arguments in; floating-point mode where ``INFINITY`` or ``NAN`` don't have the expected; values. - Clang now diagnoses attempts to bind a bitfield to an NTTP of a reference type as erroneous; converted constant expression and not as a reference to subobject.; - Clang now diagnoses ``auto`` and ``decltype(auto)`` in declarations of conversion function template; (`CWG1878 <https://cplusplus.github.io/CWG/issues/1878.html>`_); - Clang now diagnoses the requirement that non-template friend declarations with requires clauses; and template friend declarations with a constraint that depends on a template parameter from an; enclosing template must be a definition.; - Clang now diagnoses incorrect usage of ``const`` and ``pure`` attributes, so ``-Wignored-attributes`` diagnoses more cases.; - Clang now emits more descriptive diagnostics for 'unusual' expressions (e.g. incomplete index; expressions on matrix types or builtin functions without an argument list) as placement-args; to new-expressions. Before:. .. code-block:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32420,Integrability,message,message,32420,"lete index; expressions on matrix types or builtin functions without an argument list) as placement-args; to new-expressions. Before:. .. code-block:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:34440,Integrability,message,messages,34440,"sing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm-project/issues/37257>`_); - Clang's ``-Wunused-private-field`` no longer warns on fields whose type is; declared with ``[[maybe_unused]]``.; (`#61334 <https://github.com/llvm/llvm-project/issues/61334>`_); - For function multi-versioning using the ``target``, ``target_clones``, or; ``target_version`` attributes, remove comdat for internal linkage functions.; (`#65114 <https://github.com/llvm/ll",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:36702,Integrability,depend,dependent-expr,36702,ned macro expressions in constant expressions and in; local structs.; - Correctly parse non-ascii identifiers that appear immediately after a line splicing; (`#65156 <https://github.com/llvm/llvm-project/issues/65156>`_); - Clang no longer considers the loss of ``__unaligned`` qualifier from objects as; an invalid conversion during method function overload resolution.; - Fix lack of comparison of declRefExpr in ASTStructuralEquivalence; (`#66047 <https://github.com/llvm/llvm-project/issues/66047>`_); - Fix parser crash when dealing with ill-formed objective C++ header code. Fixes; (`#64836 <https://github.com/llvm/llvm-project/issues/64836>`_); - Fix crash in implicit conversions from initialize list to arrays of unknown; bound for C++20. Fixes; (`#62945 <https://github.com/llvm/llvm-project/issues/62945>`_); - Clang now allows an ``_Atomic`` qualified integer in a switch statement. Fixes; (`#65557 <https://github.com/llvm/llvm-project/issues/65557>`_); - Fixes crash when trying to obtain the common sugared type of; `decltype(instantiation-dependent-expr)`.; Fixes (`#67603 <https://github.com/llvm/llvm-project/issues/67603>`_); - Fixes a crash caused by a multidimensional array being captured by a lambda; (`#67722 <https://github.com/llvm/llvm-project/issues/67722>`_).; - Fixes a crash when instantiating a lambda with requires clause.; (`#64462 <https://github.com/llvm/llvm-project/issues/64462>`_); - Fixes a regression where the ``UserDefinedLiteral`` was not properly preserved; while evaluating consteval functions. (`#63898 <https://github.com/llvm/llvm-project/issues/63898>`_).; - Fix a crash when evaluating value-dependent structured binding; variables at compile time.; Fixes (`#67690 <https://github.com/llvm/llvm-project/issues/67690>`_); - Fixes a ``clang-17`` regression where ``LLVM_UNREACHABLE_OPTIMIZE=OFF``; cannot be used with ``Release`` mode builds. (`#68237 <https://github.com/llvm/llvm-project/issues/68237>`_).; - Fix crash in evaluating ``constexpr`` v,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:37291,Integrability,depend,dependent,37291," Fix crash in implicit conversions from initialize list to arrays of unknown; bound for C++20. Fixes; (`#62945 <https://github.com/llvm/llvm-project/issues/62945>`_); - Clang now allows an ``_Atomic`` qualified integer in a switch statement. Fixes; (`#65557 <https://github.com/llvm/llvm-project/issues/65557>`_); - Fixes crash when trying to obtain the common sugared type of; `decltype(instantiation-dependent-expr)`.; Fixes (`#67603 <https://github.com/llvm/llvm-project/issues/67603>`_); - Fixes a crash caused by a multidimensional array being captured by a lambda; (`#67722 <https://github.com/llvm/llvm-project/issues/67722>`_).; - Fixes a crash when instantiating a lambda with requires clause.; (`#64462 <https://github.com/llvm/llvm-project/issues/64462>`_); - Fixes a regression where the ``UserDefinedLiteral`` was not properly preserved; while evaluating consteval functions. (`#63898 <https://github.com/llvm/llvm-project/issues/63898>`_).; - Fix a crash when evaluating value-dependent structured binding; variables at compile time.; Fixes (`#67690 <https://github.com/llvm/llvm-project/issues/67690>`_); - Fixes a ``clang-17`` regression where ``LLVM_UNREACHABLE_OPTIMIZE=OFF``; cannot be used with ``Release`` mode builds. (`#68237 <https://github.com/llvm/llvm-project/issues/68237>`_).; - Fix crash in evaluating ``constexpr`` value for invalid template function.; Fixes (`#68542 <https://github.com/llvm/llvm-project/issues/68542>`_); - Clang will correctly evaluate ``noexcept`` expression for template functions; of template classes. Fixes; (`#68543 <https://github.com/llvm/llvm-project/issues/68543>`_,; `#42496 <https://github.com/llvm/llvm-project/issues/42496>`_,; `#77071 <https://github.com/llvm/llvm-project/issues/77071>`_,; `#77411 <https://github.com/llvm/llvm-project/issues/77411>`_); - Fixed an issue when a shift count larger than ``__INT64_MAX__``, in a right; shift operation, could result in missing warnings about; ``shift count >= width of type`` or internal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41140,Integrability,message,message,41140,llvm/llvm-project/pull/78311>`_). Before:. .. code-block:: c++. label:; #pragma omp barrier // ok. After:. .. code-block:: c++. label:; #pragma omp barrier // error: '#pragma omp barrier' cannot be an immediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts``,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41251,Integrability,message,message,41251,. code-block:: c++. label:; #pragma omp barrier // error: '#pragma omp barrier' cannot be an immediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.co,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41386,Integrability,depend,dependent,41386,mmediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.com/llvm/llvm-project/issues/18763>`_); - Fix crash due to incorrectly allowing conversion functi,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43205,Integrability,depend,dependent,43205,tants.; Fixes (`#18763 <https://github.com/llvm/llvm-project/issues/18763>`_); - Fix crash due to incorrectly allowing conversion functions in copy elision.; Fixes (`#39319 <https://github.com/llvm/llvm-project/issues/39319>`_) and; (`#60182 <https://github.com/llvm/llvm-project/issues/60182>`_) and; (`#62157 <https://github.com/llvm/llvm-project/issues/62157>`_) and; (`#64885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues/69987>`_); - Fix an issue where CTAD fails for explicit type conversion.; Fixes (`#64347 <https://github.com/llvm/llvm-project/issues/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - ,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:48538,Integrability,depend,dependent,48538,ssues/64171>`_). - Expressions producing ``nullptr`` are correctly evaluated; by the constant interpreter when appearing as the operand; of a binary comparison.; (`#64923 <https://github.com/llvm/llvm-project/issues/64923>`_). - Fix a crash when an immediate invocation is not a constant expression; and appear in an implicit cast.; (`#64949 <https://github.com/llvm/llvm-project/issues/64949>`_). - Fix crash when parsing ill-formed lambda trailing return type. Fixes:; (`#64962 <https://github.com/llvm/llvm-project/issues/64962>`_) and; (`#28679 <https://github.com/llvm/llvm-project/issues/28679>`_). - Fix a crash caused by substitution failure in expression requirements.; (`#64172 <https://github.com/llvm/llvm-project/issues/64172>`_) and; (`#64723 <https://github.com/llvm/llvm-project/issues/64723>`_). - Fix crash when parsing the requires clause of some generic lambdas.; (`#64689 <https://github.com/llvm/llvm-project/issues/64689>`_). - Fix crash when the trailing return type of a generic and dependent; lambda refers to an init-capture.; (`#65067 <https://github.com/llvm/llvm-project/issues/65067>`_ and; `#63675 <https://github.com/llvm/llvm-project/issues/63675>`_). - Clang now properly handles out of line template specializations when there is; a non-template inner-class between the function and the class template.; (`#65810 <https://github.com/llvm/llvm-project/issues/65810>`_). - Fix a crash when calling a non-constant immediate function; in the initializer of a static data member.; (`#65985 <https://github.com/llvm/llvm-project/issues/65985>`_).; - Clang now properly converts static lambda call operator to function; pointers on win32.; (`#62594 <https://github.com/llvm/llvm-project/issues/62594>`_). - Fixed some cases where the source location for an instantiated specialization; of a function template or a member function of a class template was assigned; the location of a non-defining declaration rather than the location of the; definition the specialization w,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51639,Integrability,depend,dependence,51639," to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:55314,Integrability,inject,injected,55314,ject/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:67651,Integrability,depend,dependentSizedExtVectorType,67651," for floating point types only.; - Add ``__builtin_elementwise_bitreverse`` builtin for integer types only.; - Add ``__builtin_elementwise_sqrt`` builtin for floating point types only.; - ``__builtin_isfpclass`` builtin now supports vector types.; - ``#pragma float_control(precise,on)`` enables precise floating-point; semantics. If ``math-errno`` is disabled in the current TU, clang will; re-enable ``math-errno`` in the presense of; ``#pragma float_control(precise,on)``.; - Add ``__builtin_exp10``, ``__builtin_exp10f``,; ``__builtin_exp10f16``, ``__builtin_exp10l`` and; ``__builtin_exp10f128`` builtins.; - Add ``__builtin_iszero``, ``__builtin_issignaling`` and; ``__builtin_issubnormal``.; - Add support for C99's ``#pragma STDC CX_LIMITED_RANGE`` feature. This; enables the naive mathematical formulas for complex multiplication and; division, which are faster but do not correctly handle overflow and infinities. AST Matchers; ------------; - Add ``convertVectorExpr``.; - Add ``dependentSizedExtVectorType``.; - Add ``macroQualifiedType``.; - Add ``CXXFoldExpr`` related matchers: ``cxxFoldExpr``, ``callee``,; ``hasInit``, ``hasPattern``, ``isRightFold``, ``isLeftFold``,; ``isUnaryFold``, ``isBinaryFold``, ``hasOperator``, ``hasLHS``, ``hasRHS``, ``hasEitherOperand``. clang-format; ------------; - Add ``AllowBreakBeforeNoexceptSpecifier`` option.; - Add ``AllowShortCompoundRequirementOnASingleLine`` option.; - Change ``BreakAfterAttributes`` from ``Never`` to ``Leave`` in LLVM style.; - Add ``BreakAdjacentStringLiterals`` option.; - Add ``ObjCPropertyAttributeOrder`` which can be used to sort ObjC property; attributes (like ``nonatomic, strong, nullable``).; - Add ``PenaltyBreakScopeResolution`` option.; - Add ``.clang-format-ignore`` files.; - Add ``AlignFunctionPointers`` sub-option for ``AlignConsecutiveDeclarations``.; - Add ``SkipMacroDefinitionBody`` option. libclang; --------. - Exposed arguments of ``clang::annotate``.; - ``clang::getCursorKindForDecl`` now recog",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73974,Integrability,message,messages,73974,"1 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc6730c8ac3c>`_,; `0954dc3fb921 <https://github.com/llvm/llvm-project/commit/0954dc3fb9214b994623f5306473de075f8e3593>`_). - Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https:/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:76073,Integrability,message,messages,76073,"ps://github.com/llvm/llvm-project/pull/72627>`_,; `#71518 <https://github.com/llvm/llvm-project/pull/71518>`_,; `#72016 <https://github.com/llvm/llvm-project/pull/72016>`_,; `#70540 <https://github.com/llvm/llvm-project/pull/70540>`_,; `#73638 <https://github.com/llvm/llvm-project/pull/73638>`_,; `#77331 <https://github.com/llvm/llvm-project/pull/77331>`_). - The ``alpha.security.taint.TaintPropagation`` checker no longer propagates; taint on ``strlen`` and ``strnlen`` calls, unless these are marked; explicitly propagators in the user-provided taint configuration file.; This removal empirically reduces the number of false positive reports.; Read the PR for the details.; (`#66086 <https://github.com/llvm/llvm-project/pull/66086>`_). - Other taint-related improvements.; (`#66358 <https://github.com/llvm/llvm-project/pull/66358>`_,; `#66074 <https://github.com/llvm/llvm-project/pull/66074>`_,; `#66358 <https://github.com/llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``securit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2253,Modifiability,variab,variable,2253,"e ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes. Below is a complete; list of behavior changes. .. csv-table::; :header: Test, Old value, New value. ``__has_cpp_attribute(unused)``, 201603, 0; ``__has_cpp_attribute(gnu::unused)``, 201603, 1; ``__has_c_a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2426,Modifiability,config,configuration,2426,"se for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes. Below is a complete; list of behavior changes. .. csv-table::; :header: Test, Old value, New value. ``__has_cpp_attribute(unused)``, 201603, 0; ``__has_cpp_attribute(gnu::unused)``, 201603, 1; ``__has_c_attribute(unused)``, 202106, 0; ``__has_cpp_attribute(clang::fallthrough)``, 201603, 1; ``__has_cpp_attribute(gn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2492,Modifiability,config,configuration-files,2492,"rs.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes. Below is a complete; list of behavior changes. .. csv-table::; :header: Test, Old value, New value. ``__has_cpp_attribute(unused)``, 201603, 0; ``__has_cpp_attribute(gnu::unused)``, 201603, 1; ``__has_c_attribute(unused)``, 202106, 0; ``__has_cpp_attribute(clang::fallthrough)``, 201603, 1; ``__has_cpp_attribute(gnu::fallthrough)``, 201603, 1; ``__has_c_attribute(gnu::fallthrough)``, 201910, 1; ``__has_cpp_at",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:8853,Modifiability,extend,extends,8853,"s for; these targets, which could break existing code bases with improper checks for; the ``TARGET_OS_`` macros. For example, existing checks might fail to include; the ``TargetConditionals.h`` header from Apple SDKs and therefore leaving the; macros undefined and guarded code unexercised. Affected code should be checked to see if it's still intended for the specific; target and fixed accordingly. The extension can be turned off by the option ``-fno-define-target-os-macros``; as a workaround. What's New in Clang |release|?; ==============================; Some of the major new features and improvements to Clang are listed; here. Generic improvements to Clang as a whole or to its underlying; infrastructure are described first, followed by language-specific; sections with improvements to Clang's support for those languages. C++ Language Changes; --------------------. C++20 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P1907R1 <https://wg21.link/P1907R1>`_ which extends allowed non-type template argument; kinds with e.g. floating point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:10402,Modifiability,variab,variable,10402,"r-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now OK; }; void other() {; int _; // Previously diagnosed under -Wunused, no longer diagnosed; }. - Attributes now expect unevaluated strings in attributes parameters that are string literals.; This is applied to both C++ standard attributes, and other attributes supported by Clang.; This completes the implementation of `P2361R6 Unevaluated Strings <https://wg21.link/P2361R6>`_. - Implemented `P2864R2 Remove Deprecated Arithmetic Conversion on Enumerations From C++26 <https://wg21.link/P2864R2>`_. - Implemented `P236",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:10557,Modifiability,variab,variables,10557,"^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now OK; }; void other() {; int _; // Previously diagnosed under -Wunused, no longer diagnosed; }. - Attributes now expect unevaluated strings in attributes parameters that are string literals.; This is applied to both C++ standard attributes, and other attributes supported by Clang.; This completes the implementation of `P2361R6 Unevaluated Strings <https://wg21.link/P2361R6>`_. - Implemented `P2864R2 Remove Deprecated Arithmetic Conversion on Enumerations From C++26 <https://wg21.link/P2864R2>`_. - Implemented `P2361R6 Template parameter initialization <https://wg21.link/P2308R1>`_.; This change is applied as a DR in all language mo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:10654,Modifiability,variab,variables,10654,"related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now OK; }; void other() {; int _; // Previously diagnosed under -Wunused, no longer diagnosed; }. - Attributes now expect unevaluated strings in attributes parameters that are string literals.; This is applied to both C++ standard attributes, and other attributes supported by Clang.; This completes the implementation of `P2361R6 Unevaluated Strings <https://wg21.link/P2361R6>`_. - Implemented `P2864R2 Remove Deprecated Arithmetic Conversion on Enumerations From C++26 <https://wg21.link/P2864R2>`_. - Implemented `P2361R6 Template parameter initialization <https://wg21.link/P2308R1>`_.; This change is applied as a DR in all language modes. Resolutions to C++ Defect Reports; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. - Impleme",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:10713,Modifiability,variab,variables,10713,"s://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now OK; }; void other() {; int _; // Previously diagnosed under -Wunused, no longer diagnosed; }. - Attributes now expect unevaluated strings in attributes parameters that are string literals.; This is applied to both C++ standard attributes, and other attributes supported by Clang.; This completes the implementation of `P2361R6 Unevaluated Strings <https://wg21.link/P2361R6>`_. - Implemented `P2864R2 Remove Deprecated Arithmetic Conversion on Enumerations From C++26 <https://wg21.link/P2864R2>`_. - Implemented `P2361R6 Template parameter initialization <https://wg21.link/P2308R1>`_.; This change is applied as a DR in all language modes. Resolutions to C++ Defect Reports; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. - Implemented `CWG2598 <https://wg21.link/CWG2598>`_ and `CWG2096 <https://wg21.link/CWG2096>`_,; making un",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:12358,Modifiability,flexible,flexible,12358,"1.link/P2864R2>`_. - Implemented `P2361R6 Template parameter initialization <https://wg21.link/P2308R1>`_.; This change is applied as a DR in all language modes. Resolutions to C++ Defect Reports; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. - Implemented `CWG2598 <https://wg21.link/CWG2598>`_ and `CWG2096 <https://wg21.link/CWG2096>`_,; making unions (that have either no members or at least one literal member) literal types.; (`#77924 <https://github.com/llvm/llvm-project/issues/77924>`_). C Language Changes; ------------------; - ``structs``, ``unions``, and ``arrays`` that are const may now be used as; constant expressions. This change is more consistent with the behavior of; GCC.; - Enums will now be represented in TBAA metadata using their actual underlying; integer type. Previously they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:12453,Modifiability,flexible,flexible,12453,"1.link/P2864R2>`_. - Implemented `P2361R6 Template parameter initialization <https://wg21.link/P2308R1>`_.; This change is applied as a DR in all language modes. Resolutions to C++ Defect Reports; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. - Implemented `CWG2598 <https://wg21.link/CWG2598>`_ and `CWG2096 <https://wg21.link/CWG2096>`_,; making unions (that have either no members or at least one literal member) literal types.; (`#77924 <https://github.com/llvm/llvm-project/issues/77924>`_). C Language Changes; ------------------; - ``structs``, ``unions``, and ``arrays`` that are const may now be used as; constant expressions. This change is more consistent with the behavior of; GCC.; - Enums will now be represented in TBAA metadata using their actual underlying; integer type. Previously they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:23117,Modifiability,variab,variable-declarations,23117," 4096(inclusive). .. code-block:: c++. void Array(int *array, size_t n) {; [[clang::code_align(64)]] for (int i = 0; i < n; ++i) array[i] = 0;; }. template<int A>; void func() {; [[clang::code_align(A)]] for(;;) { }; }. - Clang now introduced ``[[clang::coro_lifetimebound]]`` attribute.; All parameters of a function are considered to be lifetime bound if the function; returns a type annotated with ``[[clang::coro_lifetimebound]]`` and ``[[clang::coro_return_type]]``.; This analysis can be disabled for a function by annotating the function with ``[[clang::coro_disable_lifetimebound]]``. Improvements to Clang's diagnostics; -----------------------------------; - Clang constexpr evaluator now prints template arguments when displaying; template-specialization function calls.; - Clang contexpr evaluator now displays notes as well as an error when a constructor; of a base class is not called in the constructor of its derived class.; - Clang no longer emits ``-Wmissing-variable-declarations`` for variables declared; with the ``register`` storage class.; - Clang's ``-Wswitch-default`` flag now diagnoses whenever a ``switch`` statement; does not have a ``default`` label.; - Clang's ``-Wtautological-negation-compare`` flag now diagnoses logical; tautologies like ``x && !x`` and ``!x || x`` in expressions. This also; makes ``-Winfinite-recursion`` diagnose more cases.; (`#56035 <https://github.com/llvm/llvm-project/issues/56035>`_).; - Clang constexpr evaluator now diagnoses compound assignment operators against; uninitialized variables as a read of uninitialized object.; (`#51536 <https://github.com/llvm/llvm-project/issues/51536>`_); - Clang's ``-Wformat-truncation`` now diagnoses ``snprintf`` call that is known to; result in string truncation.; (`#64871 <https://github.com/llvm/llvm-project/issues/64871>`_).; Existing warnings that similarly warn about the overflow in ``sprintf``; now falls under its own warning group ```-Wformat-overflow`` so that it can; be disabled separ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:23145,Modifiability,variab,variables,23145," 4096(inclusive). .. code-block:: c++. void Array(int *array, size_t n) {; [[clang::code_align(64)]] for (int i = 0; i < n; ++i) array[i] = 0;; }. template<int A>; void func() {; [[clang::code_align(A)]] for(;;) { }; }. - Clang now introduced ``[[clang::coro_lifetimebound]]`` attribute.; All parameters of a function are considered to be lifetime bound if the function; returns a type annotated with ``[[clang::coro_lifetimebound]]`` and ``[[clang::coro_return_type]]``.; This analysis can be disabled for a function by annotating the function with ``[[clang::coro_disable_lifetimebound]]``. Improvements to Clang's diagnostics; -----------------------------------; - Clang constexpr evaluator now prints template arguments when displaying; template-specialization function calls.; - Clang contexpr evaluator now displays notes as well as an error when a constructor; of a base class is not called in the constructor of its derived class.; - Clang no longer emits ``-Wmissing-variable-declarations`` for variables declared; with the ``register`` storage class.; - Clang's ``-Wswitch-default`` flag now diagnoses whenever a ``switch`` statement; does not have a ``default`` label.; - Clang's ``-Wtautological-negation-compare`` flag now diagnoses logical; tautologies like ``x && !x`` and ``!x || x`` in expressions. This also; makes ``-Winfinite-recursion`` diagnose more cases.; (`#56035 <https://github.com/llvm/llvm-project/issues/56035>`_).; - Clang constexpr evaluator now diagnoses compound assignment operators against; uninitialized variables as a read of uninitialized object.; (`#51536 <https://github.com/llvm/llvm-project/issues/51536>`_); - Clang's ``-Wformat-truncation`` now diagnoses ``snprintf`` call that is known to; result in string truncation.; (`#64871 <https://github.com/llvm/llvm-project/issues/64871>`_).; Existing warnings that similarly warn about the overflow in ``sprintf``; now falls under its own warning group ```-Wformat-overflow`` so that it can; be disabled separ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:23682,Modifiability,variab,variables,23682,"on by annotating the function with ``[[clang::coro_disable_lifetimebound]]``. Improvements to Clang's diagnostics; -----------------------------------; - Clang constexpr evaluator now prints template arguments when displaying; template-specialization function calls.; - Clang contexpr evaluator now displays notes as well as an error when a constructor; of a base class is not called in the constructor of its derived class.; - Clang no longer emits ``-Wmissing-variable-declarations`` for variables declared; with the ``register`` storage class.; - Clang's ``-Wswitch-default`` flag now diagnoses whenever a ``switch`` statement; does not have a ``default`` label.; - Clang's ``-Wtautological-negation-compare`` flag now diagnoses logical; tautologies like ``x && !x`` and ``!x || x`` in expressions. This also; makes ``-Winfinite-recursion`` diagnose more cases.; (`#56035 <https://github.com/llvm/llvm-project/issues/56035>`_).; - Clang constexpr evaluator now diagnoses compound assignment operators against; uninitialized variables as a read of uninitialized object.; (`#51536 <https://github.com/llvm/llvm-project/issues/51536>`_); - Clang's ``-Wformat-truncation`` now diagnoses ``snprintf`` call that is known to; result in string truncation.; (`#64871 <https://github.com/llvm/llvm-project/issues/64871>`_).; Existing warnings that similarly warn about the overflow in ``sprintf``; now falls under its own warning group ```-Wformat-overflow`` so that it can; be disabled separately from ``Wfortify-source``.; These two new warning groups have subgroups ``-Wformat-truncation-non-kprintf``; and ``-Wformat-overflow-non-kprintf``, respectively. These subgroups are used when; the format string contains ``%p`` format specifier.; Because Linux kernel's codebase has format extensions for ``%p``, kernel developers; are encouraged to disable these two subgroups by setting ``-Wno-format-truncation-non-kprintf``; and ``-Wno-format-overflow-non-kprintf`` in order to avoid false positives on; the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:27184,Modifiability,variab,variable-length,27184,"*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use without realizing it's a; nonportable construct that has different semantics from a constant-sized; array. (`#62836 <https://github.com/llvm/llvm-project/issues/62836>`_). - Clang changed the order in which it displays candidate functions on overloading failures.; Previously, Clang used definition of ordering from the C++ Standard. The order defined in; the Standard is partial and is not suited for sorting. Instead, Clang now uses a strict; order that still attempts to push more relevant functions to the top by comparing their; corresponding conversions. In some cases, this results in better order. E.g., for the; following code. .. code-block:: cpp. struct Foo {; operator int();; operator const char*();; };. void test() { Foo() - Foo(); }. Clang now produces a list with two most relevant builtin operators at the top,; i.e. ``op",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32603,Modifiability,variab,variables,32603,"k:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32643,Modifiability,variab,variable,32643,"iable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32844,Modifiability,variab,variable,32844,"rror: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/ll",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:34018,Modifiability,variab,variables,34018,"specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:34961,Modifiability,variab,variable,34961,"tps://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm-project/issues/37257>`_); - Clang's ``-Wunused-private-field`` no longer warns on fields whose type is; declared with ``[[maybe_unused]]``.; (`#61334 <https://github.com/llvm/llvm-project/issues/61334>`_); - For function multi-versioning using the ``target``, ``target_clones``, or; ``target_version`` attributes, remove comdat for internal linkage functions.; (`#65114 <https://github.com/llvm/llvm-project/issues/65114>`_); - Clang now reports ``-Wformat`` for bool value and char specifier confusion; in scanf. Fixes; (`#64987 <https://github.com/llvm/llvm-project/issues/64987>`_); - Support MSVC predefined macro expressions in constant expressions and in; local structs.; - Correctly parse non-ascii identifiers that appear immediately after a line splicing; (`#65156 <https://github.com/llvm/llvm-project/issues/65156>`_); - Clang no longer considers the loss of ``__unaligned",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:37321,Modifiability,variab,variables,37321," Fix crash in implicit conversions from initialize list to arrays of unknown; bound for C++20. Fixes; (`#62945 <https://github.com/llvm/llvm-project/issues/62945>`_); - Clang now allows an ``_Atomic`` qualified integer in a switch statement. Fixes; (`#65557 <https://github.com/llvm/llvm-project/issues/65557>`_); - Fixes crash when trying to obtain the common sugared type of; `decltype(instantiation-dependent-expr)`.; Fixes (`#67603 <https://github.com/llvm/llvm-project/issues/67603>`_); - Fixes a crash caused by a multidimensional array being captured by a lambda; (`#67722 <https://github.com/llvm/llvm-project/issues/67722>`_).; - Fixes a crash when instantiating a lambda with requires clause.; (`#64462 <https://github.com/llvm/llvm-project/issues/64462>`_); - Fixes a regression where the ``UserDefinedLiteral`` was not properly preserved; while evaluating consteval functions. (`#63898 <https://github.com/llvm/llvm-project/issues/63898>`_).; - Fix a crash when evaluating value-dependent structured binding; variables at compile time.; Fixes (`#67690 <https://github.com/llvm/llvm-project/issues/67690>`_); - Fixes a ``clang-17`` regression where ``LLVM_UNREACHABLE_OPTIMIZE=OFF``; cannot be used with ``Release`` mode builds. (`#68237 <https://github.com/llvm/llvm-project/issues/68237>`_).; - Fix crash in evaluating ``constexpr`` value for invalid template function.; Fixes (`#68542 <https://github.com/llvm/llvm-project/issues/68542>`_); - Clang will correctly evaluate ``noexcept`` expression for template functions; of template classes. Fixes; (`#68543 <https://github.com/llvm/llvm-project/issues/68543>`_,; `#42496 <https://github.com/llvm/llvm-project/issues/42496>`_,; `#77071 <https://github.com/llvm/llvm-project/issues/77071>`_,; `#77411 <https://github.com/llvm/llvm-project/issues/77411>`_); - Fixed an issue when a shift count larger than ``__INT64_MAX__``, in a right; shift operation, could result in missing warnings about; ``shift count >= width of type`` or internal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43405,Modifiability,flexible,flexible,43405,://github.com/llvm/llvm-project/issues/39319>`_) and; (`#60182 <https://github.com/llvm/llvm-project/issues/60182>`_) and; (`#62157 <https://github.com/llvm/llvm-project/issues/62157>`_) and; (`#64885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues/69987>`_); - Fix an issue where CTAD fails for explicit type conversion.; Fixes (`#64347 <https://github.com/llvm/llvm-project/issues/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issue,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:50682,Modifiability,variab,variables,50682,"l to an immediate function.; (`#66324 <https://github.com/llvm/llvm-project/issues/66324>`_). - Fix crash for a lambda attribute with a statement expression; that contains a `return`.; (`#48527 <https://github.com/llvm/llvm-project/issues/48527>`_). - Clang now no longer asserts when an UnresolvedLookupExpr is used as an; expression requirement. (`#66612 <https://github.com/llvm/llvm-project/issues/66612>`_). - Clang now disambiguates NTTP types when printing diagnostics where the; NTTP types are compared with the 'diff' method.; (`#66744 <https://github.com/llvm/llvm-project/issues/66744>`_). - Fix crash caused by a spaceship operator returning a comparision category by; reference. Fixes:; (`#64162 <https://github.com/llvm/llvm-project/issues/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51653,Modifiability,variab,variable,51653," to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:52232,Modifiability,variab,variable-length,52232,"e now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expression.; Fixes: (`#72025 <https://github.com/llvm/llvm-project/issues/72025>`_). - Clang now defers the instantiation of explicit specifier until constraint checking; completes (except deduction guides). Fixes:; (`#59827 <",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:55224,Modifiability,variab,variables,55224,ject/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:58247,Modifiability,variab,variable,58247,"with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albeit incomplete changes. The ``_OPENACC`` macro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-refere",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:61289,Modifiability,extend,extended,61289,"series of *_prefetch_i[3|6][2|4]gather_*; * intrinsic series of *_prefetch_i[3|6][2|4]scatter_*. Arm and AArch64 Support; ^^^^^^^^^^^^^^^^^^^^^^^. - C++ function name mangling has been changed to align with the specification; (https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst).; This affects C++ functions with SVE ACLE parameters. Clang will use the old; manglings if ``-fclang-abi-compat=17`` or lower is specified. - New AArch64 asm constraints have been added for r8-r11(Uci) and r12-r15(Ucj). - Support has been added for the following processors (-mcpu identifiers in parenthesis):. For Arm:. * Cortex-M52 (cortex-m52). For AArch64:. * Cortex-A520 (cortex-a520).; * Cortex-A720 (cortex-a720).; * Cortex-X4 (cortex-x4). - Alpha support has been added for SVE2.1 intrinsics. - Support has been added for `-fstack-clash-protection` and `-mstack-probe-size`; command line options. - Function Multi Versioning has been extended to support Load-Acquire RCpc; instructions v3 (rcpc3) as well as Memory Copy and Memory Set Acceleration; instructions (mops) when targeting AArch64. The feature identifiers (in; parenthesis) can be used with either of the ``target_version`` and; ``target_clones`` attributes. Android Support; ^^^^^^^^^^^^^^^. - Android target triples are usually suffixed with a version. Clang searches for; target-specific runtime and standard libraries in directories named after the; target (e.g. if you're building with ``--target=aarch64-none-linux-android21``,; Clang will look for ``lib/aarch64-none-linux-android21`` under its resource; directory to find runtime libraries). If an exact match isn't found, Clang; would previously fall back to a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63811,Modifiability,variab,variables,63811,"explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65346,Modifiability,variab,variables,65346,"f RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementw",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65470,Modifiability,variab,variables,65470,"f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65772,Modifiability,plugin,plugin,65772,"now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp2`` builtin for floating point types only.; - Add ``__builtin_set_flt_rounds`` builtin for X86, x86_64, Arm and AArch64 only.; - Add ``__builtin_elementwise_pow`` builtin for floating point types only.; - Add ``__builtin_elementwise_bitreverse`` builtin for integer types only.; - Ad",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65905,Modifiability,variab,variables,65905,"- Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp2`` builtin for floating point types only.; - Add ``__builtin_set_flt_rounds`` builtin for X86, x86_64, Arm and AArch64 only.; - Add ``__builtin_elementwise_pow`` builtin for floating point types only.; - Add ``__builtin_elementwise_bitreverse`` builtin for integer types only.; - Add ``__builtin_elementwise_sqrt`` builtin for floating point types only.; - ``__builtin_isfpclass`` builtin now supports vector types.; - ``#pragm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70005,Modifiability,polymorphi,polymorphic,70005,"ing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary objec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70449,Modifiability,config,configuration,70449,"behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary object fields.; (`#66221 <https://github.com/llvm/llvm-project/issues/66221>`_). - A few crashes have been found and fixed using randomized testing related; to the use of ``_BitInt()`` in tidy checks and in clang analysis.; (`#67212 <https://github.com/llvm/llvm-project/pull/67212>`_,; `#66782 <https://github.com/llvm/llvm-project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-proj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:75602,Modifiability,config,configuration,75602," Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https://github.com/llvm/llvm-project/pull/74296>`_,; `#73335 <https://github.com/llvm/llvm-project/pull/73335>`_,; `#72627 <https://github.com/llvm/llvm-project/pull/72627>`_,; `#71518 <https://github.com/llvm/llvm-project/pull/71518>`_,; `#72016 <https://github.com/llvm/llvm-project/pull/72016>`_,; `#70540 <https://github.com/llvm/llvm-project/pull/70540>`_,; `#73638 <https://github.com/llvm/llvm-project/pull/73638>`_,; `#77331 <https://github.com/llvm/llvm-project/pull/77331>`_). - The ``alpha.security.taint.TaintPropagation`` checker no longer propagates; taint on ``strlen`` and ``strnlen`` calls, unless these are marked; explicitly propagators in the user-provided taint configuration file.; This removal empirically reduces the number of false positive reports.; Read the PR for the details.; (`#66086 <https://github.com/llvm/llvm-project/pull/66086>`_). - Other taint-related improvements.; (`#66358 <https://github.com/llvm/llvm-project/pull/66358>`_,; `#66074 <https://github.com/llvm/llvm-project/pull/66074>`_,; `#66358 <https://github.com/llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:9175,Performance,perform,perform,9175,"ific; target and fixed accordingly. The extension can be turned off by the option ``-fno-define-target-os-macros``; as a workaround. What's New in Clang |release|?; ==============================; Some of the major new features and improvements to Clang are listed; here. Generic improvements to Clang as a whole or to its underlying; infrastructure are described first, followed by language-specific; sections with improvements to Clang's support for those languages. C++ Language Changes; --------------------. C++20 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P1907R1 <https://wg21.link/P1907R1>`_ which extends allowed non-type template argument; kinds with e.g. floating point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:13130,Performance,perform,performing,13130,"data using their actual underlying; integer type. Previously they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now we've implemented allowing a label to be followed by a declaration; instead of a statement.; - Implemented; `N2940 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2940.pdf>`_ which; removes support for trigraphs in C23 and later. In earlier language modes,; trigraphs remain enabled by default in conforming modes (e.g. ``-std=c17``); and disabled by default in GNU and Microsoft modes (e.g., ``-std=gnu17`` or; ``-fms-compatibility``). If needed, you can enable trigraphs by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:14318,Performance,scalab,scalable,14318,"ly implemented allowing a label at the end of a compound statement,; and now we've implemented allowing a label to be followed by a declaration; instead of a statement.; - Implemented; `N2940 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2940.pdf>`_ which; removes support for trigraphs in C23 and later. In earlier language modes,; trigraphs remain enabled by default in conforming modes (e.g. ``-std=c17``); and disabled by default in GNU and Microsoft modes (e.g., ``-std=gnu17`` or; ``-fms-compatibility``). If needed, you can enable trigraphs by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM NEON's vector types; (e.g., ``uint16x8_t``), this returns the constant number of elements at compile-time.; For scalable vectors, e.g., SVE or RISC-V V, the number of elements is not known at compile-time and is; determined at runtime.; * The ``__datasizeof`` keyword has been added. It is similar to ``sizeof``; except that it returns the size of a type ignoring tail padding.; * ``__builtin_classify_type()`` now classifies ``_BitInt`` values as the return value ``18``; and vector types as return value ``19``, to match GCC 14's behavior.; * The default value of `_MSC_VER` was raised from 1920 to 1933.; * Since MSVC 19.33 added undocumented attribute ``[[msvc::constexpr]]``, this release adds the attribute as well. * Added ``#pragma clang fp reciprocal``. * The version of Unicode used by Clang (primarily to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:34239,Performance,perform,performance,34239,"h can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm-project/issues/37257>`_); - Clang's ``-Wunused-private-field`` no longer warns on fields whose type is; declared with ``[[maybe_unused]]``.; (`#61334 <https://github.com/llvm/llvm-project/issues/61334>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:41312,Performance,perform,performing,41312,mmediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; Fixes (`#13826 <https://github.com/llvm/llvm-project/issues/13826>`_); - Fix a ``clang-17`` regression where a templated friend with constraints is not; properly applied when its parameters reference an enclosing non-template class.; Fixes (`#71595 <https://github.com/llvm/llvm-project/issues/71595>`_); - Fix the name of the ifunc symbol emitted for multiversion functions declared with the; ``target_clones`` attribute. This addresses a linker error that would otherwise occur; when these functions are referenced from other TUs.; - Fixes compile error that double colon operator cannot resolve macro with parentheses.; Fixes (`#64467 <https://github.com/llvm/llvm-project/issues/64467>`_); - Clang's ``-Wchar-subscripts`` no longer warns on chars whose values are known non-negative constants.; Fixes (`#18763 <https://github.com/llvm/llvm-project/issues/18763>`_); - Fix crash due to incorrectly allowing conversion functi,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:56599,Performance,cache,cached,56599,"d.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed an import failure of recursive friend class template.; `Issue 64169 <https://github.com/llvm/llvm-project/issues/64169>`_; - Remove unnecessary RecordLayout computation when importing UnaryOperator. The; computed RecordLayout is incorrect if fields are not completely imported and; should not be cached.; `Issue 64170 <https://github.com/llvm/llvm-project/issues/64170>`_; - Fixed ``hasAnyBase`` not binding nodes in its submatcher.; (`#65421 <https://github.com/llvm/llvm-project/issues/65421>`_); - Fixed a bug where RecursiveASTVisitor fails to visit the; initializer of a bitfield.; `Issue 64916 <https://github.com/llvm/llvm-project/issues/64916>`_; - Fixed a bug where range-loop-analysis checks for trivial copyability,; rather than trivial copy-constructibility; `Issue 47355 <https://github.com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recov",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65075,Performance,tune,tune,65075,"h gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; --",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:24626,Safety,avoid,avoid,24626,"<https://github.com/llvm/llvm-project/issues/56035>`_).; - Clang constexpr evaluator now diagnoses compound assignment operators against; uninitialized variables as a read of uninitialized object.; (`#51536 <https://github.com/llvm/llvm-project/issues/51536>`_); - Clang's ``-Wformat-truncation`` now diagnoses ``snprintf`` call that is known to; result in string truncation.; (`#64871 <https://github.com/llvm/llvm-project/issues/64871>`_).; Existing warnings that similarly warn about the overflow in ``sprintf``; now falls under its own warning group ```-Wformat-overflow`` so that it can; be disabled separately from ``Wfortify-source``.; These two new warning groups have subgroups ``-Wformat-truncation-non-kprintf``; and ``-Wformat-overflow-non-kprintf``, respectively. These subgroups are used when; the format string contains ``%p`` format specifier.; Because Linux kernel's codebase has format extensions for ``%p``, kernel developers; are encouraged to disable these two subgroups by setting ``-Wno-format-truncation-non-kprintf``; and ``-Wno-format-overflow-non-kprintf`` in order to avoid false positives on; the kernel codebase.; Also clang no longer emits false positive warnings about the output length of; ``%g`` format specifier and about ``%o, %x, %X`` with ``#`` flag.; - Clang now emits ``-Wcast-qual`` for functional-style cast expressions.; - Clang no longer emits irrelevant notes about unsatisfied constraint expressions; on the left-hand side of ``||`` when the right-hand side constraint is satisfied.; (`#54678 <https://github.com/llvm/llvm-project/issues/54678>`_).; - Clang now prints its 'note' diagnostic in cyan instead of black, to be more compatible; with terminals with dark background colors. This is also more consistent with GCC.; - Clang now displays an improved diagnostic and a note when a defaulted special; member is marked ``constexpr`` in a class with a virtual base class; (`#64843 <https://github.com/llvm/llvm-project/issues/64843>`_).; - ``-Wfixed-enu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:46490,Safety,avoid,avoid,46490,"s (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can capture this.; Fixes (`#71976 <https://github.com/llvm/llvm-project/issues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified by `-fconstexpr-steps`.; (`#63562 <https://github.com/llvm/llvm-project/issues/63562>`_). - Fix a crash caused by some named unicode escape sequences designating; a Unicode character whose name contains a ``-``.; (Fixes `#64161 <https://github.com/llvm/llvm-project/issues/64161>`_). - Fix cases where we ignore ambiguous name lookup when looking up members.; (`#22413 <https://github.com/llvm/llvm-project/issues/22413>`_),; (`#29942 <https://github.com/llvm/llvm-project/issues/29942>`_),; (`#35574 <https://github.com/llvm/llvm-project/issues/35574>`_) and; (`#27224 <https://github.com/llvm/llvm-project/issues/27224>`_). - Clang emits an error on substitution failure within lambda body inside a; requires-expression. This fixes:; (`#64138 <https://github.com/llvm/llvm-project/issues/64138>`_) and; (`#71684 <https://github.com/llvm/llvm-project/issues/71684>`_). - Update ``FunctionDeclBitfields.NumFunctionDeclBi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:57549,Safety,recover,recover,57549,"etely imported and; should not be cached.; `Issue 64170 <https://github.com/llvm/llvm-project/issues/64170>`_; - Fixed ``hasAnyBase`` not binding nodes in its submatcher.; (`#65421 <https://github.com/llvm/llvm-project/issues/65421>`_); - Fixed a bug where RecursiveASTVisitor fails to visit the; initializer of a bitfield.; `Issue 64916 <https://github.com/llvm/llvm-project/issues/64916>`_; - Fixed a bug where range-loop-analysis checks for trivial copyability,; rather than trivial copy-constructibility; `Issue 47355 <https://github.com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is begin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:69691,Safety,detect,detect,69691," ""C""`` and reports them as ``CXCursor_LinkageSpec``.; - Changed the libclang library on AIX to export only the necessary symbols to; prevent issues of resolving to the wrong duplicate symbol. Static Analyzer; ---------------. New features; ^^^^^^^^^^^^. - Implemented the ``[[clang::suppress]]`` attribute for suppressing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.ht",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:69971,Safety,detect,detect,69971,"ing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary objec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73439,Safety,unsafe,unsafe,73439,"y; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc673",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73896,Safety,detect,detecting,73896,"1 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc6730c8ac3c>`_,; `0954dc3fb921 <https://github.com/llvm/llvm-project/commit/0954dc3fb9214b994623f5306473de075f8e3593>`_). - Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https:/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:12537,Security,sanitiz,sanitizer,12537,"a DR in all language modes. Resolutions to C++ Defect Reports; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. - Implemented `CWG2598 <https://wg21.link/CWG2598>`_ and `CWG2096 <https://wg21.link/CWG2096>`_,; making unions (that have either no members or at least one literal member) literal types.; (`#77924 <https://github.com/llvm/llvm-project/issues/77924>`_). C Language Changes; ------------------; - ``structs``, ``unions``, and ``arrays`` that are const may now be used as; constant expressions. This change is more consistent with the behavior of; GCC.; - Enums will now be represented in TBAA metadata using their actual underlying; integer type. Previously they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now we've implemented allowing a label to be followed by a declaration; instead of a statement.; - Implemented; `N2940 <https://www.open-st",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:13181,Security,expose,exposed,13181,"sly they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now we've implemented allowing a label to be followed by a declaration; instead of a statement.; - Implemented; `N2940 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2940.pdf>`_ which; removes support for trigraphs in C23 and later. In earlier language modes,; trigraphs remain enabled by default in conforming modes (e.g. ``-std=c17``); and disabled by default in GNU and Microsoft modes (e.g., ``-std=gnu17`` or; ``-fms-compatibility``). If needed, you can enable trigraphs by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:33996,Security,access,accesses,33996,"specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:34102,Security,access,accesses,34102,"specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45105,Security,access,accesses,45105,"ub.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can captu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45149,Security,access,accesses,45149,"ub.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can captu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:55314,Security,inject,injected,55314,ject/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:57707,Security,access,access,57707,"hasAnyBase`` not binding nodes in its submatcher.; (`#65421 <https://github.com/llvm/llvm-project/issues/65421>`_); - Fixed a bug where RecursiveASTVisitor fails to visit the; initializer of a bitfield.; `Issue 64916 <https://github.com/llvm/llvm-project/issues/64916>`_; - Fixed a bug where range-loop-analysis checks for trivial copyability,; rather than trivial copy-constructibility; `Issue 47355 <https://github.com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albei",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63239,Security,expose,expose,63239,"ons and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63797,Security,access,access,63797,"explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:64005,Security,access,access-external-data,64005," generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:64222,Security,access,accesses,64222,"se issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introdu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:64268,Security,access,access,64268,"se issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introdu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65311,Security,access,access,65311,"f RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementw",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65434,Security,access,access,65434,"f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:69707,Security,access,accesses,69707," ""C""`` and reports them as ``CXCursor_LinkageSpec``.; - Changed the libclang library on AIX to export only the necessary symbols to; prevent issues of resolving to the wrong duplicate symbol. Static Analyzer; ---------------. New features; ^^^^^^^^^^^^. - Implemented the ``[[clang::suppress]]`` attribute for suppressing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.ht",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70512,Security,secur,security,70512,"behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary object fields.; (`#66221 <https://github.com/llvm/llvm-project/issues/66221>`_). - A few crashes have been found and fixed using randomized testing related; to the use of ``_BitInt()`` in tidy checks and in clang analysis.; (`#67212 <https://github.com/llvm/llvm-project/pull/67212>`_,; `#66782 <https://github.com/llvm/llvm-project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-proj",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70710,Security,secur,security-cert-env-invalidptr,70710,"g alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary object fields.; (`#66221 <https://github.com/llvm/llvm-project/issues/66221>`_). - A few crashes have been found and fixed using randomized testing related; to the use of ``_BitInt()`` in tidy checks and in clang analysis.; (`#67212 <https://github.com/llvm/llvm-project/pull/67212>`_,; `#66782 <https://github.com/llvm/llvm-project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-project/pull/65888>`_,; `#65887 <https://github.com/llvm/llvm-project/pull/65887>`_). - Fixed note links of the HTML output.; (`#64054 <https://github.com/llvm/llvm-project/issues/64054>`_). - Allow widening rage-based for loops.; (`#70190 <https://githu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:72353,Security,secur,security,72353,"project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-project/pull/65888>`_,; `#65887 <https://github.com/llvm/llvm-project/pull/65887>`_). - Fixed note links of the HTML output.; (`#64054 <https://github.com/llvm/llvm-project/issues/64054>`_). - Allow widening rage-based for loops.; (`#70190 <https://github.com/llvm/llvm-project/pull/70190>`_). - Fixed uninitialized base class with initializer list when ctor is not; declared in the base class.; (`#70464 <https://github.com/llvm/llvm-project/issues/70464>`_,; `#59493 <https://github.com/llvm/llvm-project/issues/59493>`_,; `#54533 <https://github.com/llvm/llvm-project/issues/54533>`_). - Fixed an ``alpha.unix.cstring`` crash on variadic functions.; (`#74269 <https://github.com/llvm/llvm-project/issues/74269>`_). - Fix false positive in mutation check when using pointer to member function.; (`#66204 <https://github.com/llvm/llvm-project/issues/66204>`_). - Fixed a crash in ``security.cert.env.InvalidPtr`` checker when accidentally; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73202,Security,access,accessing,73202,"sitive in mutation check when using pointer to member function.; (`#66204 <https://github.com/llvm/llvm-project/issues/66204>`_). - Fixed a crash in ``security.cert.env.InvalidPtr`` checker when accidentally; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73350,Security,secur,security,73350,"`security.cert.env.InvalidPtr`` checker when accidentally; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73515,Security,secur,security-insecureapi-deprecatedorunsafebufferhandling-c,73515,"Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc6730c8ac3c>`_,; `0954dc3fb921 <https://github.com/llvm/llvm-project/commit/0954dc3fb9214b994623f5306473de075f8e3593>`_). - Improved the `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73860,Security,secur,security,73860,"0 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc6730c8ac3c>`_,; `0954dc3fb921 <https://github.com/llvm/llvm-project/commit/0954dc3fb9214b994623f5306473de075f8e3593>`_). - Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73914,Security,access,accesses,73914,"1 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull/72107>`_). - Improved the ``alpha.unix.cstring.OutOfBounds`` checking both ends of the; buffers in more cases.; (`c3a87ddad62a <https://github.com/llvm/llvm-project/commit/c3a87ddad62a6cc01acaccc76592bc6730c8ac3c>`_,; `0954dc3fb921 <https://github.com/llvm/llvm-project/commit/0954dc3fb9214b994623f5306473de075f8e3593>`_). - Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https:/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:75420,Security,secur,security,75420,"954dc3fb921 <https://github.com/llvm/llvm-project/commit/0954dc3fb9214b994623f5306473de075f8e3593>`_). - Improved the ``alpha.unix.Stream`` checker by modeling more functions; ``fputs``, ``fputc``, ``fgets``, ``fgetc``, ``fdopen``, ``ungetc``, ``fflush``,; ``getdelim``, ``getline`` and no not recognize alternative; ``fopen`` and ``tmpfile`` implementations.; (`#78693 <https://github.com/llvm/llvm-project/pull/78693>`_,; `#76776 <https://github.com/llvm/llvm-project/pull/76776>`_,; `#74296 <https://github.com/llvm/llvm-project/pull/74296>`_,; `#73335 <https://github.com/llvm/llvm-project/pull/73335>`_,; `#72627 <https://github.com/llvm/llvm-project/pull/72627>`_,; `#71518 <https://github.com/llvm/llvm-project/pull/71518>`_,; `#72016 <https://github.com/llvm/llvm-project/pull/72016>`_,; `#70540 <https://github.com/llvm/llvm-project/pull/70540>`_,; `#73638 <https://github.com/llvm/llvm-project/pull/73638>`_,; `#77331 <https://github.com/llvm/llvm-project/pull/77331>`_). - The ``alpha.security.taint.TaintPropagation`` checker no longer propagates; taint on ``strlen`` and ``strnlen`` calls, unless these are marked; explicitly propagators in the user-provided taint configuration file.; This removal empirically reduces the number of false positive reports.; Read the PR for the details.; (`#66086 <https://github.com/llvm/llvm-project/pull/66086>`_). - Other taint-related improvements.; (`#66358 <https://github.com/llvm/llvm-project/pull/66358>`_,; `#66074 <https://github.com/llvm/llvm-project/pull/66074>`_,; `#66358 <https://github.com/llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:76974,Security,secur,security,76974,"llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77040,Security,secur,security,77040,"rs can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77140,Security,secur,security-cert-env-invalidptr,77140,"ved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <http",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77421,Security,sanitiz,sanitizers,77421,"ules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77887,Security,access,access,77887,"ules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:9106,Testability,test,tested,9106,"os undefined and guarded code unexercised. Affected code should be checked to see if it's still intended for the specific; target and fixed accordingly. The extension can be turned off by the option ``-fno-define-target-os-macros``; as a workaround. What's New in Clang |release|?; ==============================; Some of the major new features and improvements to Clang are listed; here. Generic improvements to Clang as a whole or to its underlying; infrastructure are described first, followed by language-specific; sections with improvements to Clang's support for those languages. C++ Language Changes; --------------------. C++20 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P1907R1 <https://wg21.link/P1907R1>`_ which extends allowed non-type template argument; kinds with e.g. floating point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:9367,Testability,test,testing,9367,"==============================; Some of the major new features and improvements to Clang are listed; here. Generic improvements to Clang as a whole or to its underlying; infrastructure are described first, followed by language-specific; sections with improvements to Clang's support for those languages. C++ Language Changes; --------------------. C++20 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P1907R1 <https://wg21.link/P1907R1>`_ which extends allowed non-type template argument; kinds with e.g. floating point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:9921,Testability,test,test,9921," point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:10025,Testability,test,tested,10025,"ype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now OK; }; void other() {; int _; // Previously diagnosed under -Wunused, no longer diagnosed; }. - Attributes now expect u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:16067,Testability,test,test,16067," to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directives for ""system"" headers instead of copying; the preprocessed text to the output. This can greatly reduce the size of the; preprocessed output, which can be helpful when trying to reduce a test case.; * ``-fassume-nothrow-exception-dtor`` is added to assume that the destructor of; a thrown exception object will not throw. The generated code for catch; handlers will be smaller. A throw expression of a type with a; potentially-throwing destructor will lead to an error. * ``-fopenacc`` was added as a part of the effort to support OpenACC in Clang. * ``-fcx-limited-range`` enables the naive mathematical formulas for complex; division and multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by ``-ffast-math``. * ``-fcx-fortran-rules`` enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun. ACM 5, 8; (1962). The default is ``-fno-cx-fortran-rules``. * ``-fvisibility-global-new-delete=<value>`` gives more freedom to users to; cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:23387,Testability,log,logical,23387,"lang::coro_lifetimebound]]`` attribute.; All parameters of a function are considered to be lifetime bound if the function; returns a type annotated with ``[[clang::coro_lifetimebound]]`` and ``[[clang::coro_return_type]]``.; This analysis can be disabled for a function by annotating the function with ``[[clang::coro_disable_lifetimebound]]``. Improvements to Clang's diagnostics; -----------------------------------; - Clang constexpr evaluator now prints template arguments when displaying; template-specialization function calls.; - Clang contexpr evaluator now displays notes as well as an error when a constructor; of a base class is not called in the constructor of its derived class.; - Clang no longer emits ``-Wmissing-variable-declarations`` for variables declared; with the ``register`` storage class.; - Clang's ``-Wswitch-default`` flag now diagnoses whenever a ``switch`` statement; does not have a ``default`` label.; - Clang's ``-Wtautological-negation-compare`` flag now diagnoses logical; tautologies like ``x && !x`` and ``!x || x`` in expressions. This also; makes ``-Winfinite-recursion`` diagnose more cases.; (`#56035 <https://github.com/llvm/llvm-project/issues/56035>`_).; - Clang constexpr evaluator now diagnoses compound assignment operators against; uninitialized variables as a read of uninitialized object.; (`#51536 <https://github.com/llvm/llvm-project/issues/51536>`_); - Clang's ``-Wformat-truncation`` now diagnoses ``snprintf`` call that is known to; result in string truncation.; (`#64871 <https://github.com/llvm/llvm-project/issues/64871>`_).; Existing warnings that similarly warn about the overflow in ``sprintf``; now falls under its own warning group ```-Wformat-overflow`` so that it can; be disabled separately from ``Wfortify-source``.; These two new warning groups have subgroups ``-Wformat-truncation-non-kprintf``; and ``-Wformat-overflow-non-kprintf``, respectively. These subgroups are used when; the format string contains ``%p`` format specifier",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:25746,Testability,assert,assertion,25746,"ag.; - Clang now emits ``-Wcast-qual`` for functional-style cast expressions.; - Clang no longer emits irrelevant notes about unsatisfied constraint expressions; on the left-hand side of ``||`` when the right-hand side constraint is satisfied.; (`#54678 <https://github.com/llvm/llvm-project/issues/54678>`_).; - Clang now prints its 'note' diagnostic in cyan instead of black, to be more compatible; with terminals with dark background colors. This is also more consistent with GCC.; - Clang now displays an improved diagnostic and a note when a defaulted special; member is marked ``constexpr`` in a class with a virtual base class; (`#64843 <https://github.com/llvm/llvm-project/issues/64843>`_).; - ``-Wfixed-enum-extension`` and ``-Wmicrosoft-fixed-enum`` diagnostics are no longer; emitted when building as C23, since C23 standardizes support for enums with a; fixed underlying type.; - When describing the failure of static assertion of `==` expression, clang prints the integer; representation of the value as well as its character representation when; the user-provided expression is of character type. If the character is; non-printable, clang now shows the escpaed character.; Clang also prints multi-byte characters if the user-provided expression; is of multi-byte character type. *Example Code*:. .. code-block:: c++. static_assert(""A\n""[1] == U'🌍');. *BEFORE*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:26241,Testability,assert,assertion,26241,"a note when a defaulted special; member is marked ``constexpr`` in a class with a virtual base class; (`#64843 <https://github.com/llvm/llvm-project/issues/64843>`_).; - ``-Wfixed-enum-extension`` and ``-Wmicrosoft-fixed-enum`` diagnostics are no longer; emitted when building as C23, since C23 standardizes support for enums with a; fixed underlying type.; - When describing the failure of static assertion of `==` expression, clang prints the integer; representation of the value as well as its character representation when; the user-provided expression is of character type. If the character is; non-printable, clang now shows the escpaed character.; Clang also prints multi-byte characters if the user-provided expression; is of multi-byte character type. *Example Code*:. .. code-block:: c++. static_assert(""A\n""[1] == U'🌍');. *BEFORE*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:26544,Testability,assert,assertion,26544," When describing the failure of static assertion of `==` expression, clang prints the integer; representation of the value as well as its character representation when; the user-provided expression is of character type. If the character is; non-printable, clang now shows the escpaed character.; Clang also prints multi-byte characters if the user-provided expression; is of multi-byte character type. *Example Code*:. .. code-block:: c++. static_assert(""A\n""[1] == U'🌍');. *BEFORE*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use without realizing it's a; nonportable construct that has different semantics from a constant-sized; array. (`#62836 <https://github.com/llvm/llvm-project/issues/62836>`_). - Clang changed the order in which it displays candidate functions on overloading failures.; Previously, Clang used definition of ordering from the C++ Standard. The order defined in; t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:28073,Testability,test,test,28073,"pecs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use without realizing it's a; nonportable construct that has different semantics from a constant-sized; array. (`#62836 <https://github.com/llvm/llvm-project/issues/62836>`_). - Clang changed the order in which it displays candidate functions on overloading failures.; Previously, Clang used definition of ordering from the C++ Standard. The order defined in; the Standard is partial and is not suited for sorting. Instead, Clang now uses a strict; order that still attempts to push more relevant functions to the top by comparing their; corresponding conversions. In some cases, this results in better order. E.g., for the; following code. .. code-block:: cpp. struct Foo {; operator int();; operator const char*();; };. void test() { Foo() - Foo(); }. Clang now produces a list with two most relevant builtin operators at the top,; i.e. ``operator-(int, int)`` and ``operator-(const char*, const char*)``.; Previously ``operator-(const char*, const char*)`` was the first element,; but ``operator-(int, int)`` was only the 13th element in the output.; However, new implementation does not take into account some aspects of; C++ semantics, e.g. which function template is more specialized. This; can sometimes lead to worse ordering. - When describing a warning/error in a function-style type conversion Clang underlines only until; the end of the expression we convert from. Now Clang underlines until the closing parenthesis. Before:. .. code-block:: text. warning: cast from 'long (*)(const int &)' to 'decltype(fun_ptr)' (aka 'long (*)(int &)') converts to incompatible function type [-Wcast-function-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~. After:. .. code-block:: text. warning",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:29856,Testability,assert,assertion,29856,"ction-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~. After:. .. code-block:: text. warning: cast from 'long (*)(const int &)' to 'decltype(fun_ptr)' (aka 'long (*)(int &)') converts to incompatible function type [-Wcast-function-type-strict]; 24 | return decltype(fun_ptr)( f_ptr /*comment*/);; | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. - ``-Wzero-as-null-pointer-constant`` diagnostic is no longer emitted when using ``__null``; (or, more commonly, ``NULL`` when the platform defines it as ``__null``) to be more consistent; with GCC.; - Clang will warn on deprecated specializations used in system headers when their instantiation; is caused by user code.; - Clang will now print ``static_assert`` failure details for arithmetic binary operators.; Example:. .. code-block:: cpp. static_assert(1 << 4 == 15);. will now print:. .. code-block:: text. error: static assertion failed due to requirement '1 << 4 == 15'; 48 | static_assert(1 << 4 == 15);; | ^~~~~~~~~~~~; note: expression evaluates to '16 == 15'; 48 | static_assert(1 << 4 == 15);; | ~~~~~~~^~~~~. - Clang now diagnoses definitions of friend function specializations, e.g. ``friend void f<>(int) {}``.; - Clang now diagnoses narrowing conversions involving const references.; (`#63151 <https://github.com/llvm/llvm-project/issues/63151>`_).; - Clang now diagnoses unexpanded packs within the template argument lists of function template specializations.; - The warning `-Wnan-infinity-disabled` is now emitted when ``INFINITY``; or ``NAN`` are used in arithmetic operations or function arguments in; floating-point mode where ``INFINITY`` or ``NAN`` don't have the expected; values. - Clang now diagnoses attempts to bind a bitfield to an NTTP of a reference type as erroneous; converted constant expression and not as a reference to subobject.; - Clang now diagnoses ``auto`` and ``decltype(auto)`` in declarations of conversion function template; (`CWG1878 <https://cplusplus.github.io/CWG/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:34764,Testability,assert,assertion,34764,"ects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm-project/issues/37257>`_); - Clang's ``-Wunused-private-field`` no longer warns on fields whose type is; declared with ``[[maybe_unused]]``.; (`#61334 <https://github.com/llvm/llvm-project/issues/61334>`_); - For function multi-versioning using the ``target``, ``target_clones``, or; ``target_version`` attributes, remove comdat for internal linkage functions.; (`#65114 <https://github.com/llvm/llvm-project/issues/65114>`_); - Clang now reports ``-Wformat`` for bool value and char specifier confusion; in scanf. Fixes; (`#64987 <https://github.com/llvm/llvm-project/issues/64987>`_); - Support MSVC predefined macro expressions in constant expressions and in; local structs.; - Correctly parse non-ascii identifiers that appe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:40384,Testability,assert,assertion,40384,ocal`` instead of ``_Thread_local``.; Fixes (`#70068 <https://github.com/llvm/llvm-project/issues/70068>`_) and; (`#69167 <https://github.com/llvm/llvm-project/issues/69167>`_); - Fix crash in evaluating invalid lambda expression which forget capture this.; Fixes (`#67687 <https://github.com/llvm/llvm-project/issues/67687>`_); - Fix crash from constexpr evaluator evaluating uninitialized arrays as rvalue.; Fixes (`#67317 <https://github.com/llvm/llvm-project/issues/67317>`_); - Clang now properly diagnoses use of stand-alone OpenMP directives after a; label (including ``case`` or ``default`` labels).; - Fix compiler memory leak for enums with underlying type larger than 64 bits.; Fixes (`#78311 <https://github.com/llvm/llvm-project/pull/78311>`_). Before:. .. code-block:: c++. label:; #pragma omp barrier // ok. After:. .. code-block:: c++. label:; #pragma omp barrier // error: '#pragma omp barrier' cannot be an immediate substatement. - Fixed an issue that a benign assertion might hit when instantiating a pack expansion; inside a lambda. (`#61460 <https://github.com/llvm/llvm-project/issues/61460>`_); - Fix crash during instantiation of some class template specializations within class; templates. Fixes (`#70375 <https://github.com/llvm/llvm-project/issues/70375>`_); - Fix crash during code generation of C++ coroutine initial suspend when the return; type of await_resume is not trivially destructible.; Fixes (`#63803 <https://github.com/llvm/llvm-project/issues/63803>`_); - ``__is_trivially_relocatable`` no longer returns true for non-object types; such as references and functions.; Fixes (`#67498 <https://github.com/llvm/llvm-project/issues/67498>`_); - Fix crash when the object used as a ``static_assert`` message has ``size`` or ``data`` members; which are not member functions.; - Support UDLs in ``static_assert`` message.; - Fixed false positive error emitted by clang when performing qualified name; lookup and the current class instantiation has dependent bases.; F,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43339,Testability,assert,assertion,43339,://github.com/llvm/llvm-project/issues/39319>`_) and; (`#60182 <https://github.com/llvm/llvm-project/issues/60182>`_) and; (`#62157 <https://github.com/llvm/llvm-project/issues/62157>`_) and; (`#64885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues/69987>`_); - Fix an issue where CTAD fails for explicit type conversion.; Fixes (`#64347 <https://github.com/llvm/llvm-project/issues/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issue,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43535,Testability,assert,assertion,43535,4885 <https://github.com/llvm/llvm-project/issues/64885>`_) and; (`#65568 <https://github.com/llvm/llvm-project/issues/65568>`_); - Fix an issue where clang doesn't respect detault template arguments that; are added in a later redeclaration for CTAD.; Fixes (`#69987 <https://github.com/llvm/llvm-project/issues/69987>`_); - Fix an issue where CTAD fails for explicit type conversion.; Fixes (`#64347 <https://github.com/llvm/llvm-project/issues/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding d,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:43952,Testability,assert,assertion,43952,es/64347>`_); - Fix crash when using C++ only tokens like ``::`` in C compiler clang.; Fixes (`#73559 <https://github.com/llvm/llvm-project/issues/73559>`_); - Clang now accepts recursive non-dependent calls to functions with deduced; return type.; Fixes (`#71015 <https://github.com/llvm/llvm-project/issues/71015>`_); - Fix assertion failure when initializing union containing struct with; flexible array member using empty initializer list.; Fixes (`#77085 <https://github.com/llvm/llvm-project/issues/77085>`_); - Fix assertion crash due to failed scope restoring caused by too-early VarDecl; invalidation by invalid initializer Expr.; Fixes (`#30908 <https://github.com/llvm/llvm-project/issues/30908>`_); - Clang now emits correct source location for code-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expr,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:44757,Testability,assert,assertion,44757,"-coverage regions in `if constexpr`; and `if consteval` branches. Untaken branches are now skipped.; Fixes (`#54419 <https://github.com/llvm/llvm-project/issues/54419>`_); - Fix assertion failure when declaring a template friend function with; a constrained parameter in a template class that declares a class method; or lambda at different depth.; Fixes (`#75426 <https://github.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagno",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45537,Testability,assert,assertion,45537,"hes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can capture this.; Fixes (`#71976 <https://github.com/llvm/llvm-project/issues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45907,Testability,log,logical-operand,45907,"s/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can capture this.; Fixes (`#71976 <https://github.com/llvm/llvm-project/issues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified by `-fconstexpr-steps`.; (`#63562 <https://github.com/llvm/llvm-project/issues/63562>`_). - Fix a crash caused by some named unicode escape sequences designating; a Unicode character whose name contains a ``-``.; (Fixes `#64161 <https://github.com/llvm/llvm-project/issues/64161>`_). - Fix cases where we ignore ambiguous name lookup when looking up member",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45929,Testability,log,logical,45929,"s/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can capture this.; Fixes (`#71976 <https://github.com/llvm/llvm-project/issues/71976>`_). Bug Fixes to Compiler Builtins; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to Attribute Support; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Bug Fixes to C++ Support; ^^^^^^^^^^^^^^^^^^^^^^^^. - Clang limits the size of arrays it will try to evaluate at compile time; to avoid memory exhaustion.; This limit can be modified by `-fconstexpr-steps`.; (`#63562 <https://github.com/llvm/llvm-project/issues/63562>`_). - Fix a crash caused by some named unicode escape sequences designating; a Unicode character whose name contains a ``-``.; (Fixes `#64161 <https://github.com/llvm/llvm-project/issues/64161>`_). - Fix cases where we ignore ambiguous name lookup when looking up member",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:49979,Testability,assert,asserts,49979,nitializer of a static data member.; (`#65985 <https://github.com/llvm/llvm-project/issues/65985>`_).; - Clang now properly converts static lambda call operator to function; pointers on win32.; (`#62594 <https://github.com/llvm/llvm-project/issues/62594>`_). - Fixed some cases where the source location for an instantiated specialization; of a function template or a member function of a class template was assigned; the location of a non-defining declaration rather than the location of the; definition the specialization was instantiated from.; (`#26057 <https://github.com/llvm/llvm-project/issues/26057>`_). - Fix a crash when a default member initializer of a base aggregate; makes an invalid call to an immediate function.; (`#66324 <https://github.com/llvm/llvm-project/issues/66324>`_). - Fix crash for a lambda attribute with a statement expression; that contains a `return`.; (`#48527 <https://github.com/llvm/llvm-project/issues/48527>`_). - Clang now no longer asserts when an UnresolvedLookupExpr is used as an; expression requirement. (`#66612 <https://github.com/llvm/llvm-project/issues/66612>`_). - Clang now disambiguates NTTP types when printing diagnostics where the; NTTP types are compared with the 'diff' method.; (`#66744 <https://github.com/llvm/llvm-project/issues/66744>`_). - Fix crash caused by a spaceship operator returning a comparision category by; reference. Fixes:; (`#64162 <https://github.com/llvm/llvm-project/issues/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:54943,Testability,test,test,54943,te; parameters. Fixes:; (`#57410 <https://github.com/llvm/llvm-project/issues/57410>`_) and; (`#76604 <https://github.com/llvm/llvm-project/issues/57410>`_). - Fix a bug where clang would produce inconsistent values when; ``std::source_location::current()`` was used in a function template.; Fixes (`#78128 <https://github.com/llvm/llvm-project/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload se,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:59017,Testability,test,testing,59017," another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albeit incomplete changes. The ``_OPENACC`` macro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-reference (byref) in stead of pass-by-value (byval) for struct; arguments in C ABI. Callee is responsible for allocating stack memory and; copying the value of the struct if modified. Note that AMDGPU backend still; supports byval for struct arguments.; - The default value for ``-mcode-object-version`` is now 5.; See `AMDHSA Code Object V5 Metadata <https://llvm.org/docs/AMDGPUUsage.html#code-object-v5-metadata>`_; for more details. X86 Support; ^^^^^^^^^^^. - Added option ``-m[no-]evex512`` to disable ZMM and 64-bit mask instructions; for AVX512 features.; - Support ISA of ``USER_MSR``.; * Support intrinsic of ``_urdmsr``.; * Support intrinsic of ``_uwrmsr``.; - Support ISA of ``AVX10.1``.; - ``-march=pantherlake`` and ``-march=clearwaterforest`` ar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:62620,Testability,assert,assertion,62620," target-specific runtime and standard libraries in directories named after the; target (e.g. if you're building with ``--target=aarch64-none-linux-android21``,; Clang will look for ``lib/aarch64-none-linux-android21`` under its resource; directory to find runtime libraries). If an exact match isn't found, Clang; would previously fall back to a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:62964,Testability,stub,stubs,62964,"o a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:71161,Testability,test,testing,71161,"through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary object fields.; (`#66221 <https://github.com/llvm/llvm-project/issues/66221>`_). - A few crashes have been found and fixed using randomized testing related; to the use of ``_BitInt()`` in tidy checks and in clang analysis.; (`#67212 <https://github.com/llvm/llvm-project/pull/67212>`_,; `#66782 <https://github.com/llvm/llvm-project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-project/pull/65888>`_,; `#65887 <https://github.com/llvm/llvm-project/pull/65887>`_). - Fixed note links of the HTML output.; (`#64054 <https://github.com/llvm/llvm-project/issues/64054>`_). - Allow widening rage-based for loops.; (`#70190 <https://github.com/llvm/llvm-project/pull/70190>`_). - Fixed uninitialized base class with initializer list when ctor is not; declared in the base class.; (`#70464 <https://github.com/llvm/llvm-project/issues/70464>`_,; `#59493 <https://github.com/llvm/llvm-project/issues/59493>`_,; `#54533 <https://github.com/llvm/llvm-project/issues/54533>`_). - Fixed an ``alpha.unix.cstring`` crash on variadic functions.; (`#74269 <https://github.com/llvm/llvm-project/is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:6104,Usability,learn,learn,6104,"the old manglings if ``-fclang-abi-compat=17`` or lower is; specified.; (`#48216 <https://github.com/llvm/llvm-project/issues/48216>`_),; (`#49884 <https://github.com/llvm/llvm-project/issues/49884>`_), and; (`#61273 <https://github.com/llvm/llvm-project/issues/61273>`_). - The `ClassScopeFunctionSpecializationDecl` AST node has been removed.; Dependent class scope explicit function template specializations now use; `DependentFunctionTemplateSpecializationInfo` to store candidate primary; templates and explicit template arguments. This should not impact users of; Clang as a compiler, but it may break assumptions in Clang-based tools; iterating over the AST. - The warning `-Wenum-constexpr-conversion` is now also enabled by default on; system headers and macros. It will be turned into a hard (non-downgradable); error in the next Clang release. - The flag `-fdelayed-template-parsing` won't be enabled by default with C++20; when targetting MSVC to match the behavior of MSVC.; (`MSVC Docs <https://learn.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170>`_). - Remove the hardcoded path to the imported modules for C++20 named modules. Now we; require all the dependent modules to specified from the command line.; See (`#62707 <https://github.com/llvm/llvm-project/issues/62707>`_). - Forbid `import XXX;` in C++ to find module `XXX` comes from explicit clang modules.; See (`#64755 <https://github.com/llvm/llvm-project/issues/64755>`_). ABI Changes in This Version; ---------------------------; - Following the SystemV ABI for x86-64, ``__int128`` arguments will no longer; be split between a register and a stack slot. - Fixed Microsoft calling convention for returning certain classes with a; templated constructor. If a class has a templated constructor, it should; be returned indirectly even if it meets all the other requirements for; returning a class in a register. This affects some uses of std::pair.; (#GH86384). AST Dumping Potentially Br",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:14839,Usability,undo,undocumented,14839,"by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_size(N)))`` or ARM NEON's vector types; (e.g., ``uint16x8_t``), this returns the constant number of elements at compile-time.; For scalable vectors, e.g., SVE or RISC-V V, the number of elements is not known at compile-time and is; determined at runtime.; * The ``__datasizeof`` keyword has been added. It is similar to ``sizeof``; except that it returns the size of a type ignoring tail padding.; * ``__builtin_classify_type()`` now classifies ``_BitInt`` values as the return value ``18``; and vector types as return value ``19``, to match GCC 14's behavior.; * The default value of `_MSC_VER` was raised from 1920 to 1933.; * Since MSVC 19.33 added undocumented attribute ``[[msvc::constexpr]]``, this release adds the attribute as well. * Added ``#pragma clang fp reciprocal``. * The version of Unicode used by Clang (primarily to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51228,Usability,guid,guide,51228,"ared with the 'diff' method.; (`#66744 <https://github.com/llvm/llvm-project/issues/66744>`_). - Fix crash caused by a spaceship operator returning a comparision category by; reference. Fixes:; (`#64162 <https://github.com/llvm/llvm-project/issues/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:51422,Usability,guid,guides,51422,"/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:52009,Usability,guid,guides,52009,"causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expressi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:53213,Usability,guid,guides,53213,tps://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expression.; Fixes: (`#72025 <https://github.com/llvm/llvm-project/issues/72025>`_). - Clang now defers the instantiation of explicit specifier until constraint checking; completes (except deduction guides). Fixes:; (`#59827 <https://github.com/llvm/llvm-project/issues/59827>`_). - Fix crash when parsing nested requirement. Fixes:; (`#73112 <https://github.com/llvm/llvm-project/issues/73112>`_). - Fixed a crash caused by using return type requirement in a lambda. Fixes:; (`#63808 <https://github.com/llvm/llvm-project/issues/63808>`_); (`#64607 <https://github.com/llvm/llvm-project/issues/64607>`_); (`#64086 <https://github.com/llvm/llvm-project/issues/64086>`_). - Fixed a crash where we lost uninstantiated constraints on placeholder NTTP packs. Fixes:; (`#63837 <https://github.com/llvm/llvm-project/issues/63837>`_). - Fixed a regression where clang forgets how to substitute into constraints on template-template; parameters. Fixes:; (`#57410 <https://github.com/llvm/llvm-project/issues/57410>`_) and; (`#76604 <https://github.com/llvm/llvm-project/issues/57410>`_). - Fix a bug where clang would produce inconsistent values when; ``,MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:58164,Usability,guid,guides,58164,"com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albeit incomplete changes. The ``_OPENACC`` macro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implemen",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:59955,Usability,clear,clearwaterforest,59955,"o be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-reference (byref) in stead of pass-by-value (byval) for struct; arguments in C ABI. Callee is responsible for allocating stack memory and; copying the value of the struct if modified. Note that AMDGPU backend still; supports byval for struct arguments.; - The default value for ``-mcode-object-version`` is now 5.; See `AMDHSA Code Object V5 Metadata <https://llvm.org/docs/AMDGPUUsage.html#code-object-v5-metadata>`_; for more details. X86 Support; ^^^^^^^^^^^. - Added option ``-m[no-]evex512`` to disable ZMM and 64-bit mask instructions; for AVX512 features.; - Support ISA of ``USER_MSR``.; * Support intrinsic of ``_urdmsr``.; * Support intrinsic of ``_uwrmsr``.; - Support ISA of ``AVX10.1``.; - ``-march=pantherlake`` and ``-march=clearwaterforest`` are now supported.; - Added ABI handling for ``__float128`` to match with GCC.; - Emit warnings for options to enable knl/knm specific ISAs: AVX512PF, AVX512ER; and PREFETCHWT1. From next version (LLVM 19), these ISAs' intrinsic supports; will be deprecated:; * intrinsic series of *_exp2a23_*; * intrinsic series of *_rsqrt28_*; * intrinsic series of *_rcp28_*; * intrinsic series of *_prefetch_i[3|6][2|4]gather_*; * intrinsic series of *_prefetch_i[3|6][2|4]scatter_*. Arm and AArch64 Support; ^^^^^^^^^^^^^^^^^^^^^^^. - C++ function name mangling has been changed to align with the specification; (https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst).; This affects C++ functions with SVE ACLE parameters. Clang will use the old; manglings if ``-fclang-abi-compat=17`` or lower is specified. - New AArch64 asm constraints have been added for r8-r11(Uci) and r12-r15(Ucj). - Support has been added for the following processors (-mcpu identifiers in parenthesis",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5519,Availability,fault,fault,5519,"ecise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5566,Availability,avail,available,5566,"ecise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7132,Availability,error,errors,7132,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2151,Energy Efficiency,adapt,adaption,2151," frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3398,Energy Efficiency,allocate,allocated,3398," linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in tur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6339,Integrability,depend,depending,6339,"), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:427,Modifiability,variab,variables,427,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1056,Modifiability,variab,variables,1056,"=========. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1412,Modifiability,variab,variables,1412,"; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1641,Modifiability,variab,variables,1641,"er overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compile",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2151,Modifiability,adapt,adaption,2151," frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2939,Modifiability,variab,variables,2939,"ck. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces corr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7004,Modifiability,variab,variables,7004,"ack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an al",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7161,Modifiability,variab,variables,7161,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7294,Modifiability,variab,variables,7294,"ute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:230,Performance,perform,performance,230,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:786,Performance,perform,performance,786,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1318,Performance,perform,performance,1318,"wo distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2515,Performance,load,load,2515,"the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:326,Safety,safe,safe,326,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:345,Safety,unsafe,unsafe,345,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:363,Safety,safe,safe,363,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:467,Safety,safe,safe,467,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:488,Safety,unsafe,unsafe,488,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:579,Safety,unsafe,unsafe,579,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:637,Safety,safe,safe,637,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1083,Safety,unsafe,unsafe,1083,"=========. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1121,Safety,unsafe,unsafe,1121,"=========. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1178,Safety,unsafe,unsafe,1178,"ng any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-swee",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1371,Safety,unsafe,unsafe,1371,"; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1502,Safety,safe,safe,1502,"er overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compile",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2356,Safety,safe,safe,2356,"ormance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulne",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2365,Safety,unsafe,unsafe,2365,"ormance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulne",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2714,Safety,unsafe,unsafe,2714,"dividual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2763,Safety,safe,safe-stack,2763,"dividual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2980,Safety,safe,safe,2980,"ck. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces corr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3023,Safety,safe,safe,3023,"ck. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces corr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3047,Safety,safe,safe,3047,"lations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity prote",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3154,Safety,unsafe,unsafe,3154,"lations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity prote",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3217,Safety,safe,safe,3217,"lations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity prote",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3262,Safety,safe,safe,3262," linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in tur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3384,Safety,safe,safe,3384," linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in tur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3485,Safety,safe,safe,3485," linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in tur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3528,Safety,safe,safe,3528," linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in tur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3819,Safety,unsafe,unsafe,3819,"te__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4325,Safety,unsafe,unsafe,4325,"ization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4812,Safety,safe,safe,4812,"sm that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5049,Safety,safe,safe,5049,"sm that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5105,Safety,detect,detected,5105,"lls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, Fre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5351,Safety,safe,safe,5351,"unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5463,Safety,safe,safe,5463,"ecise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6030,Safety,safe,safe-stack,6030,"uld leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6584,Safety,safe,safe-stack,6584,"; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6684,Safety,safe,safe-stack,6684,"uld; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_sta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6748,Safety,safe,safe,6748,"uld; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_sta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6859,Safety,safe,safe-stack,6859,"uld; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_sta",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7069,Safety,safe,safe,7069,"ack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an al",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7086,Safety,safe,safe,7086,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7247,Safety,safe,safe,7247,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7507,Safety,unsafe,unsafe,7507,"de that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling; -----------------------------. The `OSDI'14 paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ mentions that; on Linux the instrumentation pass finds calls to setjmp or functions that; may throw ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7699,Safety,unsafe,unsafe,7699,"fe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling; -----------------------------. The `OSDI'14 paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ mentions that; on Linux the instrumentation pass finds calls to setjmp or functions that; may throw an exception, and inserts required instrumentation at their call; sites. Specifically, the instrumentation pass saves the shadow stack pointer; on the safe stack before the cal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7874,Safety,unsafe,unsafe,7874,"e-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling; -----------------------------. The `OSDI'14 paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ mentions that; on Linux the instrumentation pass finds calls to setjmp or functions that; may throw an exception, and inserts required instrumentation at their call; sites. Specifically, the instrumentation pass saves the shadow stack pointer; on the safe stack before the call site, and restores it either after the; call to setjmp or after an exception has been caught. This is implemented; in the function ``SafeStack::createStackRestorePoints``. Pub",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:8661,Safety,safe,safe,8661," taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epfl.ch/research/cpi/>`__; project page for more information about the design of the SafeStack and its; related technologies. setjmp and exception handling; -----------------------------. The `OSDI'14 paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ mentions that; on Linux the instrumentation pass finds calls to setjmp or functions that; may throw an exception, and inserts required instrumentation at their call; sites. Specifically, the instrumentation pass saves the shadow stack pointer; on the safe stack before the call site, and restores it either after the; call to setjmp or after an exception has been caught. This is implemented; in the function ``SafeStack::createStackRestorePoints``. Publications; ------------. `Code-Pointer Integrity <https://dslab.epfl.ch/pubs/cpi.pdf>`__.; Volodymyr Kuznetsov, Laszlo Szekeres, Mathias Payer, George Candea, R. Sekar, Dawn Song.; USENIX Symposium on Operating Systems Design and Implementation; (`OSDI <https://www.usenix.org/conference/osdi14>`_), Broomfield, CO, October 2014; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:153,Security,attack,attacks,153,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:453,Security,access,accessed,453,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1551,Security,access,accessed,1551,"er overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compile",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2966,Security,access,accessed,2966,"ck. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces corr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3203,Security,access,accessed,3203,"lations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity prote",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3577,Security,secur,security,3577,"ing; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3677,Security,attack,attacks,3677,"te__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3756,Security,integrity,integrity,3756,"te__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3919,Security,integrity,integrity,3919,"; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4119,Security,integrity,integrity,4119,"k in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4263,Security,attack,attacker,4263,"ization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4786,Security,secur,security,4786,"e integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5203,Security,encrypt,encrypt,5203,"lls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, Fre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7144,Security,access,accessing,7144,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:7234,Security,access,accesses,7234,"SD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; these variables, so extra care must be taken to manually ensure that all such; accesses are safe. Furthermore, the addresses of such local variables should; never be stored on the heap, as it would leak the location of the SafeStack. ``__builtin___get_unsafe_stack_ptr()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns current unsafe stack pointer of the current; thread. ``__builtin___get_unsafe_stack_bottom()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the bottom of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_top()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This builtin function returns a pointer to the top of the unsafe stack of the; current thread. ``__builtin___get_unsafe_stack_start()``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Deprecated: This builtin function is an alias for; ``__builtin___get_unsafe_stack_bottom()``. Design; ======. Please refer to the `Code-Pointer Integrity <https://dslab.epf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:890,Testability,benchmark,benchmarks,890,"=========; SafeStack; =========. .. contents::; :local:. Introduction; ============. SafeStack is an instrumentation pass that protects programs against attacks; based on stack buffer overflows, without introducing any measurable performance; overhead. It works by separating the program stack into two distinct regions:; the safe stack and the unsafe stack. The safe stack stores return addresses,; register spills, and local variables that are always accessed in a safe way,; while the unsafe stack stores everything else. This separation ensures that; buffer overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not curr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:6145,Testability,test,tested,6145,"ented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, FreeBSD and macOS. Low-level API; -------------. ``__has_feature(safe_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some rare cases one may need to execute different code depending on; whether SafeStack is enabled. The macro ``__has_feature(safe_stack)`` can; be used for this purpose. .. code-block:: c. #if __has_feature(safe_stack); // code that builds only under SafeStack; #endif. ``__attribute__((no_sanitize(""safe-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""safe-stack"")))`` on a function declaration; to specify that the safe stack instrumentation should not be applied to that; function, even if enabled globally (see ``-fsanitize=safe-stack`` flag). This; attribute may be required for functions that make assumptions about the; exact layout of their stack frames. All local variables in functions with this attribute will be stored on the safe; stack. The safe stack remains unprotected against memory errors when accessing; thes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SafeStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:7895,Availability,redundant,redundant,7895,"function entry block, 0 otherwise.; }. Tracing PCs; ===========. With ``-fsanitize-coverage=trace-pc`` the compiler will insert; ``__sanitizer_cov_trace_pc()`` on every edge.; With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call.; These callbacks are not implemented in the Sanitizer run-time and should be defined; by the user.; This mechanism is used for fuzzing the Linux kernel; (https://github.com/google/syzkaller). Instrumentation points; ======================; Sanitizer Coverage offers different levels of instrumentation. * ``edge`` (default): edges are instrumented (see below).; * ``bb``: basic blocks are instrumented.; * ``func``: only the entry block of every function will be instrumented. Use these flags together with ``trace-pc-guard`` or ``trace-pc``,; like this: ``-fsanitize-coverage=func,trace-pc-guard``. When ``edge`` or ``bb`` is used, some of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:2250,Performance,optimiz,optimizations,2250,"_indirect(void *callee)`` will be inserted on every indirect call. The functions `__sanitizer_cov_trace_pc_*` should be defined by the user. Example:. .. code-block:: c++. // trace-pc-guard-cb.cc; #include <stdint.h>; #include <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) return; // Initialize only once.; printf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, size",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:9303,Performance,load,loads,9303,"hat the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the comparison instructions; will not be instrumented. .. code-block:: c++. // Called before a comparison instruction.; // Arg1 and Arg2 are arguments of the comparison.; void __sanitizer_cov_trace_cmp1(uint8_t Arg1, uint8_t Arg2);; void __sanitizer_cov_trace_cmp2(uint16_t Arg1, uint16_t Arg2);; void __sanitizer_cov_trace_cmp4(uint32_t Arg1, uint32_t Arg2);; void __sanitizer_cov_trace_cmp8(uint64_t Arg1, uint64_t Arg2);. // Called before a comparison instruction if exactly one of the arguments is constant.; // Arg1 and Arg2 are arguments of the comparison, Arg1 is a compile-time constant.; // These callbacks are emitted by -fsanitize-coverage=trace-cmp since 2017-08-11; void __sanitizer_cov_trace_const_cmp1(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:9382,Performance,load,loads,9382,"hat the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the comparison instructions; will not be instrumented. .. code-block:: c++. // Called before a comparison instruction.; // Arg1 and Arg2 are arguments of the comparison.; void __sanitizer_cov_trace_cmp1(uint8_t Arg1, uint8_t Arg2);; void __sanitizer_cov_trace_cmp2(uint16_t Arg1, uint16_t Arg2);; void __sanitizer_cov_trace_cmp4(uint32_t Arg1, uint32_t Arg2);; void __sanitizer_cov_trace_cmp8(uint64_t Arg1, uint64_t Arg2);. // Called before a comparison instruction if exactly one of the arguments is constant.; // Arg1 and Arg2 are arguments of the comparison, Arg1 is a compile-time constant.; // These callbacks are emitted by -fsanitize-coverage=trace-cmp since 2017-08-11; void __sanitizer_cov_trace_const_cmp1(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:11177,Performance,load,load,11177,", Arg1 is a compile-time constant.; // These callbacks are emitted by -fsanitize-coverage=trace-cmp since 2017-08-11; void __sanitizer_cov_trace_const_cmp1(uint8_t Arg1, uint8_t Arg2);; void __sanitizer_cov_trace_const_cmp2(uint16_t Arg1, uint16_t Arg2);; void __sanitizer_cov_trace_const_cmp4(uint32_t Arg1, uint32_t Arg2);; void __sanitizer_cov_trace_const_cmp8(uint64_t Arg1, uint64_t Arg2);. // Called before a switch statement.; // Val is the switch operand.; // Cases[0] is the number of case constants.; // Cases[1] is the size of Val in bits.; // Cases[2:] are the case constants.; void __sanitizer_cov_trace_switch(uint64_t Val, uint64_t *Cases);. // Called before a division statement.; // Val is the second argument of division.; void __sanitizer_cov_trace_div4(uint32_t Val);; void __sanitizer_cov_trace_div8(uint64_t Val);. // Called before a GetElemementPtr (GEP) instruction; // for every non-constant array index.; void __sanitizer_cov_trace_gep(uintptr_t Idx);. // Called before a load of appropriate size. Addr is the address of the load.; void __sanitizer_cov_load1(uint8_t *addr);; void __sanitizer_cov_load2(uint16_t *addr);; void __sanitizer_cov_load4(uint32_t *addr);; void __sanitizer_cov_load8(uint64_t *addr);; void __sanitizer_cov_load16(__int128 *addr);; // Called before a store of appropriate size. Addr is the address of the store.; void __sanitizer_cov_store1(uint8_t *addr);; void __sanitizer_cov_store2(uint16_t *addr);; void __sanitizer_cov_store4(uint32_t *addr);; void __sanitizer_cov_store8(uint64_t *addr);; void __sanitizer_cov_store16(__int128 *addr);. Tracing control flow; ====================. With ``-fsanitize-coverage=control-flow`` the compiler will create a table to collect; control flow for each function. More specifically, for each basic block in the function,; two lists are populated. One list for successors of the basic block and another list for; non-intrinsic called functions. **TODO:** in the current implementation, indirect calls are not ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:11230,Performance,load,load,11230,"These callbacks are emitted by -fsanitize-coverage=trace-cmp since 2017-08-11; void __sanitizer_cov_trace_const_cmp1(uint8_t Arg1, uint8_t Arg2);; void __sanitizer_cov_trace_const_cmp2(uint16_t Arg1, uint16_t Arg2);; void __sanitizer_cov_trace_const_cmp4(uint32_t Arg1, uint32_t Arg2);; void __sanitizer_cov_trace_const_cmp8(uint64_t Arg1, uint64_t Arg2);. // Called before a switch statement.; // Val is the switch operand.; // Cases[0] is the number of case constants.; // Cases[1] is the size of Val in bits.; // Cases[2:] are the case constants.; void __sanitizer_cov_trace_switch(uint64_t Val, uint64_t *Cases);. // Called before a division statement.; // Val is the second argument of division.; void __sanitizer_cov_trace_div4(uint32_t Val);; void __sanitizer_cov_trace_div8(uint64_t Val);. // Called before a GetElemementPtr (GEP) instruction; // for every non-constant array index.; void __sanitizer_cov_trace_gep(uintptr_t Idx);. // Called before a load of appropriate size. Addr is the address of the load.; void __sanitizer_cov_load1(uint8_t *addr);; void __sanitizer_cov_load2(uint16_t *addr);; void __sanitizer_cov_load4(uint32_t *addr);; void __sanitizer_cov_load8(uint64_t *addr);; void __sanitizer_cov_load16(__int128 *addr);; // Called before a store of appropriate size. Addr is the address of the store.; void __sanitizer_cov_store1(uint8_t *addr);; void __sanitizer_cov_store2(uint16_t *addr);; void __sanitizer_cov_store4(uint32_t *addr);; void __sanitizer_cov_store8(uint64_t *addr);; void __sanitizer_cov_store16(__int128 *addr);. Tracing control flow; ====================. With ``-fsanitize-coverage=control-flow`` the compiler will create a table to collect; control flow for each function. More specifically, for each basic block in the function,; two lists are populated. One list for successors of the basic block and another list for; non-intrinsic called functions. **TODO:** in the current implementation, indirect calls are not tracked; and are only marked with speci",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:7895,Safety,redund,redundant,7895,"function entry block, 0 otherwise.; }. Tracing PCs; ===========. With ``-fsanitize-coverage=trace-pc`` the compiler will insert; ``__sanitizer_cov_trace_pc()`` on every edge.; With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call.; These callbacks are not implemented in the Sanitizer run-time and should be defined; by the user.; This mechanism is used for fuzzing the Linux kernel; (https://github.com/google/syzkaller). Instrumentation points; ======================; Sanitizer Coverage offers different levels of instrumentation. * ``edge`` (default): edges are instrumented (see below).; * ``bb``: basic blocks are instrumented.; * ``func``: only the entry block of every function will be instrumented. Use these flags together with ``trace-pc-guard`` or ``trace-pc``,; like this: ``-fsanitize-coverage=func,trace-pc-guard``. When ``edge`` or ``bb`` is used, some of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:1463,Security,sanitiz,sanitizer,1463,":`SourceBasedCodeCoverage <SourceBasedCodeCoverage>` instead. Tracing PCs with guards; =======================. With ``-fsanitize-coverage=trace-pc-guard`` the compiler will insert the following code; on every edge:. .. code-block:: none. __sanitizer_cov_trace_pc_guard(&guard_variable). Every edge will have its own `guard_variable` (uint32_t). The compiler will also insert calls to a module constructor:. .. code-block:: c++. // The guards are [start, stop).; // This function will be called at least once per DSO and may be called; // more than once with the same values of start/stop.; __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);. With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call. The functions `__sanitizer_cov_trace_pc_*` should be defined by the user. Example:. .. code-block:: c++. // trace-pc-guard-cb.cc; #include <stdint.h>; #include <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) return; // Initialize only once.; printf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:3079,Security,sanitiz,sanitizer,3079,"tf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, sizeof(PcDescr));; printf(""guard: %p %x PC %s\n"", guard, *guard, PcDescr);; }. .. code-block:: c++. // trace-pc-guard-example.cc; void foo() { }; int main(int argc, char **argv) {; if (argc > 1) foo();; }. .. code-block:: console. clang++ -g -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c; clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address; ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2; guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7. .. code-block:: console. ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3; guard: 0x71bcdc ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:3150,Security,sanitiz,sanitizer,3150,"Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, sizeof(PcDescr));; printf(""guard: %p %x PC %s\n"", guard, *guard, PcDescr);; }. .. code-block:: c++. // trace-pc-guard-example.cc; void foo() { }; int main(int argc, char **argv) {; if (argc > 1) foo();; }. .. code-block:: console. clang++ -g -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c; clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address; ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2; guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7. .. code-block:: console. ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3; guard: 0x71bcdc 4 PC 0x4ecdc7 in main trace-pc-guard-example.cc:4:17; guard: 0x71bcd0 1 PC 0x4ecd20 in fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:14318,Security,sanitiz,sanitizer,14318,"ns via the; function attribute ``__attribute__((no_sanitize(""coverage"")))``. Because this; attribute may not be supported by other compilers, it is recommended to use it; together with ``__has_feature(coverage_sanitizer)``. Disabling instrumentation without source modification; =====================================================. It is sometimes useful to tell SanitizerCoverage to instrument only a subset of the; functions in your target without modifying source files.; With ``-fsanitize-coverage-allowlist=allowlist.txt``; and ``-fsanitize-coverage-ignorelist=blocklist.txt``,; you can specify such a subset through the combination of an allowlist and a blocklist. SanitizerCoverage will only instrument functions that satisfy two conditions.; First, the function should belong to a source file with a path that is both allowlisted; and not blocklisted.; Second, the function should have a mangled name that is both allowlisted and not blocklisted. The allowlist and blocklist format is similar to that of the sanitizer blocklist format.; The default allowlist will match every source file and every function.; The default blocklist will match no source file and no function. A common use case is to have the allowlist list folders or source files for which you want; instrumentation and allow all function names, while the blocklist will opt out some specific; files or functions that the allowlist loosely allowed. Here is an example allowlist:. .. code-block:: none. # Enable instrumentation for a whole folder; src:bar/*; # Enable instrumentation for a specific source file; src:foo/a.cpp; # Enable instrumentation for all functions in those files; fun:*. And an example blocklist:. .. code-block:: none. # Disable instrumentation for a specific source file that the allowlist allowed; src:bar/b.cpp; # Disable instrumentation for a specific function that the allowlist allowed; fun:*myFunc*. The use of ``*`` wildcards above is required because function names are matched after mangling.;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:15867,Security,sanitiz,sanitizer,15867,"r all functions in those files; fun:*. And an example blocklist:. .. code-block:: none. # Disable instrumentation for a specific source file that the allowlist allowed; src:bar/b.cpp; # Disable instrumentation for a specific function that the allowlist allowed; fun:*myFunc*. The use of ``*`` wildcards above is required because function names are matched after mangling.; Without the wildcards, one would have to write the whole mangled name. Be careful that the paths of source files are matched exactly as they are provided on the clang; command line.; For example, the allowlist above would include file ``bar/b.cpp`` if the path was provided; exactly like this, but would it would fail to include it with other ways to refer to the same; file such as ``./bar/b.cpp``, or ``bar\b.cpp`` on Windows.; So, please make sure to always double check that your lists are correctly applied. Default implementation; ======================. The sanitizer run-time (AddressSanitizer, MemorySanitizer, etc) provide a; default implementations of some of the coverage callbacks.; You may use this implementation to dump the coverage on disk at the process; exit. Example:. .. code-block:: console. % cat -n cov.cc; 1 #include <stdio.h>; 2 __attribute__((noinline)); 3 void foo() { printf(""foo\n""); }; 4; 5 int main(int argc, char **argv) {; 6 if (argc == 2); 7 foo();; 8 printf(""main\n"");; 9 }; % clang++ -g cov.cc -fsanitize=address -fsanitize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:18093,Security,sanitiz,sanitizer,18093,"FFFFFFFFF64`` and ``0xC0BFFFFFFFFFFF32``. The last byte of the; magic defines the size of the following offsets. The rest of the data is the; offsets in the corresponding binary/DSO that were executed during the run. Sancov Tool; -----------. A simple ``sancov`` tool is provided to process coverage files.; The tool is part of LLVM project and is currently supported only on Linux.; It can handle symbolization tasks autonomously without any extra support; from the environment. You need to pass .sancov files (named; ``<module_name>.<pid>.sancov`` and paths to all corresponding binary elf files.; Sancov matches these files using module names and binaries file names. .. code-block:: console. USAGE: sancov [options] <action> (<binary file>|<.sancov file>)... Action (required); -print - Print coverage addresses; -covered-functions - Print all covered functions.; -not-covered-functions - Print all not covered functions.; -symbolize - Symbolizes the report. Options; -blocklist=<string> - Blocklist file (sanitizer blocklist format).; -demangle - Print demangled function name.; -strip_path_prefix=<string> - Strip this prefix from file paths in reports. Coverage Reports; ----------------. **Experimental**. ``.sancov`` files do not contain enough information to generate a source-level; coverage report. The missing information is contained; in debug info of the binary. Thus the ``.sancov`` has to be symbolized; to produce a ``.symcov`` file first:. .. code-block:: console. sancov -symbolize my_program.123.sancov my_program > my_program.123.symcov. The ``.symcov`` file can be browsed overlaid over the source code by; running ``tools/sancov/coverage-report-server.py`` script that will start; an HTTP server. Output directory; ----------------. By default, .sancov files are created in the current working directory.; This can be changed with ``ASAN_OPTIONS=coverage_dir=/path``:. .. code-block:: console. % ASAN_OPTIONS=""coverage=1:coverage_dir=/tmp/cov"" ./a.out foo; % ls -l /tmp/cov/*s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:120,Usability,simpl,simple,120,"=================; SanitizerCoverage; =================. .. contents::; :local:. Introduction; ============. LLVM has a simple code coverage instrumentation built in (SanitizerCoverage).; It inserts calls to user-defined functions on function-, basic-block-, and edge- levels.; Default implementations of those callbacks are provided and implement; simple coverage reporting and visualization,; however if you need *just* coverage visualization you may want to use; :doc:`SourceBasedCodeCoverage <SourceBasedCodeCoverage>` instead. Tracing PCs with guards; =======================. With ``-fsanitize-coverage=trace-pc-guard`` the compiler will insert the following code; on every edge:. .. code-block:: none. __sanitizer_cov_trace_pc_guard(&guard_variable). Every edge will have its own `guard_variable` (uint32_t). The compiler will also insert calls to a module constructor:. .. code-block:: c++. // The guards are [start, stop).; // This function will be called at least once per DSO and may be called; // more than once with the same values of start/stop.; __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);. With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call. The functions `__sanitizer_cov_trace_pc_*` should be defined by the user. Example:. .. code-block:: c++. // trace-pc-guard-cb.cc; #include <stdint.h>; #include <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:349,Usability,simpl,simple,349,"=================; SanitizerCoverage; =================. .. contents::; :local:. Introduction; ============. LLVM has a simple code coverage instrumentation built in (SanitizerCoverage).; It inserts calls to user-defined functions on function-, basic-block-, and edge- levels.; Default implementations of those callbacks are provided and implement; simple coverage reporting and visualization,; however if you need *just* coverage visualization you may want to use; :doc:`SourceBasedCodeCoverage <SourceBasedCodeCoverage>` instead. Tracing PCs with guards; =======================. With ``-fsanitize-coverage=trace-pc-guard`` the compiler will insert the following code; on every edge:. .. code-block:: none. __sanitizer_cov_trace_pc_guard(&guard_variable). Every edge will have its own `guard_variable` (uint32_t). The compiler will also insert calls to a module constructor:. .. code-block:: c++. // The guards are [start, stop).; // This function will be called at least once per DSO and may be called; // more than once with the same values of start/stop.; __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);. With an additional ``...=trace-pc,indirect-calls`` flag; ``__sanitizer_cov_trace_pc_indirect(void *callee)`` will be inserted on every indirect call. The functions `__sanitizer_cov_trace_pc_*` should be defined by the user. Example:. .. code-block:: c++. // trace-pc-guard-cb.cc; #include <stdint.h>; #include <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:2431,Usability,simpl,simple,2431,"ude <stdio.h>; #include <sanitizer/coverage_interface.h>. // This callback is inserted by the compiler as a module constructor; // into every DSO. 'start' and 'stop' correspond to the; // beginning and end of the section with the guards for the entire; // binary (executable or DSO). The callback will be called at least; // once per DSO and may be called multiple times with the same parameters.; extern ""C"" void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,; uint32_t *stop) {; static uint64_t N; // Counter for the guards.; if (start == stop || *start) return; // Initialize only once.; printf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, sizeof(PcDescr));; printf(""guard: %p %x PC %s\n"", guard, *guard, PcDescr);; }. .. code-block:: c++. // trace-pc-guard-example.cc; void foo() { }; int main(int argc, char **argv) {; if (argc > 1) foo();; }. .. code-block:: cons",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:4485,Usability,simpl,simply,4485,"ang++ -g -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c; clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address; ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2; guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7. .. code-block:: console. ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3; guard: 0x71bcdc 4 PC 0x4ecdc7 in main trace-pc-guard-example.cc:4:17; guard: 0x71bcd0 1 PC 0x4ecd20 in foo() trace-pc-guard-example.cc:2:14. Inline 8bit-counters; ====================. **Experimental, may change or disappear in future**. With ``-fsanitize-coverage=inline-8bit-counters`` the compiler will insert; inline counter increments on every edge.; This is similar to ``-fsanitize-coverage=trace-pc-guard`` but instead of a; callback the instrumentation simply increments a counter. Users need to implement a single function to capture the counters at startup. .. code-block:: c++. extern ""C""; void __sanitizer_cov_8bit_counters_init(char *start, char *end) {; // [start,end) is the array of 8-bit counters created for the current DSO.; // Capture this array in order to read/modify the counters.; }. Inline bool-flag; ================. **Experimental, may change or disappear in future**. With ``-fsanitize-coverage=inline-bool-flag`` the compiler will insert; setting an inline boolean to true on every edge.; This is similar to ``-fsanitize-coverage=inline-8bit-counter`` but instead of; an increment of a counter, it just sets a boolean to true. Users need to implement a single function to capture the flags at startup. .. code-block:: c++. extern ""C""; void __sanitizer_cov_bool_flag_init(bool *start, bool *end) {; // [start,end) is the array of boolean flags created for the current DSO.; // Capture this arr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:8583,Usability,simpl,simply,8583,"nstrumented. Use these flags together with ``trace-pc-guard`` or ``trace-pc``,; like this: ``-fsanitize-coverage=func,trace-pc-guard``. When ``edge`` or ``bb`` is used, some of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:8796,Usability,guid,guided,8796,"e of the edges/blocks may still be left; uninstrumented (pruned) if such instrumentation is considered redundant.; Use ``no-prune`` (e.g. ``-fsanitize-coverage=bb,no-prune,trace-pc-guard``); to disable pruning. This could be useful for better coverage visualization. Edge coverage; -------------. Consider this code:. .. code-block:: c++. void foo(int *a) {; if (a); *a = 0;; }. It contains 3 basic blocks, let's name them A, B, C:. .. code-block:: none. A; |\; | \; | B; | /; |/; C. If blocks A, B, and C are all covered we know for certain that the edges A=>B; and B=>C were executed, but we still don't know if the edge A=>C was executed.; Such edges of control flow graph are called; `critical <https://en.wikipedia.org/wiki/Control_flow_graph#Special_edges>`_.; The edge-level coverage simply splits all critical edges by introducing new; dummy blocks and then instruments those blocks:. .. code-block:: none. A; |\; | \; D B; | /; |/; C. Tracing data flow; =================. Support for data-flow-guided fuzzing.; With ``-fsanitize-coverage=trace-cmp`` the compiler will insert extra instrumentation; around comparison instructions and switch statements.; Similarly, with ``-fsanitize-coverage=trace-div`` the compiler will instrument; integer division instructions (to capture the right argument of division); and with ``-fsanitize-coverage=trace-gep`` --; the `LLVM GEP instructions <https://llvm.org/docs/GetElementPtr.html>`_; (to capture array indices).; Similarly, with ``-fsanitize-coverage=trace-loads`` and ``-fsanitize-coverage=trace-stores``; the compiler will instrument loads and stores, respectively. Currently, these flags do not work by themselves - they require one; of ``-fsanitize-coverage={trace-pc,inline-8bit-counters,inline-bool}``; flags to work. Unless ``no-prune`` option is provided, some of the comparison instructions; will not be instrumented. .. code-block:: c++. // Called before a comparison instruction.; // Arg1 and Arg2 are arguments of the comparison.; voi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:17026,Usability,simpl,simple,17026,"he process; exit. Example:. .. code-block:: console. % cat -n cov.cc; 1 #include <stdio.h>; 2 __attribute__((noinline)); 3 void foo() { printf(""foo\n""); }; 4; 5 int main(int argc, char **argv) {; 6 if (argc == 2); 7 foo();; 8 printf(""main\n"");; 9 }; % clang++ -g cov.cc -fsanitize=address -fsanitize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created for every DSO. Sancov data format; ------------------. The format of ``*.sancov`` files is very simple: the first 8 bytes is the magic,; one of ``0xC0BFFFFFFFFFFF64`` and ``0xC0BFFFFFFFFFFF32``. The last byte of the; magic defines the size of the following offsets. The rest of the data is the; offsets in the corresponding binary/DSO that were executed during the run. Sancov Tool; -----------. A simple ``sancov`` tool is provided to process coverage files.; The tool is part of LLVM project and is currently supported only on Linux.; It can handle symbolization tasks autonomously without any extra support; from the environment. You need to pass .sancov files (named; ``<module_name>.<pid>.sancov`` and paths to all corresponding binary elf files.; Sancov matches these files using module names and binaries file names. .. code-block:: console. USAGE: sancov [options] <action> (<binary file>|<.sancov file>)... Action (required); -print - Print coverage addresses; -covered-functions - Print all covered functions.; -not-covered-functions - Print all not covered functions.; -symbolize - Symbolizes the report. Options; -blocklis",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:17328,Usability,simpl,simple,17328,"itize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created for every DSO. Sancov data format; ------------------. The format of ``*.sancov`` files is very simple: the first 8 bytes is the magic,; one of ``0xC0BFFFFFFFFFFF64`` and ``0xC0BFFFFFFFFFFF32``. The last byte of the; magic defines the size of the following offsets. The rest of the data is the; offsets in the corresponding binary/DSO that were executed during the run. Sancov Tool; -----------. A simple ``sancov`` tool is provided to process coverage files.; The tool is part of LLVM project and is currently supported only on Linux.; It can handle symbolization tasks autonomously without any extra support; from the environment. You need to pass .sancov files (named; ``<module_name>.<pid>.sancov`` and paths to all corresponding binary elf files.; Sancov matches these files using module names and binaries file names. .. code-block:: console. USAGE: sancov [options] <action> (<binary file>|<.sancov file>)... Action (required); -print - Print coverage addresses; -covered-functions - Print all covered functions.; -not-covered-functions - Print all not covered functions.; -symbolize - Symbolizes the report. Options; -blocklist=<string> - Blocklist file (sanitizer blocklist format).; -demangle - Print demangled function name.; -strip_path_prefix=<string> - Strip this prefix from file paths in reports. Coverage Reports; ----------------. **Experimental**. ``.sancov`` files do not contain enough information to gener",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:1237,Availability,error,error,1237,"r certain source-level entities by providing a special; file at compile-time. Goal and usage; ==============. Users of sanitizer tools, such as :doc:`AddressSanitizer`, :doc:`ThreadSanitizer`; or :doc:`MemorySanitizer` may want to disable or alter some checks for; certain source-level entities to:. * speedup hot function, which is known to be correct;; * ignore a function that does some low-level magic (e.g. walks through the; thread stack, bypassing the frame boundaries);; * ignore a known problem. To achieve this, user may create a file listing the entities they want to; ignore, and pass it to clang at compile-time using; ``-fsanitize-ignorelist`` flag. See :doc:`UsersManual` for details. Example; =======. .. code-block:: bash. $ cat foo.c; #include <stdlib.h>; void bad_foo() {; int *a = (int*)malloc(40);; a[10] = 1;; }; int main() { bad_foo(); }; $ cat ignorelist.txt; # Ignore reports from bad_foo function.; fun:bad_foo; $ clang -fsanitize=address foo.c ; ./a.out; # AddressSanitizer prints an error report.; $ clang -fsanitize=address -fsanitize-ignorelist=ignorelist.txt foo.c ; ./a.out; # No error report here. Format; ======. Ignorelists consist of entries, optionally grouped into sections. Empty lines; and lines starting with ""#"" are ignored. .. note::. Prior to Clang 18, section names and entries described below use a variant of; regex where ``*`` is translated to ``.*``. Clang 18 (`D154014; <https://reviews.llvm.org/D154014>`) switches to glob and plans to remove; regex support in Clang 19. For Clang 18, regex is supported if ``#!special-case-list-v1`` is the first; line of the file. Many special case lists use ``.`` to indicate the literal character and do; not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; regex to glob transition. For more details, see `this discourse post; <https://discourse.llvm.org/t/use-glob-instead-of-regex-for-specialcaselists/71666>`_. Section names are globs written in square brackets that denote; which sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:1338,Availability,error,error,1338,"of sanitizer tools, such as :doc:`AddressSanitizer`, :doc:`ThreadSanitizer`; or :doc:`MemorySanitizer` may want to disable or alter some checks for; certain source-level entities to:. * speedup hot function, which is known to be correct;; * ignore a function that does some low-level magic (e.g. walks through the; thread stack, bypassing the frame boundaries);; * ignore a known problem. To achieve this, user may create a file listing the entities they want to; ignore, and pass it to clang at compile-time using; ``-fsanitize-ignorelist`` flag. See :doc:`UsersManual` for details. Example; =======. .. code-block:: bash. $ cat foo.c; #include <stdlib.h>; void bad_foo() {; int *a = (int*)malloc(40);; a[10] = 1;; }; int main() { bad_foo(); }; $ cat ignorelist.txt; # Ignore reports from bad_foo function.; fun:bad_foo; $ clang -fsanitize=address foo.c ; ./a.out; # AddressSanitizer prints an error report.; $ clang -fsanitize=address -fsanitize-ignorelist=ignorelist.txt foo.c ; ./a.out; # No error report here. Format; ======. Ignorelists consist of entries, optionally grouped into sections. Empty lines; and lines starting with ""#"" are ignored. .. note::. Prior to Clang 18, section names and entries described below use a variant of; regex where ``*`` is translated to ``.*``. Clang 18 (`D154014; <https://reviews.llvm.org/D154014>`) switches to glob and plans to remove; regex support in Clang 19. For Clang 18, regex is supported if ``#!special-case-list-v1`` is the first; line of the file. Many special case lists use ``.`` to indicate the literal character and do; not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; regex to glob transition. For more details, see `this discourse post; <https://discourse.llvm.org/t/use-glob-instead-of-regex-for-specialcaselists/71666>`_. Section names are globs written in square brackets that denote; which sanitizer the following entries apply to. For example, ``[address]``; specifies AddressSanitizer while ``[{cfi-vcall,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:4716,Availability,failure,failure,4716," entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code base when; finding the direct stack frame triggering the failure for every failure is; difficult.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:4734,Availability,failure,failure,4734," entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code base when; finding the direct stack frame triggering the failure for every failure is; difficult.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:4584,Safety,risk,risk,4584," entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code base when; finding the direct stack frame triggering the failure for every failure is; difficult.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:208,Security,sanitiz,sanitizer,208,"===========================; Sanitizer special case list; ===========================. .. contents::; :local:. Introduction; ============. This document describes the way to disable or alter the behavior of; sanitizer tools for certain source-level entities by providing a special; file at compile-time. Goal and usage; ==============. Users of sanitizer tools, such as :doc:`AddressSanitizer`, :doc:`ThreadSanitizer`; or :doc:`MemorySanitizer` may want to disable or alter some checks for; certain source-level entities to:. * speedup hot function, which is known to be correct;; * ignore a function that does some low-level magic (e.g. walks through the; thread stack, bypassing the frame boundaries);; * ignore a known problem. To achieve this, user may create a file listing the entities they want to; ignore, and pass it to clang at compile-time using; ``-fsanitize-ignorelist`` flag. See :doc:`UsersManual` for details. Example; =======. .. code-block:: bash. $ cat foo.c; #include <stdlib.h>; void bad_foo() {; int *a = (int*)malloc(40);; a[10] = 1;; }; int main() { bad_foo(); }; $ cat ignorelist.txt; # Ignore reports from bad_foo function.; fun:bad_foo; $ clang -fsanitize=address foo.c ; ./a.out; # AddressSanitizer prints an error report.; $ clang -fsanitize=address -fsanitize-ignorelist=ignorelist.txt foo.c ; ./a.out; # No error report here. Format; ======. Ignorelists consist of entries, optionally grouped into sections. Empty lines; and lines starting with ""#"" are ignored. .. note::. Prior to Clang 18, section names and entries described below use a variant of; regex where ``*`` is translated to ``.*``. Clang 18 (`D154014; <https://reviews.llvm.org/D154014>`) switches to glob and plans to remove; regex support in Clang 19. For Clang 18, regex is supported if ``#!special-case-list-v1`` is the first; line of the file. Many special case lists use ``.`` to indicate the literal character and do; not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; reg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:345,Security,sanitiz,sanitizer,345,"===========================; Sanitizer special case list; ===========================. .. contents::; :local:. Introduction; ============. This document describes the way to disable or alter the behavior of; sanitizer tools for certain source-level entities by providing a special; file at compile-time. Goal and usage; ==============. Users of sanitizer tools, such as :doc:`AddressSanitizer`, :doc:`ThreadSanitizer`; or :doc:`MemorySanitizer` may want to disable or alter some checks for; certain source-level entities to:. * speedup hot function, which is known to be correct;; * ignore a function that does some low-level magic (e.g. walks through the; thread stack, bypassing the frame boundaries);; * ignore a known problem. To achieve this, user may create a file listing the entities they want to; ignore, and pass it to clang at compile-time using; ``-fsanitize-ignorelist`` flag. See :doc:`UsersManual` for details. Example; =======. .. code-block:: bash. $ cat foo.c; #include <stdlib.h>; void bad_foo() {; int *a = (int*)malloc(40);; a[10] = 1;; }; int main() { bad_foo(); }; $ cat ignorelist.txt; # Ignore reports from bad_foo function.; fun:bad_foo; $ clang -fsanitize=address foo.c ; ./a.out; # AddressSanitizer prints an error report.; $ clang -fsanitize=address -fsanitize-ignorelist=ignorelist.txt foo.c ; ./a.out; # No error report here. Format; ======. Ignorelists consist of entries, optionally grouped into sections. Empty lines; and lines starting with ""#"" are ignored. .. note::. Prior to Clang 18, section names and entries described below use a variant of; regex where ``*`` is translated to ``.*``. Clang 18 (`D154014; <https://reviews.llvm.org/D154014>`) switches to glob and plans to remove; regex support in Clang 19. For Clang 18, regex is supported if ``#!special-case-list-v1`` is the first; line of the file. Many special case lists use ``.`` to indicate the literal character and do; not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; reg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:2225,Security,sanitiz,sanitizer,2225,"AddressSanitizer prints an error report.; $ clang -fsanitize=address -fsanitize-ignorelist=ignorelist.txt foo.c ; ./a.out; # No error report here. Format; ======. Ignorelists consist of entries, optionally grouped into sections. Empty lines; and lines starting with ""#"" are ignored. .. note::. Prior to Clang 18, section names and entries described below use a variant of; regex where ``*`` is translated to ``.*``. Clang 18 (`D154014; <https://reviews.llvm.org/D154014>`) switches to glob and plans to remove; regex support in Clang 19. For Clang 18, regex is supported if ``#!special-case-list-v1`` is the first; line of the file. Many special case lists use ``.`` to indicate the literal character and do; not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; regex to glob transition. For more details, see `this discourse post; <https://discourse.llvm.org/t/use-glob-instead-of-regex-for-specialcaselists/71666>`_. Section names are globs written in square brackets that denote; which sanitizer the following entries apply to. For example, ``[address]``; specifies AddressSanitizer while ``[{cfi-vcall,cfi-icall}]`` specifies Control; Flow Integrity virtual and indirect call checking. Entries without a section; will be placed under the ``[*]`` section applying to all enabled sanitizers. Entries contain an entity type, followed by a colon and a glob,; specifying the names of the entities, optionally followed by an equals sign and; a tool-specific category, e.g. ``fun:*ExampleFunc=example_category``.; Two generic entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/so",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:2518,Security,sanitiz,sanitizers,2518,"#"" are ignored. .. note::. Prior to Clang 18, section names and entries described below use a variant of; regex where ``*`` is translated to ``.*``. Clang 18 (`D154014; <https://reviews.llvm.org/D154014>`) switches to glob and plans to remove; regex support in Clang 19. For Clang 18, regex is supported if ``#!special-case-list-v1`` is the first; line of the file. Many special case lists use ``.`` to indicate the literal character and do; not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; regex to glob transition. For more details, see `this discourse post; <https://discourse.llvm.org/t/use-glob-instead-of-regex-for-specialcaselists/71666>`_. Section names are globs written in square brackets that denote; which sanitizer the following entries apply to. For example, ``[address]``; specifies AddressSanitizer while ``[{cfi-vcall,cfi-icall}]`` specifies Control; Flow Integrity virtual and indirect call checking. Entries without a section; will be placed under the ``[*]`` section applying to all enabled sanitizers. Entries contain an entity type, followed by a colon and a glob,; specifying the names of the entities, optionally followed by an equals sign and; a tool-specific category, e.g. ``fun:*ExampleFunc=example_category``.; Two generic entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:2875,Security,sanitiz,sanitizer,2875,"not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; regex to glob transition. For more details, see `this discourse post; <https://discourse.llvm.org/t/use-glob-instead-of-regex-for-specialcaselists/71666>`_. Section names are globs written in square brackets that denote; which sanitizer the following entries apply to. For example, ``[address]``; specifies AddressSanitizer while ``[{cfi-vcall,cfi-icall}]`` specifies Control; Flow Integrity virtual and indirect call checking. Entries without a section; will be placed under the ``[*]`` section applying to all enabled sanitizers. Entries contain an entity type, followed by a colon and a glob,; specifying the names of the entities, optionally followed by an equals sign and; a tool-specific category, e.g. ``fun:*ExampleFunc=example_category``.; Two generic entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:3184,Security,sanitiz,sanitizers,3184,"6>`_. Section names are globs written in square brackets that denote; which sanitizer the following entries apply to. For example, ``[address]``; specifies AddressSanitizer while ``[{cfi-vcall,cfi-icall}]`` specifies Control; Flow Integrity virtual and indirect call checking. Entries without a section; will be placed under the ``[*]`` section applying to all enabled sanitizers. Entries contain an entity type, followed by a colon and a glob,; specifying the names of the entities, optionally followed by an equals sign and; a tool-specific category, e.g. ``fun:*ExampleFunc=example_category``.; Two generic entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:3683,Security,sanitiz,sanitizer,3683," equals sign and; a tool-specific category, e.g. ``fun:*ExampleFunc=example_category``.; Two generic entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:3826,Security,sanitiz,sanitizers,3826," entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code base when; finding the direct stack frame triggering the failure for every failure is; difficult.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:3980,Security,sanitiz,sanitize,3980," entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; fun:*BadCfiCall. ``mainfile`` is similar to applying ``-fno-sanitize=`` to a set of files but; does not need plumbing into the build system. This works well for internal; linkage functions but has a caveat for C++ vague linkage functions. C++ vague linkage functions (e.g. inline functions, template instantiations) are; deduplicated at link time. A function (in an included file) ignored by a; specific ``mainfile`` pattern may not be the prevailing copy picked by the; linker. Therefore, using ``mainfile`` requires caution. It may still be useful,; e.g. when patterns are picked in a way to ensure the prevailing one is ignored.; (There is action-at-a-distance risk.). ``mainfile`` can be useful enabling a ubsan check for a large code base when; finding the direct stack frame triggering the failure for every failure is; difficult.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:609,Modifiability,variab,variable,609,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:764,Modifiability,variab,variable,764,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:104,Security,sanitiz,sanitizers,104,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:226,Security,sanitiz,sanitizers,226,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:513,Security,integrity,integrity,513,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:913,Security,sanitiz,sanitizer,913,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:1395,Security,integrity,integrity,1395,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst:125,Usability,simpl,simple,125,"==============; SanitizerStats; ==============. .. contents::; :local:. Introduction; ============. The sanitizers support a simple mechanism for gathering profiling statistics; to help understand the overhead associated with sanitizers. How to build and run; ====================. SanitizerStats can currently only be used with :doc:`ControlFlowIntegrity`.; In addition to ``-fsanitize=cfi*``, pass the ``-fsanitize-stats`` flag.; This will cause the program to count the number of times that each control; flow integrity check in the program fires. At run time, set the ``SANITIZER_STATS_PATH`` environment variable to direct; statistics output to a file. The file will be written on process exit.; The following substitutions will be applied to the environment variable:. - ``%b`` -- The executable basename.; - ``%p`` -- The process ID. You can also send the ``SIGUSR2`` signal to a process to make it write; sanitizer statistics immediately. The ``sanstats`` program can be used to dump statistics. It takes as a; command line argument the path to a statistics file produced by a program; compiled with ``-fsanitize-stats``. The output of ``sanstats`` is in four columns, separated by spaces. The first; column is the file and line number of the call site. The second column is; the function name. The third column is the type of statistic gathered (in; this case, the type of control flow integrity check). The fourth column is; the call count. Example:. .. code-block:: console. $ cat -n vcall.cc; 1 struct A {; 2 virtual void f() {}; 3 };; 4; 5 __attribute__((noinline)) void g(A *a) {; 6 a->f();; 7 }; 8; 9 int main() {; 10 A a;; 11 g(&a);; 12 }; $ clang++ -fsanitize=cfi -fvisibility=hidden -flto -fuse-ld=gold vcall.cc -fsanitize-stats -g; $ SANITIZER_STATS_PATH=a.stats ./a.out; $ sanstats a.stats; vcall.cc:6 _Z1gP1A cfi-vcall 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SanitizerStats.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerStats.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:6857,Availability,mask,masking,6857,"do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the entire program is compiled; with ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the start of the; guard region in TLS and deallocate the entire guard region including the; shadow call stack at thread exit. This is considered acceptable given that; the address of the start of the guard region is already somewhat guessable. One way in which the address of the shadow call stack could leak is in the; ``jmp_buf`` data structure used by ``setjmp`` and ``longjmp``. The Android; runtime `avoids this`_ by only storing the low bits of ``SCSReg`` in the; ``jmp_buf``, which requires the address of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:1207,Deployability,release,releases,1207,"cts programs against return address overwrites; (e.g. stack buffer overflows.) It works by saving a function's return address; to a separately allocated 'shadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does requ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:341,Energy Efficiency,allocate,allocated,341,"===============; ShadowCallStack; ===============. .. contents::; :local:. Introduction; ============. ShadowCallStack is an instrumentation pass, currently only implemented for; aarch64, that protects programs against return address overwrites; (e.g. stack buffer overflows.) It works by saving a function's return address; to a separately allocated 'shadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:1317,Energy Efficiency,consumption,consumption,1317,"hadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5883,Energy Efficiency,allocate,allocate,5883," stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the entire program is compiled; with ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:6403,Energy Efficiency,allocate,allocated,6403,"osed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the entire program is compiled; with ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the star",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:8777,Integrability,depend,depending,8777,"dress of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one may need to execute different code depending on whether; ShadowCallStack is enabled. The macro ``__has_feature(shadow_call_stack)`` can; be used for this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(shadow_call_stack); // code that builds only under ShadowCallStack; # endif; #endif. ``__attribute__((no_sanitize(""shadow-call-stack"")))``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Use ``__attribute__((no_sanitize(""shadow-call-stack"")))`` on a function; declaration to specify that the shadow call stack instrumentation should not be; applied to that function, even if enabled globally. Example; =======. The following example code:. .. code-block:: c++. int foo() {; return bar() + 1;; }. Generates the following aarch64 assembly when compiled with ``-O2``:. .. code-block:: none. stp x29, x30, [sp, #-16]!; mov x29, sp; bl bar; add w0, w0, #1; ldp x29, x30, [sp], #16; ret. Adding ``-fsanitize=shadow-call-stack`` would output the following assembly:. .. code-block:: none. str x30, [x18]",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:421,Performance,load,loading,421,"===============; ShadowCallStack; ===============. .. contents::; :local:. Introduction; ============. ShadowCallStack is an instrumentation pass, currently only implemented for; aarch64, that protects programs against return address overwrites; (e.g. stack buffer overflows.) It works by saving a function's return address; to a separately allocated 'shadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:845,Performance,perform,performance,845,"===============; ShadowCallStack; ===============. .. contents::; :local:. Introduction; ============. ShadowCallStack is an instrumentation pass, currently only implemented for; aarch64, that protects programs against return address overwrites; (e.g. stack buffer overflows.) It works by saving a function's return address; to a separately allocated 'shadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:1297,Performance,optimiz,optimize,1297,"hadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:1333,Performance,cache,cache,1333,"hadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:2104,Performance,race condition,race conditions,2104,"ionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology`: https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf. Compatibility; -------------. A runtime is not provided in compiler-rt so one must be provided by the; compiled application or the operating system. Integrating the runtime into; the operating system should be preferred since otherwise all thread creation; and destruction would need to be intercepted by the application. The instrumentation makes use of the platform register ``x18`` on AArch64 and; ``x3`` (``gp``) on RISC-V. For simplicity we will refer to this as the; ``SCSReg``. On some platforms, ``SCSReg`` is reserved, and on others, it is; designated as a scratch register. This generally means that any code that may; run on the same thread as code compiled w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:3613,Safety,risk,risks,3613,"is not provided in compiler-rt so one must be provided by the; compiled application or the operating system. Integrating the runtime into; the operating system should be preferred since otherwise all thread creation; and destruction would need to be intercepted by the application. The instrumentation makes use of the platform register ``x18`` on AArch64 and; ``x3`` (``gp``) on RISC-V. For simplicity we will refer to this as the; ``SCSReg``. On some platforms, ``SCSReg`` is reserved, and on others, it is; designated as a scratch register. This generally means that any code that may; run on the same thread as code compiled with ShadowCallStack must either target; one of the platforms whose ABI reserves ``SCSReg`` (currently Android, Darwin,; Fuchsia and Windows) or be compiled with a flag to reserve that register (e.g.,; ``-ffixed-x18``). If absolutely necessary, code compiled without reserving the; register may be run on the same thread as code that uses ShadowCallStack by; saving the register value temporarily on the stack (`example in Android`_) but; this should be done with care since it risks leaking the shadow call stack; address. .. _`example in Android`: https://android-review.googlesource.com/c/platform/frameworks/base/+/803717. Because it requires a dedicated register, the ShadowCallStack feature is; incompatible with any other feature that may use ``SCSReg``. However, there is; no inherent reason why ShadowCallStack needs to use a specific register; in; principle, a platform could choose to reserve and use another register for; ShadowCallStack, but this would be incompatible with the ABI standards; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. L",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5114,Safety,avoid,avoids,5114,"rds; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side chan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:6254,Safety,avoid,avoid,6254,"osed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the entire program is compiled; with ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the star",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:7675,Safety,avoid,avoids,7675,"ith ``SCSReg`` reserved, this is trivial: the address can be derived from the; value stored in ``SCSReg`` (e.g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the start of the; guard region in TLS and deallocate the entire guard region including the; shadow call stack at thread exit. This is considered acceptable given that; the address of the start of the guard region is already somewhat guessable. One way in which the address of the shadow call stack could leak is in the; ``jmp_buf`` data structure used by ``setjmp`` and ``longjmp``. The Android; runtime `avoids this`_ by only storing the low bits of ``SCSReg`` in the; ``jmp_buf``, which requires the address of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:7838,Safety,avoid,avoids,7838,"g. by masking out the lower bits). If a guard; region is used, the address of the start of the guard region could then be; stored at the start of the shadow call stack itself. But if it is possible; for code compiled without reserving ``SCSReg`` to run on a thread managed by the; runtime, which is the case on Android for example, the address must be stored; somewhere else instead. On Android we store the address of the start of the; guard region in TLS and deallocate the entire guard region including the; shadow call stack at thread exit. This is considered acceptable given that; the address of the start of the guard region is already somewhat guessable. One way in which the address of the shadow call stack could leak is in the; ``jmp_buf`` data structure used by ``setjmp`` and ``longjmp``. The Android; runtime `avoids this`_ by only storing the low bits of ``SCSReg`` in the; ``jmp_buf``, which requires the address of the shadow call stack to be; aligned to its size. .. _`avoids this`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/arch-arm64/bionic/setjmp.S#49. The architecture's call and return instructions (``bl`` and ``ret``) operate on; a register rather than the stack, which means that leaf functions are generally; protected from return address overwrites even without ShadowCallStack. Usage; =====. To enable ShadowCallStack, just pass the ``-fsanitize=shadow-call-stack`` flag; to both compile and link command lines. On aarch64, you also need to pass; ``-ffixed-x18`` unless your target already reserves ``x18``. On RISC-V, ``x3``; (``gp``) is always reserved. It is, however, important to disable GP relaxation; in the linker. This can be done with the ``--no-relax-gp`` flag in GNU ld. Low-level API; -------------. ``__has_feature(shadow_call_stack)``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. In some cases one may need to execute different code depending on whether; ShadowCallStack is enabled. The macro ``__has_feature",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:861,Security,secur,security,861,"===============; ShadowCallStack; ===============. .. contents::; :local:. Introduction; ============. ShadowCallStack is an instrumentation pass, currently only implemented for; aarch64, that protects programs against return address overwrites; (e.g. stack buffer overflows.) It works by saving a function's return address; to a separately allocated 'shadow call stack' in the function prolog in; non-leaf functions and loading the return address from the shadow call stack; in the function epilog. The return address is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:1602,Security,access,accesses,1602,"ddress is also stored on the regular stack; for compatibility with unwinders, but is otherwise unused. The aarch64 implementation is considered production ready, and; an `implementation of the runtime`_ has been added to Android's libc; (bionic). An x86_64 implementation was evaluated using Chromium and was found; to have critical performance and security deficiencies--it was removed in; LLVM 9.0. Details on the x86_64 implementation can be found in the; `Clang 7.0.1 documentation`_. .. _`implementation of the runtime`: https://android.googlesource.com/platform/bionic/+/808d176e7e0dd727c7f929622ec017f6e065c582/libc/bionic/pthread_create.cpp#128; .. _`Clang 7.0.1 documentation`: https://releases.llvm.org/7.0.1/tools/clang/docs/ShadowCallStack.html. Comparison; ----------. To optimize for memory consumption and cache locality, the shadow call; stack stores only an array of return addresses. This is in contrast to other; schemes, like :doc:`SafeStack`, that mirror the entire stack and trade-off; consuming more memory for shorter function prologs and epilogs with fewer; memory accesses. `Return Flow Guard`_ is a pure software implementation of shadow call stacks; on x86_64. Like the previous implementation of ShadowCallStack on x86_64, it is; inherently racy due to the architecture's use of the stack for calls and; returns. Intel `Control-flow Enforcement Technology`_ (CET) is a proposed hardware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology`: https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf. Compatibility; -------------. A runtime is not",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5170,Security,attack,attackers,5170,"rds; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side chan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5222,Security,attack,attackers,5222,"i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5274,Security,expose,exposed,5274,"i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5720,Security,attack,attacker,5720,"lStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:2898,Usability,simpl,simplicity,2898,"rdware; extension that would add native support to use a shadow stack to store/check; return addresses at call/return time. Being a hardware implementation, it; would not suffer from race conditions and would not incur the overhead of; function instrumentation, but it does require operating system support. .. _`Return Flow Guard`: https://xlab.tencent.com/en/2016/11/02/return-flow-guard/; .. _`Control-flow Enforcement Technology`: https://software.intel.com/sites/default/files/managed/4d/2a/control-flow-enforcement-technology-preview.pdf. Compatibility; -------------. A runtime is not provided in compiler-rt so one must be provided by the; compiled application or the operating system. Integrating the runtime into; the operating system should be preferred since otherwise all thread creation; and destruction would need to be intercepted by the application. The instrumentation makes use of the platform register ``x18`` on AArch64 and; ``x3`` (``gp``) on RISC-V. For simplicity we will refer to this as the; ``SCSReg``. On some platforms, ``SCSReg`` is reserved, and on others, it is; designated as a scratch register. This generally means that any code that may; run on the same thread as code compiled with ShadowCallStack must either target; one of the platforms whose ABI reserves ``SCSReg`` (currently Android, Darwin,; Fuchsia and Windows) or be compiled with a flag to reserve that register (e.g.,; ``-ffixed-x18``). If absolutely necessary, code compiled without reserving the; register may be run on the same thread as code that uses ShadowCallStack by; saving the register value temporarily on the stack (`example in Android`_) but; this should be done with care since it risks leaking the shadow call stack; address. .. _`example in Android`: https://android-review.googlesource.com/c/platform/frameworks/base/+/803717. Because it requires a dedicated register, the ShadowCallStack feature is; incompatible with any other feature that may use ``SCSReg``. However, there is; no inh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3517,Availability,recover,recovered,3517,"sing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:4188,Availability,avail,available,4188,"d (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one cop",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:12762,Availability,mask,masked,12762," x || y && z""). * Branch coverage is the percentage of ""true"" and ""false"" branches that have; been taken at least once. Each branch is tied to individual conditions in the; source code that may each evaluate to either ""true"" or ""false"". These; conditions may comprise larger boolean expressions linked by boolean logical; operators. For example, ""x = (y == 2) || (z < 10)"" is a boolean expression; that is comprised of two individual conditions, each of which evaluates to; either true or false, producing four total branch outcomes. * Modified Condition/Decision Coverage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ==================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3351,Deployability,update,updates,3351,"ofraw`` in the current directory of the program. If; ``LLVM_PROFILE_FILE`` contains a path to a non-existent directory, the missing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; le",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3363,Deployability,continuous,continuously,3363,"ofraw`` in the current directory of the program. If; ``LLVM_PROFILE_FILE`` contains a path to a non-existent directory, the missing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; le",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3931,Deployability,continuous,continuous,3931," on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:4850,Deployability,continuous,continuous,4850,"ws; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14411,Deployability,patch,patch,14411," function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ===============================. * There are no backwards or forwards compatibility guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =================================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14568,Deployability,patch,patch,14568,"overage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ===============================. * There are no backwards or forwards compatibility guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; withou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:18152,Deployability,configurat,configuration,18152,"t static initializers. Instead of calling the ``*_file()`` APIs; described above, use the following to save the profile directly to a buffer; under your control:. * Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and; call it to determine the size of the profile. You'll need to allocate a; buffer of this size. * Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call it; to copy the current counters to ``Buffer``, which is expected to already be; allocated and big enough for the profile. * Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and; call it to reset the counters before entering a specific section to be; profiled. This is only useful if there is some setup that should be excluded; from the profile. In C++ files, declare these as ``extern ""C""``. Collecting coverage reports for the llvm project; ================================================. To prepare a coverage report for llvm (and any of its sub-projects), add; ``-DLLVM_BUILD_INSTRUMENTED_COVERAGE=On`` to the cmake configuration. Raw; profiles will be written to ``$BUILD_DIR/profiles/``. To prepare an html; report, run ``llvm/utils/prepare-code-coverage-artifact.py``. To specify an alternate directory for raw profiles, use; ``-DLLVM_PROFILE_DATA_DIR``. To change the size of the profile merge pool, use; ``-DLLVM_PROFILE_MERGE_POOL_SIZE``. Drawbacks and limitations; =========================. * Prior to version 2.26, the GNU binutils BFD linker is not able link programs; compiled with ``-fcoverage-mapping`` in its ``--gc-sections`` mode. Possible; workarounds include disabling ``--gc-sections``, upgrading to a newer version; of BFD, or using the Gold linker. * Code coverage does not handle unpredictable changes in control flow or stack; unwinding in the presence of exceptions precisely. Consider the following; function:. .. code-block:: cpp. int f() {; may_throw();; return 0;; }. If the call to ``may_throw()`` propagates an exception into ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:17395,Energy Efficiency,allocate,allocate,17395,"l it to write; out a profile. This function returns 0 when it succeeds, and a non-zero value; otherwise. Calling this function multiple times appends profile data to an; existing on-disk raw profile. In C++ files, declare these as ``extern ""C""``. Using the profiling runtime without a filesystem; ------------------------------------------------. The profiling runtime also supports freestanding environments that lack a; filesystem. The runtime ships as a static archive that's structured to make; dependencies on a hosted environment optional, depending on what features; the client application uses. The first step is to export ``__llvm_profile_runtime``, as above, to disable; the default static initializers. Instead of calling the ``*_file()`` APIs; described above, use the following to save the profile directly to a buffer; under your control:. * Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and; call it to determine the size of the profile. You'll need to allocate a; buffer of this size. * Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call it; to copy the current counters to ``Buffer``, which is expected to already be; allocated and big enough for the profile. * Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and; call it to reset the counters before entering a specific section to be; profiled. This is only useful if there is some setup that should be excluded; from the profile. In C++ files, declare these as ``extern ""C""``. Collecting coverage reports for the llvm project; ================================================. To prepare a coverage report for llvm (and any of its sub-projects), add; ``-DLLVM_BUILD_INSTRUMENTED_COVERAGE=On`` to the cmake configuration. Raw; profiles will be written to ``$BUILD_DIR/profiles/``. To prepare an html; report, run ``llvm/utils/prepare-code-coverage-artifact.py``. To specify an alternate directory for raw profiles, use; ``-DLLVM_PROFILE_DATA_DIR``. To change",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:17586,Energy Efficiency,allocate,allocated,17586,"on multiple times appends profile data to an; existing on-disk raw profile. In C++ files, declare these as ``extern ""C""``. Using the profiling runtime without a filesystem; ------------------------------------------------. The profiling runtime also supports freestanding environments that lack a; filesystem. The runtime ships as a static archive that's structured to make; dependencies on a hosted environment optional, depending on what features; the client application uses. The first step is to export ``__llvm_profile_runtime``, as above, to disable; the default static initializers. Instead of calling the ``*_file()`` APIs; described above, use the following to save the profile directly to a buffer; under your control:. * Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and; call it to determine the size of the profile. You'll need to allocate a; buffer of this size. * Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call it; to copy the current counters to ``Buffer``, which is expected to already be; allocated and big enough for the profile. * Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and; call it to reset the counters before entering a specific section to be; profiled. This is only useful if there is some setup that should be excluded; from the profile. In C++ files, declare these as ``extern ""C""``. Collecting coverage reports for the llvm project; ================================================. To prepare a coverage report for llvm (and any of its sub-projects), add; ``-DLLVM_BUILD_INSTRUMENTED_COVERAGE=On`` to the cmake configuration. Raw; profiles will be written to ``$BUILD_DIR/profiles/``. To prepare an html; report, run ``llvm/utils/prepare-code-coverage-artifact.py``. To specify an alternate directory for raw profiles, use; ``-DLLVM_PROFILE_DATA_DIR``. To change the size of the profile merge pool, use; ``-DLLVM_PROFILE_MERGE_POOL_SIZE``. Drawbacks and limitations; ===================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:13831,Integrability,depend,dependent,13831,"rcuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ===============================. * There are no backwards or forwards compatibility guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:16902,Integrability,depend,dependencies,16902,")`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates any existing files; at that path. To get the same behavior without truncating existing files,; pass a filename pattern string to ``void __llvm_profile_set_filename(char; *)``. These calls can be placed anywhere so long as they precede all calls; to ``__llvm_profile_write_file``. * Forward-declare ``int __llvm_profile_write_file(void)`` and call it to write; out a profile. This function returns 0 when it succeeds, and a non-zero value; otherwise. Calling this function multiple times appends profile data to an; existing on-disk raw profile. In C++ files, declare these as ``extern ""C""``. Using the profiling runtime without a filesystem; ------------------------------------------------. The profiling runtime also supports freestanding environments that lack a; filesystem. The runtime ships as a static archive that's structured to make; dependencies on a hosted environment optional, depending on what features; the client application uses. The first step is to export ``__llvm_profile_runtime``, as above, to disable; the default static initializers. Instead of calling the ``*_file()`` APIs; described above, use the following to save the profile directly to a buffer; under your control:. * Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and; call it to determine the size of the profile. You'll need to allocate a; buffer of this size. * Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call it; to copy the current counters to ``Buffer``, which is expected to already be; allocated and big enough for the profile. * Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and; call it to reset the counters before entering a specific section to be; profiled. This is only useful if there is some setup that should be excluded; from the profile. In C++ files, declare these as ``extern ""C""``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:16949,Integrability,depend,depending,16949,")`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates any existing files; at that path. To get the same behavior without truncating existing files,; pass a filename pattern string to ``void __llvm_profile_set_filename(char; *)``. These calls can be placed anywhere so long as they precede all calls; to ``__llvm_profile_write_file``. * Forward-declare ``int __llvm_profile_write_file(void)`` and call it to write; out a profile. This function returns 0 when it succeeds, and a non-zero value; otherwise. Calling this function multiple times appends profile data to an; existing on-disk raw profile. In C++ files, declare these as ``extern ""C""``. Using the profiling runtime without a filesystem; ------------------------------------------------. The profiling runtime also supports freestanding environments that lack a; filesystem. The runtime ships as a static archive that's structured to make; dependencies on a hosted environment optional, depending on what features; the client application uses. The first step is to export ``__llvm_profile_runtime``, as above, to disable; the default static initializers. Instead of calling the ``*_file()`` APIs; described above, use the following to save the profile directly to a buffer; under your control:. * Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and; call it to determine the size of the profile. You'll need to allocate a; buffer of this size. * Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call it; to copy the current counters to ``Buffer``, which is expected to already be; allocated and big enough for the profile. * Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and; call it to reset the counters before entering a specific section to be; profiled. This is only useful if there is some setup that should be excluded; from the profile. In C++ files, declare these as ``extern ""C""``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:2251,Modifiability,variab,variable,2251,"x) {; for (unsigned I = 0; I < 10; ++I) { BAR(I); }; }; int main() {; foo<int>(0);; foo<float>(0);; return 0;; }; EOF. Compiling with coverage enabled; ===============================. To compile code with coverage enabled, pass ``-fprofile-instr-generate; -fcoverage-mapping`` to the compiler:. .. code-block:: console. # Step 1: Compile with coverage enabled.; % clang++ -fprofile-instr-generate -fcoverage-mapping foo.cc -o foo. Note that linking together code with and without coverage instrumentation is; supported. Uninstrumented code simply won't be accounted for in reports. To compile code with Modified Condition/Decision Coverage (MC/DC) enabled,; pass ``-fcoverage-mcdc`` in addition to the clang options specified above.; MC/DC is an advanced form of code coverage most applicable in the embedded; space. Running the instrumented program; ================================. The next step is to run the instrumented program. When the program exits it; will write a **raw profile** to the path specified by the ``LLVM_PROFILE_FILE``; environment variable. If that variable does not exist, the profile is written; to ``default.profraw`` in the current directory of the program. If; ``LLVM_PROFILE_FILE`` contains a path to a non-existent directory, the missing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:2269,Modifiability,variab,variable,2269,"return 0;; }; EOF. Compiling with coverage enabled; ===============================. To compile code with coverage enabled, pass ``-fprofile-instr-generate; -fcoverage-mapping`` to the compiler:. .. code-block:: console. # Step 1: Compile with coverage enabled.; % clang++ -fprofile-instr-generate -fcoverage-mapping foo.cc -o foo. Note that linking together code with and without coverage instrumentation is; supported. Uninstrumented code simply won't be accounted for in reports. To compile code with Modified Condition/Decision Coverage (MC/DC) enabled,; pass ``-fcoverage-mcdc`` in addition to the clang options specified above.; MC/DC is an advanced form of code coverage most applicable in the embedded; space. Running the instrumented program; ================================. The next step is to run the instrumented program. When the program exits it; will write a **raw profile** to the path specified by the ``LLVM_PROFILE_FILE``; environment variable. If that variable does not exist, the profile is written; to ``default.profraw`` in the current directory of the program. If; ``LLVM_PROFILE_FILE`` contains a path to a non-existent directory, the missing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:2747,Modifiability,variab,variable,2747,"strumented code simply won't be accounted for in reports. To compile code with Modified Condition/Decision Coverage (MC/DC) enabled,; pass ``-fcoverage-mcdc`` in addition to the clang options specified above.; MC/DC is an advanced form of code coverage most applicable in the embedded; space. Running the instrumented program; ================================. The next step is to run the instrumented program. When the program exits it; will write a **raw profile** to the path specified by the ``LLVM_PROFILE_FILE``; environment variable. If that variable does not exist, the profile is written; to ``default.profraw`` in the current directory of the program. If; ``LLVM_PROFILE_FILE`` contains a path to a non-existent directory, the missing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Window",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:18152,Modifiability,config,configuration,18152,"t static initializers. Instead of calling the ``*_file()`` APIs; described above, use the following to save the profile directly to a buffer; under your control:. * Forward-declare ``uint64_t __llvm_profile_get_size_for_buffer(void)`` and; call it to determine the size of the profile. You'll need to allocate a; buffer of this size. * Forward-declare ``int __llvm_profile_write_buffer(char *Buffer)`` and call it; to copy the current counters to ``Buffer``, which is expected to already be; allocated and big enough for the profile. * Optionally, forward-declare ``void __llvm_profile_reset_counters(void)`` and; call it to reset the counters before entering a specific section to be; profiled. This is only useful if there is some setup that should be excluded; from the profile. In C++ files, declare these as ``extern ""C""``. Collecting coverage reports for the llvm project; ================================================. To prepare a coverage report for llvm (and any of its sub-projects), add; ``-DLLVM_BUILD_INSTRUMENTED_COVERAGE=On`` to the cmake configuration. Raw; profiles will be written to ``$BUILD_DIR/profiles/``. To prepare an html; report, run ``llvm/utils/prepare-code-coverage-artifact.py``. To specify an alternate directory for raw profiles, use; ``-DLLVM_PROFILE_DATA_DIR``. To change the size of the profile merge pool, use; ``-DLLVM_PROFILE_MERGE_POOL_SIZE``. Drawbacks and limitations; =========================. * Prior to version 2.26, the GNU binutils BFD linker is not able link programs; compiled with ``-fcoverage-mapping`` in its ``--gc-sections`` mode. Possible; workarounds include disabling ``--gc-sections``, upgrading to a newer version; of BFD, or using the Gold linker. * Code coverage does not handle unpredictable changes in control flow or stack; unwinding in the presence of exceptions precisely. Consider the following; function:. .. code-block:: cpp. int f() {; may_throw();; return 0;; }. If the call to ``may_throw()`` propagates an exception into ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:21978,Modifiability,extend,extended,21978,"e; source code. MC/DC Instrumentation; ---------------------. When instrumenting for Modified Condition/Decision Coverage (MC/DC) using the; clang option ``-fcoverage-mcdc``, users are limited to at most **six** leaf-level; conditions in a boolean expression. A warning will be generated for boolean; expressions that contain more than six, and they will not be instrumented for; MC/DC. Also, if a boolean expression is embedded in the nest of another boolean; expression but separated by a non-logical operator, this is also not supported.; For example, in ``x = (a && b && c && func(d && f))``, the ``d && f`` case; starts a new boolean expression that is separated from the other conditions by; the operator ``func()``. When this is encountered, a warning will be generated; and the boolean expression will not be instrumented. Switch statements; -----------------. The region mapping for a switch body consists of a gap region that covers the; entire body (starting from the '{' in 'switch (...) {', and terminating where the; last case ends). This gap region has a zero count: this causes ""gap"" areas in; between case statements, which contain no executable code, to appear uncovered. When a switch case is visited, the parent region is extended: if the parent; region has no start location, its start location becomes the start of the case.; This is used to support switch statements without a ``CompoundStmt`` body, in; which the switch body and the single case share a count. For switches with ``CompoundStmt`` bodies, a new region is created at the start; of each switch case. Branch regions are also generated for each switch case, including the default; case. If there is no explicitly defined default case in the source code, a; branch region is generated to correspond to the implicit default case that is; generated by the compiler. The implicit branch region is tied to the line and; column number of the switch statement condition since no source code for the; implicit case exists.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:5094,Performance,perform,performance,5094,"t. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profd",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:5635,Performance,concurren,concurrency,5635," into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profdata``; (which can combine multiple raw profiles and index them at the same time):. .. code-block:: console. # Step 3(a): Index the raw profile.; % llvm-profdata merge -sparse foo.profraw -o foo.profdata. For an example of merging multiple profiles created by testing,; see the LLVM `coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/jenkins/jobs/jobs/llvm-coverage>`_. There are multiple different ways to render coverage reports. The simplest; option is to generate a line-oriented report:. .. code-block:: console. # Step 3(b): Create a l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14627,Performance,optimiz,optimizations,14627,"compatibility guarantees; ===============================. * There are no backwards or forwards compatibility guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14717,Performance,optimiz,optimizations,14717,"lity guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14953,Performance,optimiz,optimizer,14953,". It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; knows to skip loading the object which contains the profiling runtime's; static initializer. * Forward-declare ``void __llvm_profi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14977,Performance,optimiz,optimizer,14977,"s are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; knows to skip loading the object which contains the profiling runtime's; static initializer. * Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:15242,Performance,optimiz,optimization,15242,"rds** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; knows to skip loading the object which contains the profiling runtime's; static initializer. * Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates any existing files; at that path. To get the same behavior without truncating existing files,; pass a filename pattern string to ``void __llvm_profile_set_f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:15781,Performance,load,loading,15781,"o; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; knows to skip loading the object which contains the profiling runtime's; static initializer. * Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates any existing files; at that path. To get the same behavior without truncating existing files,; pass a filename pattern string to ``void __llvm_profile_set_filename(char; *)``. These calls can be placed anywhere so long as they precede all calls; to ``__llvm_profile_write_file``. * Forward-declare ``int __llvm_profile_write_file(void)`` and call it to write; out a profile. This function returns 0 when it succeeds, and a non-zero value; otherwise. Calling this function multiple times appends profile data to an; existing on-disk raw profile. In C++ files, declare these as ``extern ""C""``. Using the profiling runtime without a filesystem; ------------------------------------------------. The profiling runtime also supports",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3517,Safety,recover,recovered,3517,"sing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:5611,Safety,avoid,avoid,5611," into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profdata``; (which can combine multiple raw profiles and index them at the same time):. .. code-block:: console. # Step 3(a): Index the raw profile.; % llvm-profdata merge -sparse foo.profraw -o foo.profdata. For an example of merging multiple profiles created by testing,; see the LLVM `coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/jenkins/jobs/jobs/llvm-coverage>`_. There are multiple different ways to render coverage reports. The simplest; option is to generate a line-oriented report:. .. code-block:: console. # Step 3(b): Create a l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:15040,Safety,safe,safe,15040,"s are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; knows to skip loading the object which contains the profiling runtime's; static initializer. * Forward-declare ``void __llvm_profile_initialize_file(void)`` and call it; once from each instrumented executable. This function parses; ``LLVM_PROFILE_FILE``, sets the output path, and truncates",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:504,Security,sanitiz,sanitizers,504,"==========================; Source-based Code Coverage; ==========================. .. contents::; :local:. Introduction; ============. This document explains how to use clang's source-based code coverage feature.; It's called ""source-based"" because it operates on AST and preprocessor; information directly. This allows it to generate very precise coverage data. Clang ships two other code coverage implementations:. * :doc:`SanitizerCoverage` - A low-overhead tool meant for use alongside the; various sanitizers. It can provide up to edge-level coverage. * gcov - A GCC-compatible coverage implementation which operates on DebugInfo.; This is enabled by ``-ftest-coverage`` or ``--coverage``. From this point onwards ""code coverage"" will refer to the source-based kind. The code coverage workflow; ==========================. The code coverage workflow consists of three main steps:. * Compiling with coverage enabled. * Running the instrumented program. * Creating coverage reports. The next few sections work through a complete, copy-'n-paste friendly example; based on this program:. .. code-block:: cpp. % cat <<EOF > foo.cc; #define BAR(x) ((x) || (x)); template <typename T> void foo(T x) {; for (unsigned I = 0; I < 10; ++I) { BAR(I); }; }; int main() {; foo<int>(0);; foo<float>(0);; return 0;; }; EOF. Compiling with coverage enabled; ===============================. To compile code with coverage enabled, pass ``-fprofile-instr-generate; -fcoverage-mapping`` to the compiler:. .. code-block:: console. # Step 1: Compile with coverage enabled.; % clang++ -fprofile-instr-generate -fcoverage-mapping foo.cc -o foo. Note that linking together code with and without coverage instrumentation is; supported. Uninstrumented code simply won't be accounted for in reports. To compile code with Modified Condition/Decision Coverage (MC/DC) enabled,; pass ``-fcoverage-mcdc`` in addition to the clang options specified above.; MC/DC is an advanced form of code coverage most applicable in the embed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:4371,Security,access,access,4371," a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:4762,Security,access,access,4762,"ws; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:5044,Security,access,access,5044,"t. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profd",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:3689,Testability,test,testing,3689,"DIR`` environment variable. On; Darwin, this is typically set to a temporary scratch directory. * ""%Nm"" expands out to the instrumented binary's signature. When this pattern; is specified, the runtime creates a pool of N raw profiles which are used for; on-line profile merging. The runtime takes care of selecting a raw profile; from the pool, locking it, and updating it before the program exits. If N is; not specified (i.e the pattern is ""%m""), it's assumed that ``N = 1``. The; merge pool specifier can only occur once per filename pattern. * ""%c"" expands out to nothing, but enables a mode in which profile counter; updates are continuously synced to a file. This means that if the; instrumented program crashes, or is killed by a signal, perfect coverage; information can still be recovered. Continuous mode does not support value; profiling for PGO, and is only supported on Darwin at the moment. Support for; Linux may be mostly complete but requires testing, and support for Windows; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:5450,Testability,test,testing,5450,"e profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profdata``; (which can combine multiple raw profiles and index them at the same time):. .. code-block:: console. # Step 3(a): Index the raw profile.; % llvm-profdata merge -sparse foo.profraw -o foo.profdata. For an example of merging multiple profiles created by testing,; see the LLVM `coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/jenkins/jobs/jobs/llvm-coverage>`_. There are multiple different ways to render coverage reports. The si",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:6302,Testability,test,testing,6302,"-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profdata``; (which can combine multiple raw profiles and index them at the same time):. .. code-block:: console. # Step 3(a): Index the raw profile.; % llvm-profdata merge -sparse foo.profraw -o foo.profdata. For an example of merging multiple profiles created by testing,; see the LLVM `coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/jenkins/jobs/jobs/llvm-coverage>`_. There are multiple different ways to render coverage reports. The simplest; option is to generate a line-oriented report:. .. code-block:: console. # Step 3(b): Create a line-oriented coverage report.; % llvm-cov show ./foo -instr-profile=foo.profdata. This report includes a summary view as well as dedicated sub-views for; templated functions and their instantiations. For our example program, we get; distinct views for ``foo<int>(...)`` and ``foo<float>(...)``. If; ``-show-line-counts-or-regions`` is enabled, ``llvm-cov`` displays sub-line; region counts (even in macro expansions):. .. code-block:: none. 1| 20|#define BAR(x) ((x) || (x)); ^20 ^2; 2| 2|template <typename T> void foo(T x) {; 3| 22| for (unsigned I = 0; I < 10; ++I) { BAR(I); }; ^22 ^20 ^20^20; 4| 2|}; ------------------; | void foo<int>(int):; | 2| 1|template <typename T> void foo(T x) {; | 3| ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:12017,Testability,log,logical,12017,"xecuted at least once. Template functions and static inline; functions from headers are two kinds of functions which may have multiple; instantiations. This statistic is hidden by default in reports, but can be; enabled via the ``-show-instantiation-summary`` option. * Line coverage is the percentage of code lines which have been executed at; least once. Only executable lines within function bodies are considered to be; code lines. * Region coverage is the percentage of code regions which have been executed at; least once. A code region may span multiple lines (e.g in a large function; body with no control flow). However, it's also possible for a single line to; contain multiple code regions (e.g in ""return x || y && z""). * Branch coverage is the percentage of ""true"" and ""false"" branches that have; been taken at least once. Each branch is tied to individual conditions in the; source code that may each evaluate to either ""true"" or ""false"". These; conditions may comprise larger boolean expressions linked by boolean logical; operators. For example, ""x = (y == 2) || (z < 10)"" is a boolean expression; that is comprised of two individual conditions, each of which evaluates to; either true or false, producing four total branch outcomes. * Modified Condition/Decision Coverage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:12539,Testability,test,test,12539," x || y && z""). * Branch coverage is the percentage of ""true"" and ""false"" branches that have; been taken at least once. Each branch is tied to individual conditions in the; source code that may each evaluate to either ""true"" or ""false"". These; conditions may comprise larger boolean expressions linked by boolean logical; operators. For example, ""x = (y == 2) || (z < 10)"" is a boolean expression; that is comprised of two individual conditions, each of which evaluates to; either true or false, producing four total branch outcomes. * Modified Condition/Decision Coverage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ==================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:12822,Testability,log,logical,12822," x || y && z""). * Branch coverage is the percentage of ""true"" and ""false"" branches that have; been taken at least once. Each branch is tied to individual conditions in the; source code that may each evaluate to either ""true"" or ""false"". These; conditions may comprise larger boolean expressions linked by boolean logical; operators. For example, ""x = (y == 2) || (z < 10)"" is a boolean expression; that is comprised of two individual conditions, each of which evaluates to; either true or false, producing four total branch outcomes. * Modified Condition/Decision Coverage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ==================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:12980,Testability,test,tested,12980,"or ""false"". These; conditions may comprise larger boolean expressions linked by boolean logical; operators. For example, ""x = (y == 2) || (z < 10)"" is a boolean expression; that is comprised of two individual conditions, each of which evaluates to; either true or false, producing four total branch outcomes. * Modified Condition/Decision Coverage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ===============================. * There are no backwards or forwards compatibility guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
