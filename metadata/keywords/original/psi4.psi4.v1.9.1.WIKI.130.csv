id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:35772,Energy Efficiency,charge,charges,35772,"class:`~psi4.core.Matrix`; storage maps. """"""; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(self: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; has been set on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37285,Energy Efficiency,charge,charges,37285,"ject at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:38716,Energy Efficiency,charge,charge,38716,"([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:40376,Energy Efficiency,charge,charge,40376,"ready a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variab",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:42850,Energy Efficiency,charge,charges,42850,"wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have bee",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:43963,Energy Efficiency,charge,charges,43963,"s are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavef",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:5899,Integrability,message,message,5899,"orde[target]; return target. # Figure out what exactly was meant by 'target'.; resolved_target = _resolve_target(key, target). # resolved_target needs to be either a string or function for pyconstuct.; # if a string, they search for a gbs file with that name.; # if a function, it needs to apply a basis to each atom. bs, basisdict = qcdb.BasisSet.pyconstruct(mol.to_dict(),; key,; resolved_target,; fitrole,; other,; return_dict=True,; return_atomlist=return_atomlist). if return_atomlist:; atom_basis_list = []; for atbs in basisdict:; atommol = core.Molecule.from_dict(atbs['molecule']); lmbs = core.BasisSet.construct_from_pydict(atommol, atbs, puream); atom_basis_list.append(lmbs); return atom_basis_list; if isinstance(resolved_target, str):; basisdict['name'] = basisdict['name'].split('/')[-1].replace('.gbs', ''); if callable(resolved_target):; basisdict['name'] = resolved_target.__name__.replace('basisspec_psi4_yo__', '').upper(). if not quiet:; core.print_out(basisdict['message']); if 'ECP' in basisdict['message']:; core.print_out(' !!! WARNING: ECP capability is in beta. Please check occupations closely. !!!\n\n'). if basisdict['key'] is None:; basisdict['key'] = 'BASIS'; psibasis = core.BasisSet.construct_from_pydict(mol, basisdict, puream); return psibasis. core.BasisSet.build = _pybuild_basis. ## Python wavefunction helps. @staticmethod; def _core_wavefunction_build(; mol: core.Molecule,; basis: Union[None, str, core.BasisSet] = None,; *,; quiet: bool = False,; ) -> core.Wavefunction:; """"""Build a wavefunction from minimal inputs, molecule and basis set. Parameters; ----------; mol; Molecule for which to build the wavefunction instance.; basis; Basis set for which to build the wavefunction instance. If a; :class:`BasisSet`, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from :term:`BASIS <BASIS (MINTS)>`.; quiet; When True, do not print to the output file. """"""; if basis is None:; basis = core.BasisSet.build(mol, quiet=quiet);",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:5934,Integrability,message,message,5934,"orde[target]; return target. # Figure out what exactly was meant by 'target'.; resolved_target = _resolve_target(key, target). # resolved_target needs to be either a string or function for pyconstuct.; # if a string, they search for a gbs file with that name.; # if a function, it needs to apply a basis to each atom. bs, basisdict = qcdb.BasisSet.pyconstruct(mol.to_dict(),; key,; resolved_target,; fitrole,; other,; return_dict=True,; return_atomlist=return_atomlist). if return_atomlist:; atom_basis_list = []; for atbs in basisdict:; atommol = core.Molecule.from_dict(atbs['molecule']); lmbs = core.BasisSet.construct_from_pydict(atommol, atbs, puream); atom_basis_list.append(lmbs); return atom_basis_list; if isinstance(resolved_target, str):; basisdict['name'] = basisdict['name'].split('/')[-1].replace('.gbs', ''); if callable(resolved_target):; basisdict['name'] = resolved_target.__name__.replace('basisspec_psi4_yo__', '').upper(). if not quiet:; core.print_out(basisdict['message']); if 'ECP' in basisdict['message']:; core.print_out(' !!! WARNING: ECP capability is in beta. Please check occupations closely. !!!\n\n'). if basisdict['key'] is None:; basisdict['key'] = 'BASIS'; psibasis = core.BasisSet.construct_from_pydict(mol, basisdict, puream); return psibasis. core.BasisSet.build = _pybuild_basis. ## Python wavefunction helps. @staticmethod; def _core_wavefunction_build(; mol: core.Molecule,; basis: Union[None, str, core.BasisSet] = None,; *,; quiet: bool = False,; ) -> core.Wavefunction:; """"""Build a wavefunction from minimal inputs, molecule and basis set. Parameters; ----------; mol; Molecule for which to build the wavefunction instance.; basis; Basis set for which to build the wavefunction instance. If a; :class:`BasisSet`, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from :term:`BASIS <BASIS (MINTS)>`.; quiet; When True, do not print to the output file. """"""; if basis is None:; basis = core.BasisSet.build(mol, quiet=quiet);",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:21945,Integrability,message,message,21945,"by looking for assign lines, and remove them; leftover_lines = []; assignments = False; for line in command_lines:; if symbol_re.match(line):; m = symbol_re.match(line); mol.set_basis_by_symbol(m.group('symbol'), m.group('basis'), role=role); assignments = True. elif label_re.match(line):; m = label_re.match(line); mol.set_basis_by_label(m.group('label'), m.group('basis'), role=role); assignments = True. elif all_re.match(line):; m = all_re.match(line); mol.set_basis_all_atoms(m.group('basis'), role=role); assignments = True. else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if not assignments:; # case with no [basname] markers where whole block is contents of gbs file; mol.set_basis_all_atoms(name, role=role); basstrings[_basname(name)] = basblock[0]; else:; message = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[_basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES','MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise Validati",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:22086,Integrability,message,message,22086,".group('symbol'), m.group('basis'), role=role); assignments = True. elif label_re.match(line):; m = label_re.match(line); mol.set_basis_by_label(m.group('label'), m.group('basis'), role=role); assignments = True. elif all_re.match(line):; m = all_re.match(line); mol.set_basis_all_atoms(m.group('basis'), role=role); assignments = True. else:; # Ignore blank lines and accumulate remainder; if line and not line.isspace():; leftover_lines.append(line.strip()). # Now look for regular basis set definitions; basblock = list(filter(None, basislabel.split('\n'.join(leftover_lines)))); if len(basblock) == 1:; if not assignments:; # case with no [basname] markers where whole block is contents of gbs file; mol.set_basis_all_atoms(name, role=role); basstrings[_basname(name)] = basblock[0]; else:; message = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[_basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES','MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.Exte",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:22825,Integrability,rout,routing,22825,"set_basis_all_atoms(name, role=role); basstrings[_basname(name)] = basblock[0]; else:; message = (; ""Conflicting basis set specification: assign lines present but shells have no [basname] label.""; """"); raise TestComparisonError(message); else:; # case with specs separated by [basname] markers; for idx in range(0, len(basblock), 2):; basstrings[_basname(basblock[idx])] = basblock[idx + 1]. return basstrings. anon.__name__ = 'basisspec_psi4_yo__' + cleanbas; qcdb.libmintsbasisset.basishorde[name.upper()] = anon; if set_option:; core.set_global_option(key, name). core.OEProp.valid_methods = [; 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES',; 'MBIS_CHARGES','MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS'; ]. ## Option helpers. def _core_set_global_option_python(key, EXTERN):; """"""; This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul.; """"""; if (key != ""EXTERN""):; raise ValidationError(""Options: set_global_option_python does not recognize keyword %s"" % key). if EXTERN is None:; core.EXTERN = None; core.set_global_option(""EXTERN"", False); elif isinstance(EXTERN, core.ExternalPotential):; # Well this is probably the worst hack I have done, thats saying something; core.EXTERN = EXTERN; core.set_global_option(""EXTERN"", True); else:; raise ValidationError(""Options: set_global_option_python can either be a NULL or External Potential object""). core.set_global_option_python = _core_set_global_option_python. ## QCvar helps. _qcvar_transitions = {; # old: (replacement, release after next); ""SCSN-MP2 CORRELATION ENERGY"": (""SCS(N)-MP2 CORRELATION ENERGY"", 1.5),; ""SCSN-MP2 TOTAL ENERGY"": (""SCS(N)-MP2 TOTAL ENERGY"", 1.5),; ""MAYER_INDICES"": (""MAYER INDICES"", 1.5),; ""WIBERG_LOWDIN_INDICES"": (""WIBERG LOWDIN INDICES"", 1.5),; ""LOWDIN_CHARGES"": (""LOWDIN CHARGES"", 1.5),; ""MULLIKEN_CHA",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:1252,Modifiability,variab,variable-related,1252,"cluded in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); - ERISieve (constructor); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ""temp_circular_import_blocker"", # retire ASAP; ]. import os; import re; import sys; import math; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4 import extras; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:1313,Modifiability,variab,variable-related,1313,"cluded in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""; Module with PsiAPI helpers for PSIthon `{...}` syntax.; Also, many Python extensions to core classes:. - core (variable-related, gradient, python option),; - Wavefunction (variable-related, freq, Lagrangian, constructor, scratch file, serialization),; - Matrix (doublet, triplet),; - BasisSet (constructor); - JK (constructor); - VBase (grid); - OEProp (avail prop); - ERISieve (constructor); """""". __all__ = [; ""basis_helper"",; ""pcm_helper"",; ""plump_qcvar"",; ""set_options"",; ""set_module_options"",; ""temp_circular_import_blocker"", # retire ASAP; ]. import os; import re; import sys; import math; import uuid; import warnings; from collections import Counter; from itertools import product; from pathlib import Path; from tempfile import NamedTemporaryFile; from typing import Any, Callable, Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel; from psi4 import core; from psi4 import extras; from psi4.driver import qcdb. from . import optproc; from .exceptions import TestComparisonError, ValidationError, UpgradeHelper. ## Python basis helps. @staticmethod; def _pybuild_basis(; mol: core.Molecule,; key: Optional[str] = None,; target: Optional[Union[str, Callable]] = None,; fitrole: str = ""ORBITAL"",; other: Optional",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:8678,Modifiability,variab,variable,8678,"atch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not N",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:9519,Modifiability,variab,variables,9519,"file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefuncti",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:10372,Modifiability,variab,variables,10372,"m = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[label] = core.Matrix.from_array(array, name=label) if array is not None else None. for label in wfn_vector:; array = wfn_vector[label]; wfn_vector[label] = core.Vector.from_array(array, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict[str, Dict[str, Any]]:; """"""Serialize a Wavefunction object. Opposite of; :meth:`~psi4.core.Wavefunction.from_file`. Parameters; ----------; wfn; Wavefunction or inherited class instance.; filename; An optional filename to which to write the data. Returns; -------; ~typing.Dict[str, ~typing.Dict[str, ~typing.Any]]; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:10843,Modifiability,inherit,inherited,10843,"ay, name=label) if array is not None else None. for label in wfn_dimension:; tup = wfn_dimension[label]; wfn_dimension[label] = core.Dimension.from_list(tup, name=label) if tup is not None else None. for label in wfn_matrixarr:; array = wfn_matrixarr[label]; wfn_matrixarr[label] = core.Matrix.from_array(array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict[str, Dict[str, Any]]:; """"""Serialize a Wavefunction object. Opposite of; :meth:`~psi4.core.Wavefunction.from_file`. Parameters; ----------; wfn; Wavefunction or inherited class instance.; filename; An optional filename to which to write the data. Returns; -------; ~typing.Dict[str, ~typing.Dict[str, ~typing.Any]]; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.lagrangian().to_array() if w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:11091,Modifiability,variab,variables,11091,"array, name=label) if array is not None else None. # make the wavefunction; wfn = core.Wavefunction(molecule, basisset, wfn_matrix, wfn_vector, wfn_dimension, wfn_int, wfn_string,; wfn_boolean, wfn_float). # some of the wavefunction's variables can be changed directly; for k, v in wfn_floatvar.items():; wfn.set_variable(k, v); for k, v in wfn_matrixarr.items():; wfn.set_variable(k, v). return wfn. core.Wavefunction.from_file = _core_wavefunction_from_file. def _core_wavefunction_to_file(wfn: core.Wavefunction, filename: str = None) -> Dict[str, Dict[str, Any]]:; """"""Serialize a Wavefunction object. Opposite of; :meth:`~psi4.core.Wavefunction.from_file`. Parameters; ----------; wfn; Wavefunction or inherited class instance.; filename; An optional filename to which to write the data. Returns; -------; ~typing.Dict[str, ~typing.Dict[str, ~typing.Any]]; A dictionary and NumPy representation of the Wavefunction. """""". # collect the wavefunction's variables in a dictionary indexed by varaible type; # some of the data types have to be made numpy-friendly first; if wfn.basisset().name().startswith(""anonymous""):; raise ValidationError(""Cannot serialize wavefunction with custom basissets.""). wfn_data = {; 'molecule': wfn.molecule().to_dict(),; 'matrix': {; 'Ca': wfn.Ca().to_array() if wfn.Ca() else None,; 'Cb': wfn.Cb().to_array() if wfn.Cb() else None,; 'Da': wfn.Da().to_array() if wfn.Da() else None,; 'Db': wfn.Db().to_array() if wfn.Db() else None,; 'Fa': wfn.Fa().to_array() if wfn.Fa() else None,; 'Fb': wfn.Fb().to_array() if wfn.Fb() else None,; 'H': wfn.H().to_array() if wfn.H() else None,; 'S': wfn.S().to_array() if wfn.S() else None,; 'X': wfn.lagrangian().to_array() if wfn.lagrangian() else None,; 'aotoso': wfn.aotoso().to_array() if wfn.aotoso() else None,; 'gradient': wfn.gradient().to_array() if wfn.gradient() else None,; 'hessian': wfn.hessian().to_array() if wfn.hessian() else None; },; 'vector': {; 'epsilon_a': wfn.epsilon_a().to_array() if wfn.epsilon_a() else N",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:35673,Modifiability,variab,variables,35673," Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(self: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; has been set on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.varia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:35716,Modifiability,variab,variables,35716,"class:`~psi4.core.Matrix`; storage maps. """"""; return core.has_scalar_variable(key) or core.has_array_variable(key). def _core_wavefunction_has_variable(self: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; has been set on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:35864,Modifiability,variab,variables,35864,"f _core_wavefunction_has_variable(self: core.Wavefunction, key: str) -> bool:; """"""Whether scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; has been set on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:36094,Modifiability,variab,variable,36094,"key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; flo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:36152,Modifiability,variab,variable,36152,"`~psi4.core.Matrix` storage maps. """"""; return self.has_scalar_variable(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:36222,Modifiability,variab,variable,36222,"e(key) or self.has_array_variable(key). def _core_variable(key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables n",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:36303,Modifiability,variab,variable,36303,"[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from global memory. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:36680,Modifiability,variab,variable,36680," - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:36700,Modifiability,variab,variable,36700," - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37186,Modifiability,variab,variables,37186," -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyE",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37229,Modifiability,variab,variables,37229,"ject at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37377,Modifiability,variab,variables,37377,"02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if core.has_scalar_variable(key):; return core.scalar_variable(key); elif core.has_array_variable(key):; return _qcvar_reshape_get(key, core.array_variable(key)); else:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or arr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37632,Modifiability,variab,variable,37632,"se:; raise KeyError(f""psi4.core.variable: Requested variable '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.n",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37689,Modifiability,variab,variable,37689," '{key}' was not set!\n""). def _core_wavefunction_variable(self: core.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37758,Modifiability,variab,variable,37758,"e.Wavefunction, key: str) -> Union[float, core.Matrix, np.ndarray]:; """"""Return copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:37838,Modifiability,variab,variable,37838,"rn copy of scalar or array :ref:`QCVariable <sec:appendices:qcvars>`; *key* from *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :py:class:`~psi4.core.Matrix`; storage maps. Returns; -------; float or ~numpy.ndarray or Matrix; Requested QCVariable from `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:38228,Modifiability,variab,variable,38228," (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(v",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:38248,Modifiability,variab,variable,38248," (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. Raises; ------; KeyError; If `key` not set on `self`. Example; -------; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(v",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:38938,Modifiability,variab,variable,38938,"6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:39010,Modifiability,variab,variable,39010,". """"""; key = _qcvar_warnings(key). if self.has_scalar_variable(key):; return self.scalar_variable(key); elif self.has_array_variable(key):; return _qcvar_reshape_get(key, self.array_variable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instan",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:39149,Modifiability,variab,variable,39149,"iable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:39183,Modifiability,variab,variable,39183,"iable(key)); else:; raise KeyError(f""psi4.core.Wavefunction.variable: Requested variable '{key}' was not set!\n""). def _core_set_variable(key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:39363,Modifiability,variab,variable,39363,"ar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:39397,Modifiability,variab,variable,39397,"ar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* in global memory. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:39597,Modifiability,variab,variable,39597,"red in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array varia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:39631,Modifiability,variab,variable,39631,"red in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if core.has_scalar_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already a scalar variable!""); else:; core.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if core.has_array_variable(key):; raise ValidationError(f""psi4.core.set_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array varia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:40611,Modifiability,variab,variable,40611,"t_variable: Target variable '{key}' already an array variable!""); else:; core.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Par",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:40683,Modifiability,variab,variable,40683,"set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_wavefunction_set_variable(self: core.Wavefunction, key: str, val: Union[core.Matrix, np.ndarray, float]) -> None:; """"""Sets scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:40834,Modifiability,variab,variable,40834,"ar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:40868,Modifiability,variab,variable,40868,"ar or array :ref:`QCVariable <sec:appendices:qcvars>` *key* to; *val* on *self*. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or :class:`~psi4.core.Matrix`; storage maps. - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:41060,Modifiability,variab,variable,41060," - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:41094,Modifiability,variab,variable,41094," - If ``CURRENT ENERGY``, syncs with ``self.energy_``.; - If ``CURRENT GRADIENT``, syncs with ``gradient_``.; - If ``CURRENT HESSIAN``, syncs with ``self.hessian_``.; val; Scalar or array to be stored in `key`. If :class:`~numpy.ndarray` and; data `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:41306,Modifiability,variab,variable,41306,"a `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_dep",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:41340,Modifiability,variab,variable,41340,"a `key` does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; :class:`~numpy.ndarray` are stored as :class:`~psi4.core.Matrix`. Raises; ------; ~psi4.driver.ValidationError; If `val` is a scalar but `key` already exists as an array variable. Or; if `val` is an array but `key` already exists as a scalar variable. """"""; if isinstance(val, core.Matrix):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, val); elif isinstance(val, np.ndarray):; if self.has_scalar_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already a scalar variable!""); else:; self.set_array_variable(key, core.Matrix.from_array(_qcvar_reshape_set(key, val))); else:; if self.has_array_variable(key):; raise ValidationError(""psi4.core.Wavefunction.set_variable: Target variable '{key}' already an array variable!""); else:; self.set_scalar_variable(key, val). # TODO _qcvar_warnings(key). def _core_del_variable(key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from global memory if present. Parameters; ----------; key; Case-insensitive key to global double or :py:class:`~psi4.core.Matrix`; storage maps. """"""; if core.has_scalar_variable(key):; core.del_scalar_variable(key); elif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_dep",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:42751,Modifiability,variab,variables,42751,"lif core.has_array_variable(key):; core.del_array_variable(key). def _core_wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:42794,Modifiability,variab,variables,42794,"wavefunction_del_variable(self: core.Wavefunction, key: str) -> None:; """"""Removes scalar or array :ref:`QCVariable <sec:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have bee",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:42942,Modifiability,variab,variables,42942,"c:appendices:qcvars>` *key*; from *self* if present. Parameters; ----------; self; Wavefunction instance.; key; Case-insensitive key to instance's double or; :py:class:`~psi4.core.Matrix` storage maps. """"""; if self.has_scalar_variable(key):; self.del_scalar_variable(key); elif self.has_array_variable(key):; self.del_array_variable(key). def _core_variables(include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from global memory. Parameters; ----------; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or pe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:43864,Modifiability,variab,variables,43864," :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:43907,Modifiability,variab,variables,43907,"s are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavef",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:44055,Modifiability,variab,variables,44055,"y = {**core.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in core.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. def _core_wavefunction_variables(self, include_deprecated_keys: bool = False) -> Dict[str, Union[float, core.Matrix, np.ndarray]]:; """"""Return all scalar or array :ref:`QCVariables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:44513,Modifiability,variab,variable,44513,"ables <sec:appendices:qcvars>`; from *self*. Parameters; ----------; self; Wavefunction instance.; include_deprecated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variabl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:44625,Modifiability,variab,variables,44625,"recated_keys; Also return duplicate entries with keys that have been deprecated. Returns; -------; ~typing.Dict[str, ~typing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:44738,Modifiability,variab,variable,44738,"ing.Union[float, ~numpy.ndarray, Matrix]; Map of all QCVariables that have been set on `self`. - Scalar variables are returned as floats.; - Array variables not naturally 2D (like multipoles or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:44928,Modifiability,variab,variables,44928,"es or per-atom charges); are returned as :class:`~numpy.ndarray` of natural dimensionality.; - Other array variables are returned as :py:class:`~psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.varia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45084,Modifiability,variab,variable,45084,"psi4.core.Matrix` and; may have an extra dimension with symmetry information. """"""; dicary = {**self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45178,Modifiability,variab,variable,45178,"self.scalar_variables(), **{k: _qcvar_reshape_get(k, v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. de",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45231,Modifiability,variab,variables,45231,"v) for k, v in self.array_variables().items()}}. if include_deprecated_keys:; for old_key, (current_key, version) in _qcvar_transitions.items():; if current_key in dicary:; dicary[old_key] = dicary[current_key]. return dicary. core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45459,Modifiability,variab,variables,45459,"core.has_variable = _core_has_variable; core.variable = _core_variable; core.set_variable = _core_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=F",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45555,Modifiability,variab,variables,45555,"_set_variable; core.del_variable = _core_del_variable; core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variab",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45610,Modifiability,variab,variables,45610," core.variables = _core_variables. core.Wavefunction.has_variable = _core_wavefunction_has_variable; core.Wavefunction.variable = _core_wavefunction_variable; core.Wavefunction.set_variable = _core_wavefunction_set_variable; core.Wavefunction.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45844,Modifiability,variab,variable,45844,"function.del_variable = _core_wavefunction_del_variable; core.Wavefunction.variables = _core_wavefunction_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45944,Modifiability,variab,variable,45944,"tion_variables. ## Psi4 v1.4 Export Deprecations. def _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.varia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:45995,Modifiability,variab,variables,45995,"f _core_get_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variable` instead of `psi4.core.variable` (or `psi4.core.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` fo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:46228,Modifiability,variab,variables,46228,"les only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:46330,Modifiability,variab,variables,46330,"el=2); return core.scalar_variable(key). def _core_get_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunctio",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:46383,Modifiability,variab,variables,46383,"t_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_variables` instead of `psi4.core.variables` (or `psi4.core.scalar_variables` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.scalar_variables(). def _core_get_array_variable(key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.varia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:46829,Modifiability,variab,variable,46829,".core.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variable` instead of `psi4.core.variable` (or `psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:46949,Modifiability,variab,variable,46949,"psi4.core.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:47015,Modifiability,variab,variables,47015," and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variable(key). def _core_get_array_variables():; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); re",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:47272,Modifiability,variab,variable,47272,".core.get_array_variables` instead of `psi4.core.variables` (or `psi4.core.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:47389,Modifiability,variab,variable,47389,"is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:47453,Modifiability,variab,variables,47453,"ory=FutureWarning,; stacklevel=2); return core.array_variables(). core.get_variable = _core_get_variable; core.get_variables = _core_get_variables; core.get_array_variable = _core_get_array_variable; core.get_array_variables = _core_get_array_variables. def _core_wavefunction_get_variable(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_variable` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:47907,Modifiability,variab,variables,47907,"stead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.scalar_variable` for scalar variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.scalar_variable(key). def _core_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typin",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:48164,Modifiability,variab,variables,48164,"_wavefunction_get_array(cls, key):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typing.Dict[str, ~numpy.ndarray]]; A dictionary of vibrational information. See :py:func:`psi4.driver.qcdb.vib.harmonic_analysis`. """"""; if not hasattr(self, 'frequency_analysis'):; return None. vibinfo = self.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(v",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:48279,Modifiability,variab,variables,48279,". """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.get_array` instead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typing.Dict[str, ~numpy.ndarray]]; A dictionary of vibrational information. See :py:func:`psi4.driver.qcdb.vib.harmonic_analysis`. """"""; if not hasattr(self, 'frequency_analysis'):; return None. vibinfo = self.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). core.Wavefunction.freq",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:48345,Modifiability,variab,variables,48345,"nstead of `psi4.core.Wavefunction.variable` (or `psi4.core.Wavefunction.array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variable(key). def _core_wavefunction_set_array(cls, key, val):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.set_variable` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.set_array` instead of `psi4.core.Wavefunction.set_variable` (or `psi4.core.Wavefunction.set_array_variable` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.set_array_variable(key, val). def _core_wavefunction_arrays(cls):; """"""; .. deprecated:: 1.4; Use :py:func:`psi4.core.Wavefunction.variables` instead. """"""; warnings.warn(; ""Using `psi4.core.Wavefunction.arrays` instead of `psi4.core.Wavefunction.variables` (or `psi4.core.Wavefunction.array_variables` for array variables only) is deprecated, and as soon as 1.4 it will stop working\n"",; category=FutureWarning,; stacklevel=2); return cls.array_variables(). core.Wavefunction.get_variable = _core_wavefunction_get_variable; core.Wavefunction.get_array = _core_wavefunction_get_array; core.Wavefunction.set_array = _core_wavefunction_set_array; core.Wavefunction.arrays = _core_wavefunction_arrays. def _core_wavefunction_frequencies(self):; """"""Returns the results of a frequency analysis. Parameters; ----------; self; Wavefunction instance. Returns; -------; ~typing.Optional[~typing.Dict[str, ~numpy.ndarray]]; A dictionary of vibrational information. See :py:func:`psi4.driver.qcdb.vib.harmonic_analysis`. """"""; if not hasattr(self, 'frequency_analysis'):; return None. vibinfo = self.frequency_analysis; vibonly = qcdb.vib.filter_nonvib(vibinfo); return core.Vector.from_array(qcdb.vib.filter_omega_to_real(vibonly['omega'].data)). core.Wavefunction.frequencies = _core_wavefunction_frequencies. def _core_doublet(A, B, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:8228,Performance,load,load,8228,"rn wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self: core.Wavefunction, filenumber: int) -> str:; """"""Return canonical path to scratch file `filenumber` based on molecule on `self`. Parameters; ----------; self; Wavefunction instance.; filenumber; Scratch file number from :source:`psi4/include/psi4/psifiles.h`. """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmoni",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:8328,Performance,load,load,8328,") -> str:; """"""Return canonical path to scratch file `filenumber` based on molecule on `self`. Parameters; ----------; self; Wavefunction instance.; filenumber; Scratch file number from :source:`psi4/include/psi4/psifiles.h`. """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_pu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:8511,Performance,load,load,8511,"e.; filenumber; Scratch file number from :source:`psi4/include/psi4/psifiles.h`. """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:8603,Performance,load,load,8603,"e = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:8634,Performance,load,load,8634,"(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data laid out like; :meth:`~psi4.core.Wavefunction.to_file`. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to; :py:func:`numpy.load` to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables to psi4 specific data types (Matrix, Vector, Dimension); for label in wfn_matrix:; array = wfn_matrix[label]; wfn_matrix[l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:19924,Testability,test,test,19924,"h(); parsed_pcm = pcmsolver.parse_pcm_input(fl.name); extras.register_scratch_file(fl.name). with NamedTemporaryFile(mode=""w+t"", delete=False) as fl:; fl.write(parsed_pcm); core.set_local_option(""PCM"", ""PCMSOLVER_PARSED_FNAME"", fl.name); extras.register_scratch_file(fl.name) # retain with -m (messy) option. def _basname(name: str) -> str:; """"""Imitates :py:meth:`core.BasisSet.make_filename` without the gbs extension.""""""; return name.lower().replace('+', 'p').replace('*', 's').replace('(', '_').replace(')', '_').replace(',', '_'). [docs]; def temp_circular_import_blocker():; pass. [docs]; def basis_helper(block: str, name: str = '', key: str = 'BASIS', set_option: bool = True):; """"""Helper to specify a custom basis set in PsiAPI mode. This function forms a basis specification function from *block*; and associates it with keyword *key* under handle *name*. Registers; the basis spec with Psi4 so that it can be applied again to future; molecules. For usage, see :srcsample:`mints2`, :srcsample:`mints9`, and; :srcsample:`cc54` test cases. Parameters; ----------; block; Text that goes in a PSIthon ``basis {...}`` block.; name; Name label to associated with basis specified by `block`.; key; Basis keyword specified by `block`.; set_option; When True, execute the equivalent of ``set key name`` or ``set_option({key: name})``. When False, skip execution. """"""; key = key.upper(); name = ('anonymous' + str(uuid.uuid4())[:8]) if name == '' else name; cleanbas = _basname(name).replace('-', '') # further remove hyphens so can be function name; block = qcel.util.filter_comments(block); command_lines = re.split('\n', block). symbol_re = re.compile(r'^\s*assign\s+(?P<symbol>[A-Z]{1,3})\s+(?P<basis>[-+*\(\)\w]+)\s*$', re.IGNORECASE); label_re = re.compile(; r'^\s*assign\s+(?P<label>(?P<symbol>[A-Z]{1,3})(?:(_\w+)|(\d+))?)\s+(?P<basis>[-+*\(\)\w]+)\s*$',; re.IGNORECASE); all_re = re.compile(r'^\s*assign\s+(?P<basis>[-+*\(\)\w]+)\s*$', re.IGNORECASE); basislabel = re.compile(r'\s*\[\s*([-*\(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:33420,Testability,assert,assert,33420,"ex(p[0])); elif key.upper() in [""MULLIKEN_CHARGES"", ""LOWDIN_CHARGES"", ""MULLIKEN CHARGES"", ""LOWDIN CHARGES""]:; reshaper = (-1, ). if reshaper:; return val.np.reshape(reshaper); else:; return val. def _multipole_compressor(complete: np.ndarray, order: int) -> np.ndarray:; """"""Form flat unique components multipole array from complete Cartesian array. Parameters; ----------; order; Multipole order. e.g., 1 for dipole, 4 for hexadecapole.; complete; Multipole array, order-dimensional Cartesian array expanded to complete components. Returns; -------; compressed : numpy.ndarray; Multipole array, length (order + 1) * (order + 2) / 2 compressed to unique components. """"""; compressed = []; for ii in range(order + 1):; lx = order - ii; for lz in range(ii + 1):; ly = ii - lz. np_index = []; for xval in range(lx):; np_index.append(0); for yval in range(ly):; np_index.append(1); for zval in range(lz):; np_index.append(2); compressed.append(complete[tuple(np_index)]). assert len(compressed) == ((order + 1) * (order + 2) / 2); return np.array(compressed). def _multipole_plumper(compressed: np.ndarray, order: int) -> np.ndarray:; """"""Form multidimensional multipole array from unique components array. Parameters; ----------; order; Multipole order. e.g., 1 for dipole, 4 for hexadecapole.; compressed; Multipole array, length (order + 1) * (order + 2) / 2 compressed to unique components. Returns; -------; complete : numpy.ndarray; Multipole array, order-dimensional Cartesian array expanded to complete components. """"""; shape = tuple([3] * order); complete = np.zeros(shape). def compound_index(counter):; # thanks, https://www.pamoc.it/tpc_cart_mom.html Eqn 2.2!; # jn = nz + (ny + nz)(ny + nz + 1) / 2; return int(; counter.get(""2"", 0) + (counter.get(""1"", 0) + counter.get(""2"", 0)) *; (counter.get(""1"", 0) + counter.get(""2"", 0) + 1) / 2). for idx in product(""012"", repeat=order):; xyz_counts = Counter(idx) # ""010"" --> {""0"": 2, ""1"": 1}; np_index = tuple(int(x) for x in idx) # ('0', '1') --> (0, 1",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html:3508,Usability,simpl,simple,3508,"; ) -> Union[core.BasisSet, List[core.BasisSet]]:; """"""Build a primary or auxiliary basis set. Parameters; ----------; mol; Molecule for which to build the basis set instance.; key; {'BASIS', 'ORBITAL', 'DF_BASIS_SCF', 'DF_BASIS_MP2', 'DF_BASIS_CC', 'BASIS_RELATIVISTIC', 'DF_BASIS_SAD'}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ``""ORBITAL""`` or ``""BASIS""``.; target; Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from `key` in global options. If; a user-defined-basis callable is available at string `target`, `target`; value will be set to it. In practice, setting this argument to a; |PSIfour| keyword (e.g., ``core.get_option(""SCF"", ""DF_BASIS_SCF"")`` or; ``core.get_global_option(""BASIS"")``) works to handle both simple and; user-defined bases.; fitrole; {'ORBITAL', 'JKFIT', 'RIFIT', 'DECON'}; Role for which to build basis. Only used when `key` indicates auxiliary; (i.e., *is not* ``""BASIS""``) and auxiliary spec from processing `target`; can't complete the `mol`. Then, primary spec from `other` can be used; to complete the auxiliary basis by looking up suitable default basis; according to `fitrole`.; other; Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like `target`.; puream; Whether to override the native spherical/cartesian-ness of `target` for; returned basis? Value ``1`` forces spherical, value ``0`` forces; Cartesian, value ``-1`` (default) uses native puream. Note that; explicitly setting :term:`PUREAM <PUREAM (GLOBALS)>` trumps both native; puream and this `puream` argument.; return_atomlist; Build one-atom basis sets (e.g., for SAD) rather than one whole-`mol`; basis set.; quiet; When True, do not print to the output file.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/python_helpers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:2011,Availability,mask,mask,2011,"Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""cg_solver"",; ""davidson_solver"",; ""DIIS"",; ""hamiltonian_solver"",; ""SolverEngine"",; ]. import time; from abc import ABC, abstractmethod; from typing import Any, Callable, Dict, List, Optional, Type. import numpy as np. from psi4 import core. from .exceptions import ValidationError. """"""; Generalized iterative solvers for Psi4. """""". [docs]; def cg_solver(; rhs_vec: List[core.Matrix],; hx_function: Callable,; preconditioner: Callable,; guess: Optional[List[core.Matrix]] = None,; printer: Optional[Callable] = None,; printlvl: int = 1,; maxiter: int = 20,; rcond: float = 1.e-6) -> List[core.Matrix]:; """"""; Solves the :math:`Ax = b` linear equations via Conjugate Gradient. The `A` matrix must be a hermitian, positive definite matrix. Parameters; ----------; rhs_vec; The RHS vector in the Ax=b equation.; hx_function; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the preconditioned value.; guess; Starting vectors. If None, use a preconditioner (rhs) guess; printer; Takes in a list of current x and residual vectors and provides a print function. This function can also; return a value that represents the current residual.; printlvl; The level of printing provided by this function.; maxiter; The maximum number of iterations this function will take.; rcond; The residual norm for convergence. Returns; -------; ret : List[Matrix]; Solved `x` vectors and `r` vectors. Notes; -----; This is a generalized cg solver that can also take advantage of solving multiple RHS's simultaneously when; it is advantageous to do so. """""". tstart = time.time(); if printlvl:; core.print_out(""\n -----------------------------------------------------\n""); core.print_out("" "" + ""Generalized CG Solver"".center(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:2151,Availability,mask,mask,2151,"_solver"",; ""DIIS"",; ""hamiltonian_solver"",; ""SolverEngine"",; ]. import time; from abc import ABC, abstractmethod; from typing import Any, Callable, Dict, List, Optional, Type. import numpy as np. from psi4 import core. from .exceptions import ValidationError. """"""; Generalized iterative solvers for Psi4. """""". [docs]; def cg_solver(; rhs_vec: List[core.Matrix],; hx_function: Callable,; preconditioner: Callable,; guess: Optional[List[core.Matrix]] = None,; printer: Optional[Callable] = None,; printlvl: int = 1,; maxiter: int = 20,; rcond: float = 1.e-6) -> List[core.Matrix]:; """"""; Solves the :math:`Ax = b` linear equations via Conjugate Gradient. The `A` matrix must be a hermitian, positive definite matrix. Parameters; ----------; rhs_vec; The RHS vector in the Ax=b equation.; hx_function; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the Hessian-vector product.; preconditioner; Takes in a list of :py:class:`~psi4.core.Matrix` objects and a mask of active indices. Returns the preconditioned value.; guess; Starting vectors. If None, use a preconditioner (rhs) guess; printer; Takes in a list of current x and residual vectors and provides a print function. This function can also; return a value that represents the current residual.; printlvl; The level of printing provided by this function.; maxiter; The maximum number of iterations this function will take.; rcond; The residual norm for convergence. Returns; -------; ret : List[Matrix]; Solved `x` vectors and `r` vectors. Notes; -----; This is a generalized cg solver that can also take advantage of solving multiple RHS's simultaneously when; it is advantageous to do so. """""". tstart = time.time(); if printlvl:; core.print_out(""\n -----------------------------------------------------\n""); core.print_out("" "" + ""Generalized CG Solver"".center(52) + ""\n""); core.print_out("" "" + ""by Daniel. G. A. Smith"".center(52) + ""\n""); core.print_out("" --------------------------------------------",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:5334,Availability,mask,mask,5334,"e\n' % np.mean(resid)); core.print_out("" %5s %14.3e %12.3e %7d %9d\n"" %; (""Guess"", np.mean(resid), np.max(resid), len(z_vec), time.time() - tstart)). rms = np.mean(resid); rz_old = [0.0 for x in range(nrhs)]; alpha = [0.0 for x in range(nrhs)]; active = np.where(active_mask)[0]. # CG iterations; for rot_iter in range(maxiter):. # Build old RZ so we can discard vectors; for x in active:; rz_old[x] = r_vec[x].vector_dot(z_vec[x]). # Build Hx product; Ap_vec = hx_function(p_vec, active_mask). # Update x and r; for x in active:; alpha[x] = rz_old[x] / Ap_vec[x].vector_dot(p_vec[x]); if np.isnan(alpha)[0]:; core.print_out(""CG: Alpha is NaN for vector %d. Stopping vector."" % x); active_mask[x] = False; continue. x_vec[x].axpy(alpha[x], p_vec[x]); r_vec[x].axpy(-alpha[x], Ap_vec[x]); resid[x] = (r_vec[x].sum_of_squares() / grad_dot[x])**0.5. # Print out or compute the resid function; if printer:; resid = printer(rot_iter + 1, x_vec, r_vec). # Figure out active updated active mask; for x in active:; if (resid[x] < rcond):; active_mask[x] = False. # Print out if requested; if printlvl:; core.print_out("" %5d %14.3e %12.3e %7d %9d\n"" %; (rot_iter + 1, np.mean(resid), np.max(resid), sum(active_mask), time.time() - tstart)). active = np.where(active_mask)[0]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the large",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6076,Availability,error,error,6076,"e. x_vec[x].axpy(alpha[x], p_vec[x]); r_vec[x].axpy(-alpha[x], Ap_vec[x]); resid[x] = (r_vec[x].sum_of_squares() / grad_dot[x])**0.5. # Print out or compute the resid function; if printer:; resid = printer(rot_iter + 1, x_vec, r_vec). # Figure out active updated active mask; for x in active:; if (resid[x] < rcond):; active_mask[x] = False. # Print out if requested; if printlvl:; core.print_out("" %5d %14.3e %12.3e %7d %9d\n"" %; (rot_iter + 1, np.mean(resid), np.max(resid), sum(active_mask), time.time() - tstart)). active = np.where(active_mask)[0]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapol",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6214,Availability,error,error,6214,"ut or compute the resid function; if printer:; resid = printer(rot_iter + 1, x_vec, r_vec). # Figure out active updated active mask; for x in active:; if (resid[x] < rcond):; active_mask[x] = False. # Print out if requested; if printlvl:; core.print_out("" %5d %14.3e %12.3e %7d %9d\n"" %; (rot_iter + 1, np.mean(resid), np.max(resid), sum(active_mask), time.time() - tstart)). active = np.where(active_mask)[0]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state ve",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6447,Availability,error,error,6447,"t_out("" %5d %14.3e %12.3e %7d %9d\n"" %; (rot_iter + 1, np.mean(resid), np.max(resid), sum(active_mask), time.time() - tstart)). active = np.where(active_mask)[0]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6723,Availability,error,error,6723," beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6772,Availability,error,error,6772,"ld[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for nu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6863,Availability,error,error,6863,"----------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6882,Availability,error,error,6882,"----------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6906,Availability,error,error,6906,"---\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:6919,Availability,error,error,6919,"return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vec",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:7121,Availability,error,error,7121,"ate vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the largest RMS value. """""". def __init__(self, max_vec: int = 6, removal_policy: str = ""OLDEST""):; self.error = []; self.state = []; self.max_vec = max_vec; self.removal_policy = removal_policy.upper(). if self.removal_policy not in [""LARGEST"", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is un",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:7581,Availability,error,error,7581,""", ""OLDEST""]:; raise ValidationError(""DIIS: removal_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enume",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:7620,Availability,error,error,7620,"al_policy must either be oldest or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enumerate(ci[:-1]):; out.axpy(c, self.state[num]). ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:7657,Availability,error,error,7657,"t or largest.""). [docs]; def add(self, state: core.Matrix, error: core.Matrix):; """"""; Adds a DIIS state and error vector to the DIIS object. Parameters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enumerate(ci[:-1]):; out.axpy(c, self.state[num]). return out. def _diag_print_headi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:7795,Availability,error,error,7795,"meters; ----------; state; The current state vector.; error; The current error vector. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enumerate(ci[:-1]):; out.axpy(c, self.state[num]). return out. def _diag_print_heading(title_lines, solver_name, max_ss_size, nroot, r_convergence, maxiter, verbose=1):; """"""Print a message to the output file when the solver has p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:7870,Availability,error,error,7870,"r. """"""; self.error.append(error.clone()); self.state.append(state.clone()). [docs]; def extrapolate(self, out: Optional[core.Matrix] = None) -> core.Matrix:; """"""; Extrapolates next state vector from the current set of state and error vectors. Parameters; ----------; out; A array in which to place the next state vector. Returns; -------; ret : Matrix; Returns the next state vector. """""". # Limit size of DIIS vector; diis_count = len(self.state). if diis_count == 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enumerate(ci[:-1]):; out.axpy(c, self.state[num]). return out. def _diag_print_heading(title_lines, solver_name, max_ss_size, nroot, r_convergence, maxiter, verbose=1):; """"""Print a message to the output file when the solver has processed all options and is ready to begin""""""; if verbose < 1:; # no printing; retur",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:9170,Availability,toler,tolerance,9170,".ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enumerate(ci[:-1]):; out.axpy(c, self.state[num]). return out. def _diag_print_heading(title_lines, solver_name, max_ss_size, nroot, r_convergence, maxiter, verbose=1):; """"""Print a message to the output file when the solver has processed all options and is ready to begin""""""; if verbose < 1:; # no printing; return; # show title if not silent; core.print_out(""\n\n""); core.print_out(""\n"".join([x.center(77) for x in title_lines])); core.print_out(""\n""). core.print_out(""\n ==> Options <==\n\n""); core.print_out(f"" Max number of iterations = {maxiter:<5d}\n""); core.print_out(f"" Eigenvector tolerance = {r_convergence:.4e}\n""); core.print_out(f"" Max number of expansion vectors = {max_ss_size:<5d}\n""); core.print_out(""\n""); # show iteration info headings if not silent; core.print_out("" => Iterations <=\n""); if verbose == 1:; # default printing one line per iter max delta value and max residual norm; core.print_out(f"" {' ' * len(solver_name)} Max[D[value]] Max[|R|] # vectors\n""); else:; # verbose printing, value, delta, and |R| for each root; core.print_out(f"" {' ' * len(solver_name)} value D[value] |R| # vectors\n""). def _diag_print_info(solver_name, info, verbose=1):; """"""Print a message to the output file at each iteration""""""; if verbose < 1:; # no printing; return; elif verbose == 1:; # print iter maxde max|R| conv/restart; flags = []; if info['collapse']:; flags.append(""Restart""); if info['done']:; flags.append(""Converged""). m_de = np.max(info['delta_val']); m_r = np.max(info['res_norm']); nvec = info[""nvec""]; flgs = ""/"".join(flags); core.print_out(; f"" {solver_name} iter ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:19068,Availability,down,down,19068,"actmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired transition property.; prefactor; Optional float scaling factor. Returns; -------; residue : Any; The transition property.; """"""; pass. [docs]; def davidson_solver(; engine: Type[SolverEngine],; guess: List,; *,; nroot: int,; r_convergence: float = 1.0E-4,; max_ss_size: int = 100,; maxiter: int = 60,; verbose: int = 1,; nonneg_only: bool = False) -> Dict[str, Any]:; """"""Solves for the lowest few eigenvalues and eigenvectors of a large problem emulated through an engine. If the large matrix `A` has dimension `{NxN}` and N is very large, and only; a small number of roots, `k` are desired this algorithm is preferable to; standard methods as uses on the order of `N * k` memory. One only needs to; have the ability to compute the product of a times a vector. For non-hermitan `A` the basis of the algorithm breaks down. However in; practice, for strongly diagonally-dominant `A` such as the; similarity-transformed Hamiltonian in EOM-CC this algorithm is commonly still; used. Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:19543,Availability,toler,tolerance,19543,"0,; maxiter: int = 60,; verbose: int = 1,; nonneg_only: bool = False) -> Dict[str, Any]:; """"""Solves for the lowest few eigenvalues and eigenvectors of a large problem emulated through an engine. If the large matrix `A` has dimension `{NxN}` and N is very large, and only; a small number of roots, `k` are desired this algorithm is preferable to; standard methods as uses on the order of `N * k` memory. One only needs to; have the ability to compute the product of a times a vector. For non-hermitan `A` the basis of the algorithm breaks down. However in; practice, for strongly diagonally-dominant `A` such as the; similarity-transformed Hamiltonian in EOM-CC this algorithm is commonly still; used. Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:20909,Availability,failure,failure,20909,"-------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly.; """"""; nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""done"": True,; ""nvec"": 0,; ""collapse"": False,; ""product_count"": 0,; }. print_name = ""DavidsonSolver""; title_lines = [""Generalized Davidson Solver"", ""By Ruhee Dcunha""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; stats = []; best_eigvecs = []; best_eigvals = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'] += 1; old_vals = iter_info['val'].copy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if ss dimension has exceeded limits; if l >= max_ss_size:; iter_info['collapse'] = True. # compute A times trial vector products; Ax, npro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:25668,Availability,toler,tolerance,25668," is positive definite, we can transform the problem to arrive at the hermitian NxN EVP:; :math:`(A-B)^{1/2}(A+B)(A-B)^{1/2} = w^2 T`. Where :math:`T = (A-B)^{-1/2}(X+Y)`. We use a Davidson like iteration where we transform :math:`(A+B)` (H1) and :math:`(A-B)`; (H2) in to the subspace defined by the trial vectors.; The subspace analog of the NxN hermitian EVP is diagonalized and left :math:`(X-Y)`; and right :math:`(X+Y)` eigenvectors of the NxN non-hermitian EVP are approximated.; Residual vectors are formed for both and the guess space is augmented with; two correction vectors per iteration. The advantages and properties of this; algorithm are described in the literature [stratmann:1998]_ . Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue correspond",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:27156,Availability,failure,failure,27156,"or`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; best_L = []; best_R = []; best_vals = []; stats = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'] += 1; old_w = iter_info['val'].copy(). # reset flags; iter_info['collapse'] = Fal",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:29104,Availability,failure,failure,29104,"opy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if subspace dimension has exceeded limits; if l >= max_ss_size:; iter_info['collapse'] = True. # compute [A+B]*v (H1x) and [A-B]*v (H2x); H1x, H2x, nprod = engine.compute_products(vecs); iter_info['product_count'] += nprod. # form x*H1x (H1_ss) and x*H2x (H2_ss); H1_ss = np.zeros((l, l)); H2_ss = np.zeros((l, l)); for i in range(l):; for j in range(l):; H1_ss[i, j] = engine.vector_dot(vecs[i], H1x[j]); H2_ss[i, j] = engine.vector_dot(vecs[i], H2x[j]). _print_array(""Subspace Transformed (A+B)"", H1_ss, verbose); _print_array(""Subspace Transformed (A-B)"", H2_ss, verbose). # Diagonalize H2 in the subspace (eigen-decomposition to compute H2^(1/2)); H2_ss_val, H2_ss_vec = np.linalg.eigh(H2_ss); _print_array(""eigenvalues H2_ss"", H2_ss_val, verbose); _print_array(""eigenvectors H2_ss"", H2_ss_vec, verbose). # Check H2 is PD; # NOTE: If this triggers failure the SCF solution is not stable. A few ways to handle this; # 1. Use davidson solver where product function evaluates (H2 * (H1 * X)); # - Poor convergence; # 2. Switch to CIS/TDA; # - User would probably not expect this; # 3. Perform Stability update and restart with new reference; if np.any(H2_ss_val < 0.0):; msg = (""The H2 matrix is not Positive Definite. "" ""This means the reference state is not stable.""); raise RuntimeError(msg). # Build H2^(1/2); H2_ss_half = np.einsum(""ik,k,jk->ij"", H2_ss_vec, np.sqrt(H2_ss_val), H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:5319,Deployability,update,updated,5319,"e\n' % np.mean(resid)); core.print_out("" %5s %14.3e %12.3e %7d %9d\n"" %; (""Guess"", np.mean(resid), np.max(resid), len(z_vec), time.time() - tstart)). rms = np.mean(resid); rz_old = [0.0 for x in range(nrhs)]; alpha = [0.0 for x in range(nrhs)]; active = np.where(active_mask)[0]. # CG iterations; for rot_iter in range(maxiter):. # Build old RZ so we can discard vectors; for x in active:; rz_old[x] = r_vec[x].vector_dot(z_vec[x]). # Build Hx product; Ap_vec = hx_function(p_vec, active_mask). # Update x and r; for x in active:; alpha[x] = rz_old[x] / Ap_vec[x].vector_dot(p_vec[x]); if np.isnan(alpha)[0]:; core.print_out(""CG: Alpha is NaN for vector %d. Stopping vector."" % x); active_mask[x] = False; continue. x_vec[x].axpy(alpha[x], p_vec[x]); r_vec[x].axpy(-alpha[x], Ap_vec[x]); resid[x] = (r_vec[x].sum_of_squares() / grad_dot[x])**0.5. # Print out or compute the resid function; if printer:; resid = printer(rot_iter + 1, x_vec, r_vec). # Figure out active updated active mask; for x in active:; if (resid[x] < rcond):; active_mask[x] = False. # Print out if requested; if printlvl:; core.print_out("" %5d %14.3e %12.3e %7d %9d\n"" %; (rot_iter + 1, np.mean(resid), np.max(resid), sum(active_mask), time.time() - tstart)). active = np.where(active_mask)[0]. if sum(active_mask) == 0:; break. # Update p; z_vec = preconditioner(r_vec, active_mask); for x in active:; beta = r_vec[x].vector_dot(z_vec[x]) / rz_old[x]; p_vec[x].scale(beta); p_vec[x].axpy(1.0, z_vec[x]). if printlvl:; core.print_out("" -----------------------------------------------------\n""). return x_vec, r_vec. [docs]; class DIIS:; """"""; An object to assist in the DIIS extrpolation procedure. Parameters; ----------; max_vec; The maximum number of error and state vectors to hold. These are pruned based off the removal policy.; removal_policy; {""OLDEST"", ""LARGEST""}; How the state and error vectors are removed once at the maximum. OLDEST will remove the oldest vector while; largest will remove the residual with the large",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:17277,Deployability,update,updated,17277,"ine calls this method with no arguments. So any defined by the; engine for its own use should be optional. Returns; -------; X : singlet `vector`; This should be a new vector object with the correct dimensions,; assumed to be zeroed out; """"""; pass. [docs]; def vector_dot(X, Y) -> float:; """"""Compute a dot product between two `vectors`. Parameters; ----------; X : single `vector`; Y : single `vector`. Returns; -------; a : float; The dot product (X x Y); """"""; pass. # cython doesn't like static+ decorators https://github.com/cython/cython/issues/1434#issuecomment-608975116; vector_dot = staticmethod(abstractmethod(vector_dot)). [docs]; @abstractmethod; def vector_axpy(a: float, X, Y):; """"""Compute scaled `vector` addition operation `a*X + Y`. Parameters; ----------; a; The scale factor applied to `X`; X : singlet `vector`; The `vector` which will be scaled and added to `Y`; Y : single `vector`; The `vector` which the result of `a*X` is added to. Returns; -------; Y : single `vector`; The solver assumes that Y is updated, and returned. So it is safe to; avoid a copy of Y if possible; """"""; pass. [docs]; @abstractmethod; def vector_scale(a: float, X):; """"""Scale a vector by some factor. Parameters; ----------; a; The scale facor; X : single `vector`; The vector that will be scaled. Returns; -------; X : single `vector`; The solver assumes that the passed vector is modifed. So it is save; to avoid a copy of X if possible.; """"""; pass. [docs]; @abstractmethod; def vector_copy(X):; """"""Make a copy of a `vector`. Parameters; ----------; X : single `vector`; The `vector` to copy. Returns; -------; X' : single `vector`; A copy of `X` should be distinct object that can be modified; independently of the passed object, Has the same data when returned.; """"""; pass. [docs]; @abstractmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:22558,Deployability,update,update,22558,"l'].copy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if ss dimension has exceeded limits; if l >= max_ss_size:; iter_info['collapse'] = True. # compute A times trial vector products; Ax, nprod = engine.compute_products(vecs); iter_info['product_count'] += nprod. # Build Subspace matrix; G = np.zeros((l, l)); for i in range(l):; for j in range(i):; G[i, j] = G[j, i] = engine.vector_dot(vecs[i], Ax[j]); G[i, i] = engine.vector_dot(vecs[i], Ax[i]). _print_array(""SS transformed A"", G, verbose). # diagonalize subspace matrix; lam, alpha = np.linalg.eigh(G). _print_array(""SS eigenvectors"", alpha, verbose); _print_array(""SS eigenvalues"", lam, verbose). if nonneg_only:; # remove zeros/negatives; alpha = alpha[:, lam > 1.0e-10]; lam = lam[lam > 1.0e-10]. # sort/truncate to nroot; idx = np.argsort(lam); lam = lam[idx]; alpha = alpha[:, idx]. # update best_solution; best_eigvecs = _best_vectors(engine, alpha[:, :nk], vecs); best_eigvals = lam[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vector; Rk = engine.new_vector(); lam_k = lam[k]; for i in range(l):; Axi = Ax[i]; Rk = engine.vector_axpy(alpha[i, k], Axi, Rk). Rk = engine.vector_axpy(-1.0 * lam_k, best_eigvecs[k], Rk). iter_info['val'][k] = lam_k; iter_info['delta_val'][k] = abs(old_vals[k] - lam_k); iter_info['res_norm'][k] = np.sqrt((engine.vector_dot(Rk, Rk))). # augment guess vector for non-converged roots; if (iter_info[""res_norm""][k] > r_convergence):; iter_info['done'] = False; Qk = engine.precondition(Rk, lam_k); new_vecs.append(Qk). # print iteration info to output; _diag_print_info(print_name, iter_info, verbose). # save stats for this iteration; stats.append(iter_info.copy()). if iter_info['done']:. # finished; _diag_print_converged(print_name, stats, best_eigvals, verbose); break; elif iter_info['collapse']:. # restart needed; vecs = best_eigvecs; else:. # Regular ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:23618,Deployability,update,update,23618," check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vector; Rk = engine.new_vector(); lam_k = lam[k]; for i in range(l):; Axi = Ax[i]; Rk = engine.vector_axpy(alpha[i, k], Axi, Rk). Rk = engine.vector_axpy(-1.0 * lam_k, best_eigvecs[k], Rk). iter_info['val'][k] = lam_k; iter_info['delta_val'][k] = abs(old_vals[k] - lam_k); iter_info['res_norm'][k] = np.sqrt((engine.vector_dot(Rk, Rk))). # augment guess vector for non-converged roots; if (iter_info[""res_norm""][k] > r_convergence):; iter_info['done'] = False; Qk = engine.precondition(Rk, lam_k); new_vecs.append(Qk). # print iteration info to output; _diag_print_info(print_name, iter_info, verbose). # save stats for this iteration; stats.append(iter_info.copy()). if iter_info['done']:. # finished; _diag_print_converged(print_name, stats, best_eigvals, verbose); break; elif iter_info['collapse']:. # restart needed; vecs = best_eigvecs; else:. # Regular subspace update, orthonormalize preconditioned residuals and add to the trial set; vecs = _gs_orth(engine, vecs, new_vecs). # always return, the caller should check ret[""stats""][-1]['done'] == True for convergence; return {""eigvals"": best_eigvals, ""eigvecs"": list(zip(best_eigvecs, best_eigvecs)), ""stats"": stats}. [docs]; def hamiltonian_solver(; engine: Type[SolverEngine],; guess: List,; *,; nroot: int,; r_convergence: float = 1.0E-4,; max_ss_size: int = 100,; maxiter: int = 60,; verbose: int = 1):; """"""Finds the smallest eigenvalues and associated right and left hand; eigenvectors of a large real Hamiltonian eigenvalue problem emulated; through an engine. A Hamiltonian eigenvalue problem (EVP) has the following structure::. [A B][X] = [1 0](w)[X]; [B A][Y] [0 -1](w)[Y]. with A, B of some large dimension N, the problem is of dimension 2Nx2N. The real, Hamiltonian EVP can be rewritten as the NxN, non-hermitian EVP:; :math:`(A+B)(A-B)(X+Y) = w^2(X+Y)`. With left-hand eigenvectors:; :math:`(X-Y)(A-B)(A+B) = w^2(X-Y)`. if :math:`(A-B)` is positi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:29356,Deployability,update,update,29356,") and [A-B]*v (H2x); H1x, H2x, nprod = engine.compute_products(vecs); iter_info['product_count'] += nprod. # form x*H1x (H1_ss) and x*H2x (H2_ss); H1_ss = np.zeros((l, l)); H2_ss = np.zeros((l, l)); for i in range(l):; for j in range(l):; H1_ss[i, j] = engine.vector_dot(vecs[i], H1x[j]); H2_ss[i, j] = engine.vector_dot(vecs[i], H2x[j]). _print_array(""Subspace Transformed (A+B)"", H1_ss, verbose); _print_array(""Subspace Transformed (A-B)"", H2_ss, verbose). # Diagonalize H2 in the subspace (eigen-decomposition to compute H2^(1/2)); H2_ss_val, H2_ss_vec = np.linalg.eigh(H2_ss); _print_array(""eigenvalues H2_ss"", H2_ss_val, verbose); _print_array(""eigenvectors H2_ss"", H2_ss_vec, verbose). # Check H2 is PD; # NOTE: If this triggers failure the SCF solution is not stable. A few ways to handle this; # 1. Use davidson solver where product function evaluates (H2 * (H1 * X)); # - Poor convergence; # 2. Switch to CIS/TDA; # - User would probably not expect this; # 3. Perform Stability update and restart with new reference; if np.any(H2_ss_val < 0.0):; msg = (""The H2 matrix is not Positive Definite. "" ""This means the reference state is not stable.""); raise RuntimeError(msg). # Build H2^(1/2); H2_ss_half = np.einsum(""ik,k,jk->ij"", H2_ss_vec, np.sqrt(H2_ss_val), H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}T",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:32257,Deployability,update,update,32257,"; best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['val'][k] = w[k]. # augment the guess space for non-converged roots; if (iter_info['res_norm'][k] > r_convergence):; iter_info['done'] = False; new_vecs.append(engine.precondition(WR_k, w[k])); new_vecs.append(engine.precondition(WL_k, w[k])). # print iteration info to output; _diag_print_info(print_name, iter_info, verbose). # save stats for this iteration; stats.append(iter_info.copy()). if iter_info['done']:. # Finished; _diag_print_converged(print_name, stats, w[:nk], rvec=best_R, lvec=best_L, verbose=verbose); break. elif iter_info['collapse']:. # need to orthonormalize union of the Left/Right solutions on restart; vecs = _gs_orth(engine, [], best_R + best_L); else:. # Regular subspace update, orthonormalize preconditioned residuals and add to the trial set; vecs = _gs_orth(engine, vecs, new_vecs). # always return, the caller should check ret[""stats""][-1]['done'] == True for convergence; return {""eigvals"": best_vals, ""eigvecs"": list(zip(best_R, best_L)), ""stats"": stats}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.solvers.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:32730,Deployability,update,updated,32730,"; best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['val'][k] = w[k]. # augment the guess space for non-converged roots; if (iter_info['res_norm'][k] > r_convergence):; iter_info['done'] = False; new_vecs.append(engine.precondition(WR_k, w[k])); new_vecs.append(engine.precondition(WL_k, w[k])). # print iteration info to output; _diag_print_info(print_name, iter_info, verbose). # save stats for this iteration; stats.append(iter_info.copy()). if iter_info['done']:. # Finished; _diag_print_converged(print_name, stats, w[:nk], rvec=best_R, lvec=best_L, verbose=verbose); break. elif iter_info['collapse']:. # need to orthonormalize union of the Left/Right solutions on restart; vecs = _gs_orth(engine, [], best_R + best_L); else:. # Regular subspace update, orthonormalize preconditioned residuals and add to the trial set; vecs = _gs_orth(engine, vecs, new_vecs). # always return, the caller should check ret[""stats""][-1]['done'] == True for convergence; return {""eigvals"": best_vals, ""eigvecs"": list(zip(best_R, best_L)), ""stats"": stats}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.solvers.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:8351,Energy Efficiency,power,power,8351,"== 0:; raise ValidationError(""DIIS: No previous vectors.""); if diis_count == 1:; return self.state[0]. if diis_count > self.max_vec:. if self.removal_policy == ""OLDEST"":; pos = 0; else:; pos = np.argmax([x.rms() for x in self.error]). del self.state[pos]; del self.error[pos]; diis_count -= 1. # Build error matrix B; B = np.empty((diis_count + 1, diis_count + 1)); B[-1, :] = 1; B[:, -1] = 1; B[-1, -1] = 0; for num1, e1 in enumerate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enumerate(ci[:-1]):; out.axpy(c, self.state[num]). return out. def _diag_print_heading(title_lines, solver_name, max_ss_size, nroot, r_convergence, maxiter, verbose=1):; """"""Print a message to the output file when the solver has processed all options and is ready to begin""""""; if verbose < 1:; # no printing; return; # show title if not silent; core.print_out(""\n\n""); core.print_out(""\n"".join([x.center(77) for x in title_lines])); core.print_out(""\n""). core.print_out(""\n ==> Options <==\n\n""); core.print_out(f"" Max number of iterations = {maxiter:<5d}\n""); core.print_out(f"" Eigenvector tolerance = {r_convergence:.4e}\n""); core.print_out(f"" Max number of expansion vectors = {max_ss_size:<5d}\n""); core.print_out(""\n""); # show iteration info headings if not silent; core.p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:27279,Energy Efficiency,efficient,efficient,27279,"he left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; best_L = []; best_R = []; best_vals = []; stats = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'] += 1; old_w = iter_info['val'].copy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if subspace dimension has exceeded limits; if l >= max_ss_size:; iter_info['collapse'] ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:8761,Integrability,message,message,8761,"rate(self.error):; B[num1, num1] = e1.vector_dot(e1); for num2, e2 in enumerate(self.error):; if num2 >= num1:; continue; val = e1.vector_dot(e2); B[num1, num2] = B[num2, num1] = val. # Build residual vector; resid = np.zeros(diis_count + 1); resid[-1] = 1. # Solve pulay equations. # Yea, yea this is unstable make it stable; iszero = np.any(np.diag(B)[:-1] <= 0.0); if iszero:; S = np.ones((diis_count + 1)); else:; S = np.diag(B).copy(); S[:-1] **= -0.5; S[-1] = 1. # Then we gotta do a custom inverse; B *= S[:, None] * S; invB = core.Matrix.from_array(B); invB.power(-1.0, 1.e-12). ci = np.dot(invB, resid); ci *= S. # combination of previous fock matrices; if out is None:; out = core.Matrix(""DIIS result"", self.state[0].rowdim(), self.state[1].coldim()); else:; out.zero(). for num, c in enumerate(ci[:-1]):; out.axpy(c, self.state[num]). return out. def _diag_print_heading(title_lines, solver_name, max_ss_size, nroot, r_convergence, maxiter, verbose=1):; """"""Print a message to the output file when the solver has processed all options and is ready to begin""""""; if verbose < 1:; # no printing; return; # show title if not silent; core.print_out(""\n\n""); core.print_out(""\n"".join([x.center(77) for x in title_lines])); core.print_out(""\n""). core.print_out(""\n ==> Options <==\n\n""); core.print_out(f"" Max number of iterations = {maxiter:<5d}\n""); core.print_out(f"" Eigenvector tolerance = {r_convergence:.4e}\n""); core.print_out(f"" Max number of expansion vectors = {max_ss_size:<5d}\n""); core.print_out(""\n""); # show iteration info headings if not silent; core.print_out("" => Iterations <=\n""); if verbose == 1:; # default printing one line per iter max delta value and max residual norm; core.print_out(f"" {' ' * len(solver_name)} Max[D[value]] Max[|R|] # vectors\n""); else:; # verbose printing, value, delta, and |R| for each root; core.print_out(f"" {' ' * len(solver_name)} value D[value] |R| # vectors\n""). def _diag_print_info(solver_name, info, verbose=1):; """"""Print a message to the ou",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:9769,Integrability,message,message,9769,"nd is ready to begin""""""; if verbose < 1:; # no printing; return; # show title if not silent; core.print_out(""\n\n""); core.print_out(""\n"".join([x.center(77) for x in title_lines])); core.print_out(""\n""). core.print_out(""\n ==> Options <==\n\n""); core.print_out(f"" Max number of iterations = {maxiter:<5d}\n""); core.print_out(f"" Eigenvector tolerance = {r_convergence:.4e}\n""); core.print_out(f"" Max number of expansion vectors = {max_ss_size:<5d}\n""); core.print_out(""\n""); # show iteration info headings if not silent; core.print_out("" => Iterations <=\n""); if verbose == 1:; # default printing one line per iter max delta value and max residual norm; core.print_out(f"" {' ' * len(solver_name)} Max[D[value]] Max[|R|] # vectors\n""); else:; # verbose printing, value, delta, and |R| for each root; core.print_out(f"" {' ' * len(solver_name)} value D[value] |R| # vectors\n""). def _diag_print_info(solver_name, info, verbose=1):; """"""Print a message to the output file at each iteration""""""; if verbose < 1:; # no printing; return; elif verbose == 1:; # print iter maxde max|R| conv/restart; flags = []; if info['collapse']:; flags.append(""Restart""); if info['done']:; flags.append(""Converged""). m_de = np.max(info['delta_val']); m_r = np.max(info['res_norm']); nvec = info[""nvec""]; flgs = ""/"".join(flags); core.print_out(; f"" {solver_name} iter {info['count']:3d}: {m_de:-11.5e} {m_r:12.5e} {nvec:>6d} {flgs}\n""); else:; # print iter / ssdim folowed by de/|R| for each root; core.print_out(f"" {solver_name} iter {info['count']:3d}: {info['nvec']:4d} guess vectors\n""); for i, (e, de, rn) in enumerate(zip(info['val'], info['delta_val'], info['res_norm'])):; s = "" "" * len(solver_name); core.print_out(f"" {i+1:2d}: {s:} {e:-11.5f} {de:-11.5e} {rn:12.5e}\n""); if info['done']:; core.print_out("" Solver Converged! all roots\n\n""); elif info['collapse']:; core.print_out("" Subspace limits exceeded restarting\n\n""). def _diag_print_converged(solver_name, stats, vals, verbose=1, **kwargs):; """"""Print a messag",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:10825,Integrability,message,message,10825,"tion""""""; if verbose < 1:; # no printing; return; elif verbose == 1:; # print iter maxde max|R| conv/restart; flags = []; if info['collapse']:; flags.append(""Restart""); if info['done']:; flags.append(""Converged""). m_de = np.max(info['delta_val']); m_r = np.max(info['res_norm']); nvec = info[""nvec""]; flgs = ""/"".join(flags); core.print_out(; f"" {solver_name} iter {info['count']:3d}: {m_de:-11.5e} {m_r:12.5e} {nvec:>6d} {flgs}\n""); else:; # print iter / ssdim folowed by de/|R| for each root; core.print_out(f"" {solver_name} iter {info['count']:3d}: {info['nvec']:4d} guess vectors\n""); for i, (e, de, rn) in enumerate(zip(info['val'], info['delta_val'], info['res_norm'])):; s = "" "" * len(solver_name); core.print_out(f"" {i+1:2d}: {s:} {e:-11.5f} {de:-11.5e} {rn:12.5e}\n""); if info['done']:; core.print_out("" Solver Converged! all roots\n\n""); elif info['collapse']:; core.print_out("" Subspace limits exceeded restarting\n\n""). def _diag_print_converged(solver_name, stats, vals, verbose=1, **kwargs):; """"""Print a message to the output file when the solver is converged.""""""; if verbose < 1:; # no printing; return; if verbose > 1:; # print values summary + number of iterations + # of ""big"" product evals; core.print_out("" Root # eigenvalue\n""); for (i, vi) in enumerate(vals):; core.print_out(f"" {i+1:^6} {vi:20.12f}\n""); max_nvec = max(istat['nvec'] for istat in stats); core.print_out(f""\n {solver_name} converged in {stats[-1]['count']} iterations\n""); core.print_out(f"" Computed a total of {stats[-1]['product_count']} large products\n\n""). def _print_array(name, arr, verbose):; """"""print a subspace quantity (numpy array) to the output file. Parameters; ----------; name : str; The name to print above the array; arr : :py:class:`np.ndarray`; The array to print; verbose : int; The amount of information to print. Only prints for verbose > 2; """"""; if verbose > 2:; core.print_out(f""\n\n{name}:\n{str(arr)}\n""). def _gs_orth(engine, U, V, thresh: float = 1.0e-8):; """"""Perform Gram-Schmidt ortho",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:19428,Integrability,depend,dependent,19428,"0,; maxiter: int = 60,; verbose: int = 1,; nonneg_only: bool = False) -> Dict[str, Any]:; """"""Solves for the lowest few eigenvalues and eigenvectors of a large problem emulated through an engine. If the large matrix `A` has dimension `{NxN}` and N is very large, and only; a small number of roots, `k` are desired this algorithm is preferable to; standard methods as uses on the order of `N * k` memory. One only needs to; have the ability to compute the product of a times a vector. For non-hermitan `A` the basis of the algorithm breaks down. However in; practice, for strongly diagonally-dominant `A` such as the; similarity-transformed Hamiltonian in EOM-CC this algorithm is commonly still; used. Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:25553,Integrability,depend,dependent,25553," is positive definite, we can transform the problem to arrive at the hermitian NxN EVP:; :math:`(A-B)^{1/2}(A+B)(A-B)^{1/2} = w^2 T`. Where :math:`T = (A-B)^{-1/2}(X+Y)`. We use a Davidson like iteration where we transform :math:`(A+B)` (H1) and :math:`(A-B)`; (H2) in to the subspace defined by the trial vectors.; The subspace analog of the NxN hermitian EVP is diagonalized and left :math:`(X-Y)`; and right :math:`(X+Y)` eigenvectors of the NxN non-hermitian EVP are approximated.; Residual vectors are formed for both and the guess space is augmented with; two correction vectors per iteration. The advantages and properties of this; algorithm are described in the literature [stratmann:1998]_ . Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue correspond",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:27313,Integrability,depend,dependent,27313,"he left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; best_L = []; best_R = []; best_vals = []; stats = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'] += 1; old_w = iter_info['val'].copy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if subspace dimension has exceeded limits; if l >= max_ss_size:; iter_info['collapse'] ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:14072,Modifiability,inherit,inherit,14072,"----------; engine : object; The engine passed to the solver, required to define vector algebraic operations needed; ss_vectors; Numpy array {l, k}.; The k eigenvectors of the subspace problem, l = dimension of the subspace basis, and k is the number of roots; basis_vectors; list of `vector` {l}.; The current basis vectors. Returns; -------; new_vecs; list of `vector` {k}.; The approximations of the k true eigenvectors.; """"""; l, n = ss_vectors.shape; new_vecs = []; for i in range(n):; cv_i = engine.new_vector(); for j in range(l):; cv_i = engine.vector_axpy(ss_vectors[j, i], basis_vectors[j], cv_i); new_vecs.append(cv_i); return new_vecs. [docs]; class SolverEngine(ABC):; """"""Abstract Base Class defining the API for a matrix-vector product object; required by solvers. Engines implement the correct product functions for iterative solvers that; do not require the target matrix be stored directly.; Classes intended to be used as an `engine` for :func:`davidson_solver` or; :func:`hamiltonian_solver` should inherit from this base class to ensure; that the required methods are defined. .. note:: The `vector` referred to here is intentionally vague, the solver; does not care what it is and only holds individual or sets of; them. In fact an individual `vector` could be split across two; elements in a list, such as for different spin.; Whatever data type is used and individual vector should be a; single element in a list such that len(list) returns the number; of vector-like objects.; """""". [docs]; @abstractmethod; def compute_products(self, X):; r""""""Compute a Matrix * trial vector products. Parameters; ----------; X : List[`vector`]; Trial vectors. Returns; -------; Expected by :func:`davidson_solver`. AX : List[`vector`]; The product :math:`A x X_{i}` for each `X_{i}` in `X`, in that; order. Where `A` is the hermitian matrix to be diagonalized.; `len(AX) == len(X)`; n : int; The number of products that were evaluated. If the object implements; product caching this may be less",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:20572,Performance,perform,performed,20572,"ax_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly.; """"""; nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""done"": True,; ""nvec"": 0,; ""collapse"": False,; ""product_count"": 0,; }. print_name = ""DavidsonSolver""; title_lines = [""Generalized Davidson Solver"", ""By Ruhee Dcunha""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; stats = []; best_eigvecs = []; best_eigvals = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:20656,Performance,perform,performed,20656,"ax_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly.; """"""; nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""done"": True,; ""nvec"": 0,; ""collapse"": False,; ""product_count"": 0,; }. print_name = ""DavidsonSolver""; title_lines = [""Generalized Davidson Solver"", ""By Ruhee Dcunha""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; stats = []; best_eigvecs = []; best_eigvals = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:20825,Performance,perform,performed,20825,">1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly.; """"""; nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""done"": True,; ""nvec"": 0,; ""collapse"": False,; ""product_count"": 0,; }. print_name = ""DavidsonSolver""; title_lines = [""Generalized Davidson Solver"", ""By Ruhee Dcunha""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; stats = []; best_eigvecs = []; best_eigvals = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_info['count'] += 1; old_vals = iter_info['val'].copy(). # reset flags; iter_info['collapse'] = False; iter_info['done'] = True. # get subspace dimension; l = len(vecs); iter_info['nvec'] = l. # check if ss dimension has exceeded limits; if l >= m",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:26819,Performance,perform,performed,26819," maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_head",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:26903,Performance,perform,performed,26903," maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_head",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:27072,Performance,perform,performed,27072," of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even when `maxiter` iterations are performed without convergence.; The caller **must check** ``stats[-1]['done']`` for failure and handle each case accordingly. References; ----------; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, ""An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules."" J. Chem. Phys.,; 109, 8218 (1998); """""". nk = nroot. iter_info = {; ""count"": 0,; ""res_norm"": np.zeros((nk)),; ""val"": np.zeros((nk)),; ""delta_val"": np.zeros((nk)),. # conv defaults to true, and will be flipped when a non-conv root is hit; ""conv"": True,; ""nvec"": 0,; ""product_count"": 0,; }; print_name = ""HamiltonianSolver""; title_lines = [""Generalized Hamiltonian Solver"", ""By Andrew M. James""]. _diag_print_heading(title_lines, print_name, max_ss_size, nroot, r_convergence, maxiter, verbose). vecs = guess; best_L = []; best_R = []; best_vals = []; stats = []; while iter_info['count'] < maxiter:. # increment iteration/ save old vals; iter_inf",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:29647,Performance,optimiz,optimize,29647,"ngine.vector_dot(vecs[i], H2x[j]). _print_array(""Subspace Transformed (A+B)"", H1_ss, verbose); _print_array(""Subspace Transformed (A-B)"", H2_ss, verbose). # Diagonalize H2 in the subspace (eigen-decomposition to compute H2^(1/2)); H2_ss_val, H2_ss_vec = np.linalg.eigh(H2_ss); _print_array(""eigenvalues H2_ss"", H2_ss_val, verbose); _print_array(""eigenvectors H2_ss"", H2_ss_vec, verbose). # Check H2 is PD; # NOTE: If this triggers failure the SCF solution is not stable. A few ways to handle this; # 1. Use davidson solver where product function evaluates (H2 * (H1 * X)); # - Poor convergence; # 2. Switch to CIS/TDA; # - User would probably not expect this; # 3. Perform Stability update and restart with new reference; if np.any(H2_ss_val < 0.0):; msg = (""The H2 matrix is not Positive Definite. "" ""This means the reference state is not stable.""); raise RuntimeError(msg). # Build H2^(1/2); H2_ss_half = np.einsum(""ik,k,jk->ij"", H2_ss_vec, np.sqrt(H2_ss_val), H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:29846,Performance,optimiz,optimize,29846,"bspace (eigen-decomposition to compute H2^(1/2)); H2_ss_val, H2_ss_vec = np.linalg.eigh(H2_ss); _print_array(""eigenvalues H2_ss"", H2_ss_val, verbose); _print_array(""eigenvectors H2_ss"", H2_ss_vec, verbose). # Check H2 is PD; # NOTE: If this triggers failure the SCF solution is not stable. A few ways to handle this; # 1. Use davidson solver where product function evaluates (H2 * (H1 * X)); # - Poor convergence; # 2. Switch to CIS/TDA; # - User would probably not expect this; # 3. Perform Stability update and restart with new reference; if np.any(H2_ss_val < 0.0):; msg = (""The H2 matrix is not Positive Definite. "" ""This means the reference state is not stable.""); raise RuntimeError(msg). # Build H2^(1/2); H2_ss_half = np.einsum(""ik,k,jk->ij"", H2_ss_vec, np.sqrt(H2_ss_val), H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Lss, optimize=True). # Save best R/L vectors and eigenvalues; best_R = _best_vectors(engine, Rss[:, :nk], vecs); best_L = _best_vectors(engine, Lss[:, :nk], ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:30561,Performance,optimiz,optimize,30561,"^(1/2); H2_ss_half = np.einsum(""ik,k,jk->ij"", H2_ss_vec, np.sqrt(H2_ss_val), H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Lss, optimize=True). # Save best R/L vectors and eigenvalues; best_R = _best_vectors(engine, Rss[:, :nk], vecs); best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['v",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:30632,Performance,optimiz,optimize,30632," H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Lss, optimize=True). # Save best R/L vectors and eigenvalues; best_R = _best_vectors(engine, Rss[:, :nk], vecs); best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['val'][k] = w[k]. # augment the guess space for non-converged roots; if (iter_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:30703,Performance,optimiz,optimize,30703,"2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Lss, optimize=True). # Save best R/L vectors and eigenvalues; best_R = _best_vectors(engine, Rss[:, :nk], vecs); best_L = _best_vectors(engine, Lss[:, :nk], vecs); best_vals = w[:nk]. # check convergence of each solution; new_vecs = []; for k in range(nk):. # residual vectors for right and left eigenvectors; WR_k = engine.new_vector(); WL_k = engine.new_vector(); wk = w[k]; for i in range(l):; H1x_i = H1x[i]; H2x_i = H2x[i]; WL_k = engine.vector_axpy(Rss[i, k], H1x_i, WL_k); WR_k = engine.vector_axpy(Lss[i, k], H2x_i, WR_k). WL_k = engine.vector_axpy(-1.0 * wk, best_L[k], WL_k); WR_k = engine.vector_axpy(-1.0 * wk, best_R[k], WR_k). norm_R = np.sqrt(engine.vector_dot(WR_k, WR_k)); norm_L = np.sqrt(engine.vector_dot(WL_k, WL_k)). norm = norm_R + norm_L. iter_info['res_norm'][k] = norm; iter_info['delta_val'][k] = np.abs(old_w[k] - w[k]); iter_info['val'][k] = w[k]. # augment the guess space for non-converged roots; if (iter_info['res_norm'][k] > r_convergence):; iter_info['done'] = False; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:17309,Safety,safe,safe,17309,"ts own use should be optional. Returns; -------; X : singlet `vector`; This should be a new vector object with the correct dimensions,; assumed to be zeroed out; """"""; pass. [docs]; def vector_dot(X, Y) -> float:; """"""Compute a dot product between two `vectors`. Parameters; ----------; X : single `vector`; Y : single `vector`. Returns; -------; a : float; The dot product (X x Y); """"""; pass. # cython doesn't like static+ decorators https://github.com/cython/cython/issues/1434#issuecomment-608975116; vector_dot = staticmethod(abstractmethod(vector_dot)). [docs]; @abstractmethod; def vector_axpy(a: float, X, Y):; """"""Compute scaled `vector` addition operation `a*X + Y`. Parameters; ----------; a; The scale factor applied to `X`; X : singlet `vector`; The `vector` which will be scaled and added to `Y`; Y : single `vector`; The `vector` which the result of `a*X` is added to. Returns; -------; Y : single `vector`; The solver assumes that Y is updated, and returned. So it is safe to; avoid a copy of Y if possible; """"""; pass. [docs]; @abstractmethod; def vector_scale(a: float, X):; """"""Scale a vector by some factor. Parameters; ----------; a; The scale facor; X : single `vector`; The vector that will be scaled. Returns; -------; X : single `vector`; The solver assumes that the passed vector is modifed. So it is save; to avoid a copy of X if possible.; """"""; pass. [docs]; @abstractmethod; def vector_copy(X):; """"""Make a copy of a `vector`. Parameters; ----------; X : single `vector`; The `vector` to copy. Returns; -------; X' : single `vector`; A copy of `X` should be distinct object that can be modified; independently of the passed object, Has the same data when returned.; """"""; pass. [docs]; @abstractmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired transition property.; prefactor; Optional float scaling factor. Returns; ---",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:17318,Safety,avoid,avoid,17318,"ts own use should be optional. Returns; -------; X : singlet `vector`; This should be a new vector object with the correct dimensions,; assumed to be zeroed out; """"""; pass. [docs]; def vector_dot(X, Y) -> float:; """"""Compute a dot product between two `vectors`. Parameters; ----------; X : single `vector`; Y : single `vector`. Returns; -------; a : float; The dot product (X x Y); """"""; pass. # cython doesn't like static+ decorators https://github.com/cython/cython/issues/1434#issuecomment-608975116; vector_dot = staticmethod(abstractmethod(vector_dot)). [docs]; @abstractmethod; def vector_axpy(a: float, X, Y):; """"""Compute scaled `vector` addition operation `a*X + Y`. Parameters; ----------; a; The scale factor applied to `X`; X : singlet `vector`; The `vector` which will be scaled and added to `Y`; Y : single `vector`; The `vector` which the result of `a*X` is added to. Returns; -------; Y : single `vector`; The solver assumes that Y is updated, and returned. So it is safe to; avoid a copy of Y if possible; """"""; pass. [docs]; @abstractmethod; def vector_scale(a: float, X):; """"""Scale a vector by some factor. Parameters; ----------; a; The scale facor; X : single `vector`; The vector that will be scaled. Returns; -------; X : single `vector`; The solver assumes that the passed vector is modifed. So it is save; to avoid a copy of X if possible.; """"""; pass. [docs]; @abstractmethod; def vector_copy(X):; """"""Make a copy of a `vector`. Parameters; ----------; X : single `vector`; The `vector` to copy. Returns; -------; X' : single `vector`; A copy of `X` should be distinct object that can be modified; independently of the passed object, Has the same data when returned.; """"""; pass. [docs]; @abstractmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired transition property.; prefactor; Optional float scaling factor. Returns; ---",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:17659,Safety,avoid,avoid,17659," -------; a : float; The dot product (X x Y); """"""; pass. # cython doesn't like static+ decorators https://github.com/cython/cython/issues/1434#issuecomment-608975116; vector_dot = staticmethod(abstractmethod(vector_dot)). [docs]; @abstractmethod; def vector_axpy(a: float, X, Y):; """"""Compute scaled `vector` addition operation `a*X + Y`. Parameters; ----------; a; The scale factor applied to `X`; X : singlet `vector`; The `vector` which will be scaled and added to `Y`; Y : single `vector`; The `vector` which the result of `a*X` is added to. Returns; -------; Y : single `vector`; The solver assumes that Y is updated, and returned. So it is safe to; avoid a copy of Y if possible; """"""; pass. [docs]; @abstractmethod; def vector_scale(a: float, X):; """"""Scale a vector by some factor. Parameters; ----------; a; The scale facor; X : single `vector`; The vector that will be scaled. Returns; -------; X : single `vector`; The solver assumes that the passed vector is modifed. So it is save; to avoid a copy of X if possible.; """"""; pass. [docs]; @abstractmethod; def vector_copy(X):; """"""Make a copy of a `vector`. Parameters; ----------; X : single `vector`; The `vector` to copy. Returns; -------; X' : single `vector`; A copy of `X` should be distinct object that can be modified; independently of the passed object, Has the same data when returned.; """"""; pass. [docs]; @abstractmethod; def residue(self, X, so_prop_ints):; """"""Compute residue. Parameters; ----------; X; The single `vector` to use to compute the property.; so_prop_ints :; Property integrals in SO basis for the desired transition property.; prefactor; Optional float scaling factor. Returns; -------; residue : Any; The transition property.; """"""; pass. [docs]; def davidson_solver(; engine: Type[SolverEngine],; guess: List,; *,; nroot: int,; r_convergence: float = 1.0E-4,; max_ss_size: int = 100,; maxiter: int = 60,; verbose: int = 1,; nonneg_only: bool = False) -> Dict[str, Any]:; """"""Solves for the lowest few eigenvalues and ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:19765,Testability,log,logging,19765,"d only; a small number of roots, `k` are desired this algorithm is preferable to; standard methods as uses on the order of `N * k` memory. One only needs to; have the ability to compute the product of a times a vector. For non-hermitan `A` the basis of the algorithm breaks down. However in; practice, for strongly diagonally-dominant `A` such as the; similarity-transformed Hamiltonian in EOM-CC this algorithm is commonly still; used. Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only; Should eigenpairs with eigenvalue < 0 be ignored?. Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors: List[`vector`]; (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that was performed; - done : bool, if all roots were converged. Notes; -----; The solution vector is normalized to 1/2. The solver will return even ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html:25890,Testability,log,logging,25890,"d :math:`(A-B)`; (H2) in to the subspace defined by the trial vectors.; The subspace analog of the NxN hermitian EVP is diagonalized and left :math:`(X-Y)`; and right :math:`(X+Y)` eigenvectors of the NxN non-hermitian EVP are approximated.; Residual vectors are formed for both and the guess space is augmented with; two correction vectors per iteration. The advantages and properties of this; algorithm are described in the literature [stratmann:1998]_ . Parameters; ----------; engine; The engine drive all operations involving data structures that have at; least one ""large"" dimension. See :class:`SolverEngine` for requirements; guess; list {engine dependent}; At least `nroot` initial expansion vectors; nroot; Number of roots desired; r_convergence; Convergence tolerance for residual vectors; max_ss_size; The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter; The maximum number of iterations; verbose; The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns; -------; best_values : numpy.ndarray; (nroots, ) The best approximation of the eigenvalues of `w`, computed on the last iteration of the solver; best_R: List[`vector`]; (nroots) The best approximation of the right hand eigenvectors, :math:`X+Y`, computed on the last iteration of the solver.; best_L: List[`vector`]; (nroots) The best approximation of the left hand eigenvectors, :math:`X-Y`, computed on the last iteration of the solver.; stats : List[Dict]; Statistics collected on each iteration. - count : int, iteration number; - res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; - val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; - delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; - collapse : bool, if a subspace collapse was performed; - product_count : int, the running total of product evaluations that ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/solvers.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:13152,Deployability,update,updated,13152,"to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Generate y axis, i.e. molar decadic absorption coefficient; prefactor = prefactor_opa() if kind == ""opa"" else prefactor_ecd(); transform_residue = (lambda x: x**2) if kind == ""opa"" else (lambda x: x); y = prefactor * x * np.sum([transform_residue(r) * shape.lineshape(p) for p, r in zip(poles, residues)], axis=0). # Generate sticks; sticks = prefactor * np.array([p * transform_residue(r) * shape.maximum(p) for p, r in zip(poles, residues)]). return {""convolution"": {""x"": x, ""y"": y}, ""sticks"": {""poles"": poles, ""residues"": sticks}}. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.spectrum.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:4955,Energy Efficiency,charge,charge,4955,"eters; ----------; x_0; Center of the Lorentzian, i.e. its maximum. """"""; return 2.0 / (np.pi * self.gamma(x_0)). [docs]; def prefactor_opa() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]; def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hb",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:6102,Energy Efficiency,charge,charge,6102,"(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]; def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]; def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon absorption (OPA) or electronic circular dichroism (ECD); spectra with phenomenological line broadening. This function gives arrays of values ready to be plotted as OPA spectrum:. .. math::. \varepsilon(\omega) =; \frac{4\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}; \sum_{i \rightarr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:8723,Energy Efficiency,energy,energy,8723,"of the response function, i.e. the excitation energies.; These are **expected** in atomic units of angular frequency.; residues; Residues of the linear response functions, i.e. transition dipole moments (OPA) and rotatory strengths (ECD).; These are **expected** in atomic units.; kind; {""opa"", ""ecd""}; Which kind of spectrum to generate, one-photon absorption (""opa"") or electronic circular dichroism (""ecd"").; Default is `opa`.; lineshape; {""gaussian"", ""lorentzian""}; The lineshape function to use in the fitting. Default is `gaussian`.; gamma; Full width at half maximum of the lineshape function.; Default is 0.2 au of angular frequency.; This value is **expected** in atomic units of angular frequency.; npoints; How many points to generate for the x axis. Default is 5000.; out_units; Units for the output array `x`, the x axis of the spectrum plot.; Default is wavelengths in nanometers.; Valid (and case-insensitive) values for the units are:. - `au` atomic units of angular frequency; - `Eh` atomic units of energy; - `eV`; - `nm`; - `THz`. Returns; -------; spectrum : Dict[str, numpy.ndarray]; The fitted electronic absorption spectrum, with units for the x axis specified by the `out_units` parameter.; This is a dictionary containing the convoluted (key: `convolution`) and the infinitely narrow spectra (key: `sticks`). .. code-block:: python. {""convolution"": {""x"": np.ndarray, ""y"": np.ndarray},; ""sticks"": {""poles"": np.ndarray, ""residues"": np.ndarray}}. Notes; -----; * Conversion of the broadening parameter :math:`\gamma`.; The lineshape functions are formulated as functions of the angular frequency :math:`\omega`.; When converting to other physical quantities, the broadening parameter has to be modified accordingly.; If :math:`\gamma_{\omega}` is the chosen broadening parameter then:. - Wavelength: :math:`gamma_{\lambda} = \frac{\lambda_{ij}^{2}}{2\pi c}\gamma_{\omega}`; - Frequency: :math:`gamma_{\nu} = \frac{\gamma_{\omega}}{2\pi}`; - Energy: :math:`gamma_{E} = \gamma_{\o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:10923,Energy Efficiency,energy,energy,10923,"oi.org/10.1002/9781118008720.ch2; """""". # Transmute inputs to np.ndarray; if isinstance(poles, list):; poles = np.array(poles); if isinstance(residues, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:11075,Energy Efficiency,energy,energy,11075,"s, list):; residues = np.array(residues); # Validate input arrays; if poles.shape != residues.shape:; raise ValueError(f""Shapes of poles ({poles.shape}) and residues ({residues.shape}) vectors do not match!""). # Validate kind of spectrum; kind = kind.lower(); valid_kinds = [""opa"", ""ecd""]; if kind not in valid_kinds:; raise ValueError(f""Spectrum kind {kind} not among recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # V",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:1683,Integrability,depend,depends,1683," distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""Gaussian"",; ""Lineshape"",; ""Lorentzian"",; ""prefactor_ecd"",; ""prefactor_opa"",; ""spectrum"",; ]. from abc import abstractmethod; from dataclasses import dataclass; from typing import Callable, Dict, List, Union. import numpy as np; from psi4.driver import constants. [docs]; @dataclass; class Lineshape:; """"""Lineshape ABC. Attributes; ----------; domain; Domain of the spectral band.; gamma; A function returning the broadening factor. Notes; -----; Why do we use a callable broadening factor?; For plots in the *wavelength domain*, the broadening factor depends on the location of the band's maximum.; """"""; domain: Union[np.ndarray, List[float]]; gamma: Callable[[float], float]. [docs]; @abstractmethod; def lineshape(self, x_0: float) -> np.ndarray:; pass. [docs]; @abstractmethod; def maximum(self, x_0: float) -> float:; pass. [docs]; class Gaussian(Lineshape):; r""""""Gaussian function on `domain`, centered at `x_0` with broadening `gamma`. Parameters; ----------; domain; The domain of the Gaussian profile.; gamma; Broadening parameter.; This is related to the full width at half maximum as :math:`\mathrm{FWHM} = \gamma \sqrt{2\ln 2}`. Notes; -----; Use this profile to model inhomegenous broadening.; """""". [docs]; def lineshape(self, x_0: float) -> np.ndarray:; """"""Gaussian function on :py:attr:`Lineshape.domain`, centered at `x_0` with broadening :py:attr:`Lineshape.gamma`. Parameters; ----------; x_0; Center of the Gaussian, i.e. its maximum. Returns; -------; numpy.ndarray; The Gaussian profile. """"""; p",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:4658,Integrability,depend,dependent,4658,"------; numpy.ndarray; The Lorentzian profile.; """"""; prefactor = 1.0 / np.pi; numerator = self.gamma(x_0) / 2.0; denominator = (self.domain - x_0)**2 + numerator**2. return prefactor * (numerator / denominator). [docs]; def maximum(self, x_0: float) -> float:; """"""Maximum value of Lorentzian profile centered at `x_0`. Parameters; ----------; x_0; Center of the Lorentzian, i.e. its maximum. """"""; return 2.0 / (np.pi * self.gamma(x_0)). [docs]; def prefactor_opa() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]; def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:5806,Integrability,depend,dependent,5806,"speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]; def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]; def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon abs",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:5101,Testability,log,log,5101,"""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in one-photon absorption. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{4\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1.; """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""); au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""). numerator = 4.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c. return (numerator / denominator) * au_to_Coulomb_centimeter**2. [docs]; def prefactor_ecd() -> float:; r""""""Prefactor for converting microscopic observable to decadic molar; extinction coefficient in electronic circular dichroism. Notes; -----; This function implements the calculation of the following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"")",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html:6423,Testability,log,log,6423," following prefactor:. .. math::. k = \frac{16\pi^{2}N_{\mathrm{A}}}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}. The prefactor is computed in SI units and then adjusted for the fact that; we use atomic units to express microscopic observables: excitation energies; and transition dipole moments.; The refractive index :math:`n` is, in general, frequency-dependent. We; assume it to be constant and equal to 1. """""". N_A = constants.get(""Avogadro constant""); c = constants.get(""speed of light in vacuum""); hbar = constants.get(""Planck constant over 2 pi""); e_0 = constants.get(""electric constant""). au_to_Coulomb_centimeter = constants.get(""elementary charge"") * constants.get(; ""Bohr radius"") * constants.conversion_factor(""m"", ""cm""); au_to_Joule_inverse_Tesla = 2.0 * constants.get(""Bohr magneton"") * constants.conversion_factor(""m"", ""cm""); conversion = au_to_Coulomb_centimeter * au_to_Joule_inverse_Tesla. numerator = 16.0 * np.pi**2 * N_A; denominator = 3 * 1000 * np.log(10) * (4 * np.pi * e_0) * hbar * c**2. return (numerator / denominator) * conversion. [docs]; def spectrum(*,; poles: Union[List[float], np.ndarray],; residues: Union[List[float], np.ndarray],; kind: str = ""opa"",; lineshape: str = ""gaussian"",; gamma: float = 0.2,; npoints: int = 5000,; out_units: str = ""nm"") -> Dict[str, np.ndarray]:; r""""""One-photon absorption (OPA) or electronic circular dichroism (ECD); spectra with phenomenological line broadening. This function gives arrays of values ready to be plotted as OPA spectrum:. .. math::. \varepsilon(\omega) =; \frac{4\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c}; \sum_{i \rightarrow j}g_{ij}(\omega)|\mathbf{\mu}_{ij}|^{2}. or ECD spectrum:. .. math::. \Delta\varepsilon(\omega) =; \frac{16\pi^{2}N_{\mathrm{A}}\omega}{3\times 1000\times \ln(10) (4 \pi \epsilon_{0}) n \hbar c^{2}}; \sum_{i \rightarrow j}g_{ij}(\omega)\Im(\mathbf{\mu}_{ij}\cdot\mathbf{m}_{ij}). in macroscopic units of :math:`\mathrm{L}\cd",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/spectrum.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:4666,Deployability,update,updated,4666," = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.text.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:3522,Integrability,message,message,3522,"rs; ----------; seq1; First string.; seq2; Second string. """"""; oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:3596,Integrability,message,message,3596,"rs; ----------; seq1; First string.; seq2; Second string. """"""; oneago = None; thisrow = list(range(1, len(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:3667,Integrability,message,message,3667,"en(seq2) + 1)) + [0]; for x in range(len(seq1)):; twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.text.  Copyright 2007-2023, The Psi4 Project.; Last updated",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:3842,Integrability,message,message,3842," = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.text.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:3900,Integrability,wrap,wrap,3900," = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.text.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:3955,Integrability,message,message,3955," = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.text.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:4288,Integrability,wrap,wrap,4288," = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.text.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html:4257,Modifiability,extend,extend,4257," = oneago, thisrow, [0] * len(seq2) + [x + 1]; for y in range(len(seq2)):; delcost = oneago[y] + 1; addcost = thisrow[y - 1] + 1; subcost = oneago[y - 1] + (seq1[x] != seq2[y]); thisrow[y] = min(delcost, addcost, subcost); return thisrow[len(seq2) - 1]. [docs]; def find_approximate_string_matches(seq1: str, options: List[str], max_distance: int) -> List[str]:; """"""Find list of approximate (within `max_distance`) matches to string `seq1` among `options`. Parameters; ----------; seq1; Target string to look for near matches to.; options; Alternatives among which to look for near matches to `seq1`.; max_distance; Maximum Levenshtein distance from `seq1` to return. """"""; return [seq2 for seq2 in options if (levenshtein(seq1, seq2) <= max_distance)]. [docs]; def message_box(message: str, max_width: int = 80, min_width: int = 30) -> str:; """"""Put a message string into a box for extra attention. Parameters; ----------; message; Message string to be boxed.; max_width; Maximal character width of the box.; min_width; Minimal character width of the box. Returns; -------; str; Box containing the message as a multiline string.; """"""; from textwrap import wrap. # ensure box is within min/max boundaries; msg = message.splitlines(); max_line = len(max(msg, key=len)); box_width = max(min(max_width, max_line), min_width). error_str = []; error_str.append('\n!' + '-' * box_width + '--!\n'); error_str.append('!' + ' ' * box_width + ' !\n'). fmt = ""! {:"" + str(box_width) + ""} !\n""; for line in msg[:]:; error_str.extend([fmt.format(x) for x in wrap(line, box_width, subsequent_indent="" "")]). error_str.append('!' + ' ' * box_width + ' !\n'); error_str.append('!' + '-' * box_width + '--!\n'); error_str = ''.join(error_str). return error_str. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.text.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/text.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:9665,Deployability,configurat,configuration,9665," 32):; Out[2]: -cp /scratch/parrish/psi.12345.h2o.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; Out[3]: -cp /scratch/parrish/psi.12345.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; Out[4]: -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = core.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp'; if move:; cp = '/bin/mv'. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]; def libint2_configuration() -> Dict[str, List[int]]:; """"""Returns information on integral classes, derivatives, and AM from currently linked Libint2. Returns; -------; Dictionary of integrals classes with values an array of max angular momentum per derivative level.; Usual configuration returns:; `{'eri': [5, 4, 3], 'eri2': [6, 5, 4], 'eri3': [6, 5, 4], 'onebody': [6, 5, 4]}`. """"""; skel = {""onebody_"": [], ""eri_c4_"": [], ""eri_c3_"": [], ""eri_c2_"": []}. for itm in core._libint2_configuration().split("";""):; for cat in list(skel.keys()):; if itm.startswith(cat):; skel[cat].append(itm[len(cat):]). for cat in list(skel.keys()):; der_max_store = []; for der in [""d0_l"", ""d1_l"", ""d2_l""]:; lmax = -1; for itm2 in skel[cat]:; if itm2.startswith(der):; lmax = max(int(itm2[len(der):]), lmax); der_max_store.append(None if lmax == -1 else lmax); skel[cat] = der_max_store. # rename keys from components; skel[""onebody""] = skel.pop(""onebody_""); skel[""eri""] = skel.pop(""eri_c4_""); skel[""eri3""] = skel.pop(""eri_c3_""); skel[""eri2""] = skel.pop(""eri_c2_""); return skel. [docs]; def libint2_print_out() -> None:; ams = libint2_configuration(); # excluding sph_emultipole; sho = {1: 'standard', 2: 'gaussian'}[core._libint2_solid_harmonics_ordering()]; core.print_out("" => Libint2 <=\n\n"");. core.print_out(f"" Primary basis highest AM E",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:11274,Deployability,update,updated,11274,"ilename)). os.system(command). [docs]; def libint2_configuration() -> Dict[str, List[int]]:; """"""Returns information on integral classes, derivatives, and AM from currently linked Libint2. Returns; -------; Dictionary of integrals classes with values an array of max angular momentum per derivative level.; Usual configuration returns:; `{'eri': [5, 4, 3], 'eri2': [6, 5, 4], 'eri3': [6, 5, 4], 'onebody': [6, 5, 4]}`. """"""; skel = {""onebody_"": [], ""eri_c4_"": [], ""eri_c3_"": [], ""eri_c2_"": []}. for itm in core._libint2_configuration().split("";""):; for cat in list(skel.keys()):; if itm.startswith(cat):; skel[cat].append(itm[len(cat):]). for cat in list(skel.keys()):; der_max_store = []; for der in [""d0_l"", ""d1_l"", ""d2_l""]:; lmax = -1; for itm2 in skel[cat]:; if itm2.startswith(der):; lmax = max(int(itm2[len(der):]), lmax); der_max_store.append(None if lmax == -1 else lmax); skel[cat] = der_max_store. # rename keys from components; skel[""onebody""] = skel.pop(""onebody_""); skel[""eri""] = skel.pop(""eri_c4_""); skel[""eri3""] = skel.pop(""eri_c3_""); skel[""eri2""] = skel.pop(""eri_c2_""); return skel. [docs]; def libint2_print_out() -> None:; ams = libint2_configuration(); # excluding sph_emultipole; sho = {1: 'standard', 2: 'gaussian'}[core._libint2_solid_harmonics_ordering()]; core.print_out("" => Libint2 <=\n\n"");. core.print_out(f"" Primary basis highest AM E, G, H: {', '.join(('-' if d is None else str(d)) for d in ams['eri'])}\n""); core.print_out(f"" Auxiliary basis highest AM E, G, H: {', '.join(('-' if d is None else str(d)) for d in ams['eri3'])}\n""); core.print_out(f"" Onebody basis highest AM E, G, H: {', '.join(('-' if d is None else str(d)) for d in ams['onebody'])}\n""); core.print_out(f"" Solid Harmonics ordering: {sho}\n""). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.p4util.util.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:2036,Energy Efficiency,energy,energy,2036,", Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with utility functions for use in input files."""""". __all__ = [; ""copy_file_to_scratch"",; ""copy_file_from_scratch"",; ""cubeprop"",; ""get_memory"",; ""libint2_configuration"",; ""libint2_print_out"",; ""oeprop"",; ""set_memory"",; ]. import os; import re; import sys; import warnings; from typing import Dict, List, Union. from psi4 import core; from psi4.driver.procrouting import *; from .exceptions import ValidationError; from .prop_util import *. [docs]; def oeprop(wfn: core.Wavefunction, *args: List[str], **kwargs):; """"""Evaluate one-electron properties. :returns: None. :param wfn: set of molecule, basis, orbitals from which to compute properties. :param args:. Arbitrary-number of properties to be computed from *wfn*.; See :ref:`Available One-Electron Properties <table:oe_features>`. :type title: str; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:2915,Energy Efficiency,energy,energy,2915,"r; :param title: label prepended to all psivars computed. :examples:. >>> # [1] Moments with specific label; >>> E, wfn = energy('hf', return_wfn=True); >>> oeprop(wfn, 'DIPOLE', 'QUADRUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to b",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:3179,Energy Efficiency,energy,energy,3179,"RUPOLE', title='H3O+ SCF'). """"""; oe = core.OEProp(wfn); if 'title' in kwargs:; oe.set_title(kwargs['title']); for prop in args:; oe.add(prop). # If we're doing MBIS, we want the free-atom volumes; # in order to compute volume ratios,; # but only if we're calling oeprop as the whole molecule; free_atom = kwargs.get('free_atom',False); if ""MBIS_VOLUME_RATIOS"" in prop.upper() and not free_atom:; core.print_out("" Computing free-atom volumes\n""); free_atom_volumes(wfn). oe.compute(). [docs]; def cubeprop(wfn: core.Wavefunction, **kwargs):; """"""Evaluate properties on a grid and generate cube files. .. versionadded:: 0.5; *wfn* parameter passed explicitly. :returns: None. :param wfn: set of molecule, basis, orbitals from which to generate cube files. :examples:. >>> # [1] Cube files for all orbitals; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> cubeprop(wfn). >>> # [2] Cube files for density (alpha, beta, total, spin) and four orbitals; >>> # (two alpha, two beta); >>> set cubeprop_tasks ['orbitals', 'density']; >>> set cubeprop_orbitals [5, 6, -5, -6]; >>> E, wfn = energy('scf', return_wfn=True); >>> cubeprop(wfn). """"""; # By default compute the orbitals; if not core.has_global_option_changed('CUBEPROP_TASKS'):; core.set_global_option('CUBEPROP_TASKS', ['ORBITALS']). if ((core.get_global_option('INTEGRAL_PACKAGE') == 'ERD') and ('ESP' in core.get_global_option('CUBEPROP_TASKS'))):; raise ValidationError('INTEGRAL_PACKAGE ERD does not play nicely with electrostatic potential, so stopping.'). cp = core.CubeProperties(wfn); cp.compute_properties(). [docs]; def set_memory(inputval: Union[str, int, float], execute: bool = True, quiet: bool = False) -> int:; """"""Reset the total memory allocation. Parameters; ----------; inputval; Memory value. An Integer or float is taken literally as bytes to be set.; A string is taken as a unit-containing value (e.g., 30 mb), which is; case-insensitive.; execute; When False, interpret *inputval* without setting in Psi4 core.; quiet; When T",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html:9665,Modifiability,config,configuration,9665," 32):; Out[2]: -cp /scratch/parrish/psi.12345.h2o.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32):; Out[3]: -cp /scratch/parrish/psi.12345.32 /tmp/temp; >>> copy_file_to_scratch('/tmp/temp', 'psi', '', 32, True):; Out[4]: -mv /scratch/parrish/psi.12345.32 /tmp/temp. """""". pid = str(os.getpid()); scratch = core.IOManager.shared_object().get_file_path(int(unit)). cp = '/bin/cp'; if move:; cp = '/bin/mv'. unit = str(unit). target = ''; target += prefix; target += '.'; target += pid; if len(namespace):; target += '.'; target += namespace; target += '.'; target += unit. command = ('%s %s/%s %s' % (cp, scratch, target, filename)). os.system(command). [docs]; def libint2_configuration() -> Dict[str, List[int]]:; """"""Returns information on integral classes, derivatives, and AM from currently linked Libint2. Returns; -------; Dictionary of integrals classes with values an array of max angular momentum per derivative level.; Usual configuration returns:; `{'eri': [5, 4, 3], 'eri2': [6, 5, 4], 'eri3': [6, 5, 4], 'onebody': [6, 5, 4]}`. """"""; skel = {""onebody_"": [], ""eri_c4_"": [], ""eri_c3_"": [], ""eri_c2_"": []}. for itm in core._libint2_configuration().split("";""):; for cat in list(skel.keys()):; if itm.startswith(cat):; skel[cat].append(itm[len(cat):]). for cat in list(skel.keys()):; der_max_store = []; for der in [""d0_l"", ""d1_l"", ""d2_l""]:; lmax = -1; for itm2 in skel[cat]:; if itm2.startswith(der):; lmax = max(int(itm2[len(der):]), lmax); der_max_store.append(None if lmax == -1 else lmax); skel[cat] = der_max_store. # rename keys from components; skel[""onebody""] = skel.pop(""onebody_""); skel[""eri""] = skel.pop(""eri_c4_""); skel[""eri3""] = skel.pop(""eri_c3_""); skel[""eri2""] = skel.pop(""eri_c2_""); return skel. [docs]; def libint2_print_out() -> None:; ams = libint2_configuration(); # excluding sph_emultipole; sho = {1: 'standard', 2: 'gaussian'}[core._libint2_solid_harmonics_ordering()]; core.print_out("" => Libint2 <=\n\n"");. core.print_out(f"" Primary basis highest AM E",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/p4util/util.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:2213,Availability,avail,available,2213,"D LICENSE; #. import collections; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; try:; from qcengine.testing import _programs as _programs_qcng; except ModuleNotFoundError:; # _programs_qcng is up-to-date with current harnesses but it requires pytest present, so let's provide a workaround; from qcelemental.util import which, which_import; _programs_qcng = {; ""dftd3"": which(""dftd3"", return_bool=True),; ""dftd4"": which_import(""dftd4"", return_bool=True),; ""s-dftd3"": which_import(""dftd3"", return_bool=True),; ""mctc-gcp"": which(""mctc-gcp"", return_bool=True),; ""gcp"": which(""gcp"", return_bool=True),; ""mp2d"": which(""mp2d"", return_bool=True),; }. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engine",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:6293,Availability,error,error,6293,"isp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; param_tweaks; Values for the same keys as `dashcoeff[dashlevel]['default']`; (and same order if list) used to override any or all values; initialized by `name_hint`. Extra parameters will error.; engine; Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine; Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp; Whether to request atomic pairwise analysis. """"""; def __init__(self, *, name_hint: str = None, level_hint: str = None, param_tweaks: Union[Dict, List] = None, engine: str = None, gcp_engine: str = None, save_pairwise_disp: bool = False):; from .dft import dashcoeff_supplement; self.dashcoeff_supplement = dashcoeff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:14865,Deployability,update,updated,14865,"t.add(gcp_part). return dashd_part; else:; return self.disp.compute_gradient(molecule). [docs]; def compute_hessian(self,; molecule: core.Molecule,; wfn: core.Wavefunction = None) -> core.Matrix:; """"""Compute dispersion Hessian based on engine, dispersion level, and parameters in `self`.; Uses finite difference, as no dispersion engine has analytic second derivatives. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; Matrix; (3*nat, 3*nat) dispersion Hessian [Eh/a0/a0]. """"""; optstash = p4util.OptionsState(['PRINT'], ['PARENT_SYMMETRY']); core.set_global_option('PRINT', 0). core.print_out(""\n\n Analytical Dispersion Hessians are not supported by any engine.\n""); core.print_out("" Computing the Hessian through finite difference of gradients.\n\n""). # Setup the molecule; molclone = molecule.clone(); molclone.reinterpret_coordentry(False); molclone.fix_orientation(True); molclone.fix_com(True). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). findif_meta_dict = driver_findif.hessian_from_gradients_geometries(molclone, -1); for displacement in findif_meta_dict[""displacements""].values():; geom_array = np.reshape(displacement[""geometry""], (-1, 3)); molclone.set_geometry(core.Matrix.from_array(geom_array)); molclone.update_geometry(); displacement[""gradient""] = self.compute_gradient(molclone).np.ravel().tolist(). H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, -1); if wfn is not None:; wfn.set_variable('DISPERSION CORRECTION HESSIAN', H); optstash.restore(); return core.Matrix.from_array(H). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.procrouting.empirical_dispersion.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9155,Energy Efficiency,energy,energy,9155,"n.build(self.dashlevel, **resolved['dashparams']). if gcp_engine is None:; self.gcp_engine = capable_engines_for_disp[""3c""][0]; else:; if ""3c"" in _engine_can_do[gcp_engine]:; self.gcp_engine = gcp_engine; else:; raise ValidationError(f""This little engine ({engine}) can't (3c)""). [docs]; def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs]; def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9389,Energy Efficiency,energy,energy,9389,"se ValidationError(f""This little engine ({engine}) can't (3c)""). [docs]; def print_out(self):; """"""Format dispersion parameters of `self` for output file."""""". text = []; text.append("" => {}: Empirical Dispersion <="".format(; (self.fctldash.upper() if self.fctldash.upper() else 'Custom'))); text.append(''); text.append(self.description); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs]; def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSIO",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:9729,Energy Efficiency,energy,energy,9729,"ription); text.append(self.dashlevel_citation.rstrip()); if self.dashparams_citation:; text.append("" Parametrisation from:{}"".format(self.dashparams_citation.rstrip())); text.append(''); for op in self.ordered_params:; text.append("" %6s = %14.6f"" % (op, self.dashparams[op])); text.append('\n'). core.print_out('\n'.join(text)). [docs]; def compute_energy(self, molecule: core.Molecule, wfn: core.Wavefunction = None) -> float:; """"""Compute dispersion energy based on engine, dispersion level, and parameters in `self`. Parameters; ----------; molecule; System for which to compute empirical dispersion correction.; wfn; Location to set QCVariables. Returns; -------; float; Dispersion energy [Eh]. Notes; -----; :psivar:`DISPERSION CORRECTION ENERGY`; Disp always set. Overridden in SCF finalization, but that only changes for ""-3C"" methods.; :psivar:`fctl DISPERSION CORRECTION ENERGY`; Set if :py:attr:`fctldash` nonempty. """"""; if self.engine in [""s-dftd3"", 'dftd3', 'mp2d', ""dftd4""]:; resi = AtomicInput(; **{; 'driver': 'energy',; 'model': {; 'method': self.fctldash,; 'basis': '(auto)',; },; 'keywords': {; 'level_hint': self.dashlevel,; 'params_tweaks': self.dashparams,; 'dashcoeff_supplement': self.dashcoeff_supplement,; 'pair_resolved': self.save_pairwise_disp,; 'apply_qcengine_aliases': True, # for s-dftd3; 'verbose': 1,; },; 'molecule': molecule.to_schema(dtype=2),; 'provenance': p4util.provenance_stamp(__name__),; }); jobrec = qcng.compute(; resi,; self.engine,; raise_error=True,; task_config={""scratch_directory"": core.IOManager.shared_object().get_default_path(), ""ncores"": core.get_num_threads()}). dashd_part = float(jobrec.extras['qcvars']['DISPERSION CORRECTION ENERGY']); if wfn is not None:; for k, qca in jobrec.extras['qcvars'].items():; if (""CURRENT"" not in k) and (""PAIRWISE"" not in k):; wfn.set_variable(k, float(qca) if isinstance(qca, str) else qca). # Pass along the pairwise dispersion decomposition if we need it; if self.save_pairwise_disp is True:; wfn.set_varia",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:3841,Modifiability,flexible,flexible,3841,"or k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engines in capable.items():; capable_sorted_by_available[disp] = sorted(engines, key=lambda x: (not programs_disp[x], x)). return capable_sorted_by_available. [docs]; class EmpiricalDispersion():; """"""Lightweight unification of empirical dispersion calculation modes. Attributes; ----------; dashlevel : str; {""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"", ""nl"", ""dmp2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ""d4bjeeqatm""}; Name of dispersion correction to be applied. Resolved; from `name_hint` and/or `level_hint` into a key of; `empirical_dispersion_resources.dashcoeff`.; dashparams : dict; Complete set of parameter values defining the flexible parts; of :py:attr:`dashlevel`. Number and parameter names vary by; :py:attr:`dashlevel`. Resolved into a complete set (keys of; dashcoeff[dashlevel]['default']) from `name_hint` and/or; `dashcoeff_supplement` and/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""ble",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:2065,Safety,detect,detection,2065,"g; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; from typing import Dict, List, Tuple, Union. import numpy as np; from qcelemental.models import AtomicInput; import qcengine as qcng. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; try:; from qcengine.testing import _programs as _programs_qcng; except ModuleNotFoundError:; # _programs_qcng is up-to-date with current harnesses but it requires pytest present, so let's provide a workaround; from qcelemental.util import which, which_import; _programs_qcng = {; ""dftd3"": which(""dftd3"", return_bool=True),; ""dftd4"": which_import(""dftd4"", return_bool=True),; ""s-dftd3"": which_import(""dftd3"", return_bool=True),; ""mctc-gcp"": which(""mctc-gcp"", return_bool=True),; ""gcp"": which(""gcp"", return_bool=True),; ""mp2d"": which(""mp2d"", return_bool=True),; }. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_availabl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:5065,Security,validat,validating,5065,"/or user `param_tweaks`.; fctldash : str; If :py:attr:`dashparams` for :py:attr:`dashlevel` corresponds to a defined,; named, untweaked ""functional-dashlevel"" set, then that; functional. Otherwise, empty string.; description : str; Tagline for dispersion :py:attr:`dashlevel`.; dashlevel_citation : str; Literature reference for dispersion :py:attr:`dashlevel` in general,; *not necessarily* for :py:attr:`dashparams`.; dashparams_citation : str; Literature reference for dispersion parameters, if :py:attr:`dashparams`; corresponds to a defined, named, untweaked ""functional-dashlevel""; set with a citation. Otherwise, empty string.; dashcoeff_supplement : dict; See description in `qcengine.programs.empirical_dispersion_resources.from_arrays`. Used; here to ""bless"" the dispersion definitions attached to; the procedures/dft/<rung>_functionals-defined dictionaries; as legit, non-custom, and of equal validity to; `qcengine.programs.empirical_dispersion_resources.dashcoeff` itself for purposes of; validating :py:attr:`fctldash`.; engine : str; {'libdisp', ""s-dftd3"", 'dftd3', 'nl', 'mp2d', ""dftd4""}; Compute engine for dispersion. One of Psi4's internal libdisp; library, external Grimme or Beran projects, or nl.; disp : Dispersion; Only present for :py:attr:`engine` `=libdisp`. Psi4 class instance prepared; to compute dispersion.; ordered_params : list; Fixed-order list of relevant parameters for :py:attr:`dashlevel`. Matches; :rst:psivar:`DISPERSION CORRECTION ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `da",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:2261,Testability,test,testing,2261,"mport p4util; from psi4.driver import driver_findif; from psi4.driver.p4util.exceptions import ValidationError. _engine_can_do = collections.OrderedDict([; # engine order establishes default for each disp; (""libdisp"", [""d1"", ""d2"", ""chg"", ""das2009"", ""das2010"",]),; (""s-dftd3"", [ ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ""d3zeroatm"", ""d3bjatm"", ""d3mzeroatm"", ""d3mbjatm"", ]),; (""dftd3"", [ ""d2"", ""d3zero2b"", ""d3bj2b"", ""d3mzero2b"", ""d3mbj2b"", ]),; (""nl"", [ ""nl"", ]),; (""mp2d"", [ ""dmp2"", ]),; (""dftd4"", [ ""d4bjeeqatm"", ]),; (""mctc-gcp"", [ ""3c"", ]),; (""gcp"", [ ""3c"", ]),; ]) # yapf: disable. def _capable_engines_for_disp()-> Dict[str, List[str]]:; """"""Invert _engine_can_do dictionary and check program detection. Returns a dictionary with keys all dispersion levels and values a list of all; capable engines, where the engine in the first element is available, if any are. """"""; try:; from qcengine.testing import _programs as _programs_qcng; except ModuleNotFoundError:; # _programs_qcng is up-to-date with current harnesses but it requires pytest present, so let's provide a workaround; from qcelemental.util import which, which_import; _programs_qcng = {; ""dftd3"": which(""dftd3"", return_bool=True),; ""dftd4"": which_import(""dftd4"", return_bool=True),; ""s-dftd3"": which_import(""dftd3"", return_bool=True),; ""mctc-gcp"": which(""mctc-gcp"", return_bool=True),; ""gcp"": which(""gcp"", return_bool=True),; ""mp2d"": which(""mp2d"", return_bool=True),; }. programs_disp = {k: v for k, v in _programs_qcng.items() if k in _engine_can_do}; programs_disp[""libdisp""] = True; programs_disp[""nl""] = True. capable = collections.defaultdict(list); capable_sorted_by_available = collections.defaultdict(list); for eng, disps in _engine_can_do.items():; for disp in disps:; capable[disp].append(eng); for disp, engines in capable.items():; capable_sorted_by_available[disp] = sorted(engines, key=lambda x: (not programs_disp[x], x)). return capable_sorted_by_available. [docs]; class EmpiricalDispersion():; """"""Lightweight unif",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html:6570,Usability,simpl,simple-,6570,"N ENERGY` ordering. Used for printing. Parameters; ----------; name_hint; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized from; ``dashcoeff[dashlevel][functional-without-dashlevel]`` or; ``dashcoeff_supplement[dashlevel][functional-with-dashlevel]``; can be overwritten via `param_tweaks`.; level_hint; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to one.; param_tweaks; Values for the same keys as `dashcoeff[dashlevel]['default']`; (and same order if list) used to override any or all values; initialized by `name_hint`. Extra parameters will error.; engine; Override which code computes dispersion. See above for allowed; values. Formerly (pre Nov 2022) only relevant for -D2, which can be computed by; libdisp or dftd3. Now (post Nov 2022) also relevant for -D3 variants,; which can be computed by dftd3 executable or simple-dftd3 Python module.; gcp_engine; Override which code computes the gcp correction. Now can use; classic gcp or mctc-gcp executables.; save_pairwise_disp; Whether to request atomic pairwise analysis. """"""; def __init__(self, *, name_hint: str = None, level_hint: str = None, param_tweaks: Union[Dict, List] = None, engine: str = None, gcp_engine: str = None, save_pairwise_disp: bool = False):; from .dft import dashcoeff_supplement; self.dashcoeff_supplement = dashcoeff_supplement; self.save_pairwise_disp = save_pairwise_disp. resolved = qcng.programs.empirical_dispersion_resources.from_arrays(; name_hint=name_hint,; level_hint=level_hint,; param_tweaks=param_tweaks,; dashcoeff_supplement=self.dashcoeff_supplement); self.fctldash = resolved['fctldash']; self.dashlevel = resolved['dashlevel']; self.dashparams = resolved['dashparams']; self.description = qcng.programs.empirical_dispersion_resources.dashcoeff[self.dashlevel]['description']; self.order",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/empirical_dispersion.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:5560,Availability,fault,fault,5560,"_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:13013,Availability,error,error,13013,"D >>>'); # for item in c4grad:; # print(' %16.8f %16.8f %16.8f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:13148,Deployability,update,update,13148,"r instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalqua",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:17917,Deployability,update,updated,17917,"m Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.reconcile_options(userkw, mdckw). # Handle conversion of psi4 keyword structure into cfour format; optcmd = qcdb.options.prepare_options_for_cfour(userkw). # Handle text to be passed untouched to cfour; litcmd = core.get_global_option('LITERAL_CFOUR'). # Assemble ZMAT pieces; zmat = memcmd + molcmd + optcmd + mdccmd + psicmd + bascmd + litcmd. if len(re.findall(r'^\*(ACES2|CFOUR|CRAPS)\(', zmat, re.MULTILINE)) != 1:; core.print_out('\n Faulty ZMAT constructed:\n%s' % (zmat)); raise ValidationError(""""""; Multiple *CFOUR(...) blocks in input. This usually arises; because molecule or options are specified both the psi4 way through; molecule {...} and set ... and the cfour way through cfour {...}.""""""). return zmat. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.procrouting.interface_cfour.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:2051,Energy Efficiency,energy,energy,2051,"c.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:4225,Energy Efficiency,energy,energy,4225,"e. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is written from; LibMints and all is well. Otherwise, a GENBAS is looked for in; the usual places: PSIPATH, PATH, PSIDATADIR/basis. If path kwarg is; specified, also looks there preferentially for a GENBAS. Can; also specify GENBAS within an input file through a string and; setting the genbas kwarg. Note that due to the input parser's; aggression, blank lines need to be replaced by the text blankline. """"""; lowername = name.lower(); internal_p4c4_info = {}; return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_N",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:13277,Energy Efficiency,energy,energy,13277,"alse; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~dri",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:14252,Energy Efficiency,energy,energy,14252,"ose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURRENT HESSIAN'); # finalquantity.print_out(). return wfn. def cfour_list():; """"""Form list of Cfour :py:func:`~driver.energy` arguments.""""""; return qcdb.cfour.cfour_list(). def cfour_gradient_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_gradient_list(). def cfour_hessian_list():; """"""Form list of Cfour analytic :py:func:`~driver.gradient` arguments.""""""; return qcdb.cfour.cfour_hessian_list(). def cfour_psivar_list():; """"""Form dictionary of :ref:`PSI Variables <apdx:cfour_psivar>` set by Cfour methods.""""""; return qcdb.cfour.cfour_psivar_list(). def write_zmat(name, dertype, molecule):; """"""Returns string with contents of Cfour ZMAT file as gathered from; active molecule, current keyword settings, and cfour {...} block. """"""; # Handle memory; mem = int(0.000001 * core.get_memory()); if mem == 524:; memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', Fal",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:1194,Integrability,interface,interface,1194,".driver.procrouting.interface_cfour; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:1712,Integrability,wrap,wrappers,1712,"n the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:6043,Integrability,message,message,6043,"environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:6080,Integrability,interface,interface,6080,"environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:6403,Integrability,message,message,6403,"s.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:8367,Integrability,message,message,8367,"reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:8492,Integrability,message,message,8492,".outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); message = ('Program %s not found in path or execution failed: %s\n' % (cfour_executable, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); data = data.decode('utf-8'); if not data:; break; core.print_out(data); c4out += data; internal_p4c4_info['output'] = c4out. c4files = {}; core.print_out('\n'); for item in ['GRD', 'FCMFINAL', 'DIPOL']:; try:; with open(psioh.get_default_path() + cfour_tmpdir + '/' + item, 'r') as handle:; c4files[item] = handle.read(); core.print_out(' CFOUR scratch file %s has been read\n' % (item)); core.print_out('%s\n' % c4files[item]); internal_p4c4_info[item.lower()] = c4files[item]; except IOError:; pass; core.print_out('\n'). if molecule.name() == 'blank_molecule_psi4_yo':; qcdbmolecule = None; else:; molecule.update_geometry(); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.update_geometry(). # c4mol, if it exists, is dinky, just a clue to geometry of cfour results; psivar, c4grad, c4mol = qcdb.cfour.harvest(qcdbmolecule, c4out, **c4files). # Absorb results into psi4 data ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:4979,Modifiability,variab,variables,4979,"active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). optstash = p4util.OptionsState(; ['CFOUR', 'TRANSLATE_PSI4']). # Determine calling function and hence dertype; calledby = inspect.stack()[1][3]; dertype = ['energy', 'gradient', 'hessian'].index(calledby); #print('I am %s called by %s called by %s.\n' %; # (inspect.stack()[0][3], inspect.stack()[1][3], inspect.stack()[2][3])). # Save submission directory; current_directory = os.getcwd(). # Move into job scratch directory; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); os.chdir(psioh.get_default_path()). # Construct and move into cfour subdirectory of job scratch directory; cfour_tmpdir = kwargs['path'] if 'path' in kwargs else \; 'psi.' + str(os.getpid()) + '.' + psio.get_default_namespace() + \; '.cfour.' + str(uuid.uuid4())[:8]; if not os.path.exists(cfour_tmpdir):; os.mkdir(cfour_tmpdir); os.chdir(cfour_tmpdir). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFO",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:13050,Modifiability,variab,variables,13050,"f' % (item[0], item[1], item[2])). # Clean up cfour scratch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:2085,Performance,optimiz,optimize,2085,"-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT wi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:5910,Performance,load,loaded,5910,"# Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH') +; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:6626,Performance,load,loaded,6626," # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:7346,Performance,load,loaded,7346,"ule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ======\n'); #core.print_out(open('ZMAT', 'r').read()); #core.print_out('======= End ZMAT input for CFOUR =======\n\n'); #print('\n====== Begin ZMAT input for CFOUR ======'); #print(open('ZMAT', 'r').read()); #print('======= End ZMAT input for CFOUR =======\n'). if 'genbas' in kwargs:; with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(kwargs['genbas'].replace('\nblankline\n', '\n\n')); core.print_out(' GENBAS loaded from kwargs string\n'). # Close psi4 output file and reopen with filehandle; print('output in', current_directory + '/' + core.outfile_name()); pathfill = '' if os.path.isabs(core.outfile_name()) else current_directory + os.path.sep. # Handle threading; # OMP_NUM_THREADS from env is in lenv from above; # threads from psi4 -n (core.get_num_threads()) is ignored; # CFOUR_OMP_NUM_THREADS psi4 option takes precedence, handled below; if core.has_option_changed('CFOUR', 'CFOUR_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('CFOUR', 'CFOUR_OMP_NUM_THREADS')). #print(""""""\n\n<<<<< RUNNING CFOUR ... >>>>>\n\n""""""); # Call executable xcfour, directing cfour output to the psi4 output file; cfour_executable = kwargs['c4exec'] if 'c4exec' in kwargs else 'xcfour'; try:; retcode = subprocess.Popen(cfour_executable.split(), bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (cfour_executable,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:15986,Performance,load,loaded,15986,"memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; qbs = core.BasisSet.build(molecule, ""BASIS"", core.get_global_option('BASIS')); if qbs.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(qbs.genbas()); core.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:2433,Security,access,accessible,2433," from psi4 code. """"""; import os; import re; import sys; import uuid; import shutil; import inspect; import subprocess. import qcelemental as qcel. from psi4.driver import qcdb; from psi4.driver import p4util; from psi4.driver.p4util.exceptions import *; from psi4 import core; # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT within will be used. :type genbas: str; :param genbas:. Indicates that contents should be used for GENBAS file. GENBAS is a complicated topic. It is quite unnecessary if the; molecule is from a molecule {...} block and basis is set through; |Psifours| BASIS keyword. In that case, a GENBAS is w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html:13129,Usability,clear,clear,13129,"ch directory unless user instructs otherwise; keep = yes.match(str(kwargs['keep'])) if 'keep' in kwargs else False; os.chdir('..'); try:; if keep or ('path' in kwargs):; core.print_out('\n CFOUR scratch files have been kept in %s\n' % (psioh.get_default_path() + cfour_tmpdir)); else:; shutil.rmtree(cfour_tmpdir); except OSError as e:; print('Unable to remove CFOUR temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory and reopen output file; os.chdir(current_directory). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). core.print_out('\n'); p4util.banner(' Cfour %s %s Results ' % (name.lower(), calledby.capitalize())); core.print_variables(); if c4grad is not None:; psi_grad.print_out(). # Quit if Cfour threw error; if 'CFOUR ERROR CODE' in core.variables():; raise ValidationError(""""""Cfour exited abnormally.""""""). P4C4_INFO.clear(); P4C4_INFO.update(internal_p4c4_info). optstash.restore(). # new skeleton wavefunction w/mol, highest-SCF basis (just to choose one), & not energy; # Feb 2017 hack. Could get proper basis in skel wfn even if not through p4 basis kw; if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; gobas = ""sto-3g""; else:; gobas = core.get_global_option('BASIS'); basis = core.BasisSet.build(molecule, ""ORBITAL"", gobas); if basis.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); wfn = core.Wavefunction(molecule, basis); for k, v in psivar.items():; wfn.set_variable(k.upper(), float(v)). optstash.restore(). if dertype == 0:; finalquantity = psivar['CURRENT ENERGY']; elif dertype == 1:; finalquantity = psi_grad; wfn.set_gradient(finalquantity); if finalquantity.rows(0) < 20:; core.print_out('CURRENT GRADIENT'); finalquantity.print_out(); elif dertype == 2:; pass; #finalquantity = finalhessian; #wfn.set_hessian(finalquantity); #if finalquantity.rows(0) < 20:; # core.print_out('CURREN",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/interface_cfour.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:4909,Availability,avail,available,4909,"module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:12256,Availability,avail,available,12256," mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:30841,Availability,avail,available,30841,"_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def selec",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:32275,Availability,avail,available,32275,".get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:33166,Availability,avail,available,33166,"nce in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:37442,Availability,error,error,37442,"'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_functional_and_disp(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", """,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:46259,Availability,checkpoint,checkpoint,46259,"ting from converged SCF. """""". if post_scf:; name = ""scf"". optstash = p4util.OptionsState(; ['PUREAM'],; ['BASIS'],; ['QMEFP'],; ['INTS_TOLERANCE'],; ['DF_BASIS_SCF'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'ORBITALS_WRITE'],; ['SCF_TYPE'], # Hack: scope gets changed internally with the Andy trick; ). optstash2 = p4util.OptionsState(; ['BASIS'],; ['DF_BASIS_SCF'],; ['SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ). # Make sure we grab the correctly scoped integral threshold for SCF; core.set_global_option('INTS_TOLERANCE', core.get_option('SCF', 'INTS_TOLERANCE')). # Grab a few kwargs; use_c1 = kwargs.get('use_c1', False); scf_molecule = kwargs.get('molecule', core.get_active_molecule()); read_orbitals = core.get_option('SCF', 'GUESS') == ""READ""; do_timer = kwargs.pop(""do_timer"", True); ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is not None:; raise ValidationError(""Cannot seed an SCF calculation with a reference wavefunction ('ref_wfn' kwarg).""). # decide if we keep the checkpoint file; _chkfile = kwargs.get('write_orbitals', True); write_checkpoint_file = False; if isinstance(_chkfile, str):; write_checkpoint_file = True; filename = kwargs.get('write_orbitals'); core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif _chkfile is True:; write_checkpoint_file = True. # Continuum solvation needs to be run w/o symmetry; if core.get_option(""SCF"", ""PCM"") or core.get_option(""SCF"", ""DDX""):; c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.update_geometry(). scf_molecule = c1_molecule; core.print_out("""""" PCM or DDX continuum solvation does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n""""""). # PE needs to use exactly input orientation to correspond to potfile; if core.get_option(""SCF"", ""PE"") or ""external_potentials"" in kwargs:; c1_molecule = scf_molecule.clone(); if getattr(scf_molecule, ""_initial_cartesian"", None) is not None:; c1_molecule._initial_cartesian = scf_molecule._initial_c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:50391,Availability,avail,available,50391,"lif p4util.no.match(str(castdf)):; castdf = False. if castdf:; core.set_global_option('SCF_TYPE', 'DF'); core.set_local_option('SCF', 'DF_INTS_IO', 'none'). # Figure out the fitting basis set; if castdf is True:; core.set_global_option('DF_BASIS_SCF', ''); elif isinstance(castdf, str):; core.set_global_option('DF_BASIS_SCF', castdf); else:; raise ValidationError(""Unexpected castdf option (%s)."" % castdf). # Switch to the guess namespace; namespace = core.IO.get_default_namespace(); guesspace = namespace + '.guess'; if namespace == '':; guesspace = 'guess'; core.IO.set_default_namespace(guesspace). # Print some info about the guess; core.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); core.print_out('\n'). if cast and read_orbitals:; raise ValidationError(""""""Detected options to both cast and read orbitals""""""). if (core.get_option('SCF', 'STABILITY_ANALYSIS') == 'FOLLOW') and (core.get_option('SCF', 'REFERENCE') != 'UHF'):; raise ValidationError(f""""""Stability analysis root following is only available for unrestricted Hartree--Fock, not present {core.get_option('SCF', 'REFERENCE')}""""""). # If GUESS is auto guess what it should be; if core.get_option('SCF', 'GUESS') == ""AUTO"":; if (scf_molecule.natom() > 1):; core.set_local_option('SCF', 'GUESS', 'SAD'); else:; core.set_local_option('SCF', 'GUESS', 'CORE'). if core.get_global_option('BASIS') in ['', '(AUTO)']:; if name in ['hf3c', 'hf-3c']:; core.set_global_option('BASIS', 'minix'); elif name in ['pbeh3c', 'pbeh-3c']:; core.set_global_option('BASIS', 'def2-msvp'). # the FIRST scf call; if cast:; # Cast is a special case; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); core.print_out(""\n ---------------------------------------------------------\n""); if banner:; core.print_out("" "" + banner.center(58)); if cast:; core.print_out("" "" + ""SCF Castup computation"".center(58)); ref_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:58465,Availability,checkpoint,checkpoint,58465,"OLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # retain with -m (messy) option. if do_timer:; core.tstop(). optstash.restore(). if (not use_c1) or (scf_molecule.schoenflies_symbol() == 'c1'):; return scf_wfn; else:; # C1 copy quietly; c1_optstash = p4util.OptionsState(['PRINT']); core.set_global_option(""PRINT"", 0). # If we force c1 copy the active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True);",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:60200,Availability,avail,available,60200,"he active molecule; scf_molecule.update_geometry(); core.print_out(""""""\n A requested method does not make use of molecular symmetry: """"""; """"""further calculations in C1 point group.\n\n""""""); c1_molecule = scf_molecule.clone(); c1_molecule.reset_point_group('c1'); c1_molecule.fix_orientation(True); c1_molecule.fix_com(True); c1_molecule.update_geometry(); c1_basis = core.BasisSet.build(c1_molecule, ""ORBITAL"", core.get_global_option('BASIS'), quiet=True); tmp = scf_wfn.c1_deep_copy(c1_basis); if not scf_wfn.has_variable(""-D ENERGY""):; tmp.del_variable(""-D ENERGY""); c1_jkbasis = core.BasisSet.build(c1_molecule, ""DF_BASIS_SCF"",; core.get_global_option(""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'), quiet=True); tmp.set_basisset(""DF_BASIS_SCF"", c1_jkbasis); c1_optstash.restore(); return tmp. def run_dct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant theory calculation. """""". if (core.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:79381,Availability,avail,avail,79381,"'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:93717,Availability,avail,available,93717,")', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). derivobj = core.Deriv(ccwfn); grad = derivobj.compute(); del derivobj. ccwfn.set_gradient(grad); ccwfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad); core.set_variable(""CURRENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:106065,Availability,down,down,106065,"ented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX') or n_two > 0:; # WARNING!!! A one-particle property computed _with_ a two-particle property will differ; # from a one-particle property computed by itself. There are no two-particle properties at; # present, so we can kick the issue further down the road.; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); core.cclambda(ccwfn); core.ccdensity(ccwfn). # Need ccresponse only for response-type props; if n_response > 0:; core.set_global_option('DERTYPE', 'RESPONSE'); core.cclambda(ccwfn); for prop in response:; core.set_global_option('PROPERTY', prop); core.ccresponse(ccwfn). # Excited-state transition properties; if n_excited > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); else:; raise ValidationError(""""""Unknown excited-state CC wave function.""""""); core.set_global_option('DERTYPE', 'NONE'); if core.get_option('CCDENSITY', 'OPDM_RELAX'):; core.set_global_option('OPDM_ONLY', 'FALSE'); else:; core.set_global_option('OPDM_ONLY', 'TRUE'); # Tight convergence unnecessary for transition properties; core.set_local_option('CCLAMBDA', 'R_CONVERGENCE', 1e-4); core",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:114696,Availability,avail,available,114696,"r(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CCSD'); core.set_local_option('CCEOM', 'WFN', 'EOM_CCSD'); ref_wfn = run_ccenergy('ccsd', **kwargs). elif name == 'eom-cc2':; user_ref = core.get_option('CCENERGY', 'REFERENCE'); if (user_ref != 'RHF') and (user_ref != 'UHF'):; raise ValidationError('Reference %s for EOM-CC2 is not available.' % user_ref); core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC2'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC2'); ref_wfn = run_ccenergy('cc2', **kwargs). elif name == 'eom-cc3':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC3'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC3'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC3'); core.set_local_option('CCHBAR', 'WFN', 'EOM_CC3'); core.set_local_option('CCEOM', 'WFN', 'EOM_CC3'); ref_wfn = run_ccenergy('cc3', **kwargs). core.cchbar(ref_wfn); core.cceom(ref_wfn). optstash.restore(); return ref_wfn; # TODO ask if all these cc modules not actually changing wfn. def run_eom_cc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CCSD gradient calculation. """"""; optstash =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:117104,Availability,avail,available,117104,"defined sequence'); core.clean(); raise ValueError('Hit a wall in proc.py:1599'). core.set_local_option('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). from pkg_resources import parse_version; min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:120244,Availability,avail,available,120244,"glet"", ""triplet"", ""any""]:; raise ValidationError(""For RHF references the value '{}' for 'KIND' is ""; ""not supported."".format(kind.upper())); kwargs[""kind""] = kind; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one);",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:123930,Availability,toler,tolerance,123930,"root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Fea",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:124291,Availability,avail,available,124291,"tation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{lab",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:132233,Availability,avail,available,132233,"TH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:138588,Availability,avail,available,138588,"TION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:142509,Availability,avail,available,142509,". def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:151518,Availability,avail,available,151518,"'sapt2+3dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', True); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(ccd)', 'sapt2+(ccd)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name in ['sapt2+(3)(ccd)', 'sapt2+(3)(ccd)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('SAPT', 'DO_CCD_DISP', True); elif name in ['sapt2+3(ccd)', 'sapt2+3(ccd)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', True); core.set_local_option('SAPT', 'DO_CCD_DISP', True). # Make sure we are not going to run CPHF on ROHF, since its MO Hessian; # is not SPD; if core.get_option('SCF', 'REFERENCE') == 'ROHF':; core.set_local_option('SAPT', 'COUPLED_INDUCTION', False); core.print_out(' Coupled induction not available for ROHF.\n'); core.print_out(' Proceeding with uncoupled induction only.\n'). core.print_out("" Constructing Basis Sets for SAPT...\n\n""); aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"", core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got inductio",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:162762,Availability,fault,fault,162762,"= mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 file; # and dump a copy into the outfile; core.print_out('\n===== Begin fort.56 input for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prin",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:180458,Availability,avail,available,180458,"fn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # If RHF get MP2 NO's; # Why doesnt this work for conv?; if (('DF' in core.get_global_option('SCF_TYPE')) and (user_ref == 'RHF') and; (core.get_option('DETCI', 'MCSCF_TYPE') in ['DF', 'AO']) and; (core.get_option(""DETCI"", ""MCSCF_GUESS"") == ""MP2"")):; core.set_global_option('ONEPDM', True); core.set_global_option('OPDM_RELAX', False); ref_wfn = run_dfmp2_gradient(name, **kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:183641,Availability,avail,available,183641,"AS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP I",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:56152,Deployability,install,installing,56152,"n.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We alway",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:56172,Deployability,install,install,56172,"n.Cb(), ref_wfn.nbetapi(), ref_wfn.basisset(), scf_wfn.basisset()); scf_wfn.guess_Ca(pCa); scf_wfn.guess_Cb(pCb). # Print basis set info; if core.get_option(""SCF"", ""PRINT_BASIS""):; scf_wfn.basisset().print_detail_out(). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(scf_wfn, ""_disp_functor""):; disp_energy = scf_wfn._disp_functor.compute_energy(scf_wfn.molecule(), scf_wfn); scf_wfn.set_variable(""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We alway",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:56535,Deployability,install,installing,56535,"""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:56557,Deployability,install,install,56557,"""-D Energy"", disp_energy). # PCM preparation; if core.get_option('SCF', 'PCM'):; if core.get_option('SCF', 'PE'):; raise ValidationError(""""""Error: 3-layer QM/MM/PCM not implemented.\n""""""); pcmsolver_parsed_fname = core.get_local_option('PCM', 'PCMSOLVER_PARSED_FNAME'); pcm_print_level = core.get_option('SCF', ""PRINT""); scf_wfn.set_PCM(core.PCM(pcmsolver_parsed_fname, pcm_print_level, scf_wfn.basisset())). # DDPCM preparation; if core.get_option('SCF', 'DDX'):; if not solvent._have_ddx:; raise ModuleNotFoundError('Python module ddx not found. Solve by installing it: `pip install pyddx`'); ddx_options = solvent.ddx.get_ddx_options(scf_molecule); scf_wfn.ddx = solvent.ddx.DdxInterface(; molecule=scf_molecule, options=ddx_options,; basisset=scf_wfn.basisset(); ); scf_wfn.ddx_state = None. # PE preparation; if core.get_option('SCF', 'PE'):; if not solvent._have_pe:; raise ModuleNotFoundError('Python module cppe not found. Solve by installing it: `conda install -c psi4 pycppe`'); # PE needs information about molecule and basis set; pol_embed_options = solvent.pol_embed.get_pe_options(); core.print_out(f"""""" Using potential file; {pol_embed_options[""potfile""]}; for Polarizable Embedding calculation.\n""""""); scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:72481,Deployability,update,update,72481," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:107849,Deployability,update,update,107849,"A', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'R_CONVERGENCE', 1e-4); core.set_local_option('CCEOM', 'E_CONVERGENCE', 1e-5); core.cceom(ccwfn); core.cclambda(ccwfn); core.ccdensity(ccwfn). # => Make OEProp calls <=; if n_one > 0:; # ==> Initialize OEProp <==; oe = core.OEProp(ccwfn); for oe_prop_name in one:; oe.add(oe_prop_name.upper()); # ==> OEProp for the ground state <==; # TODO: When Psi is Py 3.9+, transition to the removeprefix version.; title = name.upper().replace(""EOM-"", """"); #title = name.upper().removeprefix(""EOM-""); oe.set_title(title); set_of_names = {title + "" {}"", ""CC {}""}; if name.startswith(""eom""):; gs_h = 0; for h, i in enumerate(ccwfn.soccpi()):; if i % 2:; gs_h = gs_h ^ h; ct = ccwfn.molecule().point_group().char_table(); total_h_lbl = ct.gamma(0).symbol(); gs_h_lbl = ct.gamma(gs_h).symbol(); set_of_names.update({title + "" ROOT 0 {}"", ""CC ROOT 0 {}"",; f""{title} ROOT 0 {{}} - {total_h_lbl} TRANSITION"",; f""CC ROOT 0 {{}} - {total_h_lbl} TRANSITION"",; f""{title} ROOT 0 ({gs_h_lbl}) {{}}"", f""CC ROOT 0 ({gs_h_lbl}) {{}}"",; f""{title} ROOT 0 (IN {gs_h_lbl}) {{}}"", f""CC ROOT 0 (IN {gs_h_lbl}) {{}}""}); oe.set_names(set_of_names); oe.compute(). # ==> OEProp for Excited States <==; if name.startswith('eom'):; n_root_pi = core.get_global_option(""ROOTS_PER_IRREP""); for h in range(ccwfn.nirrep()):; root_h_lbl = ct.gamma(h).symbol(); trans_h_lbl = ct.gamma(h ^ gs_h).symbol(); # Don't forget to count the ground state!; for i in range(n_root_pi[h]):; if h == gs_h: i += 1; root_title = title + f"" ROOT {i} (IN {root_h_lbl})""; oe.set_title(root_title); total_idx = ccwfn.total_index(i, h); set_of_names = {f""{title} ROOT {total_idx} {{}}"", f""CC ROOT {total_idx} {{}}"",; f""{title} ROOT {total_idx} {{}} - {trans_h_lbl} TRANSITION"",; f""CC ROOT {total_idx} {{}} - {trans_h_lbl} TRANSITION"",; f""{title} ROOT {total_idx} ({root_h_lbl}) {{}}"", f""CC ROOT {total_idx} ({root_h_lbl}) {{}}"",; f""{title} ROOT {i} (IN {root_h_lbl}) {{}}"", f""CC ROOT {i} (IN {root_h_lbl}) {",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:111811,Deployability,configurat,configuration,111811," dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_pro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:117119,Deployability,install,installing,117119,"tion('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). from pkg_resources import parse_version; min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:117143,Deployability,install,install,117143,"tion('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). from pkg_resources import parse_version; min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:117167,Deployability,install,install,117167,"tion('CCLAMBDA', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'ZETA', 'FALSE'); core.set_local_option('CCDENSITY', 'XI', 'TRUE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn); core.set_local_option('CCLAMBDA', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'ZETA', 'TRUE'); core.set_local_option('CCDENSITY', 'XI', 'FALSE'); core.cclambda(ref_wfn); core.ccdensity(ref_wfn). derivobj = core.Deriv(ref_wfn); grad = derivobj.compute(). ref_wfn.set_gradient(grad). optstash.restore(); return ref_wfn. def run_adcc(name, **kwargs):; """"""Prepare and run an ADC calculation in adcc, interpret the result and return; as a wavefunction. """"""; # TODO Maybe it would improve readability if this function was spilt; # up and the whole thing went to a separate file (like for sapt,; # interface_cfour.py, ... try:; import adcc; from adcc.exceptions import InvalidReference; except ModuleNotFoundError:; raise ValidationError(""adcc extras qc_module not available. Try installing ""; ""via 'pip install adcc' or 'conda install -c adcc adcc'.""). from pkg_resources import parse_version; min_version = ""0.15.16""; if parse_version(adcc.__version__) < parse_version(min_version):; raise ModuleNotFoundError(""adcc version {} is required at least. ""; ""Version {}""; "" was found."".format(min_version,; adcc.__version__)). if core.get_option('ADC', 'REFERENCE') not in [""RHF"", ""UHF""]:; raise ValidationError('adcc requires reference RHF or UHF'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.pop('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(). #; # Build kwargs for adcc; #; kwargs.pop(""molecule"", None). if ref_wfn.frzcpi()[0] > 0:; kwargs[""frozen_core""] = ref_wfn.frzcpi()[0]; if ref_wfn.frzvpi()[0] > 0:; kwargs[""frozen_virtual""] = ref_wfn.frzvpi()[0]; if core.get_option(""ADC"", ""NUM_CORE_ORBITALS""):; kwargs[""core_orbitals""] = core.get_option(""ADC"", ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:131794,Deployability,configurat,configuration,131794,"ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROH",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:183922,Deployability,release,release,183922,"# We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summar",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:185299,Deployability,update,updated,185299,"nction encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); do_gradient = core.get_option('EFP', 'DERTYPE') == 'FIRST'. # compute and report; efpobj.compute(do_gradient=do_gradient); core.print_out(efpobj.energy_summary(label='psi')). ene = efpobj.get_energy(label='psi'); core.set_variable('EFP ELST ENERGY', ene['electrostatic'] + ene['charge_penetration'] + ene['electrostatic_point_charges']); core.set_variable('EFP IND ENERGY', ene['polarization']); core.set_variable('EFP DISP ENERGY', ene['dispersion']); core.set_variable('EFP EXCH ENERGY', ene['exchange_repulsion']); core.set_variable('EFP TOTAL ENERGY', ene['total']); core.set_variable('CURRENT ENERGY', ene['total']). if do_gradient:; core.print_out(efpobj.gradient_summary()). torq = efpobj.get_gradient(); torq = core.Matrix.from_array(np.asarray(torq).reshape(-1, 6)); core.set_variable(""EFP TORQUE"", torq) # P::e EFP. return ene['total']. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.procrouting.proc.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:1229,Energy Efficiency,energy,energy,1229,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import sol",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:3354,Energy Efficiency,energy,energy,3354,"y.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zap",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:4324,Energy Efficiency,energy,energy,4324,"sage also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD comput",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:4341,Energy Efficiency,energy,energy,4341,"sage also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD comput",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:7054,Energy Efficiency,energy,energy,7054,"r([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:11117,Energy Efficiency,energy,energy,11117,"'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:12001,Energy Efficiency,energy,energy,12001,"bal_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:12018,Energy Efficiency,energy,energy,12018,"bal_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:13577,Energy Efficiency,energy,energy,13577," the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:15062,Energy Efficiency,energy,energy,15062,"aise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:16606,Energy Efficiency,energy,energy,16606," if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:18093,Energy Efficiency,energy,energy,18093," func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algori",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:19897,Energy Efficiency,energy,energy,19897,"name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_M",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:21389,Energy Efficiency,energy,energy,21389,"func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:22131,Energy Efficiency,energy,energy,22131,"unc is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD through CCENERGY for (RHF|ROHF) not enabled here since not advertised. It does run, though, see #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:24832,Energy Efficiency,energy,energy,24832,"SD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:25580,Energy Efficiency,energy,energy,25580,"ne:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:27912,Energy Efficiency,energy,energy,27912,"ect_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['CCENERGY']: # FORMERLY """"; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['CCENERGY']: # FORMERLY """"; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)"", ""ccsd(t)_l""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:29376,Energy Efficiency,energy,energy,29376,"nc = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif mtd_type == ""CD"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == ""ROHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:30110,Energy Efficiency,energy,energy,30110,"run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:30586,Energy Efficiency,energy,energy,30586,"tion('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:30603,Energy Efficiency,energy,energy,30603,"tion('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:31179,Energy Efficiency,energy,energy,31179,"lt modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:31916,Energy Efficiency,energy,energy,31916,"""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_opti",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:33627,Energy Efficiency,energy,energy,33627,"ence, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROH",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:36071,Energy Efficiency,energy,energy,36071,"directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selecting the algorithm for a CC3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:37104,Energy Efficiency,energy,energy,37104,"irecting to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is No",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:43080,Energy Efficiency,charge,charges,43080,"F_BASIS_SAD"",; core.get_option(""SCF"", ""DF_BASIS_SAD""),; puream=True,; return_atomlist=True); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if core.get_option(""SCF"", ""GUESS"") == ""SAPGAU"":; # Populate sapgau basis; sapgau = core.BasisSet.build(wfn.molecule(), ""SAPGAU_BASIS"", core.get_global_option(""SAPGAU_BASIS"")); wfn.set_basisset(""SAPGAU"", sapgau). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs:; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external po",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:43218,Energy Efficiency,charge,charge,43218,"); wfn.set_sad_fitting_basissets(sad_fitting_list); optstash.restore(). if core.get_option(""SCF"", ""GUESS"") == ""SAPGAU"":; # Populate sapgau basis; sapgau = core.BasisSet.build(wfn.molecule(), ""SAPGAU_BASIS"", core.get_global_option(""SAPGAU_BASIS"")); wfn.set_basisset(""SAPGAU"", sapgau). if hasattr(core, ""EXTERN"") and 'external_potentials' in kwargs:; core.print_out(""\n Warning! Both an external potential EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:43640,Energy Efficiency,charge,charge,43640,"al EXTERN object and the external_potential"" +; "" keyword argument are specified. The external_potentials keyword argument will be ignored.\n""); raise ValidationError(""double extern""). ep = kwargs.get(""external_potentials"", None); if ep is not None:; _set_external_potentials_to_wavefunction(ep, wfn). return wfn. def _set_external_potentials_to_wavefunction(external_potential: Union[List, Dict[str, List]], wfn: ""core.Wavefunction""):; """"""Initialize :py:class:`psi4.core.ExternalPotential` object(s) from charges and locations and set on **wfn**. Parameters; ----------; external_potential; List-like structure where each row corresponds to a charge. Lines can be composed of ``q, [x, y, z]`` or; ``q, x, y, z``. Locations are in [a0].; Or, dictionary where keys are FI-SAPT fragments A, B, or C and values are as above. """"""; from psi4.driver.qmmm import QMMMbohr. def validate_qxyz(qxyz):; if len(qxyz) == 2:; return qxyz[0], qxyz[1][0], qxyz[1][1], qxyz[1][2]; elif len(qxyz) == 4:; return qxyz[0], qxyz[1], qxyz[2], qxyz[3]; else:; raise ValidationError(f""Point charge '{qxyz}' not mapping into 'chg, [x, y, z]' or 'chg, x, y, z'""). if isinstance(external_potential, dict):; # For FSAPT, we can take a dictionary of external potentials, e.g.,; # external_potentials={'A': potA, 'B': potB, 'C': potC} (any optional); # For the dimer SAPT calculation, we need to account for the external potential; # in all of the subsystems A, B, C. So we add them all in total_external_potential; # and set the external potential to the dimer wave function. total_external_potential = core.ExternalPotential(). for frag, frag_qxyz in external_potential.items():; if frag.upper() in ""ABC"":; chrgfield = QMMMbohr(); for qxyz in frag_qxyz:; chrgfield.extern.addCharge(*validate_qxyz(qxyz)). wfn.set_potential_variable(frag.upper(), chrgfield.extern); total_external_potential.appendCharges(chrgfield.extern.getCharges()). else:; core.print_out(""\n Warning! Unknown key for the external_potentials argument: %s"" % fra",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:64925,Energy Efficiency,energy,energy,64925,".5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:73280,Energy Efficiency,energy,energy,73280,"); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:77104,Energy Efficiency,energy,energy,77104,"ype"": ""SCS"", },; ""custom-scs-mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""scs-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""SCS"", },; ""sos-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""SOS"", },; ""custom-scs-omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},. ""remp2"": {""wfn_type"": ""REMP"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:79337,Energy Efficiency,energy,energy,79337,"'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""TRUE"", },. ""oremp2"": {""wfn_type"": ""OREMP"", ""orb_opt"": ""TRUE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:81212,Energy Efficiency,energy,energy,81212,"component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:81439,Energy Efficiency,energy,energy,81439,"iable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:83312,Energy Efficiency,energy,energy,83312,"D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:91908,Energy Efficiency,energy,energy,91908,", 'WFN', 'CCSD_AT'); core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_AT'); elif name == 'cc2':; core.set_local_option('TRANSQT2', 'WFN', 'CC2'); core.set_local_option('CCSORT', 'WFN', 'CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'CC2'); core.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; core.set_local_option('TRANSQT2', 'WFN', 'CC3'); core.set_local_option('CCSORT', 'WFN', 'CC3'); core.set_local_option('CCTRANSORT', 'WFN', 'CC3'); core.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option(""CC_TYPE"") == ""DF"":; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if ((core.get_option('SCF', 'REFERENCE') == 'ROHF'); and ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driv",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:95537,Energy Efficiency,energy,energy,95537,"ENT GRADIENT"", grad). optstash.restore(); return ccwfn. def run_bccd(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-S",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98810,Energy Efficiency,energy,energy,98810,"ble(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98826,Energy Efficiency,energy,energy,98826,"ble(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98870,Energy Efficiency,energy,energy,98870,"ble(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:121395,Energy Efficiency,energy,energy,121395,"ng interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""C",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:121694,Energy Efficiency,energy,energy,121694,"(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_v",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:121820,Energy Efficiency,energy,energy,121820,"reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:121904,Energy Efficiency,energy,energy,121904,"""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:122006,Energy Efficiency,energy,energy,122006,"t_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.ex",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:122055,Energy Efficiency,energy,energy,122055,"?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:122117,Energy Efficiency,energy,energy,122117," not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excit",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:122177,Energy Efficiency,energy,energy,122177,"); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index}",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:122241,Energy Efficiency,energy,energy,122241,"n.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations is still a missing feature in adcc; # ... we store this variant here to be able to fall back to MP(2) energies.; is_cvs_adc3 = state.method.level >= 3 and state.ground_state.has_core_occupied_space. # Ground-state energies; mp = state.ground_state; mp_energy = mp.energy(state.method.level if not is_cvs_adc3 else 2); mp_corr = 0.0; if state.method.level > 1:; core.print_out(""Ground state energy breakdown:\n""); core.print_out("" Energy SCF {0:15.8g} [Eh]\n"".format(ref_wfn.energy())); for level in range(2, state.method.level + 1):; if level >= 3 and is_cvs_adc3:; continue; energy = mp.energy_correction(level); mp_corr += energy; adc_wfn.set_variable(f""MP{level} CORRELATION ENERGY"", energy); adc_wfn.set_variable(f""MP{level} TOTAL ENERGY"", mp.energy(level)); core.print_out(f"" Energy correlation MP{level} {energy:15.8g} [Eh]\n""); core.print_out("" Energy total {0:15.8g} [Eh]\n"".format(mp_energy)); adc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", mp_corr) # P::e ADC; adc_wfn.set_variable(""CURRENT ENERGY"", mp_energy) # P::e ADC. # Set results of excited-states computation; # TODO Does not work: Can't use strings; # adc_wfn.set_variable(""excitation kind"", state.kind); adc_wfn.set_variable(""number of excited states"", len(state.excitation_energy)); adc_wfn.set_variable(""ADC ITERATIONS"", state.n_iter) # P::e ADC; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (A) -> ROOT {root_index} (A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.exci",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:132515,Energy Efficiency,energy,energy,132515,"rmat_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:132870,Energy Efficiency,energy,energy,132870,"PTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); level = int(mtdlvl_mobj.group(""level"")); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_option('DETCI', 'WFN', 'DETCI'); co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:132896,Energy Efficiency,energy,energy,132896,"PTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROHF; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""ROHF"":; raise UpgradeHelper(f""energy('zapt{level}')"", f""energy('mp{level}')"", 1.7,; "" Replace method ZAPT with method MP for RHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). core.set_local_option('DETCI', 'WFN', 'ZAPTN'); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""mp"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'MPN', 'TRUE'); level = int(mtdlvl_mobj.group(""level"")); maxnvect = int((level + 1) / 2) + (level + 1) % 2; core.set_local_option('DETCI', 'MAX_NUM_VECS', maxnvect); if (level + 1) % 2:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 2); else:; core.set_local_option('DETCI', 'MPN_ORDER_SAVE', 1); elif name == 'ccsd':; # untested; core.set_local_option('DETCI', 'WFN', 'DETCI'); co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:153304,Energy Efficiency,charge,charge-transfer,153304,"port sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = sapt_dimer.extract_subsets(2); monomerBm.set_name('monomerBm'). if core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError('SAPT requires requires \""reference rhf\"".'). ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:164856,Energy Efficiency,energy,energy,164856,"threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.va",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:167255,Energy Efficiency,energy,energy,167255,"e.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). dire",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:168185,Energy Efficiency,energy,energy,168185," sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:168750,Energy Efficiency,energy,energy,168750,"er default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; ra",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:168924,Energy Efficiency,energy,energy,168924,"int_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; core.set_local_option('FNOCC', 'DF_BASIS_CC', ''). proc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis S",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:169272,Energy Efficiency,energy,energy,169272,"s Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:170985,Energy Efficiency,energy,energy,170985,"F_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""mp2"": { ""dfcc"": False, ""run_cepa"": False, ""run_mp2"": True, },. ""mp3"": { ""dfcc"": False, ""run_cepa"": False, ""run_mp3"": True, },; ""fno-mp3"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"":",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:173470,Energy Efficiency,energy,energy,173470," True, ""dfcc"": False, ""run_cepa"": False, ""compute_triples"": True, ""run_mp4"": True, ""compute_mp4_triples"": True, },. ""qcisd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:173644,Energy Efficiency,energy,energy,173644,"e, ""run_ccsd"": False, ""compute_triples"": False, },; ""fno-qcisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": False, },. ""qcisd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },; ""fno-qcisd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"",",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:173937,Energy Efficiency,energy,energy,173937,"a"": False, ""run_ccsd"": False, ""compute_triples"": True, },. ""ccsd"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": False, },. ""ccsd(t)"": { ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": False, ""run_ccsd"": True, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. most of these pre-trapped by select_* functions but some escape, incl. mp4(sdq) and qcisd variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_fnocc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_R",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175124,Energy Efficiency,energy,energy,175124,"vefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNO",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175141,Energy Efficiency,energy,energy,175141,"vefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNO",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175871,Energy Efficiency,energy,energy,175871,"C"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": False,},; ""fno-lccsd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": False,},; ""cepa(0)"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:178168,Energy Efficiency,energy,energy,178168,"nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(1)"", ""cepa_no_singles"": False,},. ""cepa(3)"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_b",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:178342,Energy Efficiency,energy,energy,178342,"vel"": ""cepa(3)"", ""cepa_no_singles"": False,},; ""fno-cepa(3)"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(3)"", ""cepa_no_singles"": False,},. ""acpf"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},; ""fno-acpf"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:178623,Energy Efficiency,energy,energy,178623,"un_cepa"": True, ""cepa_level"": ""acpf"", ""cepa_no_singles"": False,},. ""aqcc"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},; ""fno-aqcc"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""aqcc"", ""cepa_no_singles"": False,},. ""cisd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; ""fno-cisd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cisd"", ""cepa_no_singles"": False,},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}""). # throw exception for DF/CD. some of these pre-trapped by select_* functions but others escape, incl. cepa variants; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for FNOCC energy through `run_cepa`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if not core.get_option('FNOCC', 'USE_DF_INTS'):; # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:1954,Integrability,wrap,wrappers,1954,"neral Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:2969,Integrability,message,message,2969,"pers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:33903,Integrability,rout,route,33903,"; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:37365,Integrability,rout,routing,37365,"'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_functional_and_disp(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", """,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:37448,Integrability,message,messages,37448,"'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function selecting the algorithm for a CC* energy call; and directing to specified MRCC module. This function is unusual among ""select"" functions in that it services multiple methods and a; single module. This function could have been skipped and the methods associated directly with; run_rmcc; however, routing through this function screens for conv only while; providing uniform error messages with other select functions. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # todo fix table link anchor. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def build_functional_and_disp(name, restricted, save_pairwise_disp=False, **kwargs):. if core.has_option_changed(""SCF"", """,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:52276,Integrability,rout,routine,52276," base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # Compute additive correction: dftd3, mp2d, dftd4, etc.; if hasattr(ref_wfn, ""_disp_functor""):; disp_energy = ref_wfn._disp_functor.compute_energy(ref_wfn.molecule()); ref_wfn.set_variable(""-D Energy"", disp_energy); ref_wfn.compute_energy(). # cast clean-up; if cast:. # Move files to proper namespace; core.IO.change_file_namespace(180, guesspace, namespace); core.IO.set_default_namespace(namespace). optstash2.restore(). # Print the banner for the standard operation; core.print_out('\n'); p4util.banner(bannername.upper()); core.print_out('\n'). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n""); core.print_out("" "" + banner.center(58)). scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE'), **kwargs). # The wfn from_file routine adds the npy suffix if needed, but we add it here so that; # we can use os.path.isfile to query whether the file exists before attempting to read; read_filename = scf_wfn.get_scratch_filename(180) + '.npy'; if ((core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename)):; old_wfn = core.Wavefunction.from_file(read_filename). Ca_occ = old_wfn.Ca_subset(""SO"", ""OCC""); Cb_occ = old_wfn.Cb_subset(""SO"", ""OCC""). if old_wfn.molecule().schoenflies_symbol() != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if old_wfn.basisset().name() == scf_wfn.basisset().name():; core.print_out(f"" Reading orbitals from file {read_filename}, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out(f"" Reading orbitals from file {read_filename}, projecting to new basis.\n\n""); core.print_out("" Computing basis projection from %s to %s\n\n"" % (old_wfn.basisset().name(), scf_wfn.basisset().name())). pCa = scf_wfn.bas",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:92015,Integrability,rout,routine,92015,"ore.set_local_option('CCSORT', 'WFN', 'CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'CC2'); core.set_local_option('CCENERGY', 'WFN', 'CC2'); elif name == 'cc3':; core.set_local_option('TRANSQT2', 'WFN', 'CC3'); core.set_local_option('CCSORT', 'WFN', 'CC3'); core.set_local_option('CCTRANSORT', 'WFN', 'CC3'); core.set_local_option('CCENERGY', 'WFN', 'CC3'); elif name == 'eom-cc2':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CC2'); core.set_local_option('CCSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CC2'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CC2'); elif name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); # Call a plain energy('ccenergy') and have full control over options, incl. wfn; elif name == 'ccenergy':; pass. # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option(""CC_TYPE"") == ""DF"":; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if ((core.get_option('SCF', 'REFERENCE') == 'ROHF'); and ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:95608,Integrability,rout,routine,95608,"ls for; a Brueckner CCD calculation. """"""; dtl = docs_table_link(""dummy"", ""ccenergy""). optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'bccd':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD'); core.set_local_option('CCSORT', 'WFN', 'BCCD'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD'); core.set_local_option('CCENERGY', 'WFN', 'BCCD'). elif name == 'bccd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'BCCD_T'); core.set_local_option('CCSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCENERGY', 'WFN', 'BCCD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'BCCD_T'); core.set_local_option('CCTRIPLES', 'WFN', 'BCCD_T'); else:; raise ValidationError(""proc.py:run_bccd name %s not recognized"" % name). if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for CCENERGY energy through `run_bccd`. See Capabilities Table at {dtl}""). # Bypass routine scf if user did something special to get it to converge; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Needed for (T).; if (core.get_option('SCF', 'REFERENCE') == 'ROHF'):; ref_wfn.semicanonicalize(). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATI",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:120393,Integrability,interface,interface,120393,"nction method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:120430,Integrability,interface,interface,120430,"nction method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; # Interpret results; #; # Note: This wavefunction is not consistent ... the density; # is e.g. not the proper one (i.e. not the MP(n) one); adc_wfn = core.Wavefunction(ref_wfn.molecule(), ref_wfn.basisset()); adc_wfn.shallow_copy(ref_wfn); adc_wfn.set_reference_wavefunction(ref_wfn); adc_wfn.set_name(name); adc_wfn.set_module(""adcc""). # MP(3) energy for CVS-ADC(3) calculations i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:164540,Integrability,message,message,164540," for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:164661,Integrability,message,message,164661,".print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS'):; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); message = (""Program %s not found in path or execution failed: %s\n"" % (external_exe, e.strerror)); raise ValidationError(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:57860,Modifiability,variab,variable,57860,"f_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf_wfn.to_file(filename); extras.register_numpy_file(filename) # reta",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:61165,Modifiability,variab,variables,61165,"ionError('Frozen core is not available for DCT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). if (core.get_global_option(""DCT_TYPE"") == ""DF""):; core.print_out("" Constructing Basis Sets for DCT...\n\n""); aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_DCT"",; core.get_global_option(""DF_BASIS_DCT""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis); dct_wfn = core.dct(ref_wfn). else:; # Ensure IWL files have been written for non DF-DCT; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); dct_wfn = core.dct(ref_wfn). for k, v in dct_wfn.variables().items():; core.set_variable(k, v). return dct_wfn. def run_dct_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:62290,Modifiability,variab,variables,62290," of PSI module calls for; DCT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dct_wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_globa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:66352,Modifiability,variab,variables,66352,"rgs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", """,MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:66403,Modifiability,variab,variables,66403," is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALS",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:70171,Modifiability,variab,variables,70171,"lse:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:70222,Modifiability,variab,variables,70222,"ies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:72416,Modifiability,variab,variables,72416," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:72492,Modifiability,variab,variables,72492," given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:72630,Modifiability,variab,variables,72630,"nflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_M",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:74185,Modifiability,variab,variables,74185,", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCS"", },; ""scs(n)-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSN"", },; ""scs-mp2-vdw"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSVDW"",},; ""sos-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOS"", },; ""sos-pi-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOSPI"", },; ""custom-scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:74236,Modifiability,variab,variables,74236,"r(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); core.set_local_option('SCF', 'FAIL_ON_MAXITER', False); core.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_occ(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation. """"""; # Stash these options so we can reload them at computation end.; optstash = p4util.OptionsState(; ['OCC', 'SPIN_SCALE_TYPE'],; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE']). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCS"", },; ""scs(n)-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSN"", },; ""scs-mp2-vdw"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SCSVDW"",},; ""sos-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOS"", },; ""sos-pi-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""SOSPI"", },; ""custom-scs-mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""omp2"": ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:77607,Modifiability,variab,variables,77607," ""TRUE"", ""spin_scale_type"": ""NONE"", },. ""lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-lccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_ty",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:77773,Modifiability,variab,variables,77773,"type"": ""OCEPA"", ""orb_opt"": ""FALSE"", ""spin_scale_type"": ""CUSTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:77827,Modifiability,variab,variables,77827,"USTOM"",},. ""olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""NONE"", },; ""custom-scs-olccd"": {""wfn_type"": ""OCEPA"", ""orb_opt"": ""TRUE"", ""spin_scale_type"": ""CUSTOM"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC energy""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_occ_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a conventional integral (O)MPN computation; """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT'],; ['OCC', 'WFN_TYPE'],; ['OCC', 'DO_SCS'],; ['OCC', 'DO_SOS'],; ['GLOBALS', 'DERTYPE']). if core.get_global_option('SCF_TYPE') in ['CD', 'DF', 'MEM_DF', 'DISK_DF']:; raise ValidationError('OCC gradients need conventional SCF reference.'). director = {; ""mp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },; ""conv-omp2"": {""wfn_type"": ""OMP2"", ""orb_opt"": ""TRUE"", },. ""mp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""OMP2.5"", ""orb_opt"": ""TRUE"", },. ""mp3"": {""wfn_type"": ""OMP3"", ""orb_opt"": ""FALSE"",},; ""omp3""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:80014,Modifiability,variab,variables,80014," },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for OCC gradient""). for k, v in director[name].items():; core.set_local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:80180,Modifiability,variab,variables,80180,"local_option(""OCC"", k.upper(), v). core.set_global_option('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:80234,Modifiability,variab,variables,80234,"('DERTYPE', 'FIRST'). # locking out SCS through explicit keyword setting; # * so that current energy must match call; # * since grads not avail for scs; core.set_local_option('OCC', 'SPIN_SCALE_TYPE', 'NONE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). occ_wfn = core.occ(ref_wfn). derivobj = core.Deriv(occ_wfn); grad = derivobj.compute(). occ_wfn.set_gradient(grad); occ_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", grad). # Shove variables into global space; keep_custom_spin_scaling = core.has_option_changed(""OCC"", ""SS_SCALE"") or core.has_option_changed(""OCC"", ""OS_SCALE""); for k, v in occ_wfn.variables().items():; # Custom spin component scaling variables are meaningless if custom scalings hasn't been set. Delete them.; if k.startswith(""CUSTOM SCS"") and not keep_custom_spin_scaling:; occ_wfn.del_variable(k); else:; core.set_variable(k, v). optstash.restore(); return occ_wfn. def run_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation.; """"""; optstash_mp2 = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['DFMP2', 'MP2_OS_SCALE'],; ['DFMP2', 'MP2_SS_SCALE']). dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash_scf = proc_util.scf_set_reference_local(name, is_dft=dft_func). # See if we're doing TDSCF after, keep JK if so; if sum(core.get_option(""SCF"", ""TDSCF_STATES"")) > 0:; core.set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.funct",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:81950,Modifiability,variab,variable,81950,"set_local_option(""SCF"", ""SAVE_JK"", True). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_ener",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:82100,Modifiability,variab,variable,82100,"'SCF_TYPE', 'DF'). scf_wfn = scf_helper(name, post_scf=False, **kwargs); returnvalue = scf_wfn.energy(). ssuper = scf_wfn.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:82227,Modifiability,variab,variables,82227,"n.functional(). if ssuper.is_c_hybrid():. # throw exception for CONV/CD MP2; if (mp2_type := core.get_global_option(""MP2_TYPE"")) != ""DF"":; raise ValidationError(f""Invalid MP2 type {mp2_type} for DF-DFT energy. See capabilities Table.""). core.tstart(); aux_basis = core.BasisSet.build(scf_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlatio",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:82599,Modifiability,variab,variables,82599,"IT"", core.get_global_option('BASIS'),; puream=-1); scf_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis); if ssuper.is_c_scs_hybrid():; core.set_local_option('DFMP2', 'MP2_OS_SCALE', ssuper.c_os_alpha()); core.set_local_option('DFMP2', 'MP2_SS_SCALE', ssuper.c_ss_alpha()); dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(). vdh = dfmp2_wfn.variable('CUSTOM SCS-MP2 CORRELATION ENERGY'). else:; dfmp2_wfn = core.dfmp2(scf_wfn); dfmp2_wfn.compute_energy(); vdh = ssuper.c_alpha() * dfmp2_wfn.variable('MP2 CORRELATION ENERGY'). # remove misleading MP2 psivars computed with DFT, not HF, reference; for var in dfmp2_wfn.variables():; if var.startswith('MP2 ') and ssuper.name() not in ['MP2D']:; scf_wfn.del_variable(var). scf_wfn.set_variable(""DOUBLE-HYBRID CORRECTION ENERGY"", vdh) # P::e SCF; scf_wfn.set_variable(""{} DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.d",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:83421,Modifiability,variab,variables,83421," DOUBLE-HYBRID CORRECTION ENERGY"".format(ssuper.name()), vdh); returnvalue += vdh; scf_wfn.set_variable(""DFT TOTAL ENERGY"", returnvalue) # P::e SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variable",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:83536,Modifiability,variab,variables,83536," SCF; for pv, pvv in scf_wfn.variables().items():; if pv.endswith('DISPERSION CORRECTION ENERGY') and pv.startswith(ssuper.name()):; fctl_plus_disp_name = pv.split()[0]; scf_wfn.set_variable(fctl_plus_disp_name + ' TOTAL ENERGY', returnvalue); break; else:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:83811,Modifiability,variab,variable,83811,"lse:; scf_wfn.set_variable('{} TOTAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:83834,Modifiability,variab,variable,83834,"TAL ENERGY'.format(ssuper.name()), returnvalue). scf_wfn.set_variable('CURRENT ENERGY', returnvalue); scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:83933,Modifiability,variab,variable,83933,"; scf_wfn.set_energy(returnvalue); core.print_out('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is N",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:83978,Modifiability,variab,variable,83978,"t('\n\n'); core.print_out(' %s Energy Summary\n' % (name.upper())); core.print_out(' ' + '-' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:84071,Modifiability,variab,variable,84071,"' * (15 + len(name)) + '\n'); core.print_out(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:84117,Modifiability,variab,variable,84117,"ut(' DFT Reference Energy = %22.16lf\n' % (returnvalue - vdh)); core.print_out(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:84194,Modifiability,variab,variable,84194,"(' Scaled MP2 Correlation = %22.16lf\n' % (vdh)); core.print_out(' @Final double-hybrid DFT total energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:84285,Modifiability,variab,variable,84285,"tal energy = %22.16lf\n\n' % (returnvalue)); core.tstop(). if ssuper.name() == 'MP2D':; for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(gra",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:84380,Modifiability,variab,variable,84380," for pv, pvv in dfmp2_wfn.variables().items():; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:84419,Modifiability,variab,variables,84419,"):; scf_wfn.set_variable(pv, pvv). # Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOT",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:84468,Modifiability,variab,variables,84468,"# Conversely, remove DFT qcvars from MP2D; for var in scf_wfn.variables():; if 'DFT ' in var or 'DOUBLE-HYBRID ' in var:; scf_wfn.del_variable(var). # DFT groups dispersion with SCF. Reshuffle so dispersion with MP2 for MP2D.; for pv in ['SCF TOTAL ENERGY', 'SCF ITERATION ENERGY', 'MP2 TOTAL ENERGY']:; scf_wfn.set_variable(pv, scf_wfn.variable(pv) - scf_wfn.variable('DISPERSION CORRECTION ENERGY')). scf_wfn.set_variable('MP2D CORRELATION ENERGY', scf_wfn.variable('MP2 CORRELATION ENERGY') + scf_wfn.variable('DISPERSION CORRECTION ENERGY')); scf_wfn.set_variable('MP2D TOTAL ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY') + scf_wfn.variable('HF TOTAL ENERGY')); scf_wfn.set_variable('CURRENT ENERGY', scf_wfn.variable('MP2D TOTAL ENERGY')); scf_wfn.set_variable('CURRENT CORRELATION ENERGY', scf_wfn.variable('MP2D CORRELATION ENERGY')); scf_wfn.set_variable('CURRENT REFERENCE ENERGY', scf_wfn.variable('SCF TOTAL ENERGY')). # Shove variables into global space; for k, v in scf_wfn.variables().items():; core.set_variable(k, v). optstash_scf.restore(); optstash_mp2.restore(); return scf_wfn. def run_scf_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:85599,Modifiability,variab,variables,85599,"""""Function encoding sequence of PSI module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:85648,Modifiability,variab,variables,85648," module calls for; a SCF gradient calculation. """""". dft_func = False; if ""dft_functional"" in kwargs:; dft_func = True. optstash = proc_util.scf_set_reference_local(name, is_dft=dft_func). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). if core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF']:; ref_wfn.semicanonicalize(). if hasattr(ref_wfn, ""_disp_functor""):; disp_grad = ref_wfn._disp_functor.compute_gradient(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Gradient"", disp_grad). grad = core.scfgrad(ref_wfn). ref_wfn.set_gradient(grad). ref_wfn.set_variable(""SCF TOTAL GRADIENT"", grad) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL GRADIENT"", grad) # overwritten later for DH -- TODO when DH gradients # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL GRADIENT"", grad) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_scf_hessian(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an SCF hessian calculation. """"""; optstash = proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional()",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:86848,Modifiability,variab,variables,86848,"proc_util.scf_set_reference_local(name). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:86897,Modifiability,variab,variables,86897,"ame). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = run_scf(name, **kwargs). badref = core.get_option('SCF', 'REFERENCE') in ['ROHF', 'CUHF', 'UKS']; badint = core.get_global_option('SCF_TYPE') in [ 'CD', 'OUT_OF_CORE']; if badref or badint:; raise ValidationError(""Only RHF/UHF/RKS Hessians are currently implemented. SCF_TYPE either CD or OUT_OF_CORE not supported""). if hasattr(ref_wfn, ""_disp_functor""):; disp_hess = ref_wfn._disp_functor.compute_hessian(ref_wfn.molecule(), ref_wfn); ref_wfn.set_variable(""-D Hessian"", disp_hess). H = core.scfhess(ref_wfn); ref_wfn.set_hessian(H). ref_wfn.set_variable(""SCF TOTAL HESSIAN"", H) # P::e SCF; if ref_wfn.functional().needs_xc():; ref_wfn.set_variable(""DFT TOTAL HESSIAN"", H) # overwritten later for DH -- TODO when DH Hessians # P::e SCF; else:; ref_wfn.set_variable(""HF TOTAL HESSIAN"", H) # P::e SCF. # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ref_wfn. def run_mcscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a multiconfigurational self-consistent-field calculation. """"""; # Make sure the molecule the user provided is the active one; mcscf_molecule = kwargs.get('molecule', core.get_active_molecule()); mcscf_molecule.update_geometry(); if 'ref_wfn' in kwargs:; raise ValidationError(""It is not possible to pass run_mcscf a reference wavefunction""); new_wfn = core.Wavefunction.build(mcscf_molecule, core.get_global_option('BASIS')). return core.mcscf(new_wfn). def run_dfmp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:88604,Modifiability,variab,variables,88604,"FMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:88749,Modifiability,variab,variable,88749,"t core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRE",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:88843,Modifiability,variab,variable,88843,"("""""" SCF Algorithm Type (re)set to DF.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; fo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:88902,Modifiability,variab,variables,88902,"F.\n""""""). if ""DF"" not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 gradients need DF-SCF reference.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().ite",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89428,Modifiability,variab,variable,89428,"wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89475,Modifiability,variab,variable,89475,"_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(); dfmp2_wfn.set_gradient(grad). # Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89572,Modifiability,variab,variable,89572,"# Shove variables into global space; dfmp2_wfn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_lo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89620,Modifiability,variab,variable,89620,"fn.set_variable(""MP2 TOTAL GRADIENT"", grad) # P::e DFMP2; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); eli",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89701,Modifiability,variab,variable,89701,"CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89796,Modifiability,variab,variable,89796,"RRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCS",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89842,Modifiability,variab,variables,89842,"ATION ENERGY')); for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN',",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:89893,Modifiability,variab,variables,89893,"fn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfmp2d_gradient(name, **kwargs):; """"""Encode MP2-D method."""""". dfmp2_wfn = run_dfmp2_gradient('mp2', **kwargs); wfn_grad = dfmp2_wfn.gradient().clone(). _, _disp_functor = build_functional_and_disp('MP2D', restricted=True); disp_grad = _disp_functor.compute_gradient(dfmp2_wfn.molecule(), dfmp2_wfn); wfn_grad.add(disp_grad); dfmp2_wfn.set_gradient(wfn_grad). dfmp2_wfn.set_variable('MP2D CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY') + dfmp2_wfn.variable('DISPERSION CORRECTION ENERGY')); dfmp2_wfn.set_variable('MP2D TOTAL ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY') + dfmp2_wfn.variable('HF TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2D TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2D CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). return dfmp2_wfn. def run_ccenergy(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD, CC2, and CC3 calculation. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN']). if name == 'ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD'); core.set_local_option('CCSORT', 'WFN', 'CCSD'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD'); core.set_local_option('CCENERGY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_T'); core.set_local_option('CCSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_T'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_T'); elif name == 'a-ccsd(t)':; core.set_local_option('TRANSQT2', 'WFN', 'CCSD_AT'); core.set_local_option('CCSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCTRANSORT', 'WFN', 'CCSD_AT'); core.set_local_option('CCENERGY', 'WFN', 'CCSD_AT'); core.set_local_option('",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:93236,Modifiability,variab,variables,93236,"x_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). # Obtain semicanonical orbitals; if ((core.get_option('SCF', 'REFERENCE') == 'ROHF'); and ((name in ['ccsd(t)', 'a-ccsd(t)', 'cc2', 'cc3', 'eom-cc2', 'eom-cc3']); or core.get_option('CCTRANSORT', 'SEMICANONICAL'))):; ref_wfn.semicanonicalize(). if core.get_global_option('RUN_CCTRANSORT'):; core.cctransort(ref_wfn); else:; try:; from psi4.driver.pasture import addins; addins.ccsort_transqt2(ref_wfn); except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). ccwfn = core.ccenergy(ref_wfn); if core.get_global_option('PE'):; ccwfn.pe_state = ref_wfn.pe_state. if name == 'a-ccsd(t)':; core.cchbar(ref_wfn); lambdawfn = core.cclambda(ref_wfn); for k, v in lambdawfn.variables().items():; ccwfn.set_variable(k, v). optstash.restore(); return ccwfn. def run_ccenergy_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a CCSD and CCSD(T) gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE'],; ['CCLAMBDA', 'WFN'],; ['CCDENSITY', 'WFN']). core.set_global_option('DERTYPE', 'FIRST'). if core.get_global_option('FREEZE_CORE') not in [""FALSE"", ""0""]:; raise ValidationError('Frozen core is not available for the CC gradients.'). ccwfn = run_ccenergy(name, **kwargs). if name == 'cc2':; core.set_local_option('CCHBAR', 'WFN', 'CC2'); core.set_local_option('CCLAMBDA', 'WFN', 'CC2'); core.set_local_option('CCDENSITY', 'WFN', 'CC2'); if name == 'ccsd':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD'); elif name == 'ccsd(t)':; core.set_local_option('CCLAMBDA', 'WFN', 'CCSD_T'); core.set_local_option('CCDENSITY', 'WFN', 'CCSD_T'). core.cchbar(ccwfn); core.cclambda(cc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:96948,Modifiability,variab,variable,96948,"et_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:96991,Modifiability,variab,variable,96991,"re.set_local_option('CCTRANSORT', 'DELETE_TEI', 'false'). bcc_iter_cnt = 0; if (core.get_global_option(""RUN_CCTRANSORT"")):; sort_func = core.cctransort; else:; try:; from psi4.driver.pasture import addins; core.set_local_option('TRANSQT2', 'DELETE_TEI', 'false'); sort_func = addins.ccsort_transqt2; except Exception:; raise PastureRequiredError(""RUN_CCTRANSORT""). hold_qcvars = {; ""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:97387,Modifiability,variab,variable,97387,"""MP2 TOTAL ENERGY"": None,; ""MP2 CORRELATION ENERGY"": None,; ""MP2 SAME-SPIN CORRELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORREC",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:97451,Modifiability,variab,variable,97451,"RELATION ENERGY"": None,; ""MP2 OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""MP2 SINGLES ENERGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:97539,Modifiability,variab,variable,97539,"RGY"": None,; ""MP2 DOUBLES ENERGY"": None,; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRE",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:97579,Modifiability,variab,variable,97579,",; ""CCSD TOTAL ENERGY"": None,; ""CCSD CORRELATION ENERGY"": None,; ""CCSD SAME-SPIN CORRELATION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:97669,Modifiability,variab,variable,97669,"ION ENERGY"": None,; ""CCSD OPPOSITE-SPIN CORRELATION ENERGY"": None,; ""CCSD SINGLES ENERGY"": None,; ""CCSD DOUBLES ENERGY"": None,; }. while True:; sort_func(ref_wfn). ref_wfn = core.ccenergy(ref_wfn); core.print_out('Brueckner convergence check: %s\n' % bool(core.variable('BRUECKNER CONVERGED'))); if core.variable('BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:97978,Modifiability,variab,variable,97978,"'BRUECKNER CONVERGED'):; break. if bcc_iter_cnt >= core.get_option('CCENERGY', 'BCCD_MAXITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.g",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98067,Modifiability,variab,variable,98067,"ITER'):; core.print_out(""\n\nWarning! BCCD did not converge within the maximum number of iterations.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise Valida",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98161,Modifiability,variab,variable,98161,"tions.""); core.print_out(""You can increase the number of BCCD iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98204,Modifiability,variab,variable,98204,"D iterations by changing BCCD_MAXITER.\n\n""); break; bcc_iter_cnt += 1. if bcc_iter_cnt == 1:; for pv in hold_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98331,Modifiability,variab,variable,98331,"_qcvars:; hold_qcvars[pv] = ref_wfn.variable(pv). ref_wfn.set_variable(""BCCD TOTAL ENERGY"", ref_wfn.variable(""CCSD TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD CORRELATION ENERGY"", ref_wfn.variable(""BCCD TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")); ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD CORRELATION ENERGY"")). # copy back canonical MP2 and CCSD from initial iteration; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF refere",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:98754,Modifiability,variab,variable,98754,"ion; for pv, v in hold_qcvars.items():; if v is not None:; ref_wfn.set_variable(pv, v); core.set_variable(pv, v). if name == 'bccd(t)':; core.cctriples(ref_wfn); ref_wfn.set_variable(""B(T) CORRECTION ENERGY"", ref_wfn.variable(""(T) CORRECTION ENERGY"")); ref_wfn.set_variable(""BCCD(T) TOTAL ENERGY"", ref_wfn.variable(""CCSD(T) TOTAL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDS",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:100115,Modifiability,variab,variables,100115,"CF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in respo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:100160,Modifiability,variab,variables,100160,"list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:102330,Modifiability,variab,variable,102330,"ties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did you mean? %s"" % ("" "".join(alt_method_name)). raise ValidationError(""SCF Property: Feature '%s' is not recognized. %s"" % (unknown_property[0], alternatives)). # Validate OEProp; if len(oe_properties):; proc_util.oeprop_validator(oe_properties). if len(linear_response):; optstash_jk = p4util.OptionsState([""SAVE_JK""]); core.set_global_option(""SAVE_JK"", True). # Compute the Wavefunction; scf_wfn = run_scf(name, scf_do_properties=False, do_timer=False, **kwargs). # Run OEProp; oe = core.OEProp(scf_wfn); oe.set_title(name.upper()); for prop in oe_properties:; oe.add(prop.upper()); oe.compute(); scf_wfn.oeprop = oe. core.set_variable(""SCF DIPOLE"", core.variable(name + "" DIPOLE"")) # P::e SCF. # Run Linear Respsonse; if len(linear_response):; core.prepare_options_for_module(""SCF""); ret = response.scf_response.cpscf_linear_response(scf_wfn, *linear_response,; conv_tol = core.get_global_option(""SOLVER_CONVERGENCE""),; max_iter = core.get_global_option(""SOLVER_MAXITER""),; print_lvl = (core.get_global_option(""PRINT"") + 1)); optstash_jk.restore(). core.tstop(); optstash.restore(); return scf_wfn. def run_cc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; all CC property calculations. """"""; optstash = p4util.OptionsState(; ['WFN'],; ['DERTYPE'],; ['ONEPDM'],; ['PROPERTY'],; ['CCLAMBDA', 'R_CONVERGENCE'],; ['CCEOM', 'R_CONVERGENCE'],; ['CCEOM', 'E_CONVERGENCE']) # yapf:disable. oneel_properties = core.OEProp.valid_methods; twoel_properties = []; response_properties = ['POLARIZABILITY', 'ROTATION', 'ROA', 'ROA_TENSOR']; excited_properties = ['OSCILLATOR_STRENGTH', 'ROTATIONAL_STRENGTH']. one = []; two = []; response = []; excited =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:110819,Modifiability,variab,variable,110819,"tion('SCF_TYPE', 'DF') # local set insufficient b/c SCF option read in DFMP2; core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calcu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:110917,Modifiability,variab,variable,110917,"ype (re)set to DF.\n""""""). if 'DF' not in core.get_global_option('SCF_TYPE'):; raise ValidationError('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:111030,Modifiability,variab,variable,111030,"or('DF-MP2 properties need DF-SCF reference.'). properties = kwargs.pop('properties'); proc_util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPO",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:111124,Modifiability,variab,variable,111124,"util.oeprop_validator(properties). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, scf_do_properties=False, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in prope",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:111324,Modifiability,variab,variables,111324,"se, use_c1=True, **kwargs) # C1 certified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:111375,Modifiability,variab,variables,111375,"ified. aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). dfmp2_wfn = core.dfmp2(ref_wfn); grad = dfmp2_wfn.compute_gradient(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Comp",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:111811,Modifiability,config,configuration,111811," dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')); elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Run OEProp; oe = core.OEProp(dfmp2_wfn); oe.set_title(name.upper()); for prop in properties:; oe.add(prop.upper()); oe.compute(); dfmp2_wfn.oeprop = oe. # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def _clean_detci(keep: bool=True):; psioh = core.IOManager.shared_object(); psio = core.IO.shared_object(); cifl = core.get_option(""DETCI"", ""CI_FILE_START""); for fl in range(cifl, cifl + 4):; if psio.open_check(fl):; psio.close(fl, keep). def run_detci_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. """"""; optstash = p4util.OptionsState(; ['OPDM'],; ['TDM']). # Find valid properties; valid_transition = ['TRANSITION_DIPOLE', 'TRANSITION_QUADRUPOLE']. ci_prop = []; ci_trans = []; properties = kwargs.pop('properties'); for prop in properties:; if prop.upper() in valid_transition:; ci_trans.append(prop); else:; ci_prop.append(prop). proc_util.oeprop_validator(ci_prop). core.set_global_option('OPDM', 'TRUE'); if len(ci_trans):; core.set_global_option('TDM', 'TRUE'). # Compute; if name in ['mcscf', 'rasscf', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_pro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:123969,Modifiability,variab,variables,123969,"tion_energy); adc_wfn.set_variable(f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_pr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:124018,Modifiability,variab,variables,124018,"f""{method} ROOT 0 (IN A) -> ROOT {root_index} (IN A) EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY"",; excitation.excitation_energy); adc_wfn.set_variable(f""{method} ROOT 0 -> ROOT {root_index} EXCITATION ENERGY - A TRANSITION"",; excitation.excitation_energy). core.print_out(""\n\n ==> Excited states summary <== \n""); core.print_out(""\n"" + state.describe(oscillator_strengths=False) + ""\n""). # TODO Setting the excitation amplitude elements inside the wavefunction is a little; # challenging, since for each excitation vector one needs to extract the elements; # and map the indices from the adcc to the Psi4 convention. For this reason it; # is not yet done. core.print_out(""\n ==> Dominant amplitudes per state <== \n\n""); tol_ampl = core.get_option(""ADC"", ""CUTOFF_AMPS_PRINT""); core.print_out(state.describe_amplitudes(tolerance=tol_ampl) + ""\n\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); adc_wfn.adcc_state = state; return adc_wfn. def run_adcc_property(name, **kwargs):; """"""Run a ADC excited-states property calculation in adcc; and return the resulting properties. """"""; # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Star",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:131565,Modifiability,variab,variables,131565,"# wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:131614,Modifiability,variab,variables,131614,"OOT n OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:131794,Modifiability,config,configuration,131794,"ROOT 0 (h) -> ROOT n (i) OSCILLATOR STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n OSCILLATOR STRENGTH (VEL) - h TRANSITION"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (IN h) -> ROOT n (IN i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 (h) -> ROOT n (i) ROTATORY STRENGTH (VEL)"") # P::e ADC; # wfn.set_variable(""ADC ROOT 0 -> ROOT n ROTATORY STRENGTH (VEL) - h TRANSITION"") # P::e ADC. core.print_out(""\nExcited state properties:\n""); for i, props in enumerate(computed):; lines = [ind + f""Excited state {i}""]; for prop, data in sorted(props.items()):; lines += [ind + ind + format_vector(prop, data)]; core.print_out(""\n"".join(lines) + ""\n""). # Shove variables into global space; for k, v in adc_wfn.variables().items():; core.set_variable(k, v). if do_timer:; core.tstop(); return adc_wfn. def run_detci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn. """"""; # dtl = docs_table_link(""dummy"", ""detci""). optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['DETCI', 'MAX_NUM_VECS'],; ['DETCI', 'MPN_ORDER_SAVE'],; ['DETCI', 'MPN'],; ['DETCI', 'FCI'],; ['DETCI', 'EX_LEVEL']). # throw exception for UHF; if core.get_option('DETCI', 'REFERENCE') not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' %; core.get_option('DETCI', 'REFERENCE')). # throw exception for DF/CD. many of these pre-trapped by select_* functions but some escape, incl. zapt; if (corl_type := method_algorithm_type(name).now) != ""CONV"":; raise ValidationError(f""Invalid type {corl_type} for DETCI energy through `run_detci`."") # See Capabilities Table""). mtdlvl_mobj = re.match(r""""""\A(?P<method>[a-z]+)(?P<level>\d+)\Z"""""", name.lower()). if mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""zapt"":; level = int(mtdlvl_mobj.group(""level"")). # throw exception for non-ROH",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:134987,Modifiability,variab,variables,134987,", 'WFN', 'DETCI'); core.set_local_option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:135034,Modifiability,variab,variables,135034,"option('DETCI', 'FCI', 'TRUE'); elif name == 'cisd':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 2); elif name == 'cisdt':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1}",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:135235,Modifiability,variab,variable,135235,"ETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENE",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:135270,Modifiability,variab,variable,135270,", 'EX_LEVEL', 3); elif name == 'cisdtq':; core.set_local_option('DETCI', 'WFN', 'DETCI'); core.set_local_option('DETCI', 'EX_LEVEL', 4); elif mtdlvl_mobj and mtdlvl_mobj.group(""method"") == ""ci"":; core.set_local_option('DETCI', 'WFN', 'DETCI'); level = int(mtdlvl_mobj.group(""level"")); core.set_local_option('DETCI', 'EX_LEVEL', level); elif name == 'detci':; pass. # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORREL",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:135833,Modifiability,variab,variable,135833,"files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). ciwfn = core.detci(ref_wfn). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). print_nos = False; if core.get_option(""DETCI"", ""NAT_ORBS""):; ciwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwarg",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:136119,Modifiability,variab,variable,136119,"iwfn.ci_nat_orbs(); print_nos = True. proc_util.print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.mol",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:136167,Modifiability,variab,variable,136167,"print_ci_results(ciwfn, name.upper(), ciwfn.variable(""HF TOTAL ENERGY""), ciwfn.variable(""CURRENT ENERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:136265,Modifiability,variab,variable,136265,"NERGY""), print_nos). core.print_out(""\t\t \""A good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:136313,Modifiability,variab,variable,136313," good bug is a dead bug\"" \n\n""); core.print_out(""\t\t\t - Starship Troopers\n\n""); core.print_out(""\t\t \""I didn't write FORTRAN. That's the problem.\""\n\n""); core.print_out(""\t\t\t - Edward Valeev\n""). if core.get_global_option(""DIPMOM"") and (""mp"" not in name.lower()):; # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). ciwfn.cleanup_ci(); ciwfn.cleanup_dpd(); _clean_detci(). for lvl in range(4, 11):; if ciwfn.has_variable(f""MP{lvl} CORRELATION ENERGY"") and ciwfn.has_variable(f""MP{lvl-1} CORRELATION ENERGY""):; ciwfn.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")); core.set_variable(f""MP{lvl} CORRECTION ENERGY"", ciwfn.variable(f""MP{lvl} CORRELATION ENERGY"") - ciwfn.variable(f""MP{lvl-1} CORRELATION ENERGY"")). optstash.restore(); return ciwfn. def run_dfmp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:137439,Modifiability,variab,variable,137439,"odule calls for; a density-fitted MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:137537,Modifiability,variab,variable,137537,"SIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:137650,Modifiability,variab,variable,137650,"t_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the w",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:137744,Modifiability,variab,variable,137744,"). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:137789,Modifiability,variab,variables,137789,"tion is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:137840,Modifiability,variab,variables,137840,"'ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. core.tstart(); core.print_out('\n'); p4util.banner('DFMP2'); core.print_out('\n'). if core.get_global_option('REFERENCE') == ""ROHF"":; ref_wfn.semicanonicalize(). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DFMP2"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dfmp2_wfn = core.dfmp2(ref_wfn); dfmp2_wfn.compute_energy(). if name == 'scs-mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'mp2':; dfmp2_wfn.set_variable('CURRENT ENERGY', dfmp2_wfn.variable('MP2 TOTAL ENERGY')); dfmp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dfmp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dfmp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dfmp2_wfn. def run_dfep2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. """"""; core.tstart(); optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs) # C1 certified. if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DF-EP2 is not available for %s references."",; core.get_global_option('REFERENCE')). # Build the wavefunction; aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:139703,Modifiability,extend,extend,139703,"le(), ""DF_BASIS_EP2"",; core.get_option(""DFEP2"", ""DF_BASIS_EP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_EP2"", aux_basis). dfep2_wfn = core.DFEP2Wavefunction(ref_wfn). # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:139904,Modifiability,extend,extend,139904,". # Figure out what were doing; if core.has_option_changed('DFEP2', 'EP2_ORBITALS'):; ep2_input = core.get_global_option(""EP2_ORBITALS""). else:; n_ip = core.get_global_option(""EP2_NUM_IP""); n_ea = core.get_global_option(""EP2_NUM_EA""). eps = np.hstack(dfep2_wfn.epsilon_a().nph); irrep_map = np.hstack([np.ones_like(dfep2_wfn.epsilon_a().nph[x]) * x for x in range(dfep2_wfn.nirrep())]); sort = np.argsort(eps). ip_map = sort[dfep2_wfn.nalpha() - n_ip:dfep2_wfn.nalpha()]; ea_map = sort[dfep2_wfn.nalpha():dfep2_wfn.nalpha() + n_ea]. ep2_input = [[] for x in range(dfep2_wfn.nirrep())]; nalphapi = tuple(dfep2_wfn.nalphapi()). # Add IP info; ip_info = np.unique(irrep_map[ip_map], return_counts=True); for irrep, cnt in zip(*ip_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep] - cnt, nalphapi[irrep])). # Add EA info; ea_info = np.unique(irrep_map[ea_map], return_counts=True); for irrep, cnt in zip(*ea_info):; irrep = int(irrep); ep2_input[irrep].extend(range(nalphapi[irrep], nalphapi[irrep] + cnt)). # Compute; ret = dfep2_wfn.compute(ep2_input). # Resort it...; ret_eps = []; for h in range(dfep2_wfn.nirrep()):; ep2_data = ret[h]; inp_data = ep2_input[h]. for i in range(len(ep2_data)):; tmp = [h, ep2_data[i][0], ep2_data[i][1], dfep2_wfn.epsilon_a().get(h, inp_data[i]), inp_data[i]]; ret_eps.append(tmp). ret_eps.sort(key=lambda x: x[3]). h2ev = constants.hartree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sor",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:141301,Modifiability,variab,variable,141301,"rtree2ev; irrep_labels = dfep2_wfn.molecule().irrep_labels(). core.print_out("" ==> Results <==\n\n""); core.print_out("" %8s %12s %12s %8s\n"" % (""Orbital"", ""Koopmans (eV)"", ""EP2 (eV)"", ""EP2 PS"")); core.print_out("" ----------------------------------------------\n""); for irrep, ep2, ep2_ps, kt, pos in ret_eps:; label = str(pos + 1) + irrep_labels[irrep]; core.print_out("" %8s % 12.3f % 12.3f % 6.3f\n"" % (label, (kt * h2ev), (ep2 * h2ev), ep2_ps)); core.set_variable(""EP2 "" + label.upper() + "" ENERGY"", ep2); core.print_out("" ----------------------------------------------\n\n""). # Figure out the IP and EA; sorted_vals = np.array([x[1] for x in ret_eps]); ip_vals = sorted_vals[sorted_vals < 0]; ea_vals = sorted_vals[sorted_vals > 0]. ip_value = None; ea_value = None; if len(ip_vals):; core.set_variable(""EP2 IONIZATION POTENTIAL"", ip_vals[-1]); core.set_variable(""CURRENT ENERGY"", ip_vals[-1]); if len(ea_vals):; core.set_variable(""EP2 ELECTRON AFFINITY"", ea_vals[0]); if core.variable(""EP2 IONIZATION POTENTIAL"") == 0.0:; core.set_variable(""CURRENT ENERGY"", ea_vals[0]). core.print_out("" EP2 has completed successfully!\n\n""). core.tstop(); return dfep2_wfn. def run_dlpnomp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DLPNO-MP2 calculation. """"""; optstash = p4util.OptionsState(; ['DF_BASIS_MP2'],; ['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). # DLPNO-MP2 is only DF; if core.get_global_option('MP2_TYPE') != ""DF"":; raise ValidationError("""""" DLPNO-MP2 is only implemented with density fitting.\n""""""; """""" 'mp2_type' must be set to 'DF'.\n""""""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPN",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:143023,Modifiability,variab,variable,143023,"""). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:143127,Modifiability,variab,variable,143127,"); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; elif ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); o",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:143252,Modifiability,variab,variable,143252,"ymbol() != 'c1':; raise ValidationError("""""" DLPNO-MP2 does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:143352,Modifiability,variab,variable,143352,"""""; """"""reference wavefunction must be C1.\n""""""). if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:143397,Modifiability,variab,variables,143397,"if core.get_global_option('REFERENCE') != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:143451,Modifiability,variab,variables,143451," != ""RHF"":; raise ValidationError(""DLPNO-MP2 is not available for %s references."",; core.get_global_option('REFERENCE')). core.tstart(); core.print_out('\n'); p4util.banner('DLPNO-MP2'); core.print_out('\n'). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_MP2"",; core.get_option(""DLPNO"", ""DF_BASIS_MP2""),; ""RIFIT"", core.get_global_option('BASIS')); ref_wfn.set_basisset(""DF_BASIS_MP2"", aux_basis). dlpnomp2_wfn = core.dlpno(ref_wfn); dlpnomp2_wfn.compute_energy(). if name == 'scs-dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('SCS-MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('SCS-MP2 CORRELATION ENERGY')). elif name == 'dlpno-mp2':; dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:144174,Modifiability,variab,variables,144174," dlpnomp2_wfn.set_variable('CURRENT ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:144224,Modifiability,variab,variables,144224,"ENERGY', dlpnomp2_wfn.variable('MP2 TOTAL ENERGY')); dlpnomp2_wfn.set_variable('CURRENT CORRELATION ENERGY', dlpnomp2_wfn.variable('MP2 CORRELATION ENERGY')). # Shove variables into global space; for k, v in dlpnomp2_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); core.tstop(); return dlpnomp2_wfn. def run_dmrgscf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_CASPT2_CALC']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Sh",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:144877,Modifiability,variab,variables,144877,"wargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variab",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:144927,Modifiability,variab,variables,144927," written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). if 'CASPT2' in name.upper():; core.set_local_option(""DMRG"", ""DMRG_CASPT2_CALC"", True). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:145234,Modifiability,variab,variables,145234,"ariable(k, v). return dmrg_wfn. def run_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:145287,Modifiability,variab,variables,145287,"un_dmrgci(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an DMRG calculation. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DMRG', 'DMRG_SCF_MAX_ITER']). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). core.set_local_option('DMRG', 'DMRG_SCF_MAX_ITER', 1). dmrg_wfn = core.dmrg(ref_wfn); optstash.restore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = k",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:145839,Modifiability,variab,variables,145839,"tore(). # Shove variables into global space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); mono",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:145892,Modifiability,variab,variables,145892," space; for k, v in dmrg_wfn.variables().items():; core.set_variable(k, v). return dmrg_wfn. def run_psimrcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. """"""; mcscf_wfn = run_mcscf(name, **kwargs); psimrcc_wfn = core.psimrcc(mcscf_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_psimrcc_scf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. """"""; # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn). psimrcc_wfn = core.psimrcc(ref_wfn). # Shove variables into global space; for k, v in psimrcc_wfn.variables().items():; core.set_variable(k, v). return psimrcc_wfn. def run_sapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a SAPT calculation of any level. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_basis = kwargs.pop('sapt_basis', 'dimer'). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, sapt_basis). # Need to ensure consistent orbital freezing; # between monomer and dimer computations; monomerA_basis = core.BasisSet.build(monomerA, ""BASIS"", core.get_global_option(""BASIS"")); monomerB_basis = core.BasisSet.build(mono",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:148245,Modifiability,variab,variable,148245,"al_disp = True if '-d' in name.lower() else False. if do_empirical_disp:; ## Make sure we are turning SAPT0 dispersion off; core.set_local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=mo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:148888,Modifiability,variab,variable,148888,"SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:149434,Modifiability,variab,variable,149434," and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(""mp2"", ref_wfn=monomerB_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'); core.set_variable(""SAPT MP2 CORRELATION ENERGY"", mp2_corl_interaction_e) # P::e SAPT; core.set_global_option('DF_INTS_IO', df_ints_io). if core.get_option('SCF', 'REFERENCE') == 'RHF':; core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'). core.IO.set_default_namespace('dimer'); core.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); core.set_local_option('SAPT', 'D_CONVERGENCE', 10e-10); if name in ['sapt0', 'ssapt0']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT0'); elif name == 'sapt2':; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2'); elif name in ['sapt2+', 'sapt2+dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+'); core.set_local_option('SAPT', 'DO_CCD_DISP', False); elif name in ['sapt2+(3)', 'sapt2+(3)dmp2']:; core.set_local_option('SAPT', 'SAPT_LEVEL', 'SAPT2+3'); core.set_local_option('SAPT', 'DO_THIRD_ORDER', False); core.set_local_option('",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:152808,Modifiability,variab,variable,152808,"ASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"", core.get_global_option(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Wa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:152958,Modifiability,variab,variable,152958,"tion(""DF_BASIS_ELST""),; ""JKFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_uti",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:153062,Modifiability,variab,variable,153062,"sis). core.print_out('\n'); p4util.banner(name.upper()); core.print_out('\n'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); dimer_wfn.set_module(""sapt""). from psi4.driver.qcdb.psivardefs import sapt_psivars; p4util.expand_psivars(sapt_psivars()); optstash.restore(). # Get the SAPT name right if doing empirical dispersion; if do_empirical_disp:; sapt_name = ""sapt0""; else:; sapt_name = name. # Make sure we got induction, otherwise replace it with uncoupled induction; which_ind = 'IND'; target_ind = 'IND'; if not core.has_variable(' '.join((sapt_name.upper(), which_ind, 'ENERGY'))):; which_ind = 'IND,U'. for term in ['ELST', 'EXCH', 'DISP', 'TOTAL']:; core.set_variable(' '.join(['SAPT', term, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), term, 'ENERGY']))); # Special induction case; core.set_variable(' '.join(['SAPT', target_ind, 'ENERGY']),; core.variable(' '.join([sapt_name.upper(), which_ind, 'ENERGY']))); core.set_variable('CURRENT ENERGY', core.variable('SAPT TOTAL ENERGY')). # Empirical dispersion; if do_empirical_disp:; proc_util.sapt_empirical_dispersion(name, dimer_wfn). return dimer_wfn. def run_sapt_ct(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. """"""; optstash = p4util.OptionsState(; ['SCF_TYPE']). if 'ref_wfn' in kwargs:; core.print_out('\nWarning! Argument ref_wfn is not valid for sapt computations\n'). # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'). # Get the molecule of interest; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; sapt_dimer = kwargs.pop('molecule', core.get_active_molecule()); else:; core.print_out('Warning! SAPT argument ""ref_wfn"" is only able to use molecule information.'); sapt_dimer = ref_wfn.molecule(). sapt_dimer, monomerA, monomerB = proc_util.prepare_sapt_molecule(sapt_dimer, ""dimer""); monomerAm = sapt_dimer.extract_subsets(1); monomerAm.set_name('mono",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:157816,Modifiability,variab,variable,157816,"t_local_option('SAPT', 'DO_CCD_DISP', True). core.print_out('\n'). aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_SAPT"",; core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_SAPT"", aux_basis); if core.get_global_option(""DF_BASIS_ELST"") == """":; dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:158183,Modifiability,variab,variable,158183,"x_basis); else:; aux_basis = core.BasisSet.build(dimer_wfn.molecule(), ""DF_BASIS_ELST"",; core.get_global_option(""DF_BASIS_ELST""),; ""RIFIT"", core.get_global_option(""BASIS"")); dimer_wfn.set_basisset(""DF_BASIS_ELST"", aux_basis). core.print_out('\n'); p4util.banner('SAPT Charge Transfer'); core.print_out('\n'). core.print_out('\n'); p4util.banner('Dimer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerA', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerB', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerA_wfn, monomerB_wfn); CTd = core.variable('SAPT CT ENERGY'); dimer_wfn.set_module(""sapt""). core.print_out('\n'); p4util.banner('Monomer Basis SAPT'); core.print_out('\n'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERA, 'monomerAm', 'dimer'); core.IO.change_file_namespace(psif.PSIF_SAPT_MONOMERB, 'monomerBm', 'dimer'); e_sapt = core.sapt(dimer_wfn, monomerAm_wfn, monomerBm_wfn); CTm = core.variable('SAPT CT ENERGY'); CT = CTd - CTm. units = (1000.0, constants.hartree2kcalmol, constants.hartree2kJmol); core.print_out('\n\n'); core.print_out(' SAPT Charge Transfer Analysis\n'); core.print_out(' ------------------------------------------------------------------------------------------------\n'); core.print_out(' SAPT Induction (Dimer Basis) %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTd * u for u in units)); core.print_out(' SAPT Induction (Monomer Basis)%12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n' %; tuple(CTm * u for u in units)); core.print_out(' SAPT Charge Transfer %12.4lf [mEh] %12.4lf [kcal/mol] %12.4lf [kJ/mol]\n\n' %; tuple(CT * u for u in units)); core.set_variable(""SAPT CT ENERGY"", CT) # P::e SAPT. optstash.restore(); return dimer_wfn. def run_fisapt(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an F/ISAPT0 computation. """"""; optstash = p4util.OptionsState(['SCF_TYPE']). # Alter default algorithm; if not core.has_global_option_chang",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:162101,Modifiability,variab,variable,162101,"; if ""-d"" in name.lower():; core.set_local_option(""FISAPT"", ""FISAPT_DO_FSAPT_DISP"", False). fisapt_wfn = core.FISAPT(ref_wfn); from .sapt import fisapt_proc; fisapt_wfn.compute_energy(external_potentials=kwargs.get(""external_potentials"", None)). # Compute -D dispersion; if ""-d"" in name.lower():; proc_util.sapt_empirical_dispersion(name, ref_wfn). optstash.restore(); return ref_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:;",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:162506,Modifiability,variab,variables,162506,"ef_wfn. def run_mrcc(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Kallay's MRCC code. """"""; from .proc_data import mrcc_methods. # level is a dictionary of settings to be passed to core.mrcc; try:; level = mrcc_methods[name.lower()]; except KeyError:; if name.lower() == ""a-ccsd(t)"":; level = mrcc_methods[""ccsd(t)_l""]; else:; raise ValidationError(f""""""MRCC method '{name}' invalid.""""""). # Check to see if we really need to run the SCF code.; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs); vscf = ref_wfn.variable('SCF TOTAL ENERGY'). # Fullname is the string we need to search for in iface; fullname = level['fullname']. # User can provide 'keep' to the method.; # When provided, do not delete the MRCC scratch directory.; keep = False; if 'keep' in kwargs:; keep = kwargs['keep']. # Save current directory location; current_directory = os.getcwd(). # Find environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) +; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level); ref_wfn.set_module(""mrcc""). # Load the fort.56 f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:165636,Modifiability,variab,variable,165636,"rror(message). c4out = ''; while True:; data = retcode.stdout.readline(); if not data:; break; core.print_out(data.decode('utf-8')); c4out += data.decode('utf-8'). # Scan iface file and grab the file energy.; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do no",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:165839,Modifiability,variab,variable,165839,"; ene = 0.0; for line in open('iface'):; fields = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:165888,Modifiability,variab,variable,165888,"elds = line.split(); m = fields[1]; try:; ene = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; elif m == ""CCSD[T]"":; m = ""CCSD+T(CCSD)""; elif m == ""CCSD(T)_L"":; m = ""A-CCSD(T)""; ref_wfn.set_variable(m + ' TOTAL ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:166092,Modifiability,variab,variable,166092,"ENERGY', ene); ref_wfn.set_variable(m + ' CORRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:166143,Modifiability,variab,variable,166143,"RRELATION ENERGY', ene - vscf); except ValueError:; continue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:166967,Modifiability,variab,variables,166967,"ef_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:167016,Modifiability,variab,variables,167016,"ON ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] computation. >>> set cc_type df; >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options; optstash = p4util.OptionsState(; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'DF_BASIS_CC'],; ['SCF', 'DF_BASIS_SCF'],; ['SCF', 'DF_INTS_IO']). def set_cholesky_from(type_val):; if type_val == 'CD':; core.set_local_option('FNOCC', 'DF_BASIS_CC', 'CHOLESKY'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""). elif type_val in ['DISK_DF', 'DF']:; if core.get_option('FNOCC', 'DF_BASIS_CC') == 'CHOLESKY':; co",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:170704,Modifiability,variab,variables,170704,"onError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:170755,Modifiability,variab,variables,170755,"of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_fnocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a QCISD(T), CCSD(T), MP2.5, MP3, and MP4 computation. >>> energy('fno-ccsd(t)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # stash user options:; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'RUN_MP2'],; ['FNOCC', 'RUN_MP3'],; ['FNOCC', 'RUN_MP4'],; ['FNOCC', 'RUN_CCSD'],; ['FNOCC', 'COMPUTE_TRIPLES'],; ['FNOCC', 'COMPUTE_MP4_TRIPLES'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'NAT_ORBS']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). if name in [""mp3"", ""fno-mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). director = {; # Note ""nat_orbs",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175299,Modifiability,variab,variable,175299,"Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175404,Modifiability,variab,variable,175404,"PE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_le",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175528,Modifiability,variab,variable,175528," ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175575,Modifiability,variab,variable,175575,"DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc""",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175620,Modifiability,variab,variables,175620,"('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:175671,Modifiability,variab,variables,175671,").has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). if core.get_global_option(""RELATIVISTIC"") in [""X2C"", ""DKH""]:; rel_bas = core.BasisSet.build(ref_wfn.molecule(), ""BASIS_RELATIVISTIC"",; core.get_option(""SCF"", ""BASIS_RELATIVISTIC""),; ""DECON"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset('BASIS_RELATIVISTIC',rel_bas). fnocc_wfn = core.fnocc(ref_wfn). # set current correlation energy and total energy. only need to treat mpn here.; if (lbl := name.replace(""fno-"", """")) in [""mp3"", ""mp4(sdq)"", ""mp4""]:; fnocc_wfn.set_variable(""CURRENT ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} TOTAL ENERGY"")); fnocc_wfn.set_variable(""CURRENT CORRELATION ENERGY"", fnocc_wfn.variable(f""{lbl.upper()} CORRELATION ENERGY"")); if lbl == ""mp4"":; fnocc_wfn.set_variable(""MP4 CORRECTION ENERGY"", fnocc_wfn.variable(""MP4 CORRELATION ENERGY"") - fnocc_wfn.variable(""MP3 CORRELATION ENERGY"")). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; kwargs = p4util.kwargs_lower(kwargs); dtl = docs_table_link(""dummy"", ""fnocc""). # save user options; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['FNOCC', 'NAT_ORBS'],; ['FNOCC', 'DFCC'],; ['FNOCC', 'RUN_CEPA'],; ['FNOCC', 'USE_DF_INTS'],; ['FNOCC', 'CEPA_LEVEL'],; ['FNOCC', 'CEPA_NO_SINGLES']). # AED reinforces default; core.set_local_option('FNOCC', 'USE_DF_INTS', False). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""lccd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },; ""fno-lccd"": {""nat_orbs"": True, ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": True, },. ""lccsd"": { ""dfcc"": False, ""run_cepa"": True, ""cepa_level"": ""cepa(0)"", ""cepa_no_singles"": False,},; ""fn",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:179913,Modifiability,variab,variables,179913,"sure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if no",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:179964,Modifiability,variab,variables,179964,"oc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; core.print_out("" Constructing Basis Sets for FISAPT...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). fnocc_wfn = core.fnocc(ref_wfn). # one-electron properties; cepa_level = director[name][""cepa_level""]; if core.get_option('FNOCC', 'DIPMOM'):; if cepa_level in ['cepa(1)', 'cepa(3)']:; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); elif core.get_option('FNOCC', 'NAT_ORBS'):; core.print_out(""""""\n Error: one-electron properties not implemented for %s\n\n"""""" % name); else:; p4util.oeprop(fnocc_wfn, 'DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS', title=cepa_level.upper()). # Shove variables into global space; for k, v in fnocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return fnocc_wfn. def run_detcas(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; determinant-based multireference wavefuncations,; namely CASSCF and RASSCF.; """"""; optstash = p4util.OptionsState(; ['DETCI', 'WFN'],; ['SCF_TYPE'],; ['ONEPDM'],; ['OPDM_RELAX']; ). user_ref = core.get_option('DETCI', 'REFERENCE'); if user_ref not in ['RHF', 'ROHF']:; raise ValidationError('Reference %s for DETCI is not available.' % user_ref). if name == 'rasscf':; core.set_local_option('DETCI', 'WFN', 'RASSCF'); elif name == 'casscf':; core.set_local_option('DETCI', 'WFN', 'CASSCF'); else:; raise ValidationError(""Run DETCAS: Name %s not understood"" % name). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:. ref_optstash = p4util.OptionsState(; ['SCF_TYPE'],; ['DF_BASIS_SCF'],; ['DF_BASIS_MP2'],; ['ONEPDM'],; ['OPDM_RELAX']; ). # No real reason to do a conventional guess; if not core.has_global_option_changed('SC",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:183170,Modifiability,variab,variable,183170,"_TYPE') == 'AO':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:183215,Modifiability,variab,variables,183215,"SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efp",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:183262,Modifiability,variab,variables,183262,"n('SCF_TYPE', 'DIRECT'). # The conventional case; elif core.get_option('DETCI', 'MCSCF_TYPE') == 'CONV':; if not core.has_global_option_changed('SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'PK'). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_global_option('SCF_TYPE'), ref_wfn); else:; raise ValidationError(""Run DETCAS: MCSCF_TYPE %s not understood."" % str(core.get_option('DETCI', 'MCSCF_TYPE'))). # Second-order SCF requires non-symmetric density matrix support; if core.get_option('DETCI', 'MCSCF_ALGORITHM') in ['AH', 'OS']:; proc_util.check_non_symmetric_jk_density(""Second-order MCSCF""). ciwfn = mcscf.mcscf_solver(ref_wfn). # We always would like to print a little dipole information; oeprop = core.OEProp(ciwfn); oeprop.set_title(name.upper()); oeprop.add(""DIPOLE""); oeprop.compute(); ciwfn.oeprop = oeprop; core.set_variable(""CURRENT DIPOLE"", core.variable(name.upper() + "" DIPOLE"")). # Shove variables into global space; for k, v in ciwfn.variables().items():; core.set_variable(k, v). optstash.restore(); return ciwfn. def run_efp(name, **kwargs):; """"""Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). """""". efp_molecule = kwargs.get('molecule', core.get_active_molecule()); try:; efpobj = efp_molecule.EFP; except AttributeError:; raise ValidationError(""""""Method 'efp' not available without EFP fragments in molecule""""""). # print efp geom in [A]; core.print_out(efpobj.banner()); core.print_out(efpobj.geometry_summary(units_to_bohr=constants.bohr2angstroms)). # set options; # * 'chtr', 'qm_exch', 'qm_disp', 'qm_chtr' may be enabled in a future libefp release; efpopts = {}; for opt in ['elst', 'exch', 'ind', 'disp',; 'elst_damping', 'ind_damping', 'disp_damping']:; psiopt = 'EFP_' + opt.upper(); if core.has_option_changed('EFP', psiopt):; efpopts[opt] = core.get_option('EFP', psiopt); efpopts['qm_elst'] = False; efpopts['qm_ind'] = False; efpobj.set_opts(efpopts, label='psi', append='psi'); ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:1239,Performance,optimiz,optimize,1239,"; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import re; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import sol",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:2551,Performance,perform,performance,2551," import constants; from qcelemental.util import which. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:3402,Performance,perform,performance,3402,"y.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zap",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:5301,Performance,perform,performance,5301,"= 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp2')"", ""energy('zapt2')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""); elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference in ['RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'DFMP2']:; func = run_dfmp2. if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP2 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""F",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:6338,Performance,perform,performance,6338," specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE').",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:7102,Performance,perform,performance,7102,"r([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:7875,Performance,perform,performance,7875," ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'U",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:8597,Performance,perform,performance,8597,"unc = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC'",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:9245,Performance,perform,performance,9245,"e in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:9889,Performance,perform,performance,9889,"RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:10535,Performance,perform,performance,10535,", 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; fun",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:11165,Performance,perform,performance,11165,"'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_property(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:12648,Performance,perform,performance,12648," = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp3')"", ""energy('zapt3')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP3 as it is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:13625,Performance,perform,performance,13625," the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODU",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:14398,Performance,perform,performance,14398,"Error([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:15110,Performance,perform,performance,15110,"aise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') =",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:15862,Performance,perform,performance,15862,"me__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:16654,Performance,perform,performance,16654," if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:17431,Performance,perform,performance,17431," module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:18141,Performance,perform,performance,18141," func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd(name, **kwargs):; """"""Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algori",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:19155,Performance,perform,performance,19155,"y call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'OCC':; func = run_occ; elif module in ['', 'FNOCC']:; func = run_cepa; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:19945,Performance,perform,performance,19945,"name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_M",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:20720,Performance,perform,performance,20720,"or([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:21437,Performance,perform,performance,21437,"func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:22179,Performance,perform,performance,22179,"unc is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD through CCENERGY for (RHF|ROHF) not enabled here since not advertised. It does run, though, see #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:23875,Performance,perform,performance,23875," == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in ["""", ""OCC""]:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'CCT3' and extras.addons(""cct3""):; import cct3; func = cct3.run_cct3; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:24880,Performance,perform,performance,24880,"SD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:25628,Performance,perform,performance,25628,"ne:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:27043,Performance,perform,performance,27043,"_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['CCENERGY']: # FORMERLY """"; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['CCENERGY']: # FORMERLY """"; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:27960,Performance,perform,performance,27960,"ect_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['CCENERGY']: # FORMERLY """"; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['CCENERGY']: # FORMERLY """"; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['OCC']: # SOON """",; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a a-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; if name.lower() == ""a-ccsd(t)"":; pass; elif name.lower() in [""ccsd(at)"", ""lambda-ccsd(t)"", ""ccsd(t)_l""]:; core.print_out(f""""""\nMethod ""{name.lower()}"" has been regularized to ""a-ccsd(t)"" for QCVariables.""""""); name = ""a-ccsd(t)"". reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:29424,Performance,perform,performance,29424,"nc = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif mtd_type == ""CD"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == ""ROHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:30158,Performance,perform,performance,30158,"run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:31227,Performance,perform,performance,31227,"lt modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:31964,Performance,perform,performance,31964,"""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_opti",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:32855,Performance,perform,performance,32855,"; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_t",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:33675,Performance,perform,performance,33675,"ence, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROH",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:35100,Performance,perform,performance,35100,"C2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc2_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CC2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selectin",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:36119,Performance,perform,performance,36119,"directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] Both UHF and ROHF gradients run in ccenergy but ROHF is slightly off (1.e-5); # and UHF is more off (1.e-4). Moreover, manual only claims RHF are working, so restricting here.; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cc3(name, **kwargs):; """"""Function selecting the algorithm for a CC3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROHF':; if mtd_type == 'CONV':; # ROHF MRCC CC3 CCn methods are not implemented for ROHF reference!; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mrcc(name, **kwargs):; """"""Function",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:62515,Performance,optimiz,optimized,62515,"wfn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true'); dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC. Se",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:66615,Performance,optimiz,optimized,66615,"("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(). dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). if name in [""mp2.5"", ""mp3""] and not core.has_global_option_changed(""MP_TYPE""):; core.print_out(f"" Information: {name.upper()} default algorithm changed to DF in August 2020. Use `set mp_type conv` for previous behavior.\n""). # CC_LAMBDA keyword was being set TRUE sporadically, but that's covered c-side. director = {; ""mp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2"": {""wfn_type"": ""DF-OMP2"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp2.5"": {""wfn_type"": ""DF-OMP2.5"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:70434,Performance,optimiz,optimized,70434,"ut("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). derivobj = core.Deriv(dfocc_wfn); derivobj.compute_df(""DF_BASIS_SCF"", ""DF_BASIS_CC""). dfocc_wfn.set_variable(f""{name.upper()} TOTAL GRADIENT"", dfocc_wfn.gradient()). # Shove variables into global space; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); else:; raise ValidationError('Unidentified method ' % (name)). proc_util.check_disk_df(name.upper(), optstash). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp3', 'omp2.5', 'olccd']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:2715,Safety,avoid,avoids,2715,"les as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, UpgradeHelper, ValidationError, docs_table_link; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .proc_data import method_algorithm_type; from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:72542,Safety,risk,risks,72542,"per(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). # Shove variables into global space; # TODO: Make other methods in DFOCC update all variables, then add them to the list. Adding now, risks setting outdated information.; if name in ['mp2', 'omp2']:; for k, v in dfocc_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dfocc_wfn. def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an quadratically-convergent SCF computation. """"""; dtl = docs_table_link(""dummy"", ""occ_nonoo""). optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['SCF', 'FAIL_ON_MAXITER'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). # throw exception for CONV; if (corl_type := method_algorithm_type(name).now) not in [""DISK_DF"", ""DF"", ""CD""]:; raise ValidationError(f""Invalid type {corl_type} for QCHF energy through `run_qchf`. See Capabilities Table at {dtl}""). core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); core.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); core.set_local_option('DFOCC', 'QCHF', 'TRUE'); core.set_local_option('DFOCC', 'E_CONVERGENCE', 8). core.set",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:99040,Safety,sanity check,sanity checks,99040,"AL ENERGY"")); ref_wfn.set_variable(""BCCD(T) CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) TOTAL ENERGY"") - ref_wfn.variable(""SCF TOTAL ENERGY"")) # note != CCSD(T) CORRELATION ENERGY; ref_wfn.set_variable(""CURRENT CORRELATION ENERGY"", ref_wfn.variable(""BCCD(T) CORRELATION ENERGY"")). for pv in [""(T) CORRECTION ENERGY"", ""CCSD(T) TOTAL ENERGY"", ""CCSD(T) CORRELATION ENERGY""]:; ref_wfn.del_variable(pv); core.del_variable(pv). for pv in [; ""BCCD TOTAL ENERGY"",; ""BCCD CORRELATION ENERGY"",; ""B(T) CORRECTION ENERGY"",; ""BCCD(T) TOTAL ENERGY"",; ""BCCD(T) CORRELATION ENERGY"",; ""CURRENT CORRELATION ENERGY"",; ]:; if ref_wfn.has_variable(pv):; core.set_variable(pv, ref_wfn.variable(pv)). # Notes; # * BCCD or BCCD(T) correlation energy is total energy of last Brueckner iteration minus HF energy of first Brueckner iteration. optstash.restore(); return ref_wfn. def run_tdscf_excitations(wfn,**kwargs):. states = core.get_option(""SCF"",""TDSCF_STATES""). # some sanity checks; if sum(states) == 0:; raise ValidationError(""TDSCF: No states requested in TDSCF_STATES""). # unwrap 1-membered list of states, regardless of symmetry; # we will apportion states per irrep later on; if len(states) == 1:; states = states[0]. # Tie TDSCF_R_CONVERGENCE to D_CONVERGENCE in SCF reference; if core.has_option_changed('SCF', 'TDSCF_R_CONVERGENCE'):; r_convergence = core.get_option('SCF', 'TDSCF_R_CONVERGENCE'); else:; r_convergence = min(1.e-4, core.get_option('SCF', 'D_CONVERGENCE') * 1.e2). # ""anonymous"" return value, as we stash observables in the passed Wavefunction object internally; _ = response.scf_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TD",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:32375,Security,access,access,32375,"pe(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:33266,Security,access,access,33266,"nt_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc; elif mtd_type == ""CD"":; if module in ["""", ""OCC""]:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and whi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:65004,Testability,log,logic,65004," ""nat_orbs"": ""FALSE"",},. ""mp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""omp3"": {""wfn_type"": ""DF-OMP3"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""remp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""oremp2"": {""wfn_type"": ""DF-OREMP"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""lccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; ""olccd"": {""wfn_type"": ""DF-OLCCD"", ""orb_opt"": ""TRUE"", ""nat_orbs"": ""FALSE"",},. ""ccd"": {""wfn_type"": ""DF-CCD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",}, # changes to DF-OCCD. ""ccsd"": {""wfn_type"": ""DF-CCSD"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""ccsd(t)"": {""wfn_type"": ""DF-CCSD(T)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},. ""a-ccsd(t)"": {""wfn_type"": ""DF-CCSD(AT)"", ""orb_opt"": ""FALSE"", ""nat_orbs"": ""FALSE"",},; }. if name not in director:; raise ValidationError(f""Invalid method {name} for DFOCC energy""). # throw exception for CONV (approximately). run reference defaulting logic; set_cholesky_from(method_algorithm_type(name).now). for k, v in director[name].items():; core.set_local_option(""DFOCC"", k.upper(), v). core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; core.print_out("" Constructing Basis Sets for DFOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:125305,Testability,assert,assert,125305," # TODO Things available in ADCC, but not yet implemented here:; # Export of difference and transition density matrices for all states. properties = [prop.upper() for prop in kwargs.pop('properties')]; valid_properties = ['DIPOLE', 'OSCILLATOR_STRENGTH', 'TRANSITION_DIPOLE',; 'ROTATIONAL_STRENGTH']; unknown_properties = [prop for prop in properties if prop not in valid_properties]. if unknown_properties:; alternatives = """"; alt_method_name = p4util.text.find_approximate_string_matches(unknown_properties[0],; valid_properties, 2); if alt_method_name:; alternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gaug",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:169029,Testability,log,logic,169029,"roc_util.check_disk_df(name.upper(), optstash); else:; raise ValidationError(f""Invalid type {type_val} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). director = {; # Note ""nat_orbs"" not set defensively False for non-""fno"" calls; ""ccsd"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},; ""fno-ccsd"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": False,},. ""ccsd(t)"": { ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; ""fno-ccsd(t)"": {""nat_orbs"": True, ""dfcc"": True, ""run_cepa"": False, ""compute_triples"": True, },; }. if name not in director:; raise ValidationError(f""Invalid method {name} for FNOCC energy""). # throw exception for open-shells; if (ref := core.get_option(""SCF"", ""REFERENCE"")) != ""RHF"":; raise ValidationError(f""Invalid reference type {ref} != RHF for FNOCC energy. See Capabilities Table at {dtl}.""). # throw exception for CONV (approximately). after defaulting logic, throw exception for SCF_TYPE CONV (approximately); set_cholesky_from(method_algorithm_type(name).now); if (scf_type := core.get_global_option(""SCF_TYPE"")) not in [""CD"", ""DISK_DF""]:; raise ValidationError(f""Invalid {scf_type=} for FNOCC energy through `run_fnodfcc`. See Capabilities Table at {dtl}""). for k, v in director[name].items():; core.set_local_option(""FNOCC"", k.upper(), v). # save DF or CD ints generated by SCF for use in CC; core.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" FNOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). core.print_out("" Constructing Basis Sets for FNOCC...\n\n""); scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basis",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:57797,Usability,simpl,simplefilter,57797,"; scf_wfn.pe_state = solvent.pol_embed.CppeInterface(; molecule=scf_molecule, options=pol_embed_options,; basisset=scf_wfn.basisset(); ). e_scf = scf_wfn.compute_energy(); for obj in [core, scf_wfn]:; # set_variable(""SCF TOTAL ENERGY"") # P::e SCF; for pv in [""SCF TOTAL ENERGY"", ""CURRENT ENERGY"", ""CURRENT REFERENCE ENERGY""]:; obj.set_variable(pv, e_scf). # We always would like to print a little property information; if kwargs.get('scf_do_properties', True):; oeprop = core.OEProp(scf_wfn); oeprop.set_title(""SCF""). # Figure our properties, if empty do dipole; props = [x.upper() for x in core.get_option(""SCF"", ""SCF_PROPERTIES"")]; if ""DIPOLE"" not in props:; props.append(""DIPOLE""). proc_util.oeprop_validator(props); for x in props:; oeprop.add(x). # Populate free-atom volumes; # if we're doing MBIS; if 'MBIS_VOLUME_RATIOS' in props:; p4util.free_atom_volumes(scf_wfn). # Compute properties; oeprop.compute(); for obj in [core, scf_wfn]:; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); obj.set_variable(""CURRENT DIPOLE"", obj.variable(""SCF DIPOLE"")) # P::e SCF. # Write out MO's; if core.get_option(""SCF"", ""PRINT_MOS""):; mowriter = core.MOWriter(scf_wfn); mowriter.write(). # Write out a molden file; if core.get_option(""SCF"", ""MOLDEN_WRITE""):; filename = core.get_writer_file_prefix(scf_molecule.name()) + "".molden""; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). occa = scf_wfn.occupation_a(); occb = scf_wfn.occupation_a(). mw = core.MoldenWriter(scf_wfn); mw.write(filename, scf_wfn.Ca(), scf_wfn.Cb(), scf_wfn.epsilon_a(),; scf_wfn.epsilon_b(), scf_wfn.occupation_a(),; scf_wfn.occupation_b(), dovirt). # Write checkpoint file (orbitals and basis); Can be disabled, e.g., for findif displacements; if write_checkpoint_file and isinstance(_chkfile, str):; filename = kwargs['write_orbitals']; scf_wfn.to_file(filename); # core.set_local_option(""SCF"", ""ORBITALS_WRITE"", filename); elif write_checkpoint_file:; filename = scf_wfn.get_scratch_filename(180); scf",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:100664,Usability,simpl,simple,100664,"f_response.tdscf_excitations(wfn,; states=states,; triplets=core.get_option(""SCF"", ""TDSCF_TRIPLETS""),; tda=core.get_option(""SCF"", ""TDSCF_TDA""),; r_convergence=r_convergence,; maxiter=core.get_option(""SCF"", ""TDSCF_MAXITER""),; guess=core.get_option(""SCF"", ""TDSCF_GUESS""),; verbose=core.get_option(""SCF"", ""TDSCF_PRINT""),; coeff_cutoff=core.get_option(""SCF"", ""TDSCF_COEFF_CUTOFF""),; tdm_print=core.get_option(""SCF"", ""TDSCF_TDM_PRINT"")). # Shove variables into global space; for k, v in wfn.variables().items():; core.set_variable(k, v). return wfn. def run_tdscf_energy(name, **kwargs):. # Get a wfn in case we aren't given one; ref_wfn = kwargs.get('ref_wfn', None). if ref_wfn is None:; if name is None:; raise ValidationError(""TDSCF: No reference wave function!""); else:; ref_wfn = run_scf(name.strip('td-'), **kwargs). return run_tdscf_excitations(ref_wfn, **kwargs). def run_scf_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; SCF calculations. This is a simple alias to :py:func:`~proc.run_scf`; since SCF properties all handled through oeprop. """""". core.tstart(); optstash = proc_util.scf_set_reference_local(name). properties = kwargs.pop('properties'). # What response do we need?; response_list_vals = list(response.scf_response.property_dicts); oeprop_list_vals = core.OEProp.valid_methods. oe_properties = []; linear_response = []; unknown_property = []; for prop in properties:. prop = prop.upper(); if prop in response_list_vals:; linear_response.append(prop); elif (prop in oeprop_list_vals) or (""MULTIPOLE("" in prop):; oe_properties.append(prop); else:; unknown_property.append(prop). if ""DIPOLE"" not in oe_properties:; oe_properties.append(""DIPOLE""). # Throw if we dont know what something is; if len(unknown_property):; complete_options = oeprop_list_vals + response_list_vals; alt_method_name = p4util.text.find_approximate_string_matches(unknown_property[0],; complete_options, 2); alternatives = """"; if len(alt_method_name) > 0:; alternatives = "" Did",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:113395,Usability,clear,clear,113395,"f', 'casscf']:; ciwfn = run_detcas(name, **kwargs); else:; ciwfn = run_detci(name, **kwargs). # All property names are just CI; if 'CI' in name.upper():; name = 'CI'. states = core.get_global_option('avg_states'); nroots = core.get_global_option('num_roots'); if len(states) != nroots:; states = range(nroots). # Run OEProp; oe = core.OEProp(ciwfn); oe.set_title(name.upper()); for prop in ci_prop:; oe.add(prop.upper()). # Compute ""the"" CI density; oe.compute(); ciwfn.oeprop = oe. # If we have more than one root, compute all data; if nroots > 1:; core.print_out(""\n ===> %s properties for all CI roots <=== \n\n"" % name.upper()); for root in states:; oe.set_title(""%s ROOT %d"" % (name.upper(), root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(root, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(root, root, ""B"", True)); oe.compute(). # Transition density matrices; if (nroots > 1) and len(ci_trans):; oe.clear(); for tprop in ci_trans:; oe.add(tprop.upper()). core.print_out(""\n ===> %s properties for all CI transition density matrices <=== \n\n"" % name.upper()); for root in states[1:]:; oe.set_title(""%s ROOT %d -> ROOT %d"" % (name.upper(), 0, root)); if ciwfn.same_a_b_dens():; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); else:; oe.set_Da_mo(ciwfn.get_opdm(0, root, ""A"", True)); oe.set_Db_mo(ciwfn.get_opdm(0, root, ""B"", True)); oe.compute(). _clean_detci(); optstash.restore(); return ciwfn. def run_eom_cc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an EOM-CC calculation, namely EOM-CC2, EOM-CCSD, and EOM-CC3. """"""; optstash = p4util.OptionsState(; ['TRANSQT2', 'WFN'],; ['CCSORT', 'WFN'],; ['CCENERGY', 'WFN'],; ['CCHBAR', 'WFN'],; ['CCEOM', 'WFN']). if name == 'eom-ccsd':; core.set_local_option('TRANSQT2', 'WFN', 'EOM_CCSD'); core.set_local_option('CCSORT', 'WFN', 'EOM_CCSD'); core.set_local_option('CCENERGY', 'WFN', 'EOM_CCSD'); core.set_local_option('CCHBAR', 'WFN', 'EOM_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html:125787,Usability,simpl,simplefilter,125787,"lternatives = "" Did you mean? "" + "" "".join(alt_method_name). raise ValidationError(""ADC property: Feature '{}' is not recognized. {}""; """".format(unknown_properties[0], alternatives)). # Start timer; do_timer = kwargs.pop(""do_timer"", True); if do_timer:; core.tstart(); adc_wfn = run_adcc(name, do_timer=False, **kwargs); state = adc_wfn.adcc_state; hf = state.reference_state; mp = state.ground_state. # Formats and indention; ind = "" ""; def format_vector(label, data):; assert data.ndim == 1; return f""{label:<40s} "" + "" "".join(f""{d:12.6g}"" for d in data). if ""DIPOLE"" in properties:; lines = [""\nGround state properties""]; lines += [ind + ""Hartree-Fock (HF)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", hf.dipole_moment)]. if state.method.level > 1:; lines += [ind + ""Mller Plesset 2nd order (MP2)""]; lines += [ind + ind + format_vector(""Dipole moment (in a.u.)"", mp.dipole_moment(2))]; with warnings.catch_warnings():; warnings.simplefilter(""ignore""); for i, cart in enumerate([""X"", ""Y"", ""Z""]):; # retire components at v1.5; adc_wfn.set_variable(""MP2 dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""current dipole "" + cart, mp.dipole_moment(2)[i]); adc_wfn.set_variable(""MP2 dipole"", mp.dipole_moment(2)); adc_wfn.set_variable(""current dipole"", mp.dipole_moment(2)); lines += [""""]; core.print_out(""\n"".join(lines) + ""\n""). gauge = core.get_option(""ADC"", ""GAUGE"").lower(); if gauge == ""velocity"":; gauge_short = ""VEL""; elif gauge == ""length"":; gauge_short = ""LEN""; else:; raise ValidationError(f""Gauge {gauge} not recognised for ADC calculations.""). computed = []; methods = [name.upper(), 'ADC']; for excitation in state.excitations:; root_index = excitation.index + 1; props = {}; if any(prop in properties for prop in (""TRANSITION_DIPOLE"", ""OSCILLATOR_STRENGTH"")):; data = excitation.transition_dipole_moment; props[""Transition dipole moment (in a.u.)""] = data; data_mat = data.reshape(1, 3); for method in methods:; adc_wfn.set_variable(f""{method} ROOT 0 (",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/procrouting/proc.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:2459,Availability,error,error,2459,"st, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_string(; molstr=molinit,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); molrec = compound_molrec['qm']. elif molinit",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5113,Availability,avail,available,5113,"str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilen",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5182,Availability,avail,available,5182,"self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5864,Availability,avail,available,5864,"t_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5933,Availability,avail,available,5933," def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3}",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:37758,Availability,error,error,37758,"turn geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:40549,Availability,error,error,40549,"m']) < 5**(-(prec))] = 0. smol = qcel.molparse.to_string(; molrec,; dtype=dtype,; units=units,; atom_format=atom_format,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs]; def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43138,Availability,error,error,43138,"at(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs]; def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:58460,Availability,fault,faulty,58460,"al; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:67812,Deployability,update,updated,67812,"o_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_completion,; run_mirror=do_mirror,; verbose=verbose). compare_integers(; True, np.allclose(solution.shift, perturbation.shift, atol=6), 'shifts equiv', verbose=verbose - 1); if not do_resort:; compare_integers(; True,; np.allclose(solution.rotation.T, perturbation.rotation),; 'rotations transpose',; verbose=verbose - 1); if solution.mirror:; compare_integers(True, do_mirror, 'mirror allowed', verbose=verbose - 1). def set_fragment_pattern(self, frl, frt, frc, frm):; """"""Set fragment member data through public method analogous to psi4.core.Molecule"""""". if not (len(frl) == len(frt) == len(frc) == len(frm)):; raise ValidationError(""""""Molecule::set_fragment_pattern: fragment arguments not of same length.""""""). self.fragments = frl; self.fragment_types = frt; self.fragment_charges = frc; self.fragment_multiplicities = frm. # Attach methods to qcdb.Molecule class; from .parker import xyz2mol as _parker_xyz2mol_yo; Molecule.format_molecule_for_mol = _parker_xyz2mol_yo. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qcdb.molecule.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:1595,Energy Efficiency,charge,charge,1595,"ic License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5227,Energy Efficiency,charge,charge,5227," += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NO",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5978,Energy Efficiency,charge,charge,5978,"alse, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:7234,Energy Efficiency,charge,charge,7234," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:7262,Energy Efficiency,charge,chargem,7262," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:7326,Energy Efficiency,charge,chargem,7326," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:7350,Energy Efficiency,charge,chargem,7350," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:7435,Energy Efficiency,charge,charge,7435," instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.readlines(). # fixed-width regex ((?=[ ]*-?\d+)[ -\d]{5}); v2000 = re.compile(r'^((?=[ ]*\d+)[ \d]{3})((?=[ ]*\d+)[ \d]{3})(.*)V2000\s*$'); vend = re.compile(r'^\s*M\s+END\s*$'); NUMBER = ""((?:[-+]?\\d*\\.\\d+(?:[DdEe][-+]?\\d+)?)|(?:[-+]?\\d+\\.\\d*(?:[DdEe][-+]?\\d+)?))""; xyzM = re.compile(; r'^(?:\s*)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)' + NUMBER + r'(?:\s+)([A-Z](?:[a-z])?)(?:\s+)(.*)',; re.IGNORECASE). ## now charge and multiplicity; # $chargem = 0 ; $multm = 1 ;; #while (<MOL>) {; #if (/CHARGE/) { $chargem = <MOL> ; chop($chargem) ;}; #if (/MULTIPLICITY/) { $multm = <MOL> ; chop($multm) }; # } # end while charge and multiplicity. if not text:; raise ValidationError(""Molecule::init_with_mol2: file blank""); # Try to match header/footer; if vend.match(text[-1]):; pass; else:; raise ValidationError(""Molecule::init_with_mol2: Malformed file termination\n%s"" % (text[-1])); sysname = '_'.join(text[0].strip().split()); comment = text[2].strip(); if comment:; instance.tagline = sysname + ' ' + comment; else:; instance.tagline = sysname; #instance.tagline = text[0].strip() + ' ' + text[2].strip(); fileUnits = 'Angstrom' # defined for MOL; #instance.set_molecular_charge(int(xyz2.match(text[1]).group(1))); #instance.set_multiplicity(int(xyz2.match(text[1]).group(2))); if v2000.match(text[3]):; fileNatom = int(v2000.match(text[3]).group(1)); fileNbond = int(v2000.match(text[3]).group(2)); else:; raise ValidationError(""Molecule::init_with_mol2: Malformed fourth line\n%s"" % (text[3])); if fileNatom < 1:; raise ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:13764,Energy Efficiency,charge,charge,13764," be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True. return text, options. def format_molecule_for_psi4_xyz(self):; """"""not much examined. """"""; text = """"; if self.nallatom():. factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms; # append units and any other non-default molecule keywords; text += ""units Angstrom\n""; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); if not self.PYmove_to_com:; text += ""no_com\n""; if self.PYfix_orientation:; text += ""no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; text += ""%s%s%d %d\n"" % ("""" if Pfr == 0 else ""--\n"", ""#"" if self.fragment_types[fr] == 'Ghost'; or self.fragment_types[fr] == 'Absent' else """", self.fragment_charges[fr],; self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if self.fragment_types[fr] == 'Absent' or self.fsymbol(at) == ""X"":; pass; else:; if self.fZ(at):; text += ""%-8s"" % (self.flabel(at)); else:; text += ""%-8s"" % (""Gh("" + self.flabel(at) + "")""); [x, y, z] = self.full_atoms[at].compute(); text += '%17.12f %17.12f %17.12f\n' % \; (x * factor, y * factor, z * factor); text += ""\n"". wtext = 'molecule mol {\n'; for line in text.splitlines():; wtext += ' ' + line + '\n'; wtext += '}\n'; return wtext. def format_molecule_for_molpro(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2a",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:22626,Energy Efficiency,charge,charge,22626,"format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variabl",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:32335,Energy Efficiency,charge,charge,32335," 1.0e-6 else 0.0; ]. # Determine degeneracy of rotational constants.; degen = 0; for i in range(2):; for j in range(i + 1, 3):; if degen >= 2:; continue; rabs = math.fabs(rot_const[i] - rot_const[j]); tmp = rot_const[i] if rot_const[i] > rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:32552,Energy Efficiency,charge,charge,32552,"rot_const[j] else rot_const[j]; if rabs > ZERO:; rel = rabs / tmp; else:; rel = 0.0; if rel < tol:; degen += 1; #print ""\tDegeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:32718,Energy Efficiency,charge,charge,32718,"Degeneracy is %d\n"" % (degen). # Determine rotor type; if self.natom() == 1:; rotor_type = 'RT_ATOM'; elif rot_const[0] == 0.0:; rotor_type = 'RT_LINEAR' # 0 < IB == IC inf > B == C; elif degen == 2:; rotor_type = 'RT_SPHERICAL_TOP' # IA == IB == IC A == B == C; elif degen == 1:; if (rot_const[1] - rot_const[2]) < 1.0e-6:; rotor_type = 'RT_PROLATE_SYMMETRIC_TOP' # IA < IB == IC A > B == C; elif (rot_const[0] - rot_const[1]) < 1.0e-6:; rotor_type = 'RT_OBLATE_SYMMETRIC_TOP' # IA == IB < IC A == B > C; else:; rotor_type = 'RT_ASYMMETRIC_TOP' # IA < IB < IC A > B > C; return rotor_type. def center_of_charge(self):; """"""Computes center of charge of molecule (does not translate molecule). >>> H2OH2O.center_of_charge(); [-0.073339893272065401, 0.002959783555632145, 0.0]. """"""; ret = [0.0, 0.0, 0.0]; total_c = 0.0. for at in range(self.natom()):; c = self.charge(at); ret = add(ret, scale(self.xyz(at), c)); total_c += c. ret = scale(ret, 1.0 / total_c); return ret. def move_to_coc(self):; """"""Moves molecule to center of charge. """"""; coc = scale(self.center_of_charge(), -1.0); self.translate(coc). def rotational_symmetry_number(self):; """"""Number of unique orientations of the rigid molecule that only interchange identical atoms. Notes; -----; Source http://cccbdb.nist.gov/thermo.asp (search ""symmetry number""). """"""; pg = self.get_full_point_group(); pg = self.full_point_group_with_n(); if pg in ['ATOM', 'C1', 'Ci', 'Cs', 'C_inf_v']:; sigma = 1; elif pg == 'D_inf_h':; sigma = 2; elif pg in ['T', 'Td']:; sigma = 12; elif pg == 'Oh':; sigma = 24; elif pg == 'Ih':; sigma = 60; elif pg in ['Cn', 'Cnv', 'Cnh']:; sigma = self.full_pg_n(); elif pg in ['Dn', 'Dnd', 'Dnh']:; sigma = 2 * self.full_pg_n(); elif pg == 'Sn':; sigma = self.full_pg_n() / 2; else:; raise ValidationError(""Can't ID full symmetry group: "" + pg). return sigma. def axis_representation(self, zero=1e-8):; """"""Molecule vs. laboratory frame representation (e.g., IR or IIIL). Parameters; ----------; zero : float, optional; S",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:40636,Energy Efficiency,energy,energy-only,40636,"rmat,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs]; def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:40688,Energy Efficiency,efficient,efficient,40688,"rmat,; ghost_format=ghost_format,; width=width,; prec=prec); return smol. [docs]; def run_dftd3(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:40784,Energy Efficiency,energy,energy,40784,"ional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:40818,Energy Efficiency,energy,energy,40818,"ional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:40906,Energy Efficiency,energy,energy,40906,"ion correction via Grimme's DFTD3 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:40987,Energy Efficiency,energy,energy,40987,"--; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from `dashcoeff[dashlvl][func]` can be overwritten via; `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to override any or all values initialized by `func`.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ~numpy.ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ~numpy.ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam; jobrec = qcng.compute(resinp, 'dftd3', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43225,Energy Efficiency,energy,energy-only,43225,"]['DISPERSION CORRECTION GRADIENT']. [docs]; def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43277,Energy Efficiency,efficient,efficient,43277,"]['DISPERSION CORRECTION GRADIENT']. [docs]; def run_dftd4(self, func: Optional[str] = None, dashlvl: Optional[str] = None, dashparam: Optional[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43373,Energy Efficiency,energy,energy,43373,"l[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43407,Energy Efficiency,energy,energy,43407,"l[Dict] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute dispersion correction via Grimme's DFTD4 program. Parameters; ----------; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43488,Energy Efficiency,energy,energy,43488,"; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43562,Energy Efficiency,energy,energy,43562,"; func; Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras'][",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:45583,Energy Efficiency,energy,energy,45583,"rom psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs]; def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both ene",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:45652,Energy Efficiency,energy,energy,45652,"rom psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if derint == -1:; return (float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']),; jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs]; def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both ene",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:46277,Energy Efficiency,energy,energy-only,46277,"rogram. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_na",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:46329,Energy Efficiency,efficient,efficient,46329,"rogram. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_na",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:46444,Energy Efficiency,energy,energy,46444,"correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:46478,Energy Efficiency,energy,energy,46478,"correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3)",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:46559,Energy Efficiency,energy,energy,46559,"nt; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:46633,Energy Efficiency,energy,energy,46633,"nt; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; try:; jobrec = qcng.compute(resinp, 'mctc-gcp', raise_error=True); except qcng.exceptions.ResourceError:; jobrec = qcng.compute(resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (l",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:55315,Energy Efficiency,charge,charge,55315,"ovenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment_charges']],; molrec['fragment_multiplicities']). self.set_molecular_charge(int(molrec['molecular_charge'])); self.set_multiplicity(molrec['molecular_multiplicity']). self.fix_com(molrec['fix_com']); self.fix_orientation(molrec['fix_orientation']); if 'fix_symmetry' in molrec:; # Save the user-specified symmetry, but don't set it as the point group; # That step occurs in update_geometry, after the atoms are added; self.PYsymmetry_from_i",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:58165,Energy Efficiency,charge,charge,58165,"ays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:58706,Energy Efficiency,adapt,adapted,58706,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:62515,Energy Efficiency,charge,charge,62515," = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,; rgeom=rgeom,; cuniq=cuniq,; runiq=runiq,; do_plot=do_plot,; verbose=verbose,; atoms_map=atoms_map,; run_resorting=run_resorting,; mols_align=mols_align,; run_to_completion=run_to_completion,; run_mirror=run_mirror,; uno_cutoff=uno_cutoff). ageom, amass, aelem, aelez, auniq = solution.align_system(cgeom, cmass, celem, celez, cuniq, reverse=False); adict = qcel.molparse.from_arrays(; geom=ageom,; mass=amass,; elem=aelem,; elez=aelez,; units='Bohr',; molecular_charge=concern_mol.molecular_charge(),; molecular_multiplicity=concern_mol.multiplicity(),; fix_com=True,; fix_orientation=True); if isinstance(concern_mol, Molecule):; amol = Molecule.from_dict(adict); else:; from psi4 import core; amol = core.Molecule.fr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:37944,Integrability,wrap,wrapper,37944,"orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43633,Integrability,wrap,wraps,43633,"BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43672,Integrability,wrap,wraps,43672,"BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, ``func`` overwrites any; parameter initialized via `dashparam`.; dashlvl; Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:45951,Integrability,interface,interface,45951,"rint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs]; def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:48116,Integrability,wrap,wrapper,48116,"resinp, 'gcp', raise_error=True). jobrec = jobrec.dict(). # hack (instead of checking dertype GRAD) to collect `(nat, 3)` ndarray of gradient if present; for variable_name, qcv in jobrec['extras']['qcvars'].items():; if isinstance(qcv, (list, np.ndarray)):; jobrec['extras']['qcvars'][variable_name] = np.array(qcv).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for variable_name, qcv in jobrec['extras']['qcvars'].items():; if not isinstance(qcv, (list, np.ndarray)):; core.set_variable(variable_name, float(qcv)). if derint == -1:; return (float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']),; jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']); elif derint == 0:; return float(jobrec['extras']['qcvars']['GCP CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['GCP CORRECTION GRADIENT']. @staticmethod; def from_schema(molschema, return_dict=False, verbose=1):; """"""Construct Molecule from non-Psi4 schema. Light wrapper around :py:func:`~qcdb.Molecule.from_arrays`. Parameters; ----------; molschema : dict; Dictionary form of Molecule following known schema.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate.; verbose : int, optional; Amount of printing. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """""". molrec = qcel.molparse.from_schema(molschema, verbose=verbose). if return_dict:; return Molecule.from_dict(molrec), molrec; else:; return Molecule.from_dict(molrec). [docs]; def to_schema(self, dtype, units='Bohr'):; """"""Serializes instance into dictionary according to schema `dtype`."""""". molrec = self.to_dict(np_out=True); schmol = qcel.molparse.to_schema(molrec, dtype=dtype, units=units); return schmol. [docs]; def to_dict(self, force_c1=False, force_units=False, np_out=True):; """"""Serializes instance into Molecule dictionary."""""". self.update_geometry(); molrec = {",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:1810,Modifiability,extend,extends,1810,"See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1):; """"""Initialize Molecule object from LibmintsMolecule""""""; super(Molecule, self).__init__(). if molinit is not None or geom is not None:; if isinstance(molinit, dict):; molrec = molinit. elif isinstance(molinit, str):; compound_molrec = qcel.molparse.from_",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:4378,Modifiability,variab,variable,4378,"me,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_charge,; molecular_multiplicity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilena",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:4705,Modifiability,variab,variable,4705,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:21795,Modifiability,variab,variables,21795,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:21872,Modifiability,variab,variables,21872,"{:>17.12f}\n"""""".format(x * factor, y * factor, z * factor); # >>>; # any general finishing notation here <<<; text += '$end\n\n'; # >>>. # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); #options['QCHEM'['QCHEM_CHARGE']['value'] = self.molecular_charge(); #options['QCHEM'['QCHEM_MULTIPLICITY']['value'] = self.multiplicity(); options['QCHEM']['QCHEM_INPUT_BOHR']['value'] = False; #options['QCHEM']['QCHEM_COORDINATES']['value'] = 'CARTESIAN'; if (not self.PYmove_to_com) or self.PYfix_orientation:; options['QCHEM']['QCHEM_SYM_IGNORE']['value'] = True; #SYM_IGNORE equiv to no_reorient, no_com, symmetry c1. options['QCHEM']['QCHEM_INPUT_BOHR']['clobber'] = True; options['QCHEM']['QCHEM_SYM_IGNORE']['clobber'] = True. return text, options. def format_molecule_for_cfour_old(self):; """"""Function to print Molecule in a form readable by Cfour. This; version works as long as zmat is composed entirely of variables,; not internal values, while cartesian is all internal values,; no variables. Cutting off this line of development because,; with getting molecules after passing through libmints Molecule,; all zmats with dummies (Cfour's favorite kind) have already been; converted into cartesian. Next step, if this line was pursued; would be to shift any zmat internal values to external and any; cartesian external values to internal. """""". text = ''; text += 'auto-generated by qcdb from molecule %s\n' % (self.tagline). ## append units and any other non-default molecule keywords; #text += "" units %-s\n"" % (""Angstrom"" if self.units() == 'Angstrom' else ""Bohr""); #if not self.PYmove_to_com:; # text += "" no_com\n""; #if self.PYfix_orientation:; # text += "" no_reorient\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; #",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:23558,Modifiability,variab,variables,23558,"ent\n"". # append atoms and coordentries and fragment separators with charge and multiplicity; Pfr = 0; isZMat = False; isCart = False; for fr in range(self.nfragments()):; if self.fragment_types[fr] == 'Absent' and not self.has_zmatrix():; continue; # text += ""%s %s%d %d\n"" % (; # """" if Pfr == 0 else "" --\n"",; # ""#"" if self.fragment_types[fr] == 'Ghost' or self.fragment_types[fr] == 'Absent' else """",; # self.fragment_charges[fr], self.fragment_multiplicities[fr]); Pfr += 1; for at in range(self.fragments[fr][0], self.fragments[fr][1] + 1):; if type(self.full_atoms[at]) == ZMatrixEntry:; isZMat = True; elif type(self.full_atoms[at]) == CartesianEntry:; isCart = True; if self.fragment_types[fr] == 'Absent':; text += ""%s"" % (""X""); elif self.fZ(at) or self.fsymbol(at) == ""X"":; text += ""%s"" % (self.fsymbol(at)); else:; text += ""%s"" % (""GH"") # atom info is lost + self.fsymbol(at) + "")""); text += ""%s"" % (self.full_atoms[at].print_in_input_format_cfour()); text += ""\n"". # append any coordinate variables; if len(self.geometry_variables):; for vb, val in self.geometry_variables.items():; text += """"""%s=%.10f\n"""""" % (vb, val); text += ""\n"". # prepare molecule keywords to be set as c-side keywords; options = collections.defaultdict(lambda: collections.defaultdict(dict)); options['CFOUR']['CFOUR_CHARGE']['value'] = self.molecular_charge(); options['CFOUR']['CFOUR_MULTIPLICITY']['value'] = self.multiplicity(); options['CFOUR']['CFOUR_UNITS']['value'] = self.units(); if isZMat and not isCart:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'INTERNAL'; elif isCart and not isZMat:; options['CFOUR']['CFOUR_COORDINATES']['value'] = 'CARTESIAN'; else:; raise ValidationError(""""""Strange mix of Cartesian and ZMatrixEntries in molecule unsuitable for Cfour.""""""). return text, options. def format_molecule_for_nwchem(self):; """""". """"""; factor = 1.0 if self.PYunits == 'Angstrom' else qcel.constants.bohr2angstroms. text = """"; text += '%d %d %s\n' % (self.molecular_charge(), self.multiplicity(),",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:37927,Modifiability,variab,variables,37927,"olstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=False,; fix_orientation=False,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; missing_enabled_return='error',; tooclose=0.1,; zero_ghost_fragments=False,; nonphysical=False,; mtol=1.e-3,; verbose=1,; return_dict=False):; """"""Construct Molecule from unvalidated arrays and variables. Light wrapper around :py:func:`~qcelemental.molparse.from_arrays`; that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance. Parameters; ----------; See :py:func:`~qcelemental.molparse.from_arrays`.; return_dict : bool, optional; Additionally return Molecule dictionary intermediate. Returns; -------; mol : :py:class:`~qcdb.Molecule`; molrec : dict, optional; Dictionary representation of instance.; Only provided if `return_dict` is True. """"""; molrec = qcel.molparse.from_arrays(; geom=geom,; elea=elea,; elez=elez,; elem=elem,; mass=mass,; real=real,; elbl=elbl,; name=name,; units=units,; input_units_to_au=input_units_to_au,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; fragment_separators=fragment_separators,; fragment_charges=fragment_charges,; fragment_multiplicities=fragment_multiplicities,; molecular_charge=molecular_c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:43843,Modifiability,extend,extending,43843,"me of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in `dashcoeff` or ""alias"" or; ""formal"" to run.; dashparam; Values for the same keys as `dashcoeff[dashlvl]['default']`; used to provide custom values. Unlike run_dftd3, will not have; effect if `func` given. Must provide all parameters.; Extra parameters will error.; dertype; Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; -----; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of `func` trumping `dashparam` holds, rather than the; :py:func:`run_dftd3` behavior of `dashparam` extending or overriding `func`. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; },; 'keywords': {; 'verbose': verbose,; },; }; if dashlvl:; resinp['keywords']['level_hint'] = dashlvl; if dashparam:; resinp['keywords']['params_tweaks'] = dashparam. jobrec = qcng.compute(resinp, 'dftd4', raise_error=True); jobrec = jobrec.dict(). # hack as not checking type GRAD; for k, qca in jobrec['extras']['qcvars'].items():; if isinstance(qca, (list, np.ndarray)):; jobrec['extras']['qcvars'][k] = np.array(qca).reshape(-1, 3). if isinstance(self, Molecule):; pass; else:; from psi4 import core. for k, qca in jobrec['extras']['qcvars'].items():; if not isinstance(qca, (list, np.ndarray)):; core.set_variable(k, float(qca)). if ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:45903,Modifiability,extend,extended,45903,"rint == 0:; return float(jobrec['extras']['qcvars']['DISPERSION CORRECTION ENERGY']); elif derint == 1:; return jobrec['extras']['qcvars']['DISPERSION CORRECTION GRADIENT']. [docs]; def run_gcp(self, func: Optional[str] = None, dertype: Union[int, str, None] = None, verbose: int = 1):; """"""Compute geometrical BSSE correction via Grimme's GCP program. Function to call Grimme's GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to *self* for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, *func*. Returns energy if *dertype* is 0, gradient; if *dertype* is 1, else tuple of energy and gradient if *dertype*; unspecified. The gcp executable must be independently compiled and; found in :envvar:`PATH` or :envvar:`PSIPATH`. *self* may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters; ----------; func; Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype; Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose; Amount of printing. Unused at present. Returns; -------; energy : float; When `dertype=0`, energy [Eh].; gradient : ndarray; When `dertype=1`, (nat, 3) gradient [Eh/a0].; (energy, gradient) : tuple of float and ndarray; When `dertype=None`, both energy [Eh] and (nat, 3) gradient [Eh/a0]. """"""; import qcengine as qcng. if dertype is None:; derint, derdriver = -1, 'gradient'; else:; derint, derdriver = parse_dertype(dertype, max_derivative=1). resinp = {; 'molecule': self.to_schema(dtype=2),; 'driver': derdriver,; 'model': {; 'method': func,; 'basis': '(auto)',; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:54905,Modifiability,variab,variables,54905,"rn mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.set_geometry_variable(var[0], var[1]). else:; geom = np.array(molrec['geom']).reshape((-1, 3)); nat = geom.shape[0]; unsettled = False. for iat in range(nat):; x, y, z = geom[iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_atom(Z, x, y, z, molrec['elem'][iat], molrec['mass'][iat], Z, label, molrec['elea'][iat]); # TODO charge and 2nd elez site; # TODO real back to type Ghost?. # apparently py- and c- sides settled on a diff convention of 2nd of pair in fragments_; fragment_separators = np.array(molrec['fragment_separators'], dtype=int); fragment_separators = np.insert(fragment_separators, 0, 0); fragment_separators = np.append(fragment_separators, nat); fragments = [[fragment_separators[ifr], fr - 1] for ifr, fr in enumerate(fragment_separators[1:])]. self.set_fragment_pattern(fragments, ['Real'] * len(fragments), [int(f) for f in molrec['fragment",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:58706,Modifiability,adapt,adapted,58706,"ents is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; -----; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` `seed_atoms``.; Any existing fragmentation info/chgmult encoded in ``self`` is lost. """"""; self.update_geometry(); if self.natom() != self.nallatom():; raise ValidationError(""""""BFS not adapted for dummy atoms""""""). cgeom, cmass, celem, celez, cuniq = self.to_arrays(); frag_pattern = BFS(cgeom, celez, seed_atoms=seed_atoms, bond_threshold=bond_threshold); outputs = [frag_pattern]. if return_arrays:; fgeoms = [cgeom[fr] for fr in frag_pattern]; fmasss = [cmass[fr] for fr in frag_pattern]; felems = [celem[fr] for fr in frag_pattern]; outputs.append((fgeoms, fmasss, felems)). if return_molecules:; molrecs = [; qcel.molparse.from_arrays(; geom=cgeom[fr],; mass=cmass[fr],; elem=celem[fr],; elez=celez[fr],; units='Bohr',; fix_com=True,; fix_orientation=True) for fr in frag_pattern; ]; if isinstance(self, Molecule):; ret_mols = [Molecule.from_dict(molrec) for molrec in molrecs]; else:; from psi4 import core; ret_mols = [core.Molecule.from_dict(molrec) for molrec in molrecs]; outputs.append(ret_mols). if return_molecule:; dcontig = qcel.molparse.contiguize_from_fragment_pattern(; frag_pattern, geom=cgeom, elez=celez, elem=celem, mass=cmass); molrec = qcel.molparse.fro",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:51078,Performance,perform,performed,51078," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5062,Safety,detect,detected,5062," comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to tur",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:5813,Safety,detect,detected,5813,"dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def init_with_mol2(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from a MOl2 file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. NOTE: chg/mult NYI. >>> H2O = qcdb.Molecule.init_with_mol2('h2o.mol2'). """"""; instance = cls(); instance.lock_frame = False; instance.PYmove_to_com = not no_com; instance.PYfix_orientation = no_reorient. if contentsNotFilename:; text = xyzfilename.splitlines(); else:; try:; infile = open(xyzfilename, 'r'); except IOError:; raise ValidationError(; """"""Molecule::init_with_mol2: given filename '%s' does not exist."""""" % (xyzfilename)); if os.stat(xyzfilename).st_size == 0:; raise ValidationError(""""""Molecule::init_with_mol2: given filename '%s' is blank."""""" % (xyzfilename)); text = infile.r",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:57394,Safety,detect,detected,57394,"try termination upon no atoms; #if nat == 0:; # self.set_lock_frame(True). if not unsettled:; self.update_geometry(). [docs]; def BFS(self,; seed_atoms: List = None,; bond_threshold: float = 1.20,; return_arrays: bool = False,; return_molecules: bool = False,; return_molecule: bool = False):; """"""Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters; ----------; self : qcdb.Molecule or psi4.core.Molecule; seed_atoms; List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: `[[1, 0], [2]]`; bond_threshold; Factor beyond average of covalent radii to determine bond cutoff.; return_arrays; If `True`, also return fragments as list of arrays.; return_molecules; If True, also return fragments as list of Molecules.; return_molecule; If True, also return one big Molecule with fragmentation encoded. Returns; -------; bfs_map : list of lists; Array of atom indices (0-indexed) of detected fragments.; bfs_arrays : tuple of lists of ndarray, optional; geom, mass, elem info per-fragment.; Only provided if `return_arrays` is True.; bfs_molecules : list of qcdb.Molecule or psi4.core.Molecule, optional; List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from `self` is; not lost. Loses chgmult and ghost/dummy info from `self` and contains; default chgmult.; Only provided if `return_molecules` is True.; Returned are of same type as `self`.; bfs_molecule : qcdb.Molecule or psi4.core.Molecule, optional; Single molecule with same number of real atoms as `self` with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from `self`; keeps total charge but not total mult.; Only provided if `return_molecule` is True.; Returned is of same type as `self`. Authors; -------; Original code from Michael S. Marshall, linear-scaling algorithm from; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:1130,Security,hash,hashlib,1130,".molecule; #; # @BEGIN LICENSE; #; # Psi4: an open-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=No",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:4645,Security,access,accessing,4645,"icity=molecular_multiplicity,; comment=comment,; provenance=provenance,; connectivity=connectivity,; domain='qm',; missing_enabled_return=missing_enabled_return,; tooclose=tooclose,; zero_ghost_fragments=zero_ghost_fragments,; nonphysical=nonphysical,; mtol=mtol,; verbose=verbose). # ok, got the molrec dictionary; now build the thing; self._internal_from_dict(molrec, verbose=verbose). # The comment line; self.tagline = """". def __str__(self):; text = """""" ==> qcdb Molecule %s <==\n\n"""""" % (self.name()); text += """""" => %s <=\n\n"""""" % (self.tagline); text += self.create_psi4_string_from_molecule(); return text. def __setattr__(self, name, value):; """"""Function to overload setting attributes to allow geometry; variable assigment as if member data. """"""; if 'all_variables' in self.__dict__:; if name.upper() in self.__dict__['all_variables']:; self.set_variable(name, value); super(Molecule, self).__setattr__(name, value). def __getattr__(self, name):; """"""Function to overload accessing attribute contents to allow; retrival of geometry variable values as if member data. """"""; if 'all_variables' in self.__dict__ and name.upper() in self.__dict__['all_variables']:; return self.get_variable(name); else:; raise AttributeError. @classmethod; def init_with_xyz(cls, xyzfilename, no_com=False, no_reorient=False, contentsNotFilename=False):; """"""Pull information from an XYZ file. No fragment info detected.; Bohr/Angstrom pulled from first line if available. Charge,; multiplicity, tagline pulled from second line if available. Body; accepts atom symbol or atom charge in first column. Arguments; *no_com* and *no_reorient* can be used to turn off shift and; rotation. If *xyzfilename* is a string of the contents of an XYZ; file, rather than the name of a file, set *contentsNotFilename*; to ``True``. >>> H2O = qcdb.Molecule.init_with_xyz('h2o.xyz'). """"""; raise FeatureDeprecated(; """"""qcdb.Molecule.init_with_xyz. Replace with: qcdb.Molecule.from_string(..., dtype='xyz+')""""""). @classmethod; def in",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:35123,Security,hash,hash,35123,"; elif np.array_equal(Iidx, np.asarray([0, 1, 2])):; ar = 'IIIR'; elif np.array_equal(Iidx, np.asarray([2, 1, 0])):; ar = 'IL'; elif np.array_equal(Iidx, np.asarray([0, 2, 1])):; ar = 'IIL'; elif np.array_equal(Iidx, np.asarray([1, 0, 2])):; ar = 'IIIL'. # if inertial tensor has non-zero off-diagonals, this whole classification is iffy; if np.count_nonzero(it - np.diag(np.diagonal(it))):; ar = '~' + ar. return ar. [docs]; def to_arrays(self, dummy: bool = False, ghost_as_dummy: bool = False) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:; """"""Exports coordinate info into NumPy arrays. Parameters; ----------; dummy; Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy; Whether or not to treat ghost atoms as dummies. Returns; -------; geom, mass, elem, elez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geome",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:35942,Security,hash,hashlib,35942,"ez, uniq : numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray; (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost. Usage; -----; geom, mass, elem, elez, uniq = molinstance.to_arrays(). """"""; self.update_geometry(). if dummy:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:36434,Security,hash,hashlib,36434,"l qcdb.Molecule; geom = self.full_geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.full_geometry()); mass = np.asarray(; [(0. if (ghost_as_dummy and self.fZ(at) == 0) else self.fmass(at)) for at in range(self.nallatom())]); elem = np.asarray(; ['X' if (ghost_as_dummy and self.fZ(at) == 0) else self.fsymbol(at) for at in range(self.nallatom())]); elez = np.asarray(; [0 if (ghost_as_dummy and self.fZ(at) == 0) else self.fZ(at) for at in range(self.nallatom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest(); for at in range(self.nallatom()); ]); else:; if isinstance(self, Molecule):; # normal qcdb.Molecule; geom = self.geometry(np_out=True); else:; # psi4.core.Molecule; geom = np.array(self.geometry()); mass = np.asarray([self.mass(at) for at in range(self.natom())]); elem = np.asarray([self.symbol(at) for at in range(self.natom())]); elez = np.asarray([self.Z(at) for at in range(self.natom())]); uniq = np.asarray([; hashlib.sha1((str(elem[at]) + str(mass[at])).encode('utf-8')).hexdigest() for at in range(self.natom()); ]). return geom, mass, elem, elez, uniq. @staticmethod; def from_string(molstr,; dtype=None,; name=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; return_dict=False,; enable_qm=True,; enable_efp=True,; missing_enabled_return_qm='none',; missing_enabled_return_efp='none',; verbose=1):; molrec = qcel.molparse.from_string(; molstr=molstr,; dtype=dtype,; name=name,; fix_com=fix_com,; fix_orientation=fix_orientation,; fix_symmetry=fix_symmetry,; return_processed=False,; enable_qm=enable_qm,; enable_efp=enable_efp,; missing_enabled_return_qm=missing_enabled_return_qm,; missing_enabled_return_efp=missing_enabled_return_efp,; verbose=verbose); if return_dict:; return Molecule.from_dict(molrec['qm']), molrec; else:; return Molecule.from_dict(molrec['qm']). @staticmethod; def from_arrays(geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:51148,Security,expose,exposed,51148," # moldict['zmat'] = self.zmat; # TODO zmat, geometry_variables. nat = self.natom(); geom = np.array(self.geometry()) # [a0]; if molrec['units'] == 'Angstrom':; geom *= qcel.constants.bohr2angstroms #self.input_units_to_au(); molrec['geom'] = geom.reshape((-1)). molrec['elea'] = np.array([self.mass_number(at) for at in range(nat)]); molrec['elez'] = np.array([qcel.periodictable.to_Z(self.symbol(at)) for at in range(nat)]); molrec['elem'] = np.array([self.symbol(at).capitalize() for at in range(nat)]); molrec['mass'] = np.array([self.mass(at) for at in range(nat)]); molrec['real'] = np.array([bool(self.Z(at)) for at in range(nat)]); molrec['elbl'] = np.array([self.label(at)[len(self.symbol(at)):].lower() for at in range(nat)]). fragments = [x[:] for x in self.get_fragments()]; fragment_charges = [float(f) for f in self.get_fragment_charges()]; fragment_multiplicities = [m for m in self.get_fragment_multiplicities()]. # do trimming not performed in Molecule class b/c fragment_* member data never directly exposed; for ifr, fr in reversed(list(enumerate(self.get_fragment_types()))):; if fr == 'Ghost':; fragment_charges[ifr] = 0.; fragment_multiplicities[ifr] = 1; elif fr == 'Absent':; del fragment_charges[ifr]; del fragment_multiplicities[ifr]; # readjust atom indices for subsequent fragments; renum = fragments[ifr][0]; for iffr, ffr in enumerate(fragments):; if iffr <= ifr:; continue; lenfr = ffr[1] - ffr[0]; fragments[iffr] = [renum, renum + lenfr]; renum += lenfr; del fragments[ifr]. molrec['fragment_separators'] = [int(f[0]) for f in fragments[1:]] # np.int --> int; molrec['fragment_charges'] = fragment_charges; molrec['fragment_multiplicities'] = fragment_multiplicities. molrec['molecular_charge'] = float(self.molecular_charge()); molrec['molecular_multiplicity'] = self.multiplicity(). # * mass number (elea) untouched by qcdb.Molecule/psi4.core.Molecule and; # likely to be array of -1s, so let from_arrays fill in the values and; # (1) don't complain about the diffe",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:53946,Security,validat,validated,53946,"t_molecular_change` or `set_multiplicity`. Such alterations are an expert feature. Specifying in the original molecule string is preferred. Nonphysical masses may also trigger the warning.""""""; ); molrec['fragment_charges'] = [None] * len(fragments); molrec['fragment_multiplicities'] = [None] * len(fragments); validated_molrec = qcel.molparse.from_arrays(speclabel=False, nonphysical=True, verbose=0, domain='qm', **molrec); forgive.append('fragment_charges'); forgive.append('fragment_multiplicities'); compare_molrecs(validated_molrec, molrec, 'to_dict', atol=1.e-6, forgive=forgive, verbose=0). # from_arrays overwrites provenance; validated_molrec['provenance'] = copy.deepcopy(molrec['provenance']). if not np_out:; validated_molrec = qcel.util.unnp(validated_molrec). return validated_molrec. @classmethod; def from_dict(cls, molrec, verbose=1):. mol = cls(); mol._internal_from_dict(molrec=molrec, verbose=verbose); return mol. def _internal_from_dict(self, molrec, verbose=1):; """"""Constructs instance from fully validated and defaulted dictionary `molrec`."""""". # Compromises for qcdb.Molecule; # * molecular_charge is int, not float; # * fragment_charges are int, not float. self.lock_frame = False. if 'name' in molrec:; self.set_name(molrec['name']). if 'comment' in molrec:; self.set_comment(molrec['comment']). self.set_provenance(copy.deepcopy(molrec['provenance'])). if 'connectivity' in molrec:; self.set_connectivity(copy.deepcopy(molrec['connectivity'])). self.set_units(molrec['units']); if 'input_units_to_au' in molrec:; self.set_input_units_to_au(molrec['input_units_to_au']). if 'geom_unsettled' in molrec:; nat = len(molrec['geom_unsettled']); unsettled = True. for iat in range(nat):; entry = molrec['geom_unsettled'][iat]; label = molrec['elem'][iat] + molrec['elbl'][iat]; Z = molrec['elez'][iat] * int(molrec['real'][iat]); self.add_unsettled_atom(Z, entry, molrec['elem'][iat], molrec['mass'][iat], Z, label,; molrec['elea'][iat]); for var in molrec['variables']:; self.s",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:1347,Testability,test,testing,1347,"corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import os; import hashlib; import collections; from typing import Dict, List, Optional, Tuple, Union. import numpy as np. import qcelemental as qcel. import psi4; from .util import parse_dertype; from .libmintsmolecule import *; from .testing import compare_values, compare_integers, compare_molrecs; from .bfs import BFS. qcdbmol = ""psi4.driver.qcdb.molecule.Molecule"". [docs]; class Molecule(LibmintsMolecule):; """"""Class to store the elements, coordinates, fragmentation pattern,; charge, multiplicity of a molecule. Largely replicates psi4's libmints; Molecule class, developed by Justin M. Turney and Andy M. Simmonett; with incremental improvements by other psi4 developers. Major. This class extends `qcdb.LibmintsMolecule` and occasionally; `psi4.core.Molecule` itself. """""". def __init__(self,; molinit=None,; dtype=None,; geom=None,; elea=None,; elez=None,; elem=None,; mass=None,; real=None,; elbl=None,; name=None,; units='Angstrom',; input_units_to_au=None,; fix_com=None,; fix_orientation=None,; fix_symmetry=None,; fragment_separators=None,; fragment_charges=None,; fragment_multiplicities=None,; molecular_charge=None,; molecular_multiplicity=None,; comment=None,; provenance=None,; connectivity=None,; enable_qm=True,; enable_efp=True,; missing_enabled_ret",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:61824,Testability,test,test,61824,"; aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`psi4.driver.qcdb.Molecule` or; :py:class:`psi4.core.Molecule`. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters; ----------; concern_mol; Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with `ref_mol`.; ref_mol; Molecule to match.; atoms_map; Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc.; If true, specifying `True` can save much time.; mols_align; Whether `ref_mol` and `concern_mol` have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If `True`, procedure is truncated when RMSD condition met, saving time.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; Run reorderings to completion (past RMSD = 0) even if unnecessary because; `mols_align=True`. Used to test worst-case timings.; run_resorting; Run the resorting machinery even if unnecessary because `atoms_map=True`.; uno_cutoff; TODO; run_mirror; Run alternate geometries potentially allowing best match to `ref_mol`; from mirror image of `concern_mol`. Only run if system confirmed to; be nonsuperimposable upon mirror reflection. Returns; -------; float, tuple, qcdb.Molecule or psi4.core.Molecule; First item is RMSD [A] between `ref_mol` and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from `concern_mol` and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by `concern_mol` type. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); cgeom, cmass, celem, celez, cuniq = concern_mol.to_arrays(). rmsd, solution = qcel.molutil.B787(; cgeom=cgeom,",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html:65665,Testability,test,test,65665,"_shift; Whether to generate a random atom shift on interval [-3, 3) in each; dimension (`True`) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate; Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort; Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`).; To specify shuffle, supply a nat-element list of indices.; deflection; If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror; Whether to construct the mirror image structure by inverting y-axis.; do_plot; Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion; By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, `True` turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting; Even if atoms not shuffled, test the resorting machinery.; verbose; Print level. Returns; -------; None. """"""; rgeom, rmass, relem, relez, runiq = ref_mol.to_arrays(); nat = rgeom.shape[0]. perturbation = qcel.molutil.compute_scramble(; rgeom.shape[0],; do_shift=do_shift,; do_rotate=do_rotate,; deflection=deflection,; do_resort=do_resort,; do_mirror=do_mirror); cgeom, cmass, celem, celez, cuniq = perturbation.align_system(rgeom, rmass, relem, relez, runiq, reverse=True); cmol = Molecule.from_arrays(; geom=cgeom,; mass=cmass,; elem=celem,; elez=celez,; units='Bohr',; molecular_charge=ref_mol.molecular_charge(),; molecular_multiplicity=ref_mol.multiplicity(),; fix_com=True,; fix_orientation=True). rmsd = np.linalg.norm(cgeom - rgeom) * qcel.constants.bohr2angstroms / np.sqrt(nat); if verbose >= 1:; print('Start RMSD = {:8.4f} [A]'.format(rmsd)). rmsd, solution, amol = cmol.B787(; ref_mol,; do_plot=do_plot,; atoms_map=(not do_resort),; run_resorting=run_resorting,; mols_align=True,; run_to_completion=run_to_c",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/molecule.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:1382,Availability,toler,tolerance,1382," file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolera",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:1893,Availability,toler,tolerance,1893,"OR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:2100,Availability,toler,tolerance,2100,"import collections; import itertools; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:2140,Availability,error,error,2140,"s; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:2282,Availability,failure,failure,2282,"emental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; che",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:2517,Availability,toler,tolerance,2517,"ga_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:10933,Availability,toler,tolerance,10933,"s in diff (xyz) arrangements); idx_sort_wi_degen = np.lexsort(; (idx_max_elem_each_normco[istart:istart + degree], max_elem_each_normco[istart:istart + degree])); idx_vib_reordering[istart:istart + degree] = np.arange(istart, istart + degree)[idx_sort_wi_degen]. arr2 = arr[:, idx_vib_reordering]. reorderings = ['{}-->{}'.format(i, v) for i, v in enumerate(idx_vib_reordering) if (i != v)]; if reorderings and verbose >= 2:; print('Degenerate modes reordered:', ', '.join(reorderings)). return arr2. def _phase_cols_to_max_element(arr, tol=1.e-2, verbose=1):; """"""Returns copy of 2D `arr` scaled such that, within cols, max(fabs); element is positive. If max(fabs) is pos/neg pair, scales so first; element (within `tol`) is positive. """"""; arr2 = np.copy(arr). rephasing = []; for v in range(arr.shape[1]):; vextreme = 0.0; iextreme = None. # find most extreme value; for varr in arr[:, v]:; vextreme = max(np.absolute(varr), vextreme). # find the first index whose fabs equals that value, w/i tolerance; for iarr, varr in enumerate(arr[:, v]):; if (vextreme - np.absolute(varr)) < tol:; iextreme = iarr; break. sign = np.sign(arr[iextreme, v]); if sign == -1.:; rephasing.append(str(v)); arr2[:, v] *= sign. if rephasing and verbose >= 2:; print('Negative modes rephased:', ', '.join(rephasing)). return arr2. [docs]; def harmonic_analysis(hess: np.ndarray, geom: np.ndarray, mass: np.ndarray, basisset: psi4.core.BasisSet, irrep_labels: List[str], dipder: np.ndarray = None, project_trans: bool = True, project_rot: bool = True) -> Tuple[Dict[str, Datum], str]:; """"""Extract frequencies, normal modes and other properties from electronic Hessian. Like so much other Psi4 goodness, originally by @andysim. Parameters; ----------; hess; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; geom; (nat, 3) geometry [a0] at which Hessian computed.; mass; (nat,) atomic masses [u].; basisset; Basis set object (can be dummy, e.g., STO-3G) for SALCs.; irrep_labels; Irreducible represent",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:19007,Availability,down,downhill,19007,"(qcel.constants.na * qcel.constants.hartree2J * 1.0e19) /; (2 * np.pi * qcel.constants.c * qcel.constants.bohr2angstroms)); pre_frequency_cm_1 = np.lib.scimath.sqrt(pre_force_constant_au) * uconv_cm_1. pre_lowfreq = np.where(np.real(pre_frequency_cm_1) < 100.0)[0]; pre_lowfreq = np.append(pre_lowfreq, np.arange(nrt_expected)) # catch at least nrt modes; for lf in set(pre_lowfreq):; vlf = pre_frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' pre-proj low-frequency mode: {:9.4f}i [cm^-1]'.format(vlf.real, vlf.imag)); else:; text.append(' pre-proj low-frequency mode: {:9.4f} [cm^-1]'.format(vlf.real, '')); text.append(' pre-proj all modes:' + str(_format_omega(pre_frequency_cm_1, 4))). # project & solve; mwhess_proj = np.dot(P.T, mwhess).dot(P); text.append(mat_symm_info(mwhess_proj, lbl='projected mass-weighted Hessian') + f' ({nrt})'). #print('projhess = ', np.array_repr(mwhess_proj)); force_constant_au, qL = np.linalg.eigh(mwhess_proj). # expected order for vibrations is steepest downhill to steepest uphill; idx = np.argsort(force_constant_au); force_constant_au = force_constant_au[idx]; qL = qL[:, idx]; qL = _phase_cols_to_max_element(qL); vibinfo['q'] = Datum('normal mode', 'a0 u^1/2', qL, comment='normalized mass-weighted'). # frequency, LAB II.17; frequency_cm_1 = np.lib.scimath.sqrt(force_constant_au) * uconv_cm_1; vibinfo['omega'] = Datum('frequency', 'cm^-1', frequency_cm_1). # degeneracies; ufreq, uinv, ucts = np.unique(np.around(frequency_cm_1, 1), return_inverse=True, return_counts=True); vibinfo['degeneracy'] = Datum('degeneracy', '', ucts[uinv]). # look among the symmetry subspaces h for one to which the normco; # of vib does *not* add an extra dof to the vector space; active = []; irrep_classification = []; for idx, vib in enumerate(frequency_cm_1):. if vec_in_space(qL[:, idx], TRspace, 1.0e-4):; active.append('TR'); irrep_classification.append(None). else:; active.append('V'). for h in Uh.keys():; if vec_in_space(qL[:, idx], Uh[h], 1.0e-4):; ir",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:42797,Deployability,update,updated,42797,"andom.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps; num = np.sum(s > tol, dtype=int); Q = u[:, :num]; return Q. TRindep = orth(TRspace.T); TRindep = TRindep.T. if verbose >= 2:; print(TRindep.shape, '<--', TRspace.shape); print(np.linalg.norm(TRindep, axis=1)); print('-' * 80). return TRindep. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  . ; 1.8.2; . PSI4. Module code; psi4.driver.qcdb.vib.  Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:04AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:14221,Energy Efficiency,reduce,reduced,14221," +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | x | normal mode, normalized un-mass-weighted | a0 | ndarray(ndof, ndof) float |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | degeneracy | degree of degeneracy | | ndarray(ndof) int |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | TRV | translation/rotation/vibration | | ndarray(ndof) str 'TR' or 'V' or '-' for partial |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | gamma | irreducible representation | | ndarray(ndof) str irrep or None if unclassifiable |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | mu | reduced mass | u | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | k | force constant | mDyne/A | ndarray(ndof) float (+/-) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | DQ0 | RMS deviation v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(n",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:15647,Energy Efficiency,energy,energy,15647," | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Qtp0 | Turning point v=0 | a0 u^1/2 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | Xtp0 | Turning point v=0 | a0 | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | theta_vib | char temp | K | ndarray(ndof) float (+/0) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+; | IR_intensity | infrared intensity | km/mol | ndarray(ndof) float (+/+) |; +---------------+--------------------------------------------+-----------+------------------------------------------------------+. Examples; --------; >>> # displacement of first atom in highest energy mode; >>> vibinfo['x'].data[:, -1].reshape(nat, 3)[0]. >>> # remove translations & rotations; >>> vibonly = filter_nonvib(vibinfo). """"""; if (mass.shape[0] == geom.shape[0] == (hess.shape[0] // 3) == (hess.shape[1] // 3)) and (geom.shape[1] == 3):; pass; else:; raise ValidationError(; f""""""Dimension mismatch among mass ({mass.shape}), geometry ({geom.shape}), and Hessian ({hess.shape})""""""). def mat_symm_info(a, atol=1e-14, lbl='array', stol=None):; symm = np.allclose(a, a.T, atol=atol); herm = np.allclose(a, a.conj().T, atol=atol); ivrt = a.shape[0] - np.linalg.matrix_rank(a, tol=stol); return """""" {:32} Symmetric? {} Hermitian? {} Lin Dep Dim? {:2}"""""".format(lbl + ':', symm, herm, ivrt). def vec_in_space(vec, space, tol=1.0e-4):; merged = np.vstack((space, vec)); u, s, v = np.linalg.svd(merged); return (s[-1] < tol). vibinfo = {}; text = []. nat = len(mass); text.append(""""""\n\n ==> Harmonic Vibrational Analysis <==\n""""""). if nat == 1:; nrt_expected = 3; elif np.li",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:21441,Energy Efficiency,reduce,reduced,21441,"cted)) # catch at least nrt modes; for lf in set(lowfreq):; vlf = frequency_cm_1[lf]; if vlf.imag > vlf.real:; text.append(' post-proj low-frequency mode: {:9.4f}i [cm^-1] ({})'.format(vlf.imag, active[lf])); else:; text.append(' post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intens",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:21680,Energy Efficiency,reduce,reduced,21680,"post-proj low-frequency mode: {:9.4f} [cm^-1] ({})'.format(vlf.real, active[lf])); text.append(' post-proj all modes:' + str(_format_omega(frequency_cm_1, 4)) + '\n'); if project_trans and not project_rot:; text.append(f' Note that ""Vibration""s include {nrt_expected - 3} un-projected rotation-like modes.'); elif not project_trans and not project_rot:; text.append(; f' Note that ""Vibration""s include {nrt_expected} un-projected rotation-like and translation-like modes.'). # general conversion factors, LAB II.11; uconv_K = (qcel.constants.h * qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infr",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:22216,Energy Efficiency,meter,meter,22216,"qcel.constants.na * 1.0e21) / (8 * np.pi * np.pi * qcel.constants.c); uconv_S = np.sqrt((qcel.constants.c * (2 * np.pi * qcel.constants.bohr2angstroms)**2) /; (qcel.constants.h * qcel.constants.na * 1.0e21)). # normco & reduced mass, LAB II.14 & II.15; wL = np.einsum('i,ij->ij', sqrtmmminv, qL); vibinfo['w'] = Datum('normal mode', 'a0', wL, comment='un-mass-weighted'). reduced_mass_u = np.divide(1.0, np.linalg.norm(wL, axis=0)**2); vibinfo['mu'] = Datum('reduced mass', 'u', reduced_mass_u). xL = np.sqrt(reduced_mass_u) * wL; vibinfo['x'] = Datum('normal mode', 'a0', xL, comment='normalized un-mass-weighted'). # IR intensities, CCQC Proj. Eqns. 15-16; uconv_kmmol = (qcel.constants.get(""Avogadro constant"") * np.pi * 1.e-3 * qcel.constants.get(""electron mass in u"") *; qcel.constants.get(""fine-structure constant"")**2 * qcel.constants.get(""atomic unit of length"") / 3); uconv_D2A2u = (qcel.constants.get('atomic unit of electric dipole mom.') * 1.e11 /; qcel.constants.get('hertz-inverse meter relationship') /; qcel.constants.get('atomic unit of length'))**2; if not (dipder is None or np.array(dipder).size == 0):; qDD = dipder.dot(wL); ir_intensity = np.zeros(qDD.shape[1]); for i in range(qDD.shape[1]):; ir_intensity[i] = qDD[:, i].dot(qDD[:, i]); # working but not needed; #vibinfo['IR_intensity'] = Datum('infrared intensity', 'Eh a0/u', ir_intensity); #ir_intensity_D2A2u = ir_intensity * uconv_D2A2u; #vibinfo['IR_intensity'] = Datum('infrared intensity', '(D/AA)^2/u', ir_intens_D2A2u); ir_intensity_kmmol = ir_intensity * uconv_kmmol; vibinfo['IR_intensity'] = Datum('infrared intensity', 'km/mol', ir_intensity_kmmol). # force constants, LAB II.16 (real compensates for earlier sqrt); uconv_mdyne_a = (0.1 * (2 * np.pi * qcel.constants.c)**2) / qcel.constants.na; force_constant_mdyne_a = reduced_mass_u * (frequency_cm_1 * frequency_cm_1).real * uconv_mdyne_a; vibinfo['k'] = Datum('force constant', 'mDyne/A', force_constant_mdyne_a). force_constant_cm_1_bb = reduced_mass_u * (f",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:25372,Energy Efficiency,reduce,reduced,25372,".c / qcel.constants.kb; vib_temperature_K = frequency_cm_1.real * uconv_K; vibinfo['theta_vib'] = Datum('char temp', 'K', vib_temperature_K). return vibinfo, '\n'.join(text). def _br(string):; return '[' + string + ']'. def _format_omega(omega, decimals):; """"""Return complex frequencies in `omega` into strings showing only real or imag (""i""-labeled); to `decimals` precision. """"""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(""""""{:.{prec}f}i"""""".format(fr.imag, prec=decimals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]; def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requeste",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:25852,Energy Efficiency,reduce,reduced,25852,"mals)); else:; freqs.append(""""""{:.{prec}f}"""""".format(fr.real, prec=decimals)); return np.array(freqs). [docs]; def print_vibs(vibinfo: Dict[str, Datum], atom_lbl: List[str] = None, *, normco: str = 'x', shortlong: bool = True, groupby: int = None, prec: int = 4, ncprec: int = None) -> str:; """"""Pretty printer for vibrational analysis. Parameters; ----------; vibinfo; Results of a Hessian solution.; atom_lbl; Atomic symbols for printing. If None, integers used.; normco; {'q', 'w', 'x'}; Which normal coordinate definition to print (reduced mass, etc. unaffected by this parameter). Must be. * `q` [a0 u^1/2], the mass-weighted normalized eigenvectors of the Hessian,; * `w` [a0], the un-mass-weighted (Cartesian) of q, or; * `x` [a0], the normalized w.; shortlong; Whether normal coordinates should be in (nat, 3) `True` or (nat * 3, 1) `False` format.; groupby; How many normal coordinates per row. Defaults to 3/6 for shortlong=T/F. Value of `-1` uses one row.; prec; Number of decimal places for frequencies, reduced masses, etc.; ncprec; Number of decimal places for normal coordinates. Defaults to 2 for shortlong=short and 4 for shortlong=long. Returns; -------; str; String suitable for printing. """""". def grouper(iterable, n, fillvalue=None):; ""Collect data into fixed-length chunks or blocks""; # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx""; args = [iter(iterable)] * n; return itertools.zip_longest(*args, fillvalue=fillvalue). if normco not in ['q', 'w', 'x']:; raise ValidationError(""""""Requested normal coordinates not among allowed q/w/x: """""" + normco). nat = int(len(vibinfo['q'].data[:, 0]) / 3); if atom_lbl is None:; atom_lbl = [''] * nat. active = [idx for idx, trv in enumerate(vibinfo['TRV'].data) if trv == 'V']. presp = 2; colsp = 2; if shortlong:; groupby = groupby if groupby else 3; ncprec = ncprec if ncprec else 2; width = (ncprec + 4) * 3; prewidth = 24; else:; groupby = groupby if groupby else 6; ncprec = ncprec if ncprec else 4; width = ncprec + 8; prewidth = 24; if",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:30912,Energy Efficiency,energy,energy,30912,"t],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]; def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datu",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:33647,Energy Efficiency,reduce,reduced,33647,"const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['ele",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:37170,Energy Efficiency,energy,energy,37170,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:37220,Energy Efficiency,energy,energy,37220,"e2kcalmol, qcel.constants.hartree2kJmol, 1.]). # TODO rot_const, rotor_type; text = ''; text += """"""\n ==> Thermochemistry Components <=="""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:37307,Energy Efficiency,energy,energy,37307,""""". text += """"""\n\n Entropy, S""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' S', *sm[('S', term)] * uconv); if term == 'elec':; text += """""" (multiplicity = {})"""""".format(multiplicity); elif term == 'trans':; text += """""" (mol. weight = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); tex",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:37608,Energy Efficiency,energy,energy,37608,"t = {:.4f} [u], P = {:.2f} [Pa])"""""".format(molecular_mass, P); elif term == 'rot':; text += """""" (symmetry no. = {})"""""".format(sigma). text += """"""\n\n Constant volume heat capacity, Cv""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]; def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibratio",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:37857,Energy Efficiency,energy,energy,37857,"format(terms[term] + ' Cv', *sm[('Cv', term)] * uconv). text += """"""\n\n Constant pressure heat capacity, Cp""""""; for term in terms:; text += format_S_Cv_Cp.format(terms[term] + ' Cp', *sm[('Cp', term)] * uconv). del terms['tot']; terms['corr'] = 'Correction'. text += """"""\n\n ==> Thermochemistry Energy Analysis <=="""""". text += """"""\n\n Raw electronic energy, E0""""""; text += """"""\n Total E0, Electronic energy at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]; def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['T",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:38206,Energy Efficiency,energy,energy,38206,"at well bottom at 0 [K] {:15.8f} [Eh]"""""".format(E0). text += """"""\n\n Zero-point energy, ZPE_vib = Sum_i nu_i / 2""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' ZPE', *sm[('ZPE', term)] * uconv); if term in ['vib', 'corr']:; text += """""" {:15.3f} [cm^-1]"""""".format(sm[('ZPE', term)] * qcel.constants.hartree2wavenumbers); text += """"""\n Total ZPE, Electronic energy at 0 [K] {:15.8f} [Eh]"""""".format(; sm[('ZPE', 'tot')]). text += """"""\n\n Thermal Energy, E (includes ZPE)""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' E', *sm[('E', term)] * uconv); text += """"""\n Total E, Electronic energy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('E', 'tot')]). text += """"""\n\n Enthalpy, H_trans = E_trans + k_B * T""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' H', *sm[('H', term)] * uconv); text += """"""\n Total H, Enthalpy at {:7.2f} [K] {:15.8f} [Eh]"""""".format(; T, sm[('H', 'tot')]). text += """"""\n\n Gibbs free energy, G = H - T * S""""""; for term in terms:; text += format_ZPE_E_H_G.format(terms[term] + ' G', *sm[('G', term)] * uconv); text += """"""\n Total G, Free enthalpy at {:7.2f} [K] {:15.8f} [Eh]\n"""""".format(; T, sm[('G', 'tot')]). return therminfo, text. [docs]; def filter_nonvib(vibinfo: Dict[str, Datum], remove: List[int] = None) -> Dict[str, Datum]:; """"""From a dictionary of vibration Datum, remove normal coordinates. Parameters; ----------; vibinfo; Results of Hessian analysis.; remove; 0-indexed indices of normal modes to remove from `vibinfo`. If; None, non-vibrations (R, T, or TR as labeled in `vibinfo['TRV']`); will be removed. Returns; -------; dict; Copy of input `vibinfo` with the specified modes removed from all; dictionary entries. Examples; --------; >>> # after a harmonic analysis, remove first translations and rotations and then all non-A1 vibs; >>> allnormco = harmonic_analysis(...); >>> allvibs = filter_nonvib(allnormco); >>> a1vibs = filter_nonvib(allvibs, remove=[i for i, d in enumerate(allvi",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:2146,Integrability,message,messages,2146,"s; import math; import sys; from typing import Dict, List, Tuple, Union. import numpy as np; import qcelemental as qcel; from qcelemental import Datum. import psi4 # for typing. from .libmintsmolecule import compute_atom_map. LINEAR_A_TOL = 1.0E-2 # tolerance (roughly max dev) for TR space. __all__ = [""compare_vibinfos"", ""filter_nonvib"", ""filter_omega_to_real"", ""harmonic_analysis"", ""hessian_symmetrize"", ""print_molden_vibs"", ""print_vibs"", ""thermo""]. [docs]; def compare_vibinfos(expected: Dict[str, qcel.Datum], computed: Dict[str, Datum], tol: float, label: str, verbose: int = 1, forgive: List = None, required: List = None, toldict: Dict[str, float] = None) -> bool:; """"""Returns True if two dictionaries of vibration Datum objects are equivalent within a tolerance. Parameters; ----------; expected; Reference value against which `computed` is compared.; computed; Input value to compare against `expected`. Must contain all fields of `expected`.; tol; Absolute tolerance.; label; Label for passed and error messages.; verbose; Control printing.; forgive; Keys in top level which may change between `expected` and `computed` without triggering failure.; required; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:40143,Integrability,depend,dependencies,40143,"emove=[i for i, d in enumerate(allvibs['gamma'].data) if d != 'A1']). """"""; work = {}; if remove is None:; remove = [idx for idx, dat in enumerate(vibinfo['TRV'].data) if dat != 'V']; for asp, oasp in vibinfo.items():; if asp in ['q', 'w', 'x']:; axis = 1; else:; axis = 0; work[asp] = Datum(oasp.label, oasp.units, np.delete(oasp.data, remove, axis=axis), comment=oasp.comment, numeric=False). return work. [docs]; def filter_omega_to_real(omega: np.ndarray) -> np.ndarray:; """"""Returns ndarray (float) of `omega` (complex) where imaginary entries are converted to negative reals.""""""; freqs = []; for fr in omega:; if fr.imag > fr.real:; freqs.append(-1 * fr.imag); else:; freqs.append(fr.real); return np.asarray(freqs). def _get_TR_space(m: np.ndarray, geom: np.ndarray, space: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); as",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:3289,Modifiability,extend,extend,3289,"red; Keys in top level which must be present in `computed`. (""omega"" recc. for vibs.); toldict; Tolerances for specific keys. Returns; -------; allclose : bool; Returns True if `expected` and `computed` are equal within tolerance; False otherwise. """"""; np.set_printoptions(formatter={'float': '{: 0.4f}'.format}). def _success(label):; """"""Function to print a '*label*...PASSED' line to screen.; Used by :py:func:`util.compare_values` family when functions pass.; """"""; msg = f'\t{label:.<66}PASSED'; print(msg); sys.stdout.flush(). def print_stuff(asp, same, ref, val, space=''):; if verbose >= 1:; print(asp, ':', same); if (verbose >= 2) or (not same and verbose >= 1):; print('\texp:', space, ref); print('\tobs:', space, val); if verbose >= 1:; if not same:; try:; print('\tdif:', space, val - ref); except TypeError:; print('\tdif: Different, inspect arrays'). if forgive is None:; forgive = []. summsame = []; if required is None:; checkkeys = []; else:; checkkeys = required; checkkeys.extend(expected.keys()). svdtol = 1.e-6 if toldict is None else toldict.get(""svd"", 1.e-6); for asp in checkkeys:; if asp not in computed and asp in forgive:; continue. if toldict is not None and asp in toldict:; ktol = toldict[asp]; else:; ktol = tol. if asp in 'qwx':; ccnc = _phase_cols_to_max_element(computed[asp].data); eenc = _phase_cols_to_max_element(expected[asp].data); ccnc = _check_degen_modes(ccnc, computed['omega'].data); eenc = _check_degen_modes(eenc, expected['omega'].data); same = np.allclose(eenc, ccnc, atol=ktol); print_stuff(asp=asp, same=same, ref=eenc, val=ccnc, space='\n'); same = _check_rank_degen_modes(ccnc, computed[""omega""].data, eenc, difftol=ktol, svdtol=svdtol). elif asp in ['gamma', 'TRV']:; same = all([computed[asp].data[idx] == val for idx, val in enumerate(expected[asp].data)]); print_stuff(asp=asp, same=same, ref=expected[asp].data, val=computed[asp].data). elif isinstance(expected[asp].data, float):; same = abs(expected[asp].data - computed[asp].data) < ktol; ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:5719,Testability,test,tested,5719,"metrize(hess: np.ndarray, mol: psi4.core.Molecule) -> np.ndarray:; """"""Apply Abelian symmetry of `mol` to Hessian `hess`. Parameters; ----------; hess; (3 * nat, 3 * nat) Hessian array perhaps with jitter unbecoming a symmetric molecule.; mol; Molecule at which Hessian computed. Returns; -------; numpy.ndarray; (3 * nat, 3 * nat) symmetrized Hessian array. """"""; ct = mol.point_group().char_table(). # Obtain atom mapping of atom * symm op to atom; atom_map = compute_atom_map(mol). syms = []; smap = []; for g in range(ct.order()):; syms.append(np.asarray(ct.symm_operation(g).d)); smap.append([atom_map[at][g] for at in range(mol.natom())]). np.set_printoptions(formatter={'float': '{: 16.12f}'.format}); b_hess = blockwise_expand(hess, (3, 3), False). bDG = []; nat = b_hess.shape[0]; for iat in range(nat):; for jat in range(nat):; for sym in range(len(syms)):; bDG.append(np.zeros_like(b_hess)); bDG[sym][iat, jat] = syms[sym].dot(b_hess[iat, jat].dot(syms[sym])); # Note that tested syms all diagonal, so above may be off by some transposes. for sym in range(len(syms)):; bDG[sym] = bDG[sym][:, smap[sym]]; bDG[sym] = bDG[sym][smap[sym], :]; tot = np.sum(bDG, axis=0); tot = np.divide(tot, len(syms)). print('symmetrization diff:', np.linalg.norm(tot - b_hess)); m_tot = blockwise_contract(tot); return m_tot. [docs]; def print_molden_vibs(vibinfo: Dict[str, Datum], atom_symbol: Union[np.ndarray, List[str]], geom: Union[np.ndarray, List[List[float]]], standalone: bool = True) -> str:; """"""Format vibrational analysis for Molden. Parameters; ----------; vibinfo; Holds results of vibrational analysis.; atom_symbol; (nat,) element symbols for geometry of vibrational analysis.; geom; (nat, 3) geometry of vibrational analysis [a0].; standalone; Whether returned string prefixed ""[Molden Format]"" for standalone rather than append. Returns; -------; str; `vibinfo` formatted for Molden, including FREQ, FR-COORD, & FR-NORM-COORD fields. Notes; -----; Molden format spec from http://www.cmbi.ru.",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:32056,Testability,log,log,32056,"ty of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[(",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:32308,Testability,log,log,32308,"RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibon",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:32664,Testability,log,log,32664,"minfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constants', 'cm^-1', rot_const); therminfo['sigma'] = Datum('external symmetry number', '', sigma); therminfo['T'] = Datum('temperature', 'K', T); therminfo['P'] = Datum('pressure', 'Pa', P). # electronic; q_elec = multiplicity; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lo",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:32962,Testability,log,log,32962,"y; sm[('S', 'elec')] = math.log(q_elec). # translational; beta = 1 / (qcel.constants.kb * T); q_trans = (2.0 * np.pi * molecular_mass * qcel.constants.amu2kg /; (beta * qcel.constants.h * qcel.constants.h))**1.5 * qcel.constants.na / (beta * P); sm[('S', 'trans')] = 5 / 2 + math.log(q_trans / qcel.constants.na); sm[('Cv', 'trans')] = 3 / 2; sm[('Cp', 'trans')] = 5 / 2; sm[('E', 'trans')] = 3 / 2 * T; sm[('H', 'trans')] = 5 / 2 * T. # rotational; if rotor_type == ""RT_ATOM"":; pass; elif rotor_type == ""RT_LINEAR"":; q_rot = 1. / (beta * sigma * 100 * qcel.constants.c * qcel.constants.h * rot_const[1]); sm[('S', 'rot')] = 1.0 + math.log(q_rot); sm[('Cv', 'rot')] = 1; sm[('Cp', 'rot')] = 1; sm[('E', 'rot')] = T; else:; phi_A, phi_B, phi_C = rot_const * 100 * qcel.constants.c * qcel.constants.h / qcel.constants.kb; q_rot = math.sqrt(math.pi) * T**1.5 / (sigma * math.sqrt(phi_A * phi_B * phi_C)); sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')]",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:33923,Testability,log,log,33923,"; sm[('S', 'rot')] = 3 / 2 + math.log(q_rot); sm[('Cv', 'rot')] = 3 / 2; sm[('Cp', 'rot')] = 3 / 2; sm[('E', 'rot')] = 3 / 2 * T; sm[('H', 'rot')] = sm[('E', 'rot')]. # vibrational; vibonly = filter_nonvib(vibinfo); ZPE_cm_1 = 1 / 2 * np.sum(vibonly['omega'].data.real); omega_str = _format_omega(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uco",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:34199,Testability,assert,assert,34199,"a(vibonly['omega'].data, decimals=4). imagfreqidx = np.where(vibonly['omega'].data.imag > vibonly['omega'].data.real)[0]; if len(imagfreqidx):; print(""Warning: thermodynamics relations excluded imaginary frequencies: {}"".format(omega_str[imagfreqidx])). filtered_theta_vib = np.delete(vibonly['theta_vib'].data, imagfreqidx, None); filtered_omega_str = np.delete(omega_str, imagfreqidx, None); rT = filtered_theta_vib / T # reduced temperature. lowfreqidx = np.where(filtered_theta_vib < 900.)[0]; if len(lowfreqidx):; print(""Warning: used thermodynamics relations inappropriate for low-frequency modes: {}"".format(; filtered_omega_str[lowfreqidx])). sm[('S', 'vib')] = np.sum(rT / np.expm1(rT) - np.log(1 - np.exp(-rT))); sm[('Cv', 'vib')] = np.sum(np.exp(rT) * (rT / np.expm1(rT))**2); sm[('Cp', 'vib')] = sm[('Cv', 'vib')]; sm[('ZPE', 'vib')] = np.sum(rT) * T / 2; sm[('E', 'vib')] = sm[('ZPE', 'vib')] + np.sum(rT * T / np.expm1(rT)); sm[('H', 'vib')] = sm[('E', 'vib')]. assert (abs(ZPE_cm_1 - sm[('ZPE', 'vib')] * qcel.constants.R * qcel.constants.hartree2wavenumbers * 0.001 /; qcel.constants.hartree2kJmol) < 0.1). #real_vibs = np.ma.masked_where(vibinfo['omega'].data.imag > vibinfo['omega'].data.real, vibinfo['omega'].data). # compute Gibbs; for term in ['elec', 'trans', 'rot', 'vib']:; sm[('G', term)] = sm[('H', term)] - T * sm[('S', term)]. # convert to atomic units; for term in ['elec', 'trans', 'rot', 'vib']:; # terms above are unitless (S, Cv, Cp) or in units of temperature (ZPE, E, H, G) as expressions are divided by R.; # R [Eh/K], computed as below, slightly diff in 7th sigfig from 3.1668114e-6 (k_B in [Eh/K]); # value listed https://en.wikipedia.org/wiki/Boltzmann_constant; uconv_R_EhK = qcel.constants.R / qcel.constants.hartree2kJmol; for piece in ['S', 'Cv', 'Cp']:; sm[(piece, term)] *= uconv_R_EhK # [mEh/K] <-- []; for piece in ['ZPE', 'E', 'H', 'G']:; sm[(piece, term)] *= uconv_R_EhK * 0.001 # [Eh] <-- [K]. # sum corrections and totals; for piece in ['S', 'Cv', ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:40954,Testability,assert,assert,40954,"e: str = 'TR', tol: float = None, verbose: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in sp",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:41002,Testability,assert,assert,41002,"se: int = 1) -> np.ndarray:; """"""Form the idealized translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:41049,Testability,assert,assert,41049,"zed translation and rotation dof from geometry `geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if ",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:41096,Testability,assert,assert,41096,"geom` and masses `m`.; Remove any linear dependencies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it run",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:41144,Testability,assert,assert,41144,"encies and return an array of shape (3, 3) for atoms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]).",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:41191,Testability,assert,assert,41191,"toms, (5, 3 * nat) for linear `geom`,; or (6, 3 * nat) otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:41239,Testability,assert,assert,41239,") otherwise. To handle noisy linear geometries, pass `tol` on the order of max deviation. m1 = np.asarray([1.]); m2 = np.asarray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=Fals",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:41371,Testability,assert,assert,41371,"ray([1., 1.]); m3 = np.asarray([1., 1., 1.]); m4 = np.asarray([1., 1., 1., 1.]); g4 = np.asarray([[ 1., 1., 0.],; [-1., 1., 0.],; [-1., -1., 0.],; [ 1., -1., 0.]]); g2 = np.asarray([[ 1., 1., 0.],; [-1., -1., 0.]]); g3 = np.asarray([[3., 3., 3.],; [4., 4., 4.,],; [5., 5., 5.]]); g3noisy = np.asarray([[3., 3.001, 3.],; [4., 4.001, 4.,],; [5., 5., 5.01]]); g33 = np.asarray([[0., 0., 0.],; [1., 0., 0.],; [-1., 0., 0.]]); g1 = np.asarray([[0., 0., 0.]]); g11 = np.asarray([[1., 2., 3.]]); noise = np.random.normal(0, 1, 9).reshape(3, 3); noise = np.divide(noise, np.max(noise)). assert(_get_TR_space(m4, g4).shape == (6, 12)); assert(_get_TR_space(m2, g2).shape == (5, 6)); assert(_get_TR_space(m3, g3).shape == (5, 9)); assert(_get_TR_space(m3, g33).shape == (5, 9)); assert(_get_TR_space(m1, g1).shape == (3, 3)); assert(_get_TR_space(m1, g11).shape == (3, 3)); assert(_get_TR_space(m3, g3noisy, tol=1.e-2).shape == (5, 9)); for ns in range(2, 6):; tol = 10. ** -ns; gnoisy = g3 + tol * noise; assert(_get_TR_space(m3, gnoisy, tol=10*tol).shape == (5, 9)). """"""; sqrtmmm = np.repeat(np.sqrt(m), 3); xxx = np.repeat(geom[:, 0], 3); yyy = np.repeat(geom[:, 1], 3); zzz = np.repeat(geom[:, 2], 3). z = np.zeros_like(m); i = np.ones_like(m); ux = np.ravel([i, z, z], order='F'); uy = np.ravel([z, i, z], order='F'); uz = np.ravel([z, z, i], order='F'). # form translation and rotation unit vectors; T1 = sqrtmmm * ux; T2 = sqrtmmm * uy; T3 = sqrtmmm * uz; R4 = sqrtmmm * (yyy * uz - zzz * uy); R5 = sqrtmmm * (zzz * ux - xxx * uz); R6 = sqrtmmm * (xxx * uy - yyy * ux). TRspace = []; if 'T' in space:; TRspace.append([T1, T2, T3]); if 'R' in space:; TRspace.append([R4, R5, R6]); if not TRspace:; # not sure about this, but it runs; ZZ = np.zeros_like(T1); TRspace.append([ZZ]). TRspace = np.vstack(TRspace). def orth(A, tol=tol):; u, s, vh = np.linalg.svd(A, full_matrices=False); if verbose >= 2:; print(s); M, N = A.shape; eps = np.finfo(float).eps; if tol is None:; tol = max(M, N) * np.amax(s) * eps",MatchSource.WIKI,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.AngularMomentumInt.html:527,Deployability,update,updated,527,". AngularMomentumInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt. AngularMomentumInt. class psi4.core.AngularMomentumInt; Bases: OneBodyAOInt; Computes angular momentum integrals. table of contents. AngularMomentumInt; AngularMomentumInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; AngularMomentumInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.AngularMomentumInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.AngularMomentumInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.AOShellCombinationsIterator.html:1393,Deployability,update,updated,1393,". AOShellCombinationsIterator. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator. AOShellCombinationsIterator. class psi4.core.AOShellCombinationsIterator; Bases: pybind11_object; Attributes Summary. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Summary. first(self); docstring. is_done(self); docstring. next(self); docstring. Attributes Documentation. p; Returns current P index. q; Returns current Q index. r; Returns current R index. s; Returns current S index. Methods Documentation. first(self: psi4.core.AOShellCombinationsIterator)  None; docstring. is_done(self: psi4.core.AOShellCombinationsIterator)  bool; docstring. next(self: psi4.core.AOShellCombinationsIterator)  None; docstring. table of contents. AOShellCombinationsIterator; AOShellCombinationsIterator; AOShellCombinationsIterator.p; AOShellCombinationsIterator.q; AOShellCombinationsIterator.r; AOShellCombinationsIterator.s; AOShellCombinationsIterator.first(); AOShellCombinationsIterator.is_done(); AOShellCombinationsIterator.next(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; AOShellCombinationsIterator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.AOShellCombinationsIterator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.AOShellCombinationsIterator.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variable.html:547,Deployability,update,updated,547,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variable.html:281,Modifiability,variab,variable,281,". array_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variable. array_variable. psi4.core.array_variable(key: str)  psi4.core.Matrix; Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). table of contents. array_variable; array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variables.html:542,Deployability,update,updated,542,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  Dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variables.html:272,Modifiability,variab,variables,272,". array_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variables. array_variables. psi4.core.array_variables()  Dict[str, psi4.core.Matrix]; Returns dictionary of all Matrix QCVariables; prefer variables(). table of contents. array_variables; array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.array_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisExtents.html:1092,Deployability,update,updated,1092,". BasisExtents. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents. BasisExtents. class psi4.core.BasisExtents; Bases: pybind11_object; docstring; Methods Summary. basis(self); docstring. delta(self); docstring. maxR(self); docstring. set_delta(self,arg0); docstring. shell_extents(self); docstring. Methods Documentation. basis(self: psi4.core.BasisExtents)  psi4.core.BasisSet; docstring. delta(self: psi4.core.BasisExtents)  float; docstring. maxR(self: psi4.core.BasisExtents)  float; docstring. set_delta(self: psi4.core.BasisExtents, arg0: float)  None; docstring. shell_extents(self: psi4.core.BasisExtents)  psi4.core.Vector; docstring. table of contents. BasisExtents; BasisExtents; BasisExtents.basis(); BasisExtents.delta(); BasisExtents.maxR(); BasisExtents.set_delta(); BasisExtents.shell_extents(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BasisExtents.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisExtents.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisExtents.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisFunctions.html:1333,Deployability,update,updated,1333,". BasisFunctions. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions. BasisFunctions. class psi4.core.BasisFunctions; Bases: pybind11_object; docstring; Methods Summary. basis_values(self); docstring. compute_functions(self,arg0); docstring. deriv(self); docstring. max_functions(self); docstring. max_points(self); docstring. set_deriv(self,arg0); docstring. Methods Documentation. basis_values(self: psi4.core.BasisFunctions)  Dict[str, psi4.core.Matrix]; docstring. compute_functions(self: psi4.core.BasisFunctions, arg0: psi4.core.BlockOPoints)  None; docstring. deriv(self: psi4.core.BasisFunctions)  int; docstring. max_functions(self: psi4.core.BasisFunctions)  int; docstring. max_points(self: psi4.core.BasisFunctions)  int; docstring. set_deriv(self: psi4.core.BasisFunctions, arg0: int)  None; docstring. table of contents. BasisFunctions; BasisFunctions; BasisFunctions.basis_values(); BasisFunctions.compute_functions(); BasisFunctions.deriv(); BasisFunctions.max_functions(); BasisFunctions.max_points(); BasisFunctions.set_deriv(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BasisFunctions.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisFunctions.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:3883,Availability,avail,available,3883,"oes it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; pur",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:10270,Deployability,update,updated,10270,"int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BasisSet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:1927,Integrability,depend,depending,1927,"respond to. genbas(self); Returns basis set per atom in CFOUR format. has_ECP(self); Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it corr",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:2013,Integrability,contract,contractions,2013,"Whether this basis set object has an ECP associated with it. has_puream(self); Spherical harmonics?. make_filename(arg0); Returns filename for basis name: pluses, stars, parentheses replaced and gbs extension added. max_am(self); Returns maximum angular momentum used. max_function_per_shell(self); The max number of basis functions in a shell. max_nprimitive(self); The max number of primitives in a shell. molecule(self); Molecule object. move_atom(self,arg0,arg1); Translate a given atom by a given amount. n_ecp_core(*args,**kwargs); Overloaded function. n_ecp_shell_on_center(self,i); Return the number of ECP shells on a given center. n_frozen_core(self[,local,molecule]); Returns the number of orbital (non-ECP) frozen core electrons. name(self); Callback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisna",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:2746,Integrability,contract,contraction,2746,"llback handle, may represent string or function. nao(self); Returns number of atomic orbitals (Cartesian). nbf(self); Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self); Returns total number of primitives in all contractions. nshell(self); Returns number of shells. nshell_on_center(self,i); Return the number of shells on a given center. print_detail_out(self); Prints detailed basis set info to outfile. print_out(self); Prints basis set info to outfile. shell(*args,**kwargs); Overloaded function. shell_on_center(self,c,i); Return the i'th shell on center. shell_to_ao_function(self,i); Return the function number for the first function for the i'th shell. shell_to_basis_function(self,i); Given a shell return its first basis function. shell_to_center(self,i); Return the atomic center for the i'th shell. zero_ao_basis_set(); Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. Methods Documentation. ao_to_shell(self: psi4.core.BasisSet, i: int)  int; Given a cartesian function (AO) number what shell does it correspond to. blend(self: psi4.core.BasisSet)  str; Plus-separated string of [basisname] values. static build(mol, key=None, target=None, fitrole='ORBITAL', other=None, puream=-1, return_atomlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely fr",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:7793,Integrability,depend,depending,7793,"oes not affect the underlying molecule object. n_ecp_core(*args, **kwargs); Overloaded function. n_ecp_core(self: psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith she",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:7906,Integrability,contract,contractions,7906,"psi4.core.BasisSet) -> int. Returns the total number of core electrons associated with all ECPs in this basis. n_ecp_core(self: psi4.core.BasisSet, arg0: str) -> int. Returns the number of core electrons associated with any ECP on the specified atom type for this basis set. n_ecp_shell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of ECP shells on a given center. n_frozen_core(self: psi4.core.BasisSet, local: str = '', molecule: psi4.core.Molecule = None)  int; Returns the number of orbital (non-ECP) frozen core electrons. For a given molecule and FREEZE_CORE, (n_ecp_core()/2 + n_frozen_core()) = constant. name(self: psi4.core.BasisSet)  str; Callback handle, may represent string or function. nao(self: psi4.core.BasisSet)  int; Returns number of atomic orbitals (Cartesian). nbf(self: psi4.core.BasisSet)  int; Returns number of basis functions (Cartesian or spherical depending on has_puream). nprimitive(self: psi4.core.BasisSet)  int; Returns total number of primitives in all contractions. nshell(self: psi4.core.BasisSet)  int; Returns number of shells. nshell_on_center(self: psi4.core.BasisSet, i: int)  int; Return the number of shells on a given center. print_detail_out(self: psi4.core.BasisSet)  None; Prints detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:9144,Integrability,contract,contraction,9144,"ts detailed basis set info to outfile. print_out(self: psi4.core.BasisSet)  None; Prints basis set info to outfile. shell(*args, **kwargs); Overloaded function. shell(self: psi4.core.BasisSet, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell. shell(self: psi4.core.BasisSet, center: int, si: int) -> psi4.core.GaussianShell. Return the sith Gaussian shell on center. shell_on_center(self: psi4.core.BasisSet, c: int, i: int)  int; Return the ith shell on center. shell_to_ao_function(self: psi4.core.BasisSet, i: int)  int; Return the function number for the first function for the ith shell. shell_to_basis_function(self: psi4.core.BasisSet, i: int)  int; Given a shell return its first basis function. shell_to_center(self: psi4.core.BasisSet, i: int)  int; Return the atomic center for the ith shell. static zero_ao_basis_set()  psi4.core.BasisSet; Returns a BasisSet object that actually has a single s-function at the origin with an exponent of 0.0 and contraction of 1.0. table of contents. BasisSet; BasisSet; BasisSet.ao_to_shell(); BasisSet.blend(); BasisSet.build(); BasisSet.compute_phi(); BasisSet.construct_from_pydict(); BasisSet.ecp_shell(); BasisSet.ecp_shell_on_center(); BasisSet.function_to_center(); BasisSet.function_to_shell(); BasisSet.genbas(); BasisSet.has_ECP(); BasisSet.has_puream(); BasisSet.make_filename(); BasisSet.max_am(); BasisSet.max_function_per_shell(); BasisSet.max_nprimitive(); BasisSet.molecule(); BasisSet.move_atom(); BasisSet.n_ecp_core(); BasisSet.n_ecp_shell_on_center(); BasisSet.n_frozen_core(); BasisSet.name(); BasisSet.nao(); BasisSet.nbf(); BasisSet.nprimitive(); BasisSet.nshell(); BasisSet.nshell_on_center(); BasisSet.print_detail_out(); BasisSet.print_out(); BasisSet.shell(); BasisSet.shell_on_center(); BasisSet.shell_to_ao_function(); BasisSet.shell_to_basis_function(); BasisSet.shell_to_center(); BasisSet.zero_ao_basis_set(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html:4102,Usability,simpl,simple,4102,"omlist=False, *, quiet=False); Build a primary or auxiliary basis set. Parameters:. mol (Molecule)  Molecule for which to build the basis set instance.; key (Optional[str])  {BASIS, ORBITAL, DF_BASIS_SCF, DF_BASIS_MP2, DF_BASIS_CC, BASIS_RELATIVISTIC, DF_BASIS_SAD}; Label (effectively Psi4 keyword) to append the basis on the molecule.; The primary basis set is indicated by any of values None or; ""ORBITAL"" or ""BASIS"".; target (Union[str, Callable, None])  Defines the basis set to be constructed. Can be a string (naming a; basis file) or a callable (providing shells or multiple basis files).; For auxiliary bases to be built entirely from primary default, can be; an empty string. If None, value taken from key in global options. If; a user-defined-basis callable is available at string target, target; value will be set to it. In practice, setting this argument to a; PSI4 keyword (e.g., core.get_option(""SCF"", ""DF_BASIS_SCF"") or; core.get_global_option(""BASIS"")) works to handle both simple and; user-defined bases.; fitrole (str)  {ORBITAL, JKFIT, RIFIT, DECON}; Role for which to build basis. Only used when key indicates auxiliary; (i.e., is not ""BASIS"") and auxiliary spec from processing target; cant complete the mol. Then, primary spec from other can be used; to complete the auxiliary basis by looking up suitable default basis; according to fitrole.; other (Union[str, Callable, None])  Only used when building auxiliary basis sets. Defines the primary basis through a string or callable like target.; puream (int)  Whether to override the native spherical/cartesian-ness of target for; returned basis? Value 1 forces spherical, value 0 forces; Cartesian, value -1 (default) uses native puream. Note that; explicitly setting PUREAM trumps both native; puream and this puream argument.; return_atomlist (bool)  Build one-atom basis sets (e.g., for SAD) rather than one whole-mol; basis set.; quiet (bool)  When True, do not print to the output file. Ret",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html:592,Deployability,update,updated,592,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html:262,Integrability,rout,routines,262,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html:300,Integrability,rout,routine,300,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html:233,Testability,benchmark,benchmark,233,". benchmark_blas1. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1. benchmark_blas1. psi4.core.benchmark_blas1(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 1 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas1; benchmark_blas1(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas1.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas1.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html:592,Deployability,update,updated,592,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html:262,Integrability,rout,routines,262,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html:300,Integrability,rout,routine,300,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html:233,Testability,benchmark,benchmark,233,". benchmark_blas2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2. benchmark_blas2. psi4.core.benchmark_blas2(max_dim: int, min_time: float)  None; Perform benchmark traverse of BLAS 2 routines. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_blas2; benchmark_blas2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html:621,Deployability,update,updated,621,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html:280,Integrability,rout,routines,280,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html:318,Integrability,rout,routine,318,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html:251,Testability,benchmark,benchmark,251,". benchmark_blas3. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3. benchmark_blas3. psi4.core.benchmark_blas3(max_dim: int, min_time: float, nthread: int = 1)  None; Perform benchmark traverse of BLAS 3 routines. Use up to max_dim with each routine run at least min_time [s] on nthread. table of contents. benchmark_blas3; benchmark_blas3(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_blas3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_blas3.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html:582,Deployability,update,updated,582,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html:293,Integrability,rout,routine,293,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html:252,Performance,perform,performance,252,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html:229,Testability,benchmark,benchmark,229,". benchmark_disk. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk. benchmark_disk. psi4.core.benchmark_disk(max_dim: int, min_time: float)  None; Perform benchmark of PSIO disk performance. Use up to max_dim with each routine run at least min_time [s]. table of contents. benchmark_disk; benchmark_disk(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_disk.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_disk.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_disk.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html:687,Deployability,update,updated,687,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html:248,Testability,benchmark,benchmark,248,". benchmark_integrals. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals. benchmark_integrals. psi4.core.benchmark_integrals(max_am: int, min_time: float)  None; Perform benchmark of psi integrals (of libmints type). Benchmark integrals called from different centers. For up to max_am with each shell combination run at least min_time [s]. table of contents. benchmark_integrals; benchmark_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_integrals.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_integrals.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html:591,Deployability,update,updated,591,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html:302,Integrability,rout,routine,302,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html:215,Testability,benchmark,benchmark,215,". benchmark_math. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math. benchmark_math. psi4.core.benchmark_math(min_time: float)  None; Perform benchmark of common double floating point operations including most of cmath. For each routine run at least min_time [s]. table of contents. benchmark_math; benchmark_math(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; benchmark_math.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.benchmark_math.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.benchmark_math.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.be_quiet.html:523,Deployability,update,updated,523,". be_quiet. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; be_quiet. be_quiet. psi4.core.be_quiet()  None; Redirects output to /dev/null. To switch back to regular output mode, use reopen_outfile(). Doesnt work with Windows. table of contents. be_quiet; be_quiet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; be_quiet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.be_quiet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.be_quiet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BlockOPoints.html:1747,Deployability,update,updated,1747,". BlockOPoints. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints. BlockOPoints. class psi4.core.BlockOPoints; Bases: pybind11_object; docstring; Methods Summary. functions_local_to_global(self); docstring. npoints(self); docstring. parent_atom(self); Returns the atom number this BlockOfPoints belongs to. print_out(self[,out_fname,print]); docstring. refresh(self); docstring. shells_local_to_global(self); docstring. w(self). x(self). y(self). z(self). Methods Documentation. functions_local_to_global(self: psi4.core.BlockOPoints)  List[int]; docstring. npoints(self: psi4.core.BlockOPoints)  int; docstring. parent_atom(self: psi4.core.BlockOPoints)  int; Returns the atom number this BlockOfPoints belongs to. print_out(self: psi4.core.BlockOPoints, out_fname: str = 'outfile', print: int = 2)  None; docstring. refresh(self: psi4.core.BlockOPoints)  None; docstring. shells_local_to_global(self: psi4.core.BlockOPoints)  List[int]; docstring. w(self: psi4.core.BlockOPoints)  psi4.core.Vector. x(self: psi4.core.BlockOPoints)  psi4.core.Vector. y(self: psi4.core.BlockOPoints)  psi4.core.Vector. z(self: psi4.core.BlockOPoints)  psi4.core.Vector. table of contents. BlockOPoints; BlockOPoints; BlockOPoints.functions_local_to_global(); BlockOPoints.npoints(); BlockOPoints.parent_atom(); BlockOPoints.print_out(); BlockOPoints.refresh(); BlockOPoints.shells_local_to_global(); BlockOPoints.w(); BlockOPoints.x(); BlockOPoints.y(); BlockOPoints.z(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BlockOPoints.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BlockOPoints.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BlockOPoints.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BoysLocalizer.html:488,Deployability,update,updated,488,". BoysLocalizer. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer. BoysLocalizer. class psi4.core.BoysLocalizer; Bases: Localizer; Performs Boys orbital localization. table of contents. BoysLocalizer; BoysLocalizer. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BoysLocalizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BoysLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BoysLocalizer.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:1694,Availability,error,error,1694,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:2058,Deployability,update,updated,2058,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:346,Modifiability,extend,extend,346,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:883,Modifiability,extend,extend,883,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:930,Modifiability,extend,extend,930,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:1071,Modifiability,extend,extend,1071,"I4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:1811,Modifiability,extend,extend,1811,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:247,Usability,clear,clear,247,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:694,Usability,clear,clear,694,". BSVec. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec. BSVec. class psi4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Pytho",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html:1781,Usability,clear,clear,1781,"i4.core.BSVec; Bases: pybind11_object; Methods Summary. append(self,x); Add an item to the end of the list. clear(self); Clear the contents. count(self,x); Return the number of times x appears in the list. extend(*args,**kwargs); Overloaded function. insert(self,i,x); Insert an item at a given position. pop(*args,**kwargs); Overloaded function. remove(self,x); Remove the first item from the list whose value is x. Methods Documentation. append(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Add an item to the end of the list. clear(self: List[psi4.core.ShellInfo])  None; Clear the contents. count(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  int; Return the number of times x appears in the list. extend(*args, **kwargs); Overloaded function. extend(self: List[psi4.core.ShellInfo], L: List[psi4.core.ShellInfo]) -> None. Extend the list by appending all the items in the given list. extend(self: List[psi4.core.ShellInfo], L: Iterable) -> None. Extend the list by appending all the items in the given list. insert(self: List[psi4.core.ShellInfo], i: int, x: psi4.core.ShellInfo)  None; Insert an item at a given position. pop(*args, **kwargs); Overloaded function. pop(self: List[psi4.core.ShellInfo]) -> psi4.core.ShellInfo. Remove and return the last item. pop(self: List[psi4.core.ShellInfo], i: int) -> psi4.core.ShellInfo. Remove and return the item at index i. remove(self: List[psi4.core.ShellInfo], x: psi4.core.ShellInfo)  None; Remove the first item from the list whose value is x. It is an error if there is no such item. table of contents. BSVec; BSVec; BSVec.append(); BSVec.clear(); BSVec.count(); BSVec.extend(); BSVec.insert(); BSVec.pop(); BSVec.remove(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; BSVec.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.BSVec.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.BSVec.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccdensity.html:504,Deployability,update,updated,504,". ccdensity. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccdensity. ccdensity. psi4.core.ccdensity(ref_wfn: psi4.core.CCWavefunction)  float; Runs the code to compute coupled cluster density matrices. table of contents. ccdensity; ccdensity(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccdensity.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ccdensity.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccdensity.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccenergy.html:491,Deployability,update,updated,491,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccenergy.html:242,Energy Efficiency,energy,energy,242,". ccenergy. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccenergy. ccenergy. psi4.core.ccenergy(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster energy code. table of contents. ccenergy; ccenergy(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccenergy.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ccenergy.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccenergy.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.cceom.html:486,Deployability,update,updated,486,". cceom. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cceom. cceom. psi4.core.cceom(ref_wfn: psi4.core.CCWavefunction)  float; Runs the equation of motion coupled cluster code for excited states. table of contents. cceom; cceom(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cceom.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.cceom.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.cceom.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.cchbar.html:487,Deployability,update,updated,487,". cchbar. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cchbar. cchbar. psi4.core.cchbar(ref_wfn: psi4.core.Wavefunction)  None; Runs the code to generate the similarity transformed Hamiltonian. table of contents. cchbar; cchbar(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cchbar.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.cchbar.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.cchbar.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.cclambda.html:501,Deployability,update,updated,501,". cclambda. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cclambda. cclambda. psi4.core.cclambda(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the coupled cluster lambda equations code. table of contents. cclambda; cclambda(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cclambda.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.cclambda.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.cclambda.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccresponse.html:497,Deployability,update,updated,497,". ccresponse. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccresponse. ccresponse. psi4.core.ccresponse(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster response theory code. table of contents. ccresponse; ccresponse(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ccresponse.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ccresponse.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ccresponse.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.cctransort.html:542,Deployability,update,updated,542,". cctransort. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cctransort. cctransort. psi4.core.cctransort(ref_wfn: psi4.core.Wavefunction)  None; Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. table of contents. cctransort; cctransort(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cctransort.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.cctransort.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.cctransort.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.cctriples.html:485,Deployability,update,updated,485,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.cctriples.html:233,Energy Efficiency,energy,energy,233,". cctriples. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cctriples. cctriples. psi4.core.cctriples(ref_wfn: psi4.core.Wavefunction)  float; Runs the coupled cluster (T) energy code. table of contents. cctriples; cctriples(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; cctriples.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.cctriples.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.cctriples.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html:1440,Availability,error,error,1440," 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html:1991,Deployability,update,updated,1991," 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html:432,Energy Efficiency,energy,energy-sorted,432,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html:1144,Energy Efficiency,energy,energy,1144," 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html:1639,Energy Efficiency,energy,energy-sorted,1639," 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html:878,Integrability,depend,depending,878,". CCWavefunction. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html:1339,Modifiability,variab,variable,1339," 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction. CCWavefunction. class psi4.core.CCWavefunction; Bases: Wavefunction; Specialized Wavefunction used by the ccenergy, cceom, ccgradient, etc. modules.; Methods Summary. get_amplitudes(self); Get dict of converged T amplitudes. total_index(self,i,h); Map an index (i) within irrep (h) to its energy-sorted index among all roots. Methods Documentation. get_amplitudes(self: psi4.core.CCWavefunction)  Dict[str, psi4.core.Matrix]; Get dict of converged T amplitudes. Returns:. amps (dict (spacestr, SharedMatrix))  spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = ;  0 1;  Ne 0.0 0.0 0.0;  symmetry c1; >>> e, wfn = psi4.energy(CCSD/cc-pvdz, return_wfn=True); >>> t1 = wfn.get_amplitudes()[tia].to_array(); >>> t1_diagnostic = np.sqrt(np.dot(t1.ravel(),t1.ravel())/ (2 * wfn.nalpha()); >>> t1_diagnostic == psi4.variable(CC T1 DIAGNOSTIC); True. Warning; Symmetry free calculations only (nirreps > 1 will cause error). Warning; No checks that the amplitudes will fit in core. Do not use for proteins. total_index(self: psi4.core.CCWavefunction, i: int, h: int)  int; Map an index (i) within irrep (h) to its energy-sorted index among all roots. table of contents. CCWavefunction; CCWavefunction; CCWavefunction.get_amplitudes(); CCWavefunction.total_index(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CCWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CCWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CCWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalc.html:1041,Deployability,update,updated,1041,". CdSalc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CdSalc. CdSalc. class psi4.core.CdSalc; Bases: pybind11_object; Cartesian displacement SALC; Methods Summary. irrep(self); Return the irrep bit representation. irrep_index(self); Return the irrep index. print_out(self); Print the irrep index and the coordinates of the SALC of Cartesian displacements. Methods Documentation. irrep(self: psi4.core.CdSalc)  str; Return the irrep bit representation. irrep_index(self: psi4.core.CdSalc)  int; Return the irrep index. print_out(self: psi4.core.CdSalc)  None; Print the irrep index and the coordinates of the SALC of Cartesian displacements. Irrep index is 0-indexed and Cotton ordered. table of contents. CdSalc; CdSalc; CdSalc.irrep(); CdSalc.irrep_index(); CdSalc.print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CdSalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CdSalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalcList.html:2025,Deployability,update,updated,2025,"++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalcList.html:227,Energy Efficiency,adapt,adapted,227,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2024, ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalcList.html:227,Modifiability,adapt,adapted,227,". CdSalcList. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList. CdSalcList. class psi4.core.CdSalcList; Bases: pybind11_object; Class for generating symmetry adapted linear combinations of Cartesian displacements; Methods Summary. create_matrices(self,basename,factory); Return a vector of matrices with the SALC symmetries. matrix(self); Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self,h); Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self); Return the number of cartesian displacements SALCs. nirrep(self); Return the number of irreps. print_out(self); Print the SALCs to the output file. salc_name(self,i); Return the name of SALC #i. Methods Documentation. create_matrices(self: psi4.core.CdSalcList, basename: str, factory: psi4.core.MatrixFactory)  List[psi4.core.Matrix]; Return a vector of matrices with the SALC symmetries. Dimensions determined by factory. matrix(self: psi4.core.CdSalcList)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs. matrix_irrep(self: psi4.core.CdSalcList, h: int)  psi4.core.Matrix; Return the matrix that transforms Cartesian displacements to SALCs of irrep h. ncd(self: psi4.core.CdSalcList)  int; Return the number of cartesian displacements SALCs. nirrep(self: psi4.core.CdSalcList)  int; Return the number of irreps. print_out(self: psi4.core.CdSalcList)  None; Print the SALCs to the output file. salc_name(self: psi4.core.CdSalcList, i: int)  str; Return the name of SALC #i. table of contents. CdSalcList; CdSalcList; CdSalcList.create_matrices(); CdSalcList.matrix(); CdSalcList.matrix_irrep(); CdSalcList.ncd(); CdSalcList.nirrep(); CdSalcList.print_out(); CdSalcList.salc_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CdSalcList.  Copyright 2007-2024, ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CdSalcList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CdSalcList.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CharacterTable.html:1203,Deployability,update,updated,1203,". CharacterTable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable. CharacterTable. class psi4.core.CharacterTable; Bases: pybind11_object; Contains the character table of the point group; Methods Summary. gamma(self,arg0); Returns the irrep with the given index in the character table. order(self); Return the order of the point group. symm_operation(self,arg0); Return the i'th symmetry operation. Methods Documentation. gamma(self: psi4.core.CharacterTable, arg0: int)  psi4.core.IrreducibleRepresentation; Returns the irrep with the given index in the character table. order(self: psi4.core.CharacterTable)  int; Return the order of the point group. symm_operation(self: psi4.core.CharacterTable, arg0: int)  psi4.core.SymmetryOperation; Return the ith symmetry operation. 0-indexed. table of contents. CharacterTable; CharacterTable; CharacterTable.gamma(); CharacterTable.order(); CharacterTable.symm_operation(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CharacterTable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CharacterTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CharacterTable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CIVector.html:2961,Deployability,update,updated,2961,"loat, arg1: psi4.core.CIVector, arg2: int, arg3: int)  None; docstring. close_io_files(self: psi4.core.CIVector, arg0: int)  None; docstring. copy(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  None; docstring. dcalc(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: int)  float; docstring. divide(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: float, arg2: int, arg3: int)  None; docstring. init_io_files(self: psi4.core.CIVector, arg0: bool)  None; docstring. norm(self: psi4.core.CIVector, arg0: int)  float; docstring. read(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. scale(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. set_nvec(self: psi4.core.CIVector, arg0: int)  None; docstring. shift(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. symnormalize(self: psi4.core.CIVector, arg0: float, arg1: int)  None; docstring. vdot(self: psi4.core.CIVector, arg0: psi4.core.CIVector, arg1: int, arg2: int)  float; docstring. vector_multiply(self: psi4.core.CIVector, arg0: float, arg1: psi4.core.CIVector, arg2: psi4.core.CIVector, arg3: int, arg4: int, arg5: int)  None; docstring. write(self: psi4.core.CIVector, arg0: int, arg1: int)  int; docstring. zero(self: psi4.core.CIVector)  None; docstring. table of contents. CIVector; CIVector; CIVector.np; CIVector.axpy(); CIVector.close_io_files(); CIVector.copy(); CIVector.dcalc(); CIVector.divide(); CIVector.init_io_files(); CIVector.norm(); CIVector.read(); CIVector.scale(); CIVector.set_nvec(); CIVector.shift(); CIVector.symnormalize(); CIVector.vdot(); CIVector.vector_multiply(); CIVector.write(); CIVector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CIVector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CIVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CIVector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CIWavefunction.html:7641,Deployability,update,updated,7641,"(*args, **kwargs); Overloaded function. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int) -> None. docstring. sigma(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int, arg4: psi4.core.Vector, arg5: psi4.core.Vector) -> None. docstring. tpdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. transform_ci_integrals(self: psi4.core.CIWavefunction)  None; Transforms the one- and two-electron integrals for a CI computation. transform_mcscf_integrals(self: psi4.core.CIWavefunction, arg0: bool)  None; docstring. table of contents. CIWavefunction; CIWavefunction; CIWavefunction.D_vector(); CIWavefunction.Hd_vector(); CIWavefunction.ci_nat_orbs(); CIWavefunction.cleanup_ci(); CIWavefunction.cleanup_dpd(); CIWavefunction.compute_state_transfer(); CIWavefunction.diag_h(); CIWavefunction.form_opdm(); CIWavefunction.form_tpdm(); CIWavefunction.get_dimension(); CIWavefunction.get_opdm(); CIWavefunction.get_orbitals(); CIWavefunction.get_tpdm(); CIWavefunction.hamiltonian(); CIWavefunction.mcscf_object(); CIWavefunction.ndet(); CIWavefunction.new_civector(); CIWavefunction.opdm(); CIWavefunction.pitzer_to_ci_order_onel(); CIWavefunction.pitzer_to_ci_order_twoel(); CIWavefunction.print_vector(); CIWavefunction.reset_ci_H0block(); CIWavefunction.rotate_mcscf_integrals(); CIWavefunction.semicanonical_orbs(); CIWavefunction.set_ci_guess(); CIWavefunction.set_orbitals(); CIWavefunction.sigma(); CIWavefunction.tpdm(); CIWavefunction.transform_ci_integrals(); CIWavefunction.transform_mcscf_integrals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CIWavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CIWavefunction.html:4039,Integrability,contract,contract,4039,"ulations.; Jroot (int)  The index of the root in the ket. Select -1 for the same as Iroot.; Always use -1 for single-state calculations.; spin (str)  {A, B, SUM}; Return the alpha density matrix, the beta density matrix, or their sum?; full_space (bool)  Return a density matrix in the space of all orbitals (true) or the active orbitals (false)?. Returns:; The selected one-particle density/transition matrix with Pitzer-ordered orbitals.; Irrep h of the matrix corresponds to orbitals of irrep h.; Element pq is <|a^p a_q|>. Return type:; Matrix. get_orbitals(self: psi4.core.CIWavefunction, arg0: str)  psi4.core.Matrix; docstring. get_tpdm(self: psi4.core.CIWavefunction, spin: str, symmetrize: bool)  psi4.core.Matrix; Returns the two-particle density matrix. Parameters:. spin (str)  {AA, AB, BB, SUM}; Which spin-block of the TPDM should be returned? SUM sums over all possible spin cases.; symmetrize (bool)  Return a genuine TPDM element (false) or an average of TPDM elements that contract with the same integral (true)?; Only working for SUM. Returns:; The two-particle density matrix with Pitzer-ordered orbitals, restricted to the active space.; If symmetrize is false, element pqrs is <|a^p a^r a_s a_q|>.; If symmetrize is true, element pqrs is obtained by summing over all flips of p/s, q/r, and multiplying by 0.5. Return type:; Matrix. hamiltonian(self: psi4.core.CIWavefunction, arg0: int)  psi4.core.Matrix; docstring. mcscf_object(self: psi4.core.CIWavefunction)  psi4.core.SOMCSCF; docstring. ndet(self: psi4.core.CIWavefunction)  int; docstring. new_civector(self: psi4.core.CIWavefunction, arg0: int, arg1: int, arg2: bool, arg3: bool)  psi4.core.CIVector; docstring. opdm(self: psi4.core.CIWavefunction, arg0: psi4.core.CIVector, arg1: psi4.core.CIVector, arg2: int, arg3: int)  List[psi4.core.Matrix]; docstring. pitzer_to_ci_order_onel(self: psi4.core.CIWavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Vector)  None; docstri",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CIWavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CIWavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean.html:436,Deployability,update,updated,436,". clean. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean. clean. psi4.core.clean()  None; Remove scratch files. Call between independent jobs. table of contents. clean; clean(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.clean.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean_options.html:469,Deployability,update,updated,469,". clean_options. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean_options. clean_options. psi4.core.clean_options()  None; Reset options to clean state. table of contents. clean_options; clean_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean_options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.clean_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean_options.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean_timers.html:544,Deployability,update,updated,544,". clean_timers. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean_timers. clean_timers. psi4.core.clean_timers()  None; Reinitialize timers for independent timer.dat entries. Vital when earlier independent calc finished improperly. table of contents. clean_timers; clean_timers(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean_timers.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.clean_timers.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean_timers.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean_variables.html:532,Deployability,update,updated,532,". clean_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean_variables. clean_variables. psi4.core.clean_variables()  None; Empties all double and Matrix QCVariables that have been set in global memory. table of contents. clean_variables; clean_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; clean_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.clean_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.clean_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.close_outfile.html:463,Deployability,update,updated,463,". close_outfile. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; close_outfile. close_outfile. psi4.core.close_outfile()  None; Closes the output file. table of contents. close_outfile; close_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; close_outfile.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.close_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.close_outfile.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CompositeJK.html:1237,Deployability,update,updated,1237,". CompositeJK. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK. CompositeJK. class psi4.core.CompositeJK; Bases: JK; docstring; Methods Summary. clear_D_prev(self); Clear previous D matrices. do_incfock_iter(self); Was the last Fock build incremental?. get_COSX_grid(self); Return grid used for COSX for this SCF iteration. set_COSX_grid(self,arg0); Set grid to use for COSX for this SCF iteration. Methods Documentation. clear_D_prev(self: psi4.core.CompositeJK)  None; Clear previous D matrices. do_incfock_iter(self: psi4.core.CompositeJK)  bool; Was the last Fock build incremental?. get_COSX_grid(self: psi4.core.CompositeJK)  str; Return grid used for COSX for this SCF iteration. set_COSX_grid(self: psi4.core.CompositeJK, arg0: str)  None; Set grid to use for COSX for this SCF iteration. table of contents. CompositeJK; CompositeJK; CompositeJK.clear_D_prev(); CompositeJK.do_incfock_iter(); CompositeJK.get_COSX_grid(); CompositeJK.set_COSX_grid(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CompositeJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CompositeJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CompositeJK.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationFactor.html:772,Deployability,update,updated,772,". CorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor. CorrelationFactor. class psi4.core.CorrelationFactor; Bases: pybind11_object; docstring; Methods Summary. set_params(self,coeff,exponent); Set coefficient and exponent. Methods Documentation. set_params(self: psi4.core.CorrelationFactor, coeff: psi4.core.Vector, exponent: psi4.core.Vector)  None; Set coefficient and exponent. table of contents. CorrelationFactor; CorrelationFactor; CorrelationFactor.set_params(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CorrelationFactor.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationFactor.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationTable.html:2120,Deployability,update,updated,2120,"ses: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationTable.html:571,Energy Efficiency,reduce,reduced,571,". CorrelationTable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable. CorrelationTable. class psi4.core.CorrelationTable; Bases: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationTable.html:1373,Energy Efficiency,reduce,reduced,1373,"ses: pybind11_object; Provides a correlation table between two point groups; Methods Summary. degen(self,arg0); Returns the degenercy of the irrep. group(*args,**kwargs); Overloaded function. n(self); Returns the number of irreps in high order group. ngamma(self,arg0); Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self,arg0); Returns the degeneracy of the subgroup irrep. subgroup(self); Returns lower order pointgroup. subn(self); Returns number of irreps in subgroup. Methods Documentation. degen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degenercy of the irrep. group(*args, **kwargs); Overloaded function. group(self: psi4.core.CorrelationTable) -> psi4.core.PointGroup. Returns higher order point group. group(self: psi4.core.CorrelationTable, arg0: int, arg1: int) -> int. Returns the higher order point group. n(self: psi4.core.CorrelationTable)  int; Returns the number of irreps in high order group. ngamma(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the number of irreps in the low order group that an irrep from the high order group can be reduced to. subdegen(self: psi4.core.CorrelationTable, arg0: int)  int; Returns the degeneracy of the subgroup irrep. subgroup(self: psi4.core.CorrelationTable)  psi4.core.PointGroup; Returns lower order pointgroup. subn(self: psi4.core.CorrelationTable)  int; Returns number of irreps in subgroup. table of contents. CorrelationTable; CorrelationTable; CorrelationTable.degen(); CorrelationTable.group(); CorrelationTable.n(); CorrelationTable.ngamma(); CorrelationTable.subdegen(); CorrelationTable.subgroup(); CorrelationTable.subn(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CorrelationTable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CorrelationTable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CorrelationTable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CubeProperties.html:1793,Deployability,update,updated,1793,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CubeProperties.html:533,Integrability,wrap,wrapper,533,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CubeProperties.html:1183,Integrability,wrap,wrapper,1183,". CubeProperties. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties. CubeProperties. class psi4.core.CubeProperties; Bases: pybind11_object; docstring; Methods Summary. basisset(self); Returns orbital/primary basis set associated with cubeprop. compute_density(self,D,key); Compute and dump a cube file for a density matrix. compute_orbitals(self,C,indices,labels,key); Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self); Compute all relevant properties from options object specifications. Methods Documentation. basisset(self: psi4.core.CubeProperties)  psi4.core.BasisSet; Returns orbital/primary basis set associated with cubeprop. compute_density(self: psi4.core.CubeProperties, D: psi4.core.Matrix, key: str)  None; Compute and dump a cube file for a density matrix. compute_orbitals(self: psi4.core.CubeProperties, C: psi4.core.Matrix, indices: List[int], labels: List[str], key: str)  None; Compute and dump a cube file for a set of orbitals. compute_properties(); Filesystem wrapper for CubeProperties::raw_compute_properties. raw_compute_properties(self: psi4.core.CubeProperties)  None; Compute all relevant properties from options object specifications. table of contents. CubeProperties; CubeProperties; CubeProperties.basisset(); CubeProperties.compute_density(); CubeProperties.compute_orbitals(); CubeProperties.compute_properties(); CubeProperties.raw_compute_properties(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CubeProperties.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CubeProperties.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CubeProperties.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.CUHF.html:1301,Deployability,update,updated,1301,". CUHF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CUHF. CUHF. class psi4.core.CUHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring :rtype: float. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. Methods Documentation. c1_deep_copy(self: psi4.core.CUHF, basis: psi4.core.BasisSet)  psi4.core.CUHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring; :rtype: float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . Return type:; float. diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.CUHF)  psi4.core.MintsHelper; The MintsHelper object. table of contents. CUHF; CUHF; CUHF.c1_deep_copy(); CUHF.compute_orbital_gradient(); CUHF.diis(); CUHF.mintshelper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; CUHF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.CUHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.CUHF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DASUM.html:445,Deployability,update,updated,445,". DASUM. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DASUM. DASUM. psi4.core.DASUM(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. table of contents. DASUM; DASUM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DASUM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DASUM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DASUM.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DAXPY.html:487,Deployability,update,updated,487,". DAXPY. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DAXPY. DAXPY. psi4.core.DAXPY(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int, arg5: psi::Vector, arg6: int)  None; docstring. table of contents. DAXPY; DAXPY(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DAXPY.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DAXPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DAXPY.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DCOPY.html:474,Deployability,update,updated,474,". DCOPY. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DCOPY. DCOPY. psi4.core.DCOPY(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. table of contents. DCOPY; DCOPY(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DCOPY.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DCOPY.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DCOPY.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dct.html:470,Deployability,update,updated,470,". dct. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dct. dct. psi4.core.dct(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density cumulant (functional) theory code. table of contents. dct; dct(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dct.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dct.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dct.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DDOT.html:468,Deployability,update,updated,468,". DDOT. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DDOT. DDOT. psi4.core.DDOT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  float; docstring. table of contents. DDOT; DDOT(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DDOT.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DDOT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DDOT.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.del_array_variable.html:559,Deployability,update,updated,559,". del_array_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable. del_array_variable. psi4.core.del_array_variable(key: str)  None; Removes the Matrix QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_array_variable; del_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; del_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.del_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.del_array_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.del_scalar_variable.html:566,Deployability,update,updated,566,". del_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable. del_scalar_variable. psi4.core.del_scalar_variable(key: str)  None; Removes the double QCVariable key (case-insensitive); prefer del_variable(). table of contents. del_scalar_variable; del_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; del_scalar_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.del_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.del_scalar_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.del_variable.html:621,Deployability,update,updated,621,". del_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; del_variable. del_variable. psi4.core.del_variable(key); Removes scalar or array QCVariable key from global memory if present.; :rtype: None. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; None. table of contents. del_variable; del_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; del_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.del_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.del_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Deriv.html:1698,Deployability,update,updated,1698,". Deriv. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Deriv. Deriv. class psi4.core.Deriv; Bases: pybind11_object; Computes gradients of wavefunctions; Methods Summary. compute(self,deriv_calc_type); Compute the gradient. compute_df(self,arg0,arg1); Compute the density-fitted gradient. set_deriv_density_backtransformed(self[,val]); Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self[,val]); Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self[,val]); Is the TPDM already presorted? Default is False. Methods Documentation. compute(self: psi4.core.Deriv, deriv_calc_type: psi4.core.DerivCalcType = <DerivCalcType.Default: 0>)  psi4.core.Matrix; Compute the gradient. compute_df(self: psi4.core.Deriv, arg0: str, arg1: str)  psi4.core.Matrix; Compute the density-fitted gradient. set_deriv_density_backtransformed(self: psi4.core.Deriv, val: bool = False)  None; Is the deriv_density already backtransformed? Default is False. set_ignore_reference(self: psi4.core.Deriv, val: bool = False)  None; Ignore reference contributions to the gradient? Default is False. set_tpdm_presorted(self: psi4.core.Deriv, val: bool = False)  None; Is the TPDM already presorted? Default is False. table of contents. Deriv; Deriv; Deriv.compute(); Deriv.compute_df(); Deriv.set_deriv_density_backtransformed(); Deriv.set_ignore_reference(); Deriv.set_tpdm_presorted(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Deriv.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Deriv.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Deriv.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DerivCalcType.html:841,Deployability,update,updated,841,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DerivCalcType.html:242,Testability,log,logic,242,". DerivCalcType. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType. DerivCalcType. class psi4.core.DerivCalcType; Bases: pybind11_object; Members:; Default : Use internal logic.; Correlated : Correlated methods that write RDMs and Lagrangian to disk.; Attributes Summary. Correlated. Default. name. value. Attributes Documentation. Correlated = <DerivCalcType.Correlated: 1>. Default = <DerivCalcType.Default: 0>. name. value. table of contents. DerivCalcType; DerivCalcType; DerivCalcType.Correlated; DerivCalcType.Default; DerivCalcType.name; DerivCalcType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DerivCalcType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DerivCalcType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DerivCalcType.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.detci.html:232,Deployability,configurat,configuration,232,". detci. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.detci.html:491,Deployability,update,updated,491,". detci. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.detci.html:232,Modifiability,config,configuration,232,". detci. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; detci. detci. psi4.core.detci(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the determinant-based configuration interaction code. table of contents. detci; detci(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; detci.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.detci.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.detci.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html:866,Deployability,update,updated,866,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html:357,Energy Efficiency,energy,energy,357,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html:545,Energy Efficiency,energy,energy,545,". DFEP2Wavefunction. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction. DFEP2Wavefunction. class psi4.core.DFEP2Wavefunction; Bases: Wavefunction; A density-fitted second-order Electron Propagator Wavefunction.; Methods Summary. compute(self,arg0); Computes the density-fitted EP2 energy for the input orbitals. Methods Documentation. compute(self: psi4.core.DFEP2Wavefunction, arg0: List[List[int]])  List[List[Tuple[float, float]]]; Computes the density-fitted EP2 energy for the input orbitals. table of contents. DFEP2Wavefunction; DFEP2Wavefunction; DFEP2Wavefunction.compute(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFEP2Wavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFEP2Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFHelper.html:3477,Deployability,update,updated,3477,"verloaded function. get_tensor(self: psi4.core.DFHelper, arg0: str) -> psi4.core.Matrix; get_tensor(self: psi4.core.DFHelper, arg0: str, arg1: List[int], arg2: List[int], arg3: List[int]) -> psi4.core.Matrix. get_tensor_shape(self: psi4.core.DFHelper, arg0: str)  Tuple[int, int, int]. get_tensor_size(self: psi4.core.DFHelper, arg0: str)  int. hold_met(self: psi4.core.DFHelper, arg0: bool)  None. initialize(self: psi4.core.DFHelper)  None. print_header(self: psi4.core.DFHelper)  None. set_AO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_MO_core(self: psi4.core.DFHelper, arg0: bool)  None. set_memory(self: psi4.core.DFHelper, arg0: int)  None. set_method(self: psi4.core.DFHelper, arg0: str)  None. set_nthreads(self: psi4.core.DFHelper, arg0: int)  None. set_schwarz_cutoff(self: psi4.core.DFHelper, arg0: float)  None. set_subalgo(self: psi4.core.DFHelper, arg0: str)  None. transform(self: psi4.core.DFHelper)  None. transpose(self: psi4.core.DFHelper, arg0: str, arg1: Tuple[int, int, int])  None. table of contents. DFHelper; DFHelper; DFHelper.add_space(); DFHelper.add_transformation(); DFHelper.clear_all(); DFHelper.clear_spaces(); DFHelper.get_AO_core(); DFHelper.get_AO_size(); DFHelper.get_MO_core(); DFHelper.get_memory(); DFHelper.get_method(); DFHelper.get_schwarz_cutoff(); DFHelper.get_space_size(); DFHelper.get_tensor(); DFHelper.get_tensor_shape(); DFHelper.get_tensor_size(); DFHelper.hold_met(); DFHelper.initialize(); DFHelper.print_header(); DFHelper.set_AO_core(); DFHelper.set_MO_core(); DFHelper.set_memory(); DFHelper.set_method(); DFHelper.set_nthreads(); DFHelper.set_schwarz_cutoff(); DFHelper.set_subalgo(); DFHelper.transform(); DFHelper.transpose(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DFHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dfmp2.html:454,Deployability,update,updated,454,". dfmp2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dfmp2. dfmp2. psi4.core.dfmp2(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DF-MP2 code. table of contents. dfmp2; dfmp2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dfmp2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dfmp2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dfmp2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dfocc.html:484,Deployability,update,updated,484,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dfocc.html:237,Performance,optimiz,optimized,237,". dfocc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dfocc. dfocc. psi4.core.dfocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the density-fitted orbital optimized CC codes. table of contents. dfocc; dfocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dfocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dfocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dfocc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFSOMCSCF.html:433,Deployability,update,updated,433,". DFSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF. DFSOMCSCF. class psi4.core.DFSOMCSCF; Bases: SOMCSCF; docstring. table of contents. DFSOMCSCF; DFSOMCSCF. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFSOMCSCF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DFSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFSOMCSCF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFTensor.html:1180,Deployability,update,updated,1180,". DFTensor. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFTensor. DFTensor. class psi4.core.DFTensor; Bases: pybind11_object; docstring; Methods Summary. Idfmo(self); doctsring. Imo(self); doctsring. Qmo(self); doctsring. Qoo(self); doctsring. Qov(self); doctsring. Qso(self); doctsring. Qvv(self); doctsring. Methods Documentation. Idfmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Imo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qmo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qoo(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qov(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qso(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. Qvv(self: psi4.core.DFTensor)  psi4.core.Matrix; doctsring. table of contents. DFTensor; DFTensor; DFTensor.Idfmo(); DFTensor.Imo(); DFTensor.Qmo(); DFTensor.Qoo(); DFTensor.Qov(); DFTensor.Qso(); DFTensor.Qvv(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFTensor.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DFTensor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFTensor.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFTGrid.html:784,Deployability,update,updated,784,". DFTGrid. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid. DFTGrid. class psi4.core.DFTGrid; Bases: MolecularGrid; docstring; Methods Summary. build(*args,**kwargs); Overloaded function. Methods Documentation. static build(*args, **kwargs); Overloaded function. build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet) -> psi4.core.DFTGrid; build(arg0: psi4.core.Molecule, arg1: psi4.core.BasisSet, arg2: Dict[str, int], arg3: Dict[str, str]) -> psi4.core.DFTGrid. table of contents. DFTGrid; DFTGrid; DFTGrid.build(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DFTGrid.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DFTGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DFTGrid.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGBMV.html:578,Deployability,update,updated,578,". DGBMV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGBMV. DGBMV. psi4.core.DGBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int, arg11: float, arg12: psi::Vector, arg13: int)  None; docstring. table of contents. DGBMV; DGBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGBMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGBMV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGEEV.html:597,Deployability,update,updated,597,". DGEEV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGEEV. DGEEV. psi4.core.DGEEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int, arg12: psi::Vector, arg13: int)  int; docstring. table of contents. DGEEV; DGEEV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGEEV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGEEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGEEV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGEMM.html:578,Deployability,update,updated,578,". DGEMM. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGEMM. DGEMM. psi4.core.DGEMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: int, arg6: float, arg7: psi::Matrix, arg8: int, arg9: psi::Matrix, arg10: int, arg11: float, arg12: psi::Matrix, arg13: int)  None; docstring. table of contents. DGEMM; DGEMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGEMM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGEMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGEMM.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGEMV.html:554,Deployability,update,updated,554,". DGEMV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGEMV. DGEMV. psi4.core.DGEMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. table of contents. DGEMV; DGEMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGEMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGEMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGEMV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGER.html:521,Deployability,update,updated,521,". DGER. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGER. DGER. psi4.core.DGER(arg0: int, arg1: int, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. table of contents. DGER; DGER(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGER.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGER.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGER.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGETRF.html:483,Deployability,update,updated,483,". DGETRF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGETRF. DGETRF. psi4.core.DGETRF(arg0: int, arg1: int, arg2: int, arg3: psi::Matrix, arg4: int, arg5: psi::IntVector)  int; docstring. table of contents. DGETRF; DGETRF(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGETRF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGETRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGETRF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGETRI.html:502,Deployability,update,updated,502,". DGETRI. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGETRI. DGETRI. psi4.core.DGETRI(arg0: int, arg1: int, arg2: psi::Matrix, arg3: int, arg4: psi::IntVector, arg5: psi::Vector, arg6: int)  int; docstring. table of contents. DGETRI; DGETRI(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGETRI.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGETRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGETRI.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGETRS.html:524,Deployability,update,updated,524,". DGETRS. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGETRS. DGETRS. psi4.core.DGETRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int)  int; docstring. table of contents. DGETRS; DGETRS(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DGETRS.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DGETRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DGETRS.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DiagonalizeOrder.html:862,Deployability,update,updated,862,". DiagonalizeOrder. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder. DiagonalizeOrder. class psi4.core.DiagonalizeOrder; Bases: pybind11_object; Defines ordering of eigenvalues after diagonalization; Members:. Ascending; Descending. Attributes Summary. Ascending. Descending. name. value. Attributes Documentation. Ascending = <DiagonalizeOrder.Ascending: 1>. Descending = <DiagonalizeOrder.Descending: 3>. name. value. table of contents. DiagonalizeOrder; DiagonalizeOrder; DiagonalizeOrder.Ascending; DiagonalizeOrder.Descending; DiagonalizeOrder.name; DiagonalizeOrder.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DiagonalizeOrder.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DiagonalizeOrder.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DiagonalizeOrder.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Dimension.html:2745,Deployability,update,updated,2745," the dimension. Used in printing. Methods Documentation. fill(self: psi4.core.Dimension, val: int)  None; Fill all elements with given value. classmethod from_list(dims, name='New Dimension'); Builds a Dimension object from a Python list or tuple. If a Dimension object is passed, a copy will be returned.; :rtype: Dimension. Parameters:. dims (Union[Tuple[int], List[int], ndarray, Dimension])  Iterable of integers defining irrep dimensions.; name  Name for new instance. Return type:; Dimension. init(self: psi4.core.Dimension, arg0: int, arg1: str)  None; Re-initializes the dimension object. max(*args, **kwargs); Overloaded function. max(self: psi4.core.Dimension) -> int. Gets the maximum value from the dimension object. max(self: psi4.core.Dimension) -> int. Return the maximum element. n(self: psi4.core.Dimension)  int; The order of the dimension. print_out(self: psi4.core.Dimension)  None; Print out the dimension object to the output file. sum(*args, **kwargs); Overloaded function. sum(self: psi4.core.Dimension) -> int. Gets the sum of the values in the dimension object. sum(self: psi4.core.Dimension) -> int. Return the sum of constituent dimensions. to_tuple(); Serializes Dimension to a tuple.; :rtype: Tuple[int]. Parameters:; self (Dimension)  . Return type:; Tuple[int]. zero(*args, **kwargs); Overloaded function. zero(self: psi4.core.Dimension) -> None. Zeros all values in the dimension object. zero(self: psi4.core.Dimension) -> None. Zero all elements. table of contents. Dimension; Dimension; Dimension.name; Dimension.fill(); Dimension.from_list(); Dimension.init(); Dimension.max(); Dimension.n(); Dimension.print_out(); Dimension.sum(); Dimension.to_tuple(); Dimension.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Dimension.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Dimension.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Dimension.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DipoleInt.html:454,Deployability,update,updated,454,". DipoleInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt. DipoleInt. class psi4.core.DipoleInt; Bases: OneBodyAOInt; Computes dipole integrals. table of contents. DipoleInt; DipoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DipoleInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DipoleInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DirectJK.html:639,Deployability,update,updated,639,". DirectJK. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DirectJK. DirectJK. class psi4.core.DirectJK; Bases: JK; docstring; Methods Summary. do_incfock_iter(self); Was the last Fock build incremental?. Methods Documentation. do_incfock_iter(self: psi4.core.DirectJK)  bool; Was the last Fock build incremental?. table of contents. DirectJK; DirectJK; DirectJK.do_incfock_iter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DirectJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DirectJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DirectJK.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DiskSOMCSCF.html:447,Deployability,update,updated,447,". DiskSOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF. DiskSOMCSCF. class psi4.core.DiskSOMCSCF; Bases: SOMCSCF; docstring. table of contents. DiskSOMCSCF; DiskSOMCSCF. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DiskSOMCSCF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DiskSOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DiskSOMCSCF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Dispersion.html:3509,Deployability,update,updated,3509," compute_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. compute_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  psi4.core.Matrix; docstring. d(self: psi4.core.Dispersion)  float; docstring. description(self: psi4.core.Dispersion)  str; docstring. name(self: psi4.core.Dispersion)  str; docstring. print_energy(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_gradient(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_hessian(self: psi4.core.Dispersion, arg0: psi4.core.Molecule)  str; docstring. print_out(self: psi4.core.Dispersion)  None; docstring. s6(self: psi4.core.Dispersion)  float; docstring. s8(self: psi4.core.Dispersion)  float; docstring. set_bibtex(self: psi4.core.Dispersion, arg0: str)  None; Set the BibTeX key for the literature reference. set_citation(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_description(self: psi4.core.Dispersion, arg0: str)  None; docstring. set_name(self: psi4.core.Dispersion, arg0: str)  None; docstring. sr6(self: psi4.core.Dispersion)  float; docstring. table of contents. Dispersion; Dispersion; Dispersion.a1(); Dispersion.a2(); Dispersion.bibtex(); Dispersion.build(); Dispersion.citation(); Dispersion.compute_energy(); Dispersion.compute_gradient(); Dispersion.compute_hessian(); Dispersion.d(); Dispersion.description(); Dispersion.name(); Dispersion.print_energy(); Dispersion.print_gradient(); Dispersion.print_hessian(); Dispersion.print_out(); Dispersion.s6(); Dispersion.s8(); Dispersion.set_bibtex(); Dispersion.set_citation(); Dispersion.set_description(); Dispersion.set_name(); Dispersion.sr6(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Dispersion.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Dispersion.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dlpno.html:451,Deployability,update,updated,451,". dlpno. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dlpno. dlpno. psi4.core.dlpno(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the DLPNO codes. table of contents. dlpno; dlpno(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dlpno.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dlpno.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dlpno.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dmrg.html:446,Deployability,update,updated,446,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dmrg.html:201,Integrability,interface,interface,201,". dmrg. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dmrg. dmrg. psi4.core.dmrg(ref_wfn: psi4.core.Wavefunction)  float; Runs the CheMPS2 interface DMRG code. table of contents. dmrg; dmrg(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dmrg.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dmrg.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dmrg.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DNRM2.html:445,Deployability,update,updated,445,". DNRM2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DNRM2. DNRM2. psi4.core.DNRM2(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  float; docstring. table of contents. DNRM2; DNRM2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DNRM2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DNRM2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DNRM2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.doublet.html:588,Deployability,update,updated,588,". doublet. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; doublet. doublet. psi4.core.doublet(A: psi4.core.Matrix, B: psi4.core.Matrix, transA: bool = False, transB: bool = False)  psi4.core.Matrix; Returns the multiplication of two matrices A and B, with options to transpose each beforehand. table of contents. doublet; doublet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; doublet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.doublet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.doublet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dpdbuf4.html:1121,Deployability,update,updated,1121,". dpdbuf4. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4. dpdbuf4. class psi4.core.dpdbuf4; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all with entries. Methods Documentation. axpy_matrix(self: psi4.core.dpdbuf4, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdbuf4)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdbuf4)  int; Fill all with entries. table of contents. dpdbuf4; dpdbuf4; dpdbuf4.axpy_matrix(); dpdbuf4.coldim(); dpdbuf4.rowdim(); dpdbuf4.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dpdbuf4.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dpdbuf4.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dpdbuf4.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dpdfile2.html:1150,Deployability,update,updated,1150,". dpdfile2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2. dpdfile2. class psi4.core.dpdfile2; Bases: pybind11_object; docstring; Methods Summary. axpy_matrix(self,arg0,arg1); Add 'a' times a Matrix to this. coldim(self); Return the dimensions of the column index. rowdim(self); Return the dimensions of the row index. zero(self); Fill all entries with zeroes. Methods Documentation. axpy_matrix(self: psi4.core.dpdfile2, arg0: psi4.core.Matrix, arg1: float)  int; Add a times a Matrix to this. coldim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the column index. rowdim(self: psi4.core.dpdfile2)  psi4.core.Dimension; Return the dimensions of the row index. zero(self: psi4.core.dpdfile2)  int; Fill all entries with zeroes. table of contents. dpdfile2; dpdfile2; dpdfile2.axpy_matrix(); dpdfile2.coldim(); dpdfile2.rowdim(); dpdfile2.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dpdfile2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dpdfile2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dpdfile2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DPOTRF.html:461,Deployability,update,updated,461,". DPOTRF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF. DPOTRF. psi4.core.DPOTRF(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. table of contents. DPOTRF; DPOTRF(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DPOTRF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DPOTRF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DPOTRF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DPOTRI.html:461,Deployability,update,updated,461,". DPOTRI. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI. DPOTRI. psi4.core.DPOTRI(arg0: int, arg1: str, arg2: int, arg3: psi::Matrix, arg4: int)  int; docstring. table of contents. DPOTRI; DPOTRI(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DPOTRI.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DPOTRI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DPOTRI.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DPOTRS.html:502,Deployability,update,updated,502,". DPOTRS. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS. DPOTRS. psi4.core.DPOTRS(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Matrix, arg7: int)  int; docstring. table of contents. DPOTRS; DPOTRS(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DPOTRS.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DPOTRS.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DPOTRS.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DROT.html:493,Deployability,update,updated,493,". DROT. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DROT. DROT. psi4.core.DROT(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int, arg6: float, arg7: float)  None; docstring. table of contents. DROT; DROT(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DROT.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DROT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DROT.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSBMV.html:554,Deployability,update,updated,554,". DSBMV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSBMV. DSBMV. psi4.core.DSBMV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: float, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int, arg9: float, arg10: psi::Vector, arg11: int)  None; docstring. table of contents. DSBMV; DSBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSBMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSBMV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSCAL.html:457,Deployability,update,updated,457,". DSCAL. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSCAL. DSCAL. psi4.core.DSCAL(arg0: int, arg1: int, arg2: float, arg3: psi::Vector, arg4: int)  None; docstring. table of contents. DSCAL; DSCAL(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSCAL.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSCAL.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSCAL.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSWAP.html:474,Deployability,update,updated,474,". DSWAP. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSWAP. DSWAP. psi4.core.DSWAP(arg0: int, arg1: int, arg2: psi::Vector, arg3: int, arg4: psi::Vector, arg5: int)  None; docstring. table of contents. DSWAP; DSWAP(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSWAP.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSWAP.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSWAP.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYEV.html:514,Deployability,update,updated,514,". DSYEV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYEV. DSYEV. psi4.core.DSYEV(arg0: int, arg1: str, arg2: str, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: psi::Vector, arg8: int)  int; docstring. table of contents. DSYEV; DSYEV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYEV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYEV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYEV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYMM.html:566,Deployability,update,updated,566,". DSYMM. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYMM. DSYMM. psi4.core.DSYMM(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. table of contents. DSYMM; DSYMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYMM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYMM.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYMV.html:542,Deployability,update,updated,542,". DSYMV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYMV. DSYMV. psi4.core.DSYMV(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Matrix, arg5: int, arg6: psi::Vector, arg7: int, arg8: float, arg9: psi::Vector, arg10: int)  None; docstring. table of contents. DSYMV; DSYMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYMV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYR.html:491,Deployability,update,updated,491,". DSYR. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYR. DSYR. psi4.core.DSYR(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Matrix, arg7: int)  None; docstring. table of contents. DSYR; DSYR(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYR.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYR.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYR.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYR2.html:528,Deployability,update,updated,528,". DSYR2. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYR2. DSYR2. psi4.core.DSYR2(arg0: int, arg1: str, arg2: int, arg3: float, arg4: psi::Vector, arg5: int, arg6: psi::Vector, arg7: int, arg8: psi::Matrix, arg9: int)  None; docstring. table of contents. DSYR2; DSYR2(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYR2.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYR2.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYR2.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYR2K.html:573,Deployability,update,updated,573,". DSYR2K. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K. DSYR2K. psi4.core.DSYR2K(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: psi::Matrix, arg9: int, arg10: float, arg11: psi::Matrix, arg12: int)  None; docstring. table of contents. DSYR2K; DSYR2K(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYR2K.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYR2K.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYR2K.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYRK.html:534,Deployability,update,updated,534,". DSYRK. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYRK. DSYRK. psi4.core.DSYRK(arg0: int, arg1: str, arg2: str, arg3: int, arg4: int, arg5: float, arg6: psi::Matrix, arg7: int, arg8: float, arg9: psi::Matrix, arg10: int)  None; docstring. table of contents. DSYRK; DSYRK(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYRK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYRK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYRK.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYSV.html:548,Deployability,update,updated,548,". DSYSV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYSV. DSYSV. psi4.core.DSYSV(arg0: int, arg1: str, arg2: int, arg3: int, arg4: psi::Matrix, arg5: int, arg6: psi::IntVector, arg7: psi::Matrix, arg8: int, arg9: psi::Vector, arg10: int)  int; docstring. table of contents. DSYSV; DSYSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DSYSV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DSYSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DSYSV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTBMV.html:518,Deployability,update,updated,518,". DTBMV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTBMV. DTBMV. psi4.core.DTBMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. table of contents. DTBMV; DTBMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTBMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DTBMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTBMV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTBSV.html:518,Deployability,update,updated,518,". DTBSV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTBSV. DTBSV. psi4.core.DTBSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: int, arg6: psi::Matrix, arg7: int, arg8: psi::Vector, arg9: int)  None; docstring. table of contents. DTBSV; DTBSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTBSV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DTBSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTBSV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRMM.html:544,Deployability,update,updated,544,". DTRMM. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRMM. DTRMM. psi4.core.DTRMM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. table of contents. DTRMM; DTRMM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRMM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DTRMM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRMM.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRMV.html:507,Deployability,update,updated,507,". DTRMV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRMV. DTRMV. psi4.core.DTRMV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. table of contents. DTRMV; DTRMV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRMV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DTRMV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRMV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRSM.html:544,Deployability,update,updated,544,". DTRSM. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRSM. DTRSM. psi4.core.DTRSM(arg0: int, arg1: str, arg2: str, arg3: str, arg4: str, arg5: int, arg6: int, arg7: float, arg8: psi::Matrix, arg9: int, arg10: psi::Matrix, arg11: int)  None; docstring. table of contents. DTRSM; DTRSM(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRSM.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DTRSM.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRSM.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRSV.html:507,Deployability,update,updated,507,". DTRSV. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRSV. DTRSV. psi4.core.DTRSV(arg0: int, arg1: str, arg2: str, arg3: str, arg4: int, arg5: psi::Matrix, arg6: int, arg7: psi::Vector, arg8: int)  None; docstring. table of contents. DTRSV; DTRSV(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; DTRSV.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.DTRSV.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.DTRSV.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.dummy_einsums.html:506,Deployability,update,updated,506,". dummy_einsums. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dummy_einsums. dummy_einsums. psi4.core.dummy_einsums(ref_wfn: psi4.core.Wavefunction)  float; Runs the einsums placeholder code. table of contents. dummy_einsums; dummy_einsums(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; dummy_einsums.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.dummy_einsums.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.dummy_einsums.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ElectricFieldInt.html:511,Deployability,update,updated,511,". ElectricFieldInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt. ElectricFieldInt. class psi4.core.ElectricFieldInt; Bases: OneBodyAOInt; Computes electric field integrals. table of contents. ElectricFieldInt; ElectricFieldInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ElectricFieldInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ElectricFieldInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ElectricFieldInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ElectrostaticInt.html:510,Deployability,update,updated,510,". ElectrostaticInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt. ElectrostaticInt. class psi4.core.ElectrostaticInt; Bases: OneBodyAOInt; Computes electrostatic integrals. table of contents. ElectrostaticInt; ElectrostaticInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ElectrostaticInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ElectrostaticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ElectrostaticInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ERI.html:435,Deployability,update,updated,435,". ERI. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ERI. ERI. class psi4.core.ERI; Bases: TwoBodyAOInt; Computes normal two electron repulsion integrals. table of contents. ERI; ERI. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ERI.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ERI.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ERI.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ERISieve.html:1844,Deployability,update,updated,1844,". ERISieve. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ERISieve. ERISieve. class psi4.core.ERISieve; Bases: pybind11_object; docstring; Methods Summary. build(orbital_basis[,cutoff,do_csam]); This function previously constructed a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for ERI screening and an optional input to enable CSAM screening (over Schwarz screening). shell_significant(self,arg0,arg1,arg2,arg3). Methods Documentation. static build(orbital_basis, cutoff=0.0, do_csam=False); This function previously constructed a Psi4 ERISieve object from an input basis set, with an optional cutoff threshold for; ERI screening and an optional input to enable CSAM screening (over Schwarz screening).; However, as the ERISieve class was removed from Psi4 in v1.9, the function now throws with an UpgradeHelper; exception, and lets the user know to use TwoBodyAOInt instead. Parameters:. orbital_basis (BasisSet)  Basis set to use in the ERISieve object.; cutoff (float)  Integral cutoff threshold to use for Schwarz/CSAM screening. Defaults to 0.0, disabling screening entirely.; do_csam (bool)  Use CSAM screening? If True, CSAM screening is used; else, Schwarz screening is used. By default,; Schwarz screening is utilized. Returns:; Initialized ERISieve object. Return type:; ERISieve. Example; >>> sieve = psi4.core.ERISieve.build(bas, cutoff, csam). shell_significant(self: psi4.core.ERISieve, arg0: int, arg1: int, arg2: int, arg3: int)  bool. table of contents. ERISieve; ERISieve; ERISieve.build(); ERISieve.shell_significant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ERISieve.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ERISieve.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ERISieve.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html:1163,Deployability,update,updated,1163,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html:218,Integrability,rout,routines,218,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html:208,Security,access,access,208,". ESPPropCalc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc. ESPPropCalc. class psi4.core.ESPPropCalc; Bases: Prop; ESPPropCalc gives access to routines calculating the ESP on a grid; Methods Summary. compute_esp_over_grid_in_memory(self,arg0); Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self,arg0); Computes field on specified grid Nx3 (as SharedMatrix). Methods Documentation. compute_esp_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Vector; Computes ESP on specified grid Nx3 (as SharedMatrix). compute_field_over_grid_in_memory(self: psi4.core.ESPPropCalc, arg0: psi4.core.Matrix)  psi4.core.Matrix; Computes field on specified grid Nx3 (as SharedMatrix). table of contents. ESPPropCalc; ESPPropCalc; ESPPropCalc.compute_esp_over_grid_in_memory(); ESPPropCalc.compute_field_over_grid_in_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ESPPropCalc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ESPPropCalc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:3338,Deployability,update,updated,3338,"loat, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:435,Energy Efficiency,charge,charge,435,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Mo",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:502,Energy Efficiency,charge,charge,502,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Mo",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:816,Energy Efficiency,energy,energy,816,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Mo",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:982,Energy Efficiency,charge,charge,982,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Mo",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:1057,Energy Efficiency,charge,charges,1057,"on. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:1448,Energy Efficiency,charge,charge,1448,"y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:1593,Energy Efficiency,charge,charge,1593,"he field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:2069,Energy Efficiency,energy,energy,2069,"mbedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotentia",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:2376,Energy Efficiency,charge,charge,2376,"ents. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Last updat",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:2500,Energy Efficiency,charge,charges,2500,"loat, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:548,Usability,clear,clear,548,". ExternalPotential. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential. ExternalPotential. class psi4.core.ExternalPotential; Bases: pybind11_object; Stores external potential field, computes external potential matrix; Methods Summary. addBasis(self,basis,coefs); Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self,Z,x,y,z); Add a charge Z at (x,y,z). appendCharges(self,arg0); Append a vector of charge tuples to a current ExternalPotential. clear(self); Reset the field to zero (eliminates all entries). computeExternExternInteraction(self,arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Mo",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:1639,Usability,clear,clear,1639,"arg0); Compute the interaction between this potential and other external potential. computeNuclearEnergy(self,arg0); Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self,basis); Compute the external potential matrix in the given basis set. getCharges(self); Get the vector of charge tuples. gradient_on_charges(self); Get the gradient on the embedded charges. print_out(self); Print python print helper to the outfile. setName(self,arg0); Sets the name. Methods Documentation. addBasis(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet, coefs: psi4.core.Vector)  None; Add a basis of S auxiliary functions iwth Df coefficients. addCharge(self: psi4.core.ExternalPotential, Z: float, x: float, y: float, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential,",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html:2854,Usability,clear,clear,2854,"loat, z: float)  None; Add a charge Z at (x,y,z). appendCharges(self: psi4.core.ExternalPotential, arg0: List[Tuple[float, float, float, float]])  None; Append a vector of charge tuples to a current ExternalPotential. clear(self: psi4.core.ExternalPotential)  None; Reset the field to zero (eliminates all entries). computeExternExternInteraction(self: psi4.core.ExternalPotential, arg0: psi4.core.ExternalPotential)  float; Compute the interaction between this potential and other external potential. computeNuclearEnergy(self: psi4.core.ExternalPotential, arg0: psi4.core.Molecule)  float; Compute the contribution to the nuclear repulsion energy for the given molecule. computePotentialMatrix(self: psi4.core.ExternalPotential, basis: psi4.core.BasisSet)  psi4.core.Matrix; Compute the external potential matrix in the given basis set. getCharges(self: psi4.core.ExternalPotential)  List[Tuple[float, float, float, float]]; Get the vector of charge tuples. gradient_on_charges(self: psi4.core.ExternalPotential)  psi4.core.Matrix; Get the gradient on the embedded charges. print_out(self: psi4.core.ExternalPotential)  None; Print python print helper to the outfile. setName(self: psi4.core.ExternalPotential, arg0: str)  None; Sets the name. table of contents. ExternalPotential; ExternalPotential; ExternalPotential.addBasis(); ExternalPotential.addCharge(); ExternalPotential.appendCharges(); ExternalPotential.clear(); ExternalPotential.computeExternExternInteraction(); ExternalPotential.computeNuclearEnergy(); ExternalPotential.computePotentialMatrix(); ExternalPotential.getCharges(); ExternalPotential.gradient_on_charges(); ExternalPotential.print_out(); ExternalPotential.setName(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ExternalPotential.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ExternalPotential.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ExternalPotential.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FCHKWriter.html:1104,Deployability,update,updated,1104,". FCHKWriter. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter. FCHKWriter. class psi4.core.FCHKWriter; Bases: pybind11_object; Extracts information from a wavefunction object, and writes it to an FCHK file; Methods Summary. SCF_Dtot(self). set_postscf_density_label(self,label); Set base label for post-SCF density, e.g. ' CC Density'. write(self,filename); Write wavefunction information to file. Methods Documentation. SCF_Dtot(self: psi4.core.FCHKWriter)  psi4.core.Matrix. set_postscf_density_label(self: psi4.core.FCHKWriter, label: str)  None; Set base label for post-SCF density, e.g.  CC Density. write(self: psi4.core.FCHKWriter, filename: str)  None; Write wavefunction information to file. table of contents. FCHKWriter; FCHKWriter; FCHKWriter.SCF_Dtot(); FCHKWriter.set_postscf_density_label(); FCHKWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FCHKWriter.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FCHKWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FCHKWriter.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.fcidump_tei_helper.html:619,Deployability,update,updated,619,". fcidump_tei_helper. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper. fcidump_tei_helper. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str = 'INTDUMP')  None; Write integrals to file in FCIDUMP format. table of contents. fcidump_tei_helper; fcidump_tei_helper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; fcidump_tei_helper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.fcidump_tei_helper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.fcidump_tei_helper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FDDS_Dispersion.html:2856,Deployability,update,updated,2856,"y AO to auxiliary AO space. Methods Documentation. R_A(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer A. R_B(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains (R^t)^-1 for monomer B. aux_overlap(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS aux_overlap. form_aux_matrices(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  Dict[str, psi4.core.Matrix]; Forms the uncoupled amplitudes and other matrices for either monomer. form_unc_amplitude(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: float)  psi4.core.Matrix; Forms the uncoupled amplitudes for either monomer. get_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: Tuple[int, int, int])  psi4.core.Matrix; Debug only: fetches 3-index intermediate from disk and return as matrix. metric(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric. metric_inv(self: psi4.core.FDDS_Dispersion)  psi4.core.Matrix; Obtains the FDDS metric_inv. print_tensor_pqQ(self: psi4.core.FDDS_Dispersion, arg0: str, arg1: str, arg2: Tuple[int, int, int])  None; Debug only: prints formatted 3-index intermediate to file. project_densities(self: psi4.core.FDDS_Dispersion, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; Projects a density from the primary AO to auxiliary AO space. table of contents. FDDS_Dispersion; FDDS_Dispersion; FDDS_Dispersion.R_A(); FDDS_Dispersion.R_B(); FDDS_Dispersion.aux_overlap(); FDDS_Dispersion.form_aux_matrices(); FDDS_Dispersion.form_unc_amplitude(); FDDS_Dispersion.get_tensor_pqQ(); FDDS_Dispersion.metric(); FDDS_Dispersion.metric_inv(); FDDS_Dispersion.print_tensor_pqQ(); FDDS_Dispersion.project_densities(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FDDS_Dispersion.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FDDS_Dispersion.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FDDS_Dispersion.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.finalize.html:459,Deployability,update,updated,459,". finalize. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; finalize. finalize. psi4.core.finalize()  None; Called upon psi4 module exit to closes timers and I/O. table of contents. finalize; finalize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; finalize.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.finalize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.finalize.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html:4962,Deployability,update,updated,4962,"ISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. unify_part2(self: psi4.core.FISAPT)  None; Finish producing unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FISAPT.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html:390,Energy Efficiency,energy,energy,390,". FISAPT. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FISAPT. FISAPT. class psi4.core.FISAPT; Bases: pybind11_object; A Fragment-SAPT Wavefunction; Methods Summary. coulomb(self); Build the J/K potentials for C, D, and E. dHF(self); SAPT0 delta HF. disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self); Prepare cube files for orbital/density pictures. elst(self); SAPT0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool) ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html:1512,Energy Efficiency,energy,energy,1512,"0 electrostatics. exch(self); SAPT0 exchange. fdisp(self); F-SAPT0 dispersion. felst(self); F-SAPT0 electrostatics. fexch(self); F-SAPT0 exchange. find(self); F-SAPT0 induction. flocalize(self); F-SAPT0 localize. freeze_core(self); Freeze the core orbitals. ind(self); SAPT0 induction. kinetic(self); Build the kinetic integrals T. localize(self); Localize the active occupied orbitals via IBO2. matrices(self); Return the interally computed matrices (not copied). molecule(self); Returns the FISAPT's molecule. nuclear(self); Build the nuclear potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT)  None; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html:2057,Energy Efficiency,energy,energy,2057,"ar potentials V and interaction energies. overlap(self); Build the overlap integrals S. partition(self); Partition the nuclei and electrons. print_header(self); Print header, bases, sizes, etc. print_trailer(self); Print SAPT results. raw_plot(self,arg0); Plot some analysis files. scalars(self); Return the interally computed scalars (not copied). scf(self); Solve the relaxed SCF equations for A0 and B0. sinf_disp(self,arg0,arg1,arg2); Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self); Produce unified matrices for A', B', and C'. unify_part2(self); Finish producing unified matrices for A', B', and C'. vectors(self); Return the interally computed vectors (not copied). Methods Documentation. coulomb(self: psi4.core.FISAPT)  None; Build the J/K potentials for C, D, and E. dHF(self: psi4.core.FISAPT)  None; SAPT0 delta HF. disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy. do_cubes(self: psi4.core.FISAPT)  None; Prepare cube files for orbital/density pictures. elst(self: psi4.core.FISAPT)  None; SAPT0 electrostatics. exch(self: psi4.core.FISAPT)  None; SAPT0 exchange. fdisp(self: psi4.core.FISAPT)  None; F-SAPT0 dispersion. felst(self: psi4.core.FISAPT)  None; F-SAPT0 electrostatics. fexch(self: psi4.core.FISAPT)  None; F-SAPT0 exchange. find(self: psi4.core.FISAPT)  None; F-SAPT0 induction. flocalize(self: psi4.core.FISAPT)  None; F-SAPT0 localize. freeze_core(self: psi4.core.FISAPT)  None; Freeze the core orbitals. ind(self: psi4.core.FISAPT)  None; SAPT0 induction. kinetic(self: psi4.core.FISAPT)  None; Build the kinetic integrals T. localize(self: psi4.core.FISAPT)  None; Localize the active occupied orbitals via IBO2. matrices(self: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molec",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html:3895,Energy Efficiency,energy,energy,3895,"lf: psi4.core.FISAPT)  Dict[str, psi4.core.Matrix]; Return the interally computed matrices (not copied). molecule(self: psi4.core.FISAPT)  psi4.core.Molecule; Returns the FISAPTs molecule. nuclear(self: psi4.core.FISAPT)  None; Build the nuclear potentials V and interaction energies. overlap(self: psi4.core.FISAPT)  None; Build the overlap integrals S. partition(self: psi4.core.FISAPT)  None; Partition the nuclei and electrons. print_header(self: psi4.core.FISAPT)  None; Print header, bases, sizes, etc. print_trailer(self: psi4.core.FISAPT)  None; Print SAPT results. raw_plot(self: psi4.core.FISAPT, arg0: str)  None; Plot some analysis files. scalars(self: psi4.core.FISAPT)  Dict[str, float]; Return the interally computed scalars (not copied). scf(self: psi4.core.FISAPT)  None; Solve the relaxed SCF equations for A0 and B0. sinf_disp(self: psi4.core.FISAPT, arg0: Dict[str, psi4.core.Matrix], arg1: Dict[str, psi4.core.Vector], arg2: bool)  None; Computes the MP2-based DispE20 and Exch-DispE20 energy without S^2. unify(self: psi4.core.FISAPT)  None; Produce unified matrices for A, B, and C. unify_part2(self: psi4.core.FISAPT)  None; Finish producing unified matrices for A, B, and C. vectors(self: psi4.core.FISAPT)  Dict[str, psi4.core.Vector]; Return the interally computed vectors (not copied). table of contents. FISAPT; FISAPT; FISAPT.coulomb(); FISAPT.dHF(); FISAPT.disp(); FISAPT.do_cubes(); FISAPT.elst(); FISAPT.exch(); FISAPT.fdisp(); FISAPT.felst(); FISAPT.fexch(); FISAPT.find(); FISAPT.flocalize(); FISAPT.freeze_core(); FISAPT.ind(); FISAPT.kinetic(); FISAPT.localize(); FISAPT.matrices(); FISAPT.molecule(); FISAPT.nuclear(); FISAPT.overlap(); FISAPT.partition(); FISAPT.print_header(); FISAPT.print_trailer(); FISAPT.raw_plot(); FISAPT.scalars(); FISAPT.scf(); FISAPT.sinf_disp(); FISAPT.unify(); FISAPT.unify_part2(); FISAPT.vectors(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; .",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FISAPT.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FISAPT.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FittedSlaterCorrelationFactor.html:747,Deployability,update,updated,747,". FittedSlaterCorrelationFactor. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor. FittedSlaterCorrelationFactor. class psi4.core.FittedSlaterCorrelationFactor; Bases: CorrelationFactor; docstring; Methods Summary. exponent(self). Methods Documentation. exponent(self: psi4.core.FittedSlaterCorrelationFactor)  float. table of contents. FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor; FittedSlaterCorrelationFactor.exponent(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FittedSlaterCorrelationFactor.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FittedSlaterCorrelationFactor.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FittedSlaterCorrelationFactor.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FittingMetric.html:2047,Deployability,update,updated,2047,"ingMetric. FittingMetric. class psi4.core.FittingMetric; Bases: pybind11_object; docstring; Methods Summary. form_QR_inverse(self,arg0); docstring. form_cholesky_inverse(self); docstring. form_eig_inverse(self,arg0); docstring. form_fitting_metric(self); docstring. form_full_inverse(self); docstring. get_algorithm(self); docstring. get_metric(self); docstring. get_pivots(self); docstring. get_reverse_pivots(self); docstring. is_inverted(self); docstring. is_poisson(self); docstring. Methods Documentation. form_QR_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_cholesky_inverse(self: psi4.core.FittingMetric)  None; docstring. form_eig_inverse(self: psi4.core.FittingMetric, arg0: float)  None; docstring. form_fitting_metric(self: psi4.core.FittingMetric)  None; docstring. form_full_inverse(self: psi4.core.FittingMetric)  None; docstring. get_algorithm(self: psi4.core.FittingMetric)  str; docstring. get_metric(self: psi4.core.FittingMetric)  psi4.core.Matrix; docstring. get_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. get_reverse_pivots(self: psi4.core.FittingMetric)  psi4.core.IntVector; docstring. is_inverted(self: psi4.core.FittingMetric)  bool; docstring. is_poisson(self: psi4.core.FittingMetric)  bool; docstring. table of contents. FittingMetric; FittingMetric; FittingMetric.form_QR_inverse(); FittingMetric.form_cholesky_inverse(); FittingMetric.form_eig_inverse(); FittingMetric.form_fitting_metric(); FittingMetric.form_full_inverse(); FittingMetric.get_algorithm(); FittingMetric.get_metric(); FittingMetric.get_pivots(); FittingMetric.get_reverse_pivots(); FittingMetric.is_inverted(); FittingMetric.is_poisson(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FittingMetric.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FittingMetric.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FittingMetric.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.flush_outfile.html:464,Deployability,update,updated,464,". flush_outfile. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile. flush_outfile. psi4.core.flush_outfile()  None; Flushes the output file. table of contents. flush_outfile; flush_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; flush_outfile.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.flush_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.flush_outfile.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.fnocc.html:484,Deployability,update,updated,484,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.fnocc.html:244,Energy Efficiency,energy,energy,244,". fnocc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; fnocc. fnocc. psi4.core.fnocc(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the FNO-CCSD(T)/QCISD(T)/MP4/CEPA energy code. table of contents. fnocc; fnocc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; fnocc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.fnocc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.fnocc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.FragmentType.html:806,Deployability,update,updated,806,". FragmentType. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FragmentType. FragmentType. class psi4.core.FragmentType; Bases: pybind11_object; Fragment activation status; Members:. Absent; Real; Ghost. Attributes Summary. Absent. Ghost. Real. name. value. Attributes Documentation. Absent = <FragmentType.Absent: 0>. Ghost = <FragmentType.Ghost: 2>. Real = <FragmentType.Real: 1>. name. value. table of contents. FragmentType; FragmentType; FragmentType.Absent; FragmentType.Ghost; FragmentType.Real; FragmentType.name; FragmentType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; FragmentType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.FragmentType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.FragmentType.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Functional.html:3805,Deployability,update,updated,3805,"ional)  str; docstring. omega(self: psi4.core.Functional)  float; docstring. print_detail(self: psi4.core.Functional, arg0: int)  None; docstring. print_out(self: psi4.core.Functional)  None; docstring. set_alpha(self: psi4.core.Functional, arg0: float)  None; docstring. set_citation(self: psi4.core.Functional, arg0: str)  None; docstring. set_density_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_description(self: psi4.core.Functional, arg0: str)  None; docstring. set_gga(self: psi4.core.Functional, arg0: bool)  None; docstring. set_lsda_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_meta(self: psi4.core.Functional, arg0: bool)  None; docstring. set_meta_cutoff(self: psi4.core.Functional, arg0: float)  None; docstring. set_name(self: psi4.core.Functional, arg0: str)  None; docstring. set_omega(self: psi4.core.Functional, arg0: float)  None; docstring. set_parameter(self: psi4.core.Functional, arg0: str, arg1: float)  None; docstring. table of contents. Functional; Functional; Functional.alpha(); Functional.build_base(); Functional.citation(); Functional.compute_functional(); Functional.density_cutoff(); Functional.description(); Functional.is_gga(); Functional.is_lrc(); Functional.is_meta(); Functional.lsda_cutoff(); Functional.meta_cutoff(); Functional.name(); Functional.omega(); Functional.print_detail(); Functional.print_out(); Functional.set_alpha(); Functional.set_citation(); Functional.set_density_cutoff(); Functional.set_description(); Functional.set_gga(); Functional.set_lsda_cutoff(); Functional.set_meta(); Functional.set_meta_cutoff(); Functional.set_name(); Functional.set_omega(); Functional.set_parameter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Functional.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Functional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Functional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:3043,Deployability,update,updated,3043,"ical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:359,Integrability,contract,contraction,359,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:410,Integrability,contract,contraction,410,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:490,Integrability,contract,contraction,490,". GaussianShell. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:1028,Integrability,contract,contraction,1028,"vigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.Gaus",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:1089,Integrability,contract,contraction,1089,"PSI4. PSI4 API: Linking C++ and Python; GaussianShell. GaussianShell. class psi4.core.GaussianShell; Bases: pybind11_object; Class containing information about basis functions; Attributes Summary. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the giv",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:1338,Integrability,contract,contraction,1338,"character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical ha",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:1390,Integrability,contract,contraction,1390,"The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:1471,Integrability,contract,contraction,1471,"er symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Summary. coef(self,pi); Return coefficient of the pi'th primitive. erd_coef(self,pi); Return ERD normalized coefficient of pi'th primitive. exp(self,prim); Returns the exponent of the given primitive. is_cartesian(self); Returns true if the contraction is Cartesian. is_pure(self); Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primiti",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:2170,Integrability,contract,contraction,2170,"ical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html:2264,Integrability,contract,contraction,2264,"ical harmonic basis function. original_coef(self,pi); Return unnormalized coefficient of the pi'th primitive. Attributes Documentation. AMCHAR; The upper-case character symbol for the angular momentum of the given contraction. am; The angular momentum of the given contraction. amchar; The character symbol for the angular momentum of the given contraction. function_index; Basis function index where this shell starts. ncartesian; Total number of basis functions if this shell was Cartesian. ncenter; Returns atom number this shell is on. nfunction; Total number of basis functions. nprimitive; The number of primitive gaussians. Methods Documentation. coef(self: psi4.core.GaussianShell, pi: int)  float; Return coefficient of the pith primitive. erd_coef(self: psi4.core.GaussianShell, pi: int)  float; Return ERD normalized coefficient of pith primitive. exp(self: psi4.core.GaussianShell, prim: int)  float; Returns the exponent of the given primitive. is_cartesian(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is Cartesian. is_pure(self: psi4.core.GaussianShell)  bool; Returns true if the contraction is pure, i.e. a spherical harmonic basis function. original_coef(self: psi4.core.GaussianShell, pi: int)  float; Return unnormalized coefficient of the pith primitive. table of contents. GaussianShell; GaussianShell; GaussianShell.AMCHAR; GaussianShell.am; GaussianShell.amchar; GaussianShell.function_index; GaussianShell.ncartesian; GaussianShell.ncenter; GaussianShell.nfunction; GaussianShell.nprimitive; GaussianShell.coef(); GaussianShell.erd_coef(); GaussianShell.exp(); GaussianShell.is_cartesian(); GaussianShell.is_pure(); GaussianShell.original_coef(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianShell.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianShell.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianShell.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianType.html:794,Deployability,update,updated,794,". GaussianType. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianType. GaussianType. class psi4.core.GaussianType; Bases: pybind11_object; 0 if Cartesian, 1 if Pure; Members:. Cartesian : (n+1)(n+2)/2 functions; Pure : 2n+1 functions. Attributes Summary. Cartesian. Pure. name. value. Attributes Documentation. Cartesian = <GaussianType.Cartesian: 0>. Pure = <GaussianType.Pure: 1>. name. value. table of contents. GaussianType; GaussianType; GaussianType.Cartesian; GaussianType.Pure; GaussianType.name; GaussianType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GaussianType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GaussianType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GaussianType.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.GeometryUnits.html:772,Deployability,update,updated,772,". GeometryUnits. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits. GeometryUnits. class psi4.core.GeometryUnits; Bases: pybind11_object; The units used to define the geometry; Members:. Angstrom; Bohr. Attributes Summary. Angstrom. Bohr. name. value. Attributes Documentation. Angstrom = <GeometryUnits.Angstrom: 0>. Bohr = <GeometryUnits.Bohr: 1>. name. value. table of contents. GeometryUnits; GeometryUnits; GeometryUnits.Angstrom; GeometryUnits.Bohr; GeometryUnits.name; GeometryUnits.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; GeometryUnits.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.GeometryUnits.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.GeometryUnits.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_active_molecule.html:541,Deployability,update,updated,541,". get_active_molecule. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule. get_active_molecule. psi4.core.get_active_molecule()  psi4.core.Molecule; Returns the currently active molecule object. table of contents. get_active_molecule; get_active_molecule(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_active_molecule.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_active_molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variable.html:595,Deployability,update,updated,595,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variable; get_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variable.html:248,Modifiability,variab,variable,248,". get_array_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable. get_array_variable. psi4.core.get_array_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variable; get_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variables.html:600,Deployability,update,updated,600,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variables; get_array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variables.html:249,Modifiability,variab,variables,249,". get_array_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables. get_array_variables. psi4.core.get_array_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_array_variables; get_array_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_array_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_array_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_array_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_datadir.html:479,Deployability,update,updated,479,". get_datadir. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_datadir. get_datadir. psi4.core.get_datadir()  str; Returns the path to shared text resources, PSIDATADIR. table of contents. get_datadir; get_datadir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_datadir.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_datadir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_datadir.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_global_option.html:394,Availability,error,error,394,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_global_option.html:689,Deployability,update,updated,689,". get_global_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_global_option. get_global_option. psi4.core.get_global_option(key: str)  object; Return keyword key value at global (all-module) scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized. table of contents. get_global_option; get_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_global_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_global_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_global_option_list.html:545,Deployability,update,updated,545,". get_global_option_list. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list. get_global_option_list. psi4.core.get_global_option_list()  List[str]; Returns a list of all global options. table of contents. get_global_option_list; get_global_option_list(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_global_option_list.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_global_option_list.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_global_option_list.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_local_option.html:390,Availability,error,error,390,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_local_option.html:697,Deployability,update,updated,697,". get_local_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_local_option. get_local_option. psi4.core.get_local_option(module: str, key: str)  object; Return keyword key value at module scope. Use psi4.core.get_option() for more common usage of negotiated value between global and local defaults and settings. Returns error if key is not recognized for the module. table of contents. get_local_option; get_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_local_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_local_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_memory.html:204,Availability,avail,available,204,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_memory.html:475,Deployability,update,updated,475,". get_memory. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_memory. get_memory. psi4.core.get_memory()  int; Returns the amount of memory available to Psi (in bytes). table of contents. get_memory; get_memory(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_memory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_memory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_memory.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_num_threads.html:519,Deployability,update,updated,519,". get_num_threads. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads. get_num_threads. psi4.core.get_num_threads()  int; Returns the number of threads to use in SMP parallel computations. table of contents. get_num_threads; get_num_threads(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_num_threads.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_num_threads.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_option.html:388,Availability,error,error,388,". get_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_option.html:714,Deployability,update,updated,714,". get_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_option. get_option. psi4.core.get_option(module: str, key: str)  object; Return keyword key value used by module. Returns the local value associated with the keyword if its been set, else the global value if its been set, else the local default value. Returns error if key is not recognized globally or if key is not recognized for the module. table of contents. get_option; get_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_options.html:451,Deployability,update,updated,451,". get_options. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_options. get_options. psi4.core.get_options()  psi4.core.Options; Get options. table of contents. get_options; get_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_options.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_output_file.html:518,Deployability,update,updated,518,". get_output_file. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_output_file. get_output_file. psi4.core.get_output_file()  str; Returns output file name (stem + suffix, no directory). stdout. table of contents. get_output_file; get_output_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_output_file.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_output_file.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variable.html:553,Deployability,update,updated,553,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variable; get_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variable.html:224,Modifiability,variab,variable,224,". get_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variable. get_variable. psi4.core.get_variable(key). Deprecated since version 1.4: Use psi4.core.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variable; get_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variables.html:558,Deployability,update,updated,558,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variables; get_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variables.html:225,Modifiability,variab,variables,225,". get_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variables. get_variables. psi4.core.get_variables(). Deprecated since version 1.4: Use psi4.core.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. table of contents. get_variables; get_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_writer_file_prefix.html:586,Deployability,update,updated,586,". get_writer_file_prefix. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix. get_writer_file_prefix. psi4.core.get_writer_file_prefix(molecule_name: str)  str; Returns the prefix to use for writing files for external programs. table of contents. get_writer_file_prefix; get_writer_file_prefix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; get_writer_file_prefix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.get_writer_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.get_writer_file_prefix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.git_version.html:455,Deployability,update,updated,455,". git_version. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; git_version. git_version. psi4.core.git_version()  None. Deprecated since version 1.4. table of contents. git_version; git_version(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; git_version.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.git_version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.git_version.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_array_variable.html:558,Deployability,update,updated,558,". has_array_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable. has_array_variable. psi4.core.has_array_variable(key: str)  bool; Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_array_variable; has_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.has_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_array_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_global_option_changed.html:807,Deployability,update,updated,807,". has_global_option_changed. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed. has_global_option_changed. psi4.core.has_global_option_changed(key: str)  bool; Whether keyword key value has been touched at global (all-module) scope. Has it been touched in the global scope, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the global scope by the user. table of contents. has_global_option_changed; has_global_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_global_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.has_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_global_option_changed.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_local_option_changed.html:815,Deployability,update,updated,815,". has_local_option_changed. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed. has_local_option_changed. psi4.core.has_local_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched at module scope. Has it been touched in the scope of the specified module by either user or code.Notwithstanding, code is written such that in practice, this returns whether the option has been touched in the module scope by the user. table of contents. has_local_option_changed; has_local_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_local_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.has_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_local_option_changed.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_option_changed.html:767,Deployability,update,updated,767,". has_option_changed. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed. has_option_changed. psi4.core.has_option_changed(module: str, key: str)  bool; Whether keyword key value has been touched or is default. Has it been touched either locally to the specified module or globally, by either user or code. Notwithstanding, code is written such that in practice, this returns whether the option has been touched by the user. table of contents. has_option_changed; has_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.has_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_option_changed.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_scalar_variable.html:565,Deployability,update,updated,565,". has_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable. has_scalar_variable. psi4.core.has_scalar_variable(key: str)  bool; Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). table of contents. has_scalar_variable; has_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_scalar_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.has_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_scalar_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_variable.html:621,Deployability,update,updated,621,". has_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_variable. has_variable. psi4.core.has_variable(key); Whether scalar or array QCVariable key has been set in global memory.; :rtype: bool. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Return type:; bool. table of contents. has_variable; has_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; has_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.has_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.has_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:4347,Deployability,update,update,4347,"nergies(). print_header(self); docstring. print_orbitals(self); docstring. print_preiterations([small]). print_stability_analysis(self,arg0); docstring. push_back_external_potential(self,V); Add an external potential to the private external_potentials list. reset_occupation(self); docstring. rotate_orbitals(self,arg0,arg1); docstring. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_pot",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:10939,Deployability,update,update,10939,"ensity_and_energy(self: psi4.core.HF)  None; docstring. scf_type(self: psi4.core.HF)  str; Return the value of scf_type used in the SCF computation. semicanonicalize(self: psi4.core.HF)  None; Semicanonicalizes the orbitals for ROHF. set_energies(self: psi4.core.HF, arg0: str, arg1: float)  None; docstring. set_external_cpscf_perturbation(self: psi4.core.HF, name: str, function: Callable[[psi4.core.Matrix], psi4.core.Matrix])  None; Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self: psi4.core.HF, arg0: psi4.core.JK)  None; Sets the internal JK object !expert. set_sad_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self: psi4.core.HF, arg0: List[psi4.core.BasisSet])  None; Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self: psi4.core.HF, arg0: float, arg1: int, arg2: int, arg3: int)  int; Computes a second-order SCF update. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. twoel_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str)  List[psi4.core.Matrix]; Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.iteration_energies; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbita",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:13149,Deployability,update,updated,13149,"ntrol options. Raises:; psi4.driver.p4util.exceptions.ValidationError  If any of DIIS options dont play well together. Returns:; Whether some form of DIIS is enabled during SCF. Return type:; bool. table of contents. HF; HF; HF.MOM_excited_; HF.MOM_performed_; HF.attempt_number_; HF.diis_enabled_; HF.diis_manager_; HF.diis_start_; HF.frac_performed_; HF.initialized_diis_manager_; HF.iteration_; HF.iteration_energies; HF.reset_occ_; HF.sad_; HF.V_potential(); HF.Va(); HF.Vb(); HF.check_phases(); HF.clear_external_cpscf_perturbations(); HF.clear_external_potentials(); HF.compute_E(); HF.compute_energy(); HF.compute_fvpi(); HF.compute_initial_E(); HF.compute_orbital_gradient(); HF.compute_spin_contamination(); HF.cphf_Hx(); HF.cphf_converged(); HF.cphf_solve(); HF.damping_update(); HF.diis(); HF.finalize(); HF.finalize_energy(); HF.find_occupation(); HF.form_C(); HF.form_D(); HF.form_F(); HF.form_FDSmSDF(); HF.form_G(); HF.form_H(); HF.form_Shalf(); HF.form_V(); HF.form_initial_C(); HF.form_initial_F(); HF.frac_renormalize(); HF.functional(); HF.get_energies(); HF.guess(); HF.guess_Ca(); HF.guess_Cb(); HF.initialize(); HF.initialize_gtfock_jk(); HF.initialize_jk(); HF.iterations(); HF.jk(); HF.occupation_a(); HF.occupation_b(); HF.onel_Hx(); HF.print_energies(); HF.print_header(); HF.print_orbitals(); HF.print_preiterations(); HF.print_stability_analysis(); HF.push_back_external_potential(); HF.reset_occupation(); HF.rotate_orbitals(); HF.save_density_and_energy(); HF.scf_type(); HF.semicanonicalize(); HF.set_energies(); HF.set_external_cpscf_perturbation(); HF.set_jk(); HF.set_sad_basissets(); HF.set_sad_fitting_basissets(); HF.soscf_update(); HF.stability_analysis(); HF.twoel_Hx(); HF.validate_diis(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; HF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:1920,Energy Efficiency,energy,energy,1920,"); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbital Matrices from the current Fock Matrices. form_D(self); Forms the Density Matrices from the current Orbitals Matrices. form_F(self); Forms the F matrix. form_FDSmSDF(self,arg0,arg1); Forms the residual of SCF theory. form_G(self); Forms the G matrix. form_H(self); Forms the core Hamiltonian. form_Shalf(self); Forms the S^1/2 matrix. form_V(self); Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self); Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self); Forms the initial F matrix. frac_renormalize(self); docstring. functional(self); Returns the internal DFT Superfunctional. get_energies(self,arg0); docstring. guess(self); Forms the guess (guarantees C, D, and E). guess_Ca(self,arg0); Sets the guess Alpha Orbital Matrix. guess_Cb(self,arg0); Sets the guess Beta Orbital Matrix. ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:6056,Energy Efficiency,energy,energy,6056,"ken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and call",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:7118,Energy Efficiency,energy,energy,7118,"puted by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the in",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:7186,Energy Efficiency,energy,energy,7186,"elf: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF)  None; docstring. form_C(self: psi4.core.HF, shift: float = 0.0)  None; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF)  None; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF)  None; Forms the F matrix. form_FDSmSDF(self: psi4.core.HF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Forms the residual of SCF theory. form_G(self: psi4.core.HF)  None; Forms the G matrix. form_H(self: psi4.core.HF)  None; Forms the core Hamiltonian. form_Shalf(self: psi4.core.HF)  None; Forms the S^1/2 matrix. form_V(self: psi4.core.HF)  None; Form the Kohn-Sham Potential Matrices from the current Density Matrices. form_initial_C(self: psi4.core.HF)  None; Forms the initial Orbital Matrices from the current Fock Matrices. form_initial_F(self: psi4.core.HF)  None; Forms the initial F matri",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:5974,Integrability,wrap,wrapper,5974,"r SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:260,Performance,perform,performed,260,". HF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. iteration_energies. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbita",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:470,Performance,perform,performed,470,". HF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; HF. HF. class psi4.core.HF; Bases: Wavefunction; docstring; Attributes Summary. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. iteration_energies. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Summary. V_potential(self); Returns the internal DFT V object. Va(self); Returns the Alpha Kohn-Sham Potential Matrix. Vb(self); Returns the Beta Kohn-Sham Potential Matrix. check_phases(self); docstring. clear_external_cpscf_perturbations(self); Clear private external_cpscf_perturbations map. clear_external_potentials(self); Clear private external_potentials list. compute_E(self); docstring. compute_energy(); Base class Wavefunction requires this function. compute_fvpi(self); Update number of frozen virtuals. compute_initial_E(self); docstring. compute_orbital_gradient(self,arg0,arg1); docstring. compute_spin_contamination(self); docstring. cphf_Hx(self,arg0); CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self); Adds occupied guess alpha orbitals. cphf_solve(self,x_vec,conv_tol,max_iter); Solves the CPHF equations for a given set of x vectors. damping_update(self,arg0); docstring. diis(self,arg0); docstring. finalize(self); Cleans up the the Wavefunction's temporary data. finalize_energy(); Performs stability analysis and calls back SCF with new guess if needed, Returns the SCF energy. find_occupation(self); docstring. form_C(self[,shift]); Forms the Orbita",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:4648,Performance,perform,performed,4648,"ng. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self,arg0,arg1); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_per",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:4863,Performance,perform,performed,4863,"); docstring. set_external_cpscf_perturbation(self,name,...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self,arg0); Sets the internal JK object !expert. set_sad_basissets(self,arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self,arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self,arg0,arg1,arg2,arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self,arg0,arg1,arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. attempt_number_; Current macroiteration (1-indexed) for stability analysis. diis_enabled_; docstring. diis_manager_; The DIIS object. diis_start_; docstring. frac_performed_; Frac performed current iteration?. initialized_diis_manager_; Has the DIIS object been initialized?. iteration_; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF) ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:5965,Usability,simpl,simply,5965,"r SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []. reset_occ_; Do reset the occupation after the guess to the inital occupation. sad_; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF)  psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF)  psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF)  psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF)  None; docstring. clear_external_cpscf_perturbations(self: psi4.core.HF)  None; Clear private external_cpscf_perturbations map. clear_external_potentials(self: psi4.core.HF)  None; Clear private external_potentials list. compute_E(self: psi4.core.HF)  float; docstring. compute_energy(); Base class Wavefunction requires this function. Here it is; simply a wrapper around initialize(), iterations(), finalize_energy(). It; returns the SCF energy computed by finalize_energy(). compute_fvpi(self: psi4.core.HF)  None; Update number of frozen virtuals. compute_initial_E(self: psi4.core.HF)  float; docstring. compute_orbital_gradient(self: psi4.core.HF, arg0: bool, arg1: int)  float; docstring. compute_spin_contamination(self: psi4.core.HF)  None; docstring. cphf_Hx(self: psi4.core.HF, arg0: List[psi4.core.Matrix])  List[psi4.core.Matrix]; CPHF Hessian-vector prodcuts (4 * J - K - K.T). cphf_converged(self: psi4.core.HF)  bool; Adds occupied guess alpha orbitals. cphf_solve(self: psi4.core.HF, x_vec: List[psi4.core.Matrix], conv_tol: float, max_iter: int, print_lvl: int = 2)  List[psi4.core.Matrix]; Solves the CPHF equations for a given set of x vectors. damping_update(self: psi4.core.HF, arg0: float)  None; docstring. diis(self: psi4.core.HF, arg0: float)  bool; docstring. finalize(self: psi4.core.HF)  None; Cleans up the the Wavefunctions te",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.HF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IDAMAX.html:450,Deployability,update,updated,450,". IDAMAX. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX. IDAMAX. psi4.core.IDAMAX(arg0: int, arg1: int, arg2: psi::Vector, arg3: int)  int; docstring. table of contents. IDAMAX; IDAMAX(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IDAMAX.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IDAMAX.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IDAMAX.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.initialize.html:504,Deployability,update,updated,504,". initialize. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; initialize. initialize. psi4.core.initialize()  bool; Called upon psi4 module import to initialize timers, singletons, and I/O. Idempotent. table of contents. initialize; initialize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; initialize.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.initialize.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.initialize.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IntegralFactory.html:9205,Deployability,update,updated,9205,")  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nabla integral. so_overlap(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO overlap integrals. so_potential(self: psi4.core.IntegralFactory, deriv: int = 0)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the SO nuclear attraction integral. so_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes SO the quadrupole integral. so_traceless_quadrupole(self: psi4.core.IntegralFactory)  psi4.core.OneBodySOInt; Returns a OneBodyInt that computes the traceless SO quadrupole integral. table of contents. IntegralFactory; IntegralFactory; IntegralFactory.ao_angular_momentum(); IntegralFactory.ao_dipole(); IntegralFactory.ao_kinetic(); IntegralFactory.ao_multipole_potential(); IntegralFactory.ao_multipoles(); IntegralFactory.ao_nabla(); IntegralFactory.ao_overlap(); IntegralFactory.ao_potential(); IntegralFactory.ao_quadrupole(); IntegralFactory.ao_traceless_quadrupole(); IntegralFactory.electric_field(); IntegralFactory.electrostatic(); IntegralFactory.erf_complement_eri(); IntegralFactory.erf_eri(); IntegralFactory.eri(); IntegralFactory.f12(); IntegralFactory.f12_double_commutator(); IntegralFactory.f12_squared(); IntegralFactory.f12g12(); IntegralFactory.overlap_3c(); IntegralFactory.shells_iterator(); IntegralFactory.so_angular_momentum(); IntegralFactory.so_dipole(); IntegralFactory.so_kinetic(); IntegralFactory.so_multipoles(); IntegralFactory.so_nabla(); IntegralFactory.so_overlap(); IntegralFactory.so_potential(); IntegralFactory.so_quadrupole(); IntegralFactory.so_traceless_quadrupole(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IntegralFactory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IntegralFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IntegralFactory.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IntegralTransform.html:7187,Deployability,update,updated,7187,"grals. update_orbitals(self: psi4.core.IntegralTransform)  None; docstring. table of contents. IntegralTransform; IntegralTransform; IntegralTransform.DPD_ID(); IntegralTransform.alpha_corr_to_pitzer(); IntegralTransform.backtransform_density(); IntegralTransform.backtransform_tpdm_restricted(); IntegralTransform.backtransform_tpdm_unrestricted(); IntegralTransform.beta_corr_to_pitzer(); IntegralTransform.compute_fock_like_matrices(); IntegralTransform.get_dpd_id(); IntegralTransform.get_frozen_core_energy(); IntegralTransform.get_keep_dpd_so_ints(); IntegralTransform.get_keep_ht_ints(); IntegralTransform.get_keep_iwl_so_ints(); IntegralTransform.get_memory(); IntegralTransform.get_print(); IntegralTransform.get_psio(); IntegralTransform.get_tei_already_presorted(); IntegralTransform.initialize(); IntegralTransform.nirrep(); IntegralTransform.presort_so_tei(); IntegralTransform.print_dpd_lookup(); IntegralTransform.reset_so_int(); IntegralTransform.set_aa_int_name(); IntegralTransform.set_ab_int_name(); IntegralTransform.set_bb_int_name(); IntegralTransform.set_dpd_id(); IntegralTransform.set_dpd_int_file(); IntegralTransform.set_keep_dpd_so_ints(); IntegralTransform.set_keep_ht_ints(); IntegralTransform.set_keep_iwl_so_ints(); IntegralTransform.set_memory(); IntegralTransform.set_orbitals(); IntegralTransform.set_print(); IntegralTransform.set_psio(); IntegralTransform.set_so_tei_file(); IntegralTransform.set_tei_already_presorted(); IntegralTransform.set_tpdm_already_presorted(); IntegralTransform.set_write_dpd_so_tpdm(); IntegralTransform.transform_tei(); IntegralTransform.transform_tei_first_half(); IntegralTransform.transform_tei_second_half(); IntegralTransform.update_orbitals(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IntegralTransform.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IntegralTransform.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IntegralTransform.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IntVector.html:3309,Deployability,update,updated,3309,": psi4.core.ProtoIntVector)  None; Copy another vector into this. dim(self: psi4.core.IntVector, h: int = 0)  int; Returns the number of dimensions per irrep h. dimpi(self: psi4.core.IntVector)  psi4.core.Dimension; Returns the Dimension object. get(*args, **kwargs); Overloaded function. get(self: psi4.core.IntVector, m: int) -> int. Returns a single element value located at m. get(self: psi4.core.IntVector, h: int, m: int) -> int. Returns a single element value located at m in irrep h. get_block(self: psi4.core.IntVector, slice: psi4.core.Slice)  psi4.core.IntVector; Get a vector block. init(self: psi4.core.IntVector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. static iota(arg0: psi4.core.Dimension)  psi4.core.IntVector. nirrep(self: psi4.core.IntVector)  int; Returns the number of irreps. print_out(self: psi4.core.IntVector)  None; Prints the vector to the output file. set(*args, **kwargs); Overloaded function. set(self: psi4.core.IntVector, m: int, val: int) -> None. Sets a single element value located at m. set(self: psi4.core.IntVector, h: int, m: int, val: int) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.IntVector, slice: psi4.core.Slice, block: psi4.core.ProtoIntVector)  None; Set a vector block. zero(self: psi4.core.IntVector)  None; Zeros the vector. table of contents. IntVector; IntVector; IntVector.name; IntVector.add(); IntVector.clone(); IntVector.copy(); IntVector.dim(); IntVector.dimpi(); IntVector.get(); IntVector.get_block(); IntVector.init(); IntVector.iota(); IntVector.nirrep(); IntVector.print_out(); IntVector.set(); IntVector.set_block(); IntVector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IntVector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IntVector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IO.html:3662,Deployability,update,updated,3662,"str; Lookup process id. open(self: psi4.core.IO, unit: int, status: int)  None; Open unit. Status can be PSIO_OPEN_OLD (if existing file is to be opened) or PSIO_OPEN_NEW if new file should be open. open_check(self: psi4.core.IO, unit: int)  int; Return 1 if unit is open. rehash(self: psi4.core.IO, unit: int)  None; Sync up the object to the file on disk by closing and opening the file, if necessary. static set_default_namespace(ns: str)  None; Set the current namespace (for PREFIX.NAMESPACE.UNIT file numbering). set_pid(self: psi4.core.IO, pid: str)  None; Set process id. static shared_object()  psi4.core.IO; Return the global shared object. state(self: psi4.core.IO)  int; Return 1 if PSIO library is activated. tocclean(self: psi4.core.IO, unit: int, key: str)  None; Delete all TOC entries after the given key. If a blank key is given, the entire TOC will be wiped. tocentry_exists(self: psi4.core.IO, arg0: int, arg1: str)  bool; Checks the TOC to see if a particular keyword exists there or not. tocprint(self: psi4.core.IO, arg0: int)  None; Print the table of contents for the given unit. tocscan(self: psi4.core.IO, arg0: int, arg1: str)  psi4.core.psio_entry; Seek string in binary file. This export is only good for catching None, as returned success object not exported. tocwrite(self: psi4.core.IO, arg0: int)  None; Write the table of contents for passed file number. table of contents. IO; IO; IO.change_file_namespace(); IO.close(); IO.exists(); IO.get_default_namespace(); IO.getpid(); IO.open(); IO.open_check(); IO.rehash(); IO.set_default_namespace(); IO.set_pid(); IO.shared_object(); IO.state(); IO.tocclean(); IO.tocentry_exists(); IO.tocprint(); IO.tocscan(); IO.tocwrite(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IO.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IO.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IO.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IOManager.html:3208,Deployability,update,updated,3208,"4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_specific_retention(); IOManager.shared_object(); IOManager.write_scratch_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IOManager.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IOManager.html:745,Integrability,protocol,protocol,745,". IOManager. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IOManager. IOManager. class psi4.core.IOManager; Bases: pybind11_object; PSIOManager is a class designed to be used as a static object to track all PSIO operations in a given PSI4 computation; Methods Summary. crashclean(self); Clean from disk-mirrored image after crash. get_default_path(self); Return the default path. get_file_path(self,fileno); Get the path for a specific file number. mark_file_for_retention(self,full_path,retain); Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self); Print the current status of PSI4 files. psiclean(self); Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self,path); Set the default path for files to be stored. set_specific_path(self,fileno,path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. se",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IOManager.html:1915,Integrability,protocol,protocol,1915,"path); Set the path for specific file numbers. set_specific_retention(self,fileno,retain); Set the specific file number to be retained. shared_object(); The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self,full_path,text); Write a string to a temporary file. Methods Documentation. crashclean(self: psi4.core.IOManager)  None; Clean from disk-mirrored image after crash. NOT to be called during regular computation. get_default_path(self: psi4.core.IOManager)  str; Return the default path. get_file_path(self: psi4.core.IOManager, fileno: int)  str; Get the path for a specific file number. mark_file_for_retention(self: psi4.core.IOManager, full_path: str, retain: bool)  None; Mark a file to be retained after a psiclean operation, ie for use in a later computation. print_out(self: psi4.core.IOManager)  None; Print the current status of PSI4 files. psiclean(self: psi4.core.IOManager)  None; Execute the psiclean protocol, deleting all recorded files, except those currently marked for retention. set_default_path(self: psi4.core.IOManager, path: str)  None; Set the default path for files to be stored. set_specific_path(self: psi4.core.IOManager, fileno: int, path: str)  None; Set the path for specific file numbers. set_specific_retention(self: psi4.core.IOManager, fileno: int, retain: bool)  None; Set the specific file number to be retained. static shared_object()  psi4.core.IOManager; The one and (should be) only instance of PSIOManager for a PSI4 instance. write_scratch_file(self: psi4.core.IOManager, full_path: str, text: str)  None; Write a string to a temporary file. The scratch file is opened and closed by this function. table of contents. IOManager; IOManager; IOManager.crashclean(); IOManager.get_default_path(); IOManager.get_file_path(); IOManager.mark_file_for_retention(); IOManager.print_out(); IOManager.psiclean(); IOManager.set_default_path(); IOManager.set_specific_path(); IOManager.set_speci",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IOManager.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IOManager.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.IrreducibleRepresentation.html:1087,Deployability,update,updated,1087,". IrreducibleRepresentation. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation. IrreducibleRepresentation. class psi4.core.IrreducibleRepresentation; Bases: pybind11_object; An irreducible representation of the point group; Methods Summary. character(self,arg0); Return the character of the i'th symmetry operation for the irrep. symbol(self); Return the symbol for the irrep. Methods Documentation. character(self: psi4.core.IrreducibleRepresentation, arg0: int)  float; Return the character of the ith symmetry operation for the irrep. 0-indexed. symbol(self: psi4.core.IrreducibleRepresentation)  str; Return the symbol for the irrep. table of contents. IrreducibleRepresentation; IrreducibleRepresentation; IrreducibleRepresentation.character(); IrreducibleRepresentation.symbol(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; IrreducibleRepresentation.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.IrreducibleRepresentation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.IrreducibleRepresentation.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.JK.html:5630,Deployability,update,updated,5630,"nge-separated DFT. get_omega_beta(self: psi4.core.JK)  float; Weight for dampened exchange term in range-separated DFT. get_wcombine(self: psi4.core.JK)  bool; wcombine. initialize(self: psi4.core.JK)  None. memory_estimate(self: psi4.core.JK)  int. name(self: psi4.core.JK)  str. print_header(self: psi4.core.JK)  None; docstring. set_cutoff(self: psi4.core.JK, arg0: float)  None. set_do_J(self: psi4.core.JK, arg0: bool)  None. set_do_K(self: psi4.core.JK, arg0: bool)  None. set_do_wK(self: psi4.core.JK, arg0: bool)  None. set_memory(self: psi4.core.JK, arg0: int)  None. set_omega(self: psi4.core.JK, omega: float)  None; Dampening term for range separated DFT. set_omega_alpha(self: psi4.core.JK, alpha: float)  None; Weight for HF exchange term in range-separated DFT. set_omega_beta(self: psi4.core.JK, beta: float)  None; Weight for dampened exchange term in range-separated DFT. set_omp_nthread(self: psi4.core.JK, arg0: int)  None. set_print(self: psi4.core.JK, arg0: int)  None. set_wcombine(self: psi4.core.JK, wcombine: bool)  None; Are Exchange terms in one Matrix. wK(self: psi4.core.JK)  List[psi4.core.Matrix]. table of contents. JK; JK; JK.C_add(); JK.C_clear(); JK.C_left_add(); JK.C_right_add(); JK.D(); JK.J(); JK.K(); JK.basisset(); JK.build(); JK.build_JK(); JK.compute(); JK.computed_shells_per_iter(); JK.finalize(); JK.get_omega(); JK.get_omega_alpha(); JK.get_omega_beta(); JK.get_wcombine(); JK.initialize(); JK.memory_estimate(); JK.name(); JK.print_header(); JK.set_cutoff(); JK.set_do_J(); JK.set_do_K(); JK.set_do_wK(); JK.set_memory(); JK.set_omega(); JK.set_omega_alpha(); JK.set_omega_beta(); JK.set_omp_nthread(); JK.set_print(); JK.set_wcombine(); JK.wK(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; JK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.JK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.JK.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.KineticInt.html:462,Deployability,update,updated,462,". KineticInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; KineticInt. KineticInt. class psi4.core.KineticInt; Bases: OneBodyAOInt; Computes kinetic integrals. table of contents. KineticInt; KineticInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; KineticInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.KineticInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.KineticInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.LaplaceDenominator.html:1317,Deployability,update,updated,1317,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.LaplaceDenominator.html:290,Energy Efficiency,energy,energy,290,". LaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator. LaplaceDenominator. class psi4.core.LaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the four-index energy denominator in MP2 and coupled-cluster; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized doubles denominator (nweights * nocc). denominator_vir(self: psi4.core.LaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized doubles denominator (nweights * nvirt). table of contents. LaplaceDenominator; LaplaceDenominator; LaplaceDenominator.denominator_occ(); LaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; LaplaceDenominator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.LaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.LaplaceDenominator.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.libint2_solid_harmonics_ordering.html:637,Deployability,update,updated,637,". libint2_solid_harmonics_ordering. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; libint2_solid_harmonics_ordering. libint2_solid_harmonics_ordering. psi4.core.libint2_solid_harmonics_ordering()  str; The solid harmonics setting of Libint2 currently active for Psi4. table of contents. libint2_solid_harmonics_ordering; libint2_solid_harmonics_ordering(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; libint2_solid_harmonics_ordering.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.libint2_solid_harmonics_ordering.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.libint2_solid_harmonics_ordering.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.LibXCFunctional.html:2014,Deployability,update,updated,2014,"4 API: Linking C++ and Python; LibXCFunctional. LibXCFunctional. class psi4.core.LibXCFunctional; Bases: Functional; docstring; Methods Summary. density_cutoff(self); docstring. get_mix_data(self); docstring. query_libxc(self,arg0); query libxc regarding functional parameters. set_density_cutoff(self,arg0); docstring. set_omega(self,arg0); docstring. set_tweak(*args,**kwargs); Overloaded function. xclib_description(); query libxc for version and citation. Methods Documentation. density_cutoff(self: psi4.core.LibXCFunctional)  float; docstring. get_mix_data(self: psi4.core.LibXCFunctional)  List[Tuple[str, int, float]]; docstring. query_libxc(self: psi4.core.LibXCFunctional, arg0: str)  Dict[str, float]; query libxc regarding functional parameters. set_density_cutoff(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_omega(self: psi4.core.LibXCFunctional, arg0: float)  None; docstring. set_tweak(*args, **kwargs); Overloaded function. set_tweak(self: psi4.core.LibXCFunctional, tweaks: List[float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a list. Deprecated in v1.4. set_tweak(self: psi4.core.LibXCFunctional, tweaks: Dict[str, float], quiet: bool = False) -> None. Set all tweaks on a LibXC functional through a dictionary of names (usually underscore prepended) and values. New in v1.4. xclib_description()  str; query libxc for version and citation. table of contents. LibXCFunctional; LibXCFunctional; LibXCFunctional.density_cutoff(); LibXCFunctional.get_mix_data(); LibXCFunctional.query_libxc(); LibXCFunctional.set_density_cutoff(); LibXCFunctional.set_omega(); LibXCFunctional.set_tweak(); LibXCFunctional.xclib_description(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; LibXCFunctional.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.LibXCFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.LibXCFunctional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Localizer.html:1207,Deployability,update,updated,1207,". Localizer. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Localizer. Localizer. class psi4.core.Localizer; Bases: pybind11_object; Class containing orbital localization procedures; Attributes Summary. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Summary. build(arg0,arg1,arg2); Build the localization scheme. localize(self); Perform the localization procedure. Attributes Documentation. L; Localized orbital coefficients. U; Orbital rotation matrix. converged; Did the localization procedure converge?. Methods Documentation. static build(arg0: str, arg1: psi4.core.BasisSet, arg2: psi4.core.Matrix)  psi4.core.Localizer; Build the localization scheme. localize(self: psi4.core.Localizer)  None; Perform the localization procedure. table of contents. Localizer; Localizer; Localizer.L; Localizer.U; Localizer.converged; Localizer.build(); Localizer.localize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Localizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Localizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Localizer.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:19820,Deployability,update,updated,19820,"; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:3327,Energy Efficiency,power,power,3327,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:3387,Energy Efficiency,power,power,3387,"rix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,bl",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:13105,Energy Efficiency,power,power,13105,"constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. row",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:13226,Energy Efficiency,power,power,13226,"Py. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12)  psi4.core.Dimension; Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self: psi4.core.Matrix, RMRoutfile: str = 'outfile')  None; Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self: psi4.core.Matrix)  None; Prints the matrix to the output file. pseudoinverse(self: psi4.core.Matrix, condition: float, nremoved: int)  psi4.core.Matrix; Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix)  None; Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self: psi4.core.Matrix)  float; Returns the rms of this matrix. rotate_columns(self: psi4.core.Matrix, h: int, i: int, j: int, theta: float)  None; Rotates columns i and j in irrep h by angle theta. rowdim(self: psi4.core.Matrix)  psi4.core.Dimension; Returns the rows per irrep array. rows(self: psi4.core.Matrix, h: int = 0)  int; Returns the rows in irrep h. save(*args, **kwargs); Overloa",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:18990,Energy Efficiency,power,power,18990,"; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:16514,Integrability,depend,depending,16514,"ce, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the tran",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:2770,Performance,load,load,2770,"array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type :rtype: Union[Matrix, Vector]. gemm(self,transa,transb,alpha,a,b,beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoa",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:3026,Performance,load,load,3026,"); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args,**kwargs); Overloaded function. get_block(self,rows,cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args,**kwargs); Overloaded function. load_mpqc(self,filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[,delta,...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self,alpha[,cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[,RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self,condition,nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self,a,transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*ar",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11180,Performance,load,load,11180,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11225,Performance,load,load,11225,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return typ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11349,Performance,load,load,11349,"nsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using nump",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11517,Performance,load,load,11517,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Op",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:12024,Performance,load,load,12024,"ix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False)  psi4.core.Matrix; Computes the fully pivoted partial Cholesky factorization of ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:18864,Performance,load,load,18864,"lf: psi4.core.Matrix)  None; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix)  None; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix)  None; Zero the lower triangle. zero_upper(self: psi4.core.Matrix)  None; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Matrix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Crea",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:4819,Security,access,accessor,4819,"ix. rotate_columns(self,h,i,j,theta); Rotates columns i and j in irrep h by angle theta. rowdim(self); Returns the rows per irrep array. rows(self[,h]); Returns the rows in irrep h. save(*args,**kwargs); Overloaded function. scale(self,a); Scales the matrix by the floating point value a. scale_column(self,h,n,a); Scales column n of irrep h by a. scale_row(self,h,m,a); Scales row m of irrep h by a. schmidt(self); Calls the libqt schmidt function. set(*args,**kwargs); Overloaded function. set_block(self,rows,cols,block); Set a matrix block. subtract(self,arg0); Substract a matrix from this matrix. sum_of_squares(self); Returns the sum of the squares of this matrix. symmetrize_gradient(self,mol); Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self); Returns the overall symmetry of the matrix. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. trace(self); Returns the trace of the matrix. transform(*args,**kwargs); Overloaded function. transpose(self); Creates a new matrix that is the transpose of this matrix. transpose_this(self); Transpose the matrix in-place. triplet(A,B,C,transA,transB,transC); Multiply three matrices together. vector_dot(self,rhs); Returns the vector dot product of this with rhs. zero(self); Zero all elements of the matrix. zero_diagonal(self); Zero the diagonal of the matrix. zero_lower(self); Zero the lower triangle. zero_upper(self); Zero the upper triangle. Attributes Documentation. name; The name of the Matrix. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. absmax(self: psi4.core.Matrix)  float; Returns the absolute maximum value. accumulate_product(self: psi4.core.Matrix, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  None; Multiplies two arguments and adds the result to this ma",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:16809,Security,access,accessor,16809,": psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*args, **kwargs); Overloaded function. transform(self: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform this matrix with transformer. transform(self: psi4.core.Matrix, a: psi4.core.Matrix, transformer: psi4.core.Matrix) -> None. Transform A with transformer. transpose(self: psi4.core.Matrix)  psi4.core.Matrix; Creates a new matrix that is the transpose of this matrix. transpose_this(self: psi4.core.Matrix)  None; Transpose the matrix in-place. static triplet(A, B, C, transA, transB, transC); Multiply three matrices together. Deprecated since version 1.4: Use psi4.core.triplet() instead. vector_dot(self: psi4.core.Matrix, rhs: psi4.core.Matrix)  float; Returns th",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11323,Testability,test,tests,11323,"rix)  None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice)  psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix)  None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix)  None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix)  None; Sets the matrix to the identity. invert(self: psi4.core.Matrix)  None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str)  None; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped ma",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:16131,Usability,simpl,simply,16131,"ne. Sets every element of a matrix to val. set(self: psi4.core.Matrix, m: int, n: int, val: float) -> None. Sets a single element of a matrix to val at row m, col n. set(self: psi4.core.Matrix, h: int, m: int, n: int, val: float) -> None. Sets a single element of a matrix, subblock h, row m, col n, with value val. set_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice, block: psi4.core.Matrix)  None; Set a matrix block. subtract(self: psi4.core.Matrix, arg0: psi4.core.Matrix)  None; Substract a matrix from this matrix. sum_of_squares(self: psi4.core.Matrix)  float; Returns the sum of the squares of this matrix. symmetrize_gradient(self: psi4.core.Matrix, mol: psi::Molecule)  None; Symmetrizes a gradient-like matrix (N,3) using information from a given molecule. symmetry(self: psi4.core.Matrix)  int; Returns the overall symmetry of the matrix. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. trace(self: psi4.core.Matrix)  float; Returns the trace of the matrix. transform(*a",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Matrix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MatrixFactory.html:920,Deployability,update,updated,920,". MatrixFactory. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory. MatrixFactory. class psi4.core.MatrixFactory; Bases: pybind11_object; Creates Matrix objects; Methods Summary. create_matrix(*args,**kwargs); Overloaded function. Methods Documentation. create_matrix(*args, **kwargs); Overloaded function. create_matrix(self: psi4.core.MatrixFactory) -> psi4.core.Matrix. Returns a new matrix object with default dimensions. create_matrix(self: psi4.core.MatrixFactory, arg0: str) -> psi4.core.Matrix. Returns a new Matrix object named name with default dimensions. table of contents. MatrixFactory; MatrixFactory; MatrixFactory.create_matrix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MatrixFactory.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MatrixFactory.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MatrixFactory.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.mcscf.html:494,Deployability,update,updated,494,". mcscf. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; mcscf. mcscf. psi4.core.mcscf(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the MCSCF code, (N.B. restricted to certain active spaces). table of contents. mcscf; mcscf(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; mcscf.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.mcscf.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.mcscf.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MemDFJK.html:588,Deployability,update,updated,588,". MemDFJK. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK. MemDFJK. class psi4.core.MemDFJK; Bases: JK; docstring; Methods Summary. dfh(self); Return the DFHelper object. Methods Documentation. dfh(self: psi4.core.MemDFJK)  psi4.core.DFHelper; Return the DFHelper object. table of contents. MemDFJK; MemDFJK; MemDFJK.dfh(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MemDFJK.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MemDFJK.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MemDFJK.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html:22079,Deployability,update,updated,22079,"tsHelper.ao_oei_deriv1(); MintsHelper.ao_oei_deriv2(); MintsHelper.ao_overlap(); MintsHelper.ao_overlap_half_deriv1(); MintsHelper.ao_potential(); MintsHelper.ao_pvp(); MintsHelper.ao_quadrupole(); MintsHelper.ao_tei_deriv1(); MintsHelper.ao_tei_deriv2(); MintsHelper.ao_traceless_quadrupole(); MintsHelper.basisset(); MintsHelper.cdsalcs(); MintsHelper.core_hamiltonian_grad(); MintsHelper.dipole_grad(); MintsHelper.electric_field(); MintsHelper.electric_field_value(); MintsHelper.electrostatic_potential_value(); MintsHelper.f12_cgtg(); MintsHelper.factory(); MintsHelper.induction_operator(); MintsHelper.integral(); MintsHelper.integrals(); MintsHelper.integrals_erf(); MintsHelper.integrals_erfc(); MintsHelper.kinetic_grad(); MintsHelper.mo_elec_dip_deriv1(); MintsHelper.mo_erf_eri(); MintsHelper.mo_eri(); MintsHelper.mo_f12(); MintsHelper.mo_f12_double_commutator(); MintsHelper.mo_f12_squared(); MintsHelper.mo_f12g12(); MintsHelper.mo_oei_deriv1(); MintsHelper.mo_oei_deriv2(); MintsHelper.mo_overlap_half_deriv1(); MintsHelper.mo_spin_eri(); MintsHelper.mo_tei_deriv1(); MintsHelper.mo_tei_deriv2(); MintsHelper.mo_transform(); MintsHelper.multipole_grad(); MintsHelper.nbf(); MintsHelper.one_electron_integrals(); MintsHelper.overlap_grad(); MintsHelper.perturb_grad(); MintsHelper.petite_list(); MintsHelper.petite_list1(); MintsHelper.play(); MintsHelper.potential_grad(); MintsHelper.set_basisset(); MintsHelper.set_print(); MintsHelper.so_angular_momentum(); MintsHelper.so_dipole(); MintsHelper.so_dkh(); MintsHelper.so_kinetic(); MintsHelper.so_nabla(); MintsHelper.so_overlap(); MintsHelper.so_potential(); MintsHelper.so_quadrupole(); MintsHelper.so_traceless_quadrupole(); MintsHelper.sobasisset(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MintsHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html:2733,Energy Efficiency,charge,charges,2733,"ion. ao_overlap_half_deriv1(self,side,atom); Half-derivative of AO basis overlap integrals: returns (3 * natoms) matrices. ao_potential(*args,**kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...);",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html:2810,Energy Efficiency,charge,charge,2810,"ap integrals: returns (3 * natoms) matrices. ao_potential(*args,**kwargs); Overloaded function. ao_pvp(self); AO pvp integrals. ao_quadrupole(self); Vector AO quadrupole integrals. ao_tei_deriv1(self,atom[,omega,factory]); Gradient of AO basis TEI integrals: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4);",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html:12781,Energy Efficiency,charge,charges,12781,"2 matrices. ao_traceless_quadrupole(self: psi4.core.MintsHelper)  List[psi4.core.Matrix]; Vector AO traceless quadrupole integrals. basisset(self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  Non",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html:12938,Energy Efficiency,charge,charge,12938,"self: psi4.core.MintsHelper)  psi4.core.BasisSet; Returns the basis set being used. cdsalcs(self: psi4.core.MintsHelper, arg0: int, arg1: bool, arg2: bool)  psi4.core.CdSalcList; Returns a CdSalcList object. core_hamiltonian_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative T + V + Perturb integrals. dipole_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic int",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html:3043,Integrability,contract,contracting,3043,"s: returns (3 * natoms) matrices. ao_tei_deriv2(self,atom1,atom2); Hessian of AO basis TEI integrals: returns (3 * natoms)^2 matrices. ao_traceless_quadrupole(self); Vector AO traceless quadrupole integrals. basisset(self); Returns the basis set being used. cdsalcs(self,arg0,arg1,arg2); Returns a CdSalcList object. core_hamiltonian_grad(self,arg0); First nuclear derivative T + V + Perturb integrals. dipole_grad(self,arg0); First nuclear derivative dipole integrals. electric_field(self,origin[,deriv]); Vector electric field integrals. electric_field_value(self,arg0,arg1); Electric field expectation value at given sites. electrostatic_potential_value(self,charges,...); Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self[,exponent]); F12 Fitted Slater Correlation Factor. factory(self); Returns the Matrix factory being used. induction_operator(self,arg0,arg1); Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self); Integral factory being used. integrals(self); Molecular integrals. integrals_erf(self[,w]); ERF integrals. integrals_erfc(self[,w]); ERFC integrals. kinetic_grad(self,arg0); First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self,atom,C1,C2); Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self,omega,C1,C2,C3,C4); MO ERFC Omega Integrals. mo_eri(self,C1,C2,C3,C4); MO ERI Integrals. mo_f12(self,corr,C1,C2,C3,C4); MO F12 Integrals. mo_f12_double_commutator(self,corr,C1,C2,...); MO F12 double commutator integrals. mo_f12_squared(self,corr,C1,C2,C3,C4); MO F12 squared integrals. mo_f12g12(self,corr,C1,C2,C3,C4); MO F12G12 integrals. mo_oei_deriv1(self,oei_type,atom,C1,C2); Gradient of MO basis OEI integrals: returns (3 * natoms) matrices. mo_oei_deriv2(self,oei_type,atom1,atom2,...); Hessian of ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html:13363,Integrability,contract,contracting,13363," dipole integrals. electric_field(self: psi4.core.MintsHelper, origin: List[float], deriv: int = 0)  List[psi4.core.Matrix]; Vector electric field integrals. electric_field_value(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Electric field expectation value at given sites. electrostatic_potential_value(self: psi4.core.MintsHelper, charges: psi4.core.Vector, coords: psi4.core.Matrix, D: psi4.core.Matrix)  psi4.core.Vector; Electrostatic potential values at given sites with associated charge, specified as an (n_sites, 4) matrix. f12_cgtg(self: psi4.core.MintsHelper, exponent: float = 1.0)  List[Tuple[float, float]]; F12 Fitted Slater Correlation Factor. factory(self: psi4.core.MintsHelper)  psi4.core.MatrixFactory; Returns the Matrix factory being used. induction_operator(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix; Induction operator, formed by contracting electric field integrals with dipole moments at given coordinates (needed for EFP and PE). integral(self: psi4.core.MintsHelper)  psi4.core.IntegralFactory; Integral factory being used. integrals(self: psi4.core.MintsHelper)  None; Molecular integrals. integrals_erf(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERF integrals. integrals_erfc(self: psi4.core.MintsHelper, w: float = -1.0)  None; ERFC integrals. kinetic_grad(self: psi4.core.MintsHelper, arg0: psi4.core.Matrix)  psi4.core.Matrix; First nuclear derivative kinetic integrals. mo_elec_dip_deriv1(self: psi4.core.MintsHelper, atom: int, C1: psi4.core.Matrix, C2: psi4.core.Matrix)  List[psi4.core.Matrix]; Gradient of MO basis electric dipole integrals: returns (3 * natoms) matrices. mo_erf_eri(self: psi4.core.MintsHelper, omega: float, C1: psi4.core.Matrix, C2: psi4.core.Matrix, C3: psi4.core.Matrix, C4: psi4.core.Matrix)  psi4.core.Matrix; MO ERFC Omega Integrals. mo_eri(self: psi4.core.MintsHelper, C1: psi4.core.Matrix, C2: psi",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MintsHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MintsHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MoldenWriter.html:926,Deployability,update,updated,926,". MoldenWriter. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter. MoldenWriter. class psi4.core.MoldenWriter; Bases: pybind11_object; Writes wavefunction information in molden format; Methods Summary. write(self,filename,Ca,Cb,Ea,Eb,OccA,...); Writes wavefunction information in molden format. Methods Documentation. write(self: psi4.core.MoldenWriter, filename: str, Ca: psi4.core.Matrix, Cb: psi4.core.Matrix, Ea: psi4.core.Vector, Eb: psi4.core.Vector, OccA: psi4.core.Vector, OccB: psi4.core.Vector, dovirtual: bool)  None; Writes wavefunction information in molden format. table of contents. MoldenWriter; MoldenWriter; MoldenWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MoldenWriter.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MoldenWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MoldenWriter.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MolecularGrid.html:1984,Deployability,update,updated,1984,". ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid. MolecularGrid. class psi4.core.MolecularGrid; Bases: pybind11_object; docstring; Methods Summary. atomic_blocks(self); Returns a list of blocks. blocks(self); Returns a list of blocks. collocation_size(self); Returns the total collocation size of all blocks. max_functions(self); Returns the maximum number of functions in a block. max_points(self); Returns the maximum number of points in a block. npoints(self); Returns the number of grid points. orientation(self); Returns the orientation of the grid. print(self,arg0,arg1); Prints grid information. Methods Documentation. atomic_blocks(self: psi4.core.MolecularGrid)  List[List[psi4.core.BlockOPoints]]; Returns a list of blocks. blocks(self: psi4.core.MolecularGrid)  List[psi4.core.BlockOPoints]; Returns a list of blocks. collocation_size(self: psi4.core.MolecularGrid)  int; Returns the total collocation size of all blocks. max_functions(self: psi4.core.MolecularGrid)  int; Returns the maximum number of functions in a block. max_points(self: psi4.core.MolecularGrid)  int; Returns the maximum number of points in a block. npoints(self: psi4.core.MolecularGrid)  int; Returns the number of grid points. orientation(self: psi4.core.MolecularGrid)  psi4.core.Matrix; Returns the orientation of the grid. print(self: psi4.core.MolecularGrid, arg0: str, arg1: int)  None; Prints grid information. table of contents. MolecularGrid; MolecularGrid; MolecularGrid.atomic_blocks(); MolecularGrid.blocks(); MolecularGrid.collocation_size(); MolecularGrid.max_functions(); MolecularGrid.max_points(); MolecularGrid.npoints(); MolecularGrid.orientation(); MolecularGrid.print(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MolecularGrid.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MolecularGrid.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MolecularGrid.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:2061,Availability,toler,tolerance,2061,"a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:2158,Availability,toler,tolerance,2158,"f,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-in",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:10087,Availability,toler,tolerance,10087,"g0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0);",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:15286,Availability,fault,faulty,15286,"ts of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:18860,Availability,toler,tolerance,18860,"ts(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the po",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:19014,Availability,toler,tolerance,19014,"ract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:20453,Availability,error,error,20453,", or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Mo",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:28827,Availability,error,error,28827,"al_symmetry_number(self: psi4.core.Molecule)  int; Returns number of unique orientations of the rigid molecule that only interchange identical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30118,Availability,error,error,30118,"ertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geom",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:37522,Availability,toler,tolerance,37522,"elf: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[so",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:43430,Deployability,update,updated,43430,"nergy_deriv1(); Molecule.nuclear_repulsion_energy_deriv2(); Molecule.orientation_fixed(); Molecule.point_group(); Molecule.print_bond_angles(); Molecule.print_cluster(); Molecule.print_distances(); Molecule.print_in_input_format(); Molecule.print_out(); Molecule.print_out_in_angstrom(); Molecule.print_out_in_bohr(); Molecule.print_out_of_planes(); Molecule.print_rotational_constants(); Molecule.provenance(); Molecule.reinterpret_coordentry(); Molecule.reset_point_group(); Molecule.rotational_constants(); Molecule.rotational_symmetry_number(); Molecule.rotor_type(); Molecule.run_dftd3(); Molecule.run_dftd4(); Molecule.run_gcp(); Molecule.save_string_xyz(); Molecule.save_string_xyz_file(); Molecule.save_xyz_file(); Molecule.schoenflies_symbol(); Molecule.scramble(); Molecule.set_active_fragment(); Molecule.set_active_fragments(); Molecule.set_basis_all_atoms(); Molecule.set_basis_by_label(); Molecule.set_basis_by_number(); Molecule.set_basis_by_symbol(); Molecule.set_comment(); Molecule.set_connectivity(); Molecule.set_full_geometry(); Molecule.set_geometry(); Molecule.set_ghost_fragment(); Molecule.set_ghost_fragments(); Molecule.set_input_units_to_au(); Molecule.set_mass(); Molecule.set_molecular_charge(); Molecule.set_multiplicity(); Molecule.set_name(); Molecule.set_nuclear_charge(); Molecule.set_point_group(); Molecule.set_provenance(); Molecule.set_units(); Molecule.set_variable(); Molecule.symbol(); Molecule.symmetrize(); Molecule.symmetry_from_input(); Molecule.to_arrays(); Molecule.to_dict(); Molecule.to_schema(); Molecule.to_string(); Molecule.translate(); Molecule.true_atomic_number(); Molecule.units(); Molecule.update_geometry(); Molecule.x(); Molecule.xyz(); Molecule.y(); Molecule.z(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Molecule.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:266,Energy Efficiency,charge,charge,266,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:611,Energy Efficiency,charge,charge,611,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:904,Energy Efficiency,charge,charge,904,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:1188,Energy Efficiency,charge,charge,1188,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:1213,Energy Efficiency,charge,charge,1213,"rdinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:1627,Energy Efficiency,charge,charges,1627,"0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:1906,Energy Efficiency,charge,charge,1906,"ed atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:1983,Energy Efficiency,charge,charge,1983,"rloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_sc",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:3912,Energy Efficiency,charge,charge,3912,"es. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:5141,Energy Efficiency,charge,charge,5141,"gments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separato",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:5574,Energy Efficiency,energy,energy,5574,"s molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:5674,Energy Efficiency,energy,energy,5674,"nit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_r",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:5791,Energy Efficiency,energy,energy,5791,"els. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self); Get whether or not orientation is fixed. point_group(self); Returns the current point group object. print_bond_angles(self); Print the bond angle geometrical parameters. print_cluster(self); Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self); Print the interatomic distance geometrical parameters. print_in_input_format(self); Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self); Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self); Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self); Prints the molecule in Cartesians in Bohr to output file. print_out_of_planes(self); Print the out-of-plane angle geometrical parameters to output file. print_rotational_constants(self); Print the rotational constants to output file. provenance(self); Gets molecule",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:9282,Energy Efficiency,charge,charge,9282,"arg2); Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self,arg0,arg1,arg2); Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self,arg0); Sets molecule comment. set_connectivity(self,arg0); Sets molecule connectivity. set_full_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); E",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:9461,Energy Efficiency,charge,charge,9461,"basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self,arg0); Sets molecule comment. set_connectivity(self,arg0); Sets molecule connectivity. set_full_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self,arg0); Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema d",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:13152,Energy Efficiency,charge,charge,13152,"ed final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool)  Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float)  TODO; run_mirror (bool)  Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int)  . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule)  ; seed_atoms (Optional[List])  List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float)  Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool)  If True, also return fragments as list of arrays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:15005,Energy Efficiency,charge,charge,15005,"rays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists)  Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overl",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:15484,Energy Efficiency,charge,charge,15484,"ch built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.c",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:15741,Energy Efficiency,charge,charge,15741,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without du",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:15903,Energy Efficiency,charge,charge,15903,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without du",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:16714,Energy Efficiency,charge,charge,16714," str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Mole",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:16773,Energy Efficiency,charge,charge,16773," None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.M",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:17363,Energy Efficiency,charge,charges,17363," tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without dummies). clone(self: psi4.core.Molecule)  psi4.core.Molecule; Returns a new Molecule identical to arg1. com_fixed(self: psi4.core.Molecule)  bool; Gets whether or not center of mass is fixed. comment(self: psi4.core.Molecule)  str; Gets molecule comment. connectivity(self: psi4.core.Molecule)  List[Tuple[int, int, float]]; Gets molecule connectivity. create_psi4_string_from_molecule(self: psi4.core.Molecule)  str; Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be inactive. distance_matrix(self: psi4.core.Molecule)  psi4.core.Matrix; Returns Matrix of interatom distances. extract_subsets(*args, **kwargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: p",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:18652,Energy Efficiency,charge,charge,18652,"wargs); Overloaded function. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-i",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:18763,Energy Efficiency,charge,charge,18763,"si4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int], arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragments Ghost. extract_subsets(self: psi4.core.Molecule, arg0: int, arg1: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real and arg1 fragment Ghost. extract_subsets(self: psi4.core.Molecule, arg0: List[int]) -> psi4.core.Molecule. Returns copy of self with arg0 fragments Real. extract_subsets(self: psi4.core.Molecule, arg0: int) -> psi4.core.Molecule. Returns copy of self with arg0 fragment Real. fZ(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed including dummies). find_highest_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds highest possible computational molecular point group. find_point_group(self: psi4.core.Molecule, tolerance: float = 1e-08)  psi4.core.PointGroup; Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self: psi4.core.Molecule, arg0: bool)  None; Sets whether to fix the Cartesian position, or to translate to the C.O.M. Expert use only; use before molecule finalized by update_geometry. fix_orientation(self: psi4.core.Molecule, arg0: bool)  None; Fix the orientation at its current frame. Expert use only; use before molecule finalized by update_geometry. flabel(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed i",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:23018,Energy Efficiency,charge,charge,23018," C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule)  int; Gets n in Cnv, etc.; If there is no n (e.g. Td) its the highest-order rotation axis. fx(self: psi4.core.Molecule, arg0: int)  float; x position of atom arg0 (0-indexed including dummies in Bohr). fy(self: psi4.core.Molecule, arg0: int)  float; y position of atom arg0 (0-indexed including dummies in Bohr). fz(self: psi4.core.Molecule, arg0: int)  float; z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:24734,Energy Efficiency,charge,charge,24734,"str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0])  float; Computes nuclear repul",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:25724,Energy Efficiency,energy,energy,25724," int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  Non",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:25927,Energy Efficiency,energy,energy,25927,"nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:26084,Energy Efficiency,energy,energy,26084,"e)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4.core.Molecule, arg0: psi4.core.Vector3) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to a specified origin atg0. nuclear_dipole(self: psi4.core.Molecule) -> psi4.core.Vector3. Gets the nuclear contribution to the dipole, with respect to the origin. nuclear_repulsion_energy(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0])  float; Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self: psi4.core.Molecule, dipole_field: Annotated[List[float], FixedSize(3)] = [0.0, 0.0, 0.0])  psi4.core.Matrix; Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self: psi4.core.Molecule)  psi4.core.Matrix; Returns second derivative of nuclear repulsion energy as a matrix (natom X 3, natom X 3). orientation_fixed(self: psi4.core.Molecule)  bool; Get whether or not orientation is fixed. point_group(self: psi4.core.Molecule)  psi4.core.PointGroup; Returns the current point group object. print_bond_angles(self: psi4.core.Molecule)  None; Print the bond angle geometrical parameters. print_cluster(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units adding fragment separators. print_distances(self: psi4.core.Molecule)  None; Print the interatomic distance geometrical parameters. print_in_input_format(self: psi4.core.Molecule)  None; Prints the molecule as Cartesian or ZMatrix entries, just as inputted. print_out(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in input units to output file. print_out_in_angstrom(self: psi4.core.Molecule)  None; Prints the molecule in Cartesians in Angstroms to output file. print_out_in_bohr(self: psi4.core.Molecule)  None; Prints the m",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:28939,Energy Efficiency,energy,energy-only,28939,"ical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:28991,Energy Efficiency,efficient,efficient,28991,"ical atoms. rotor_type(self: psi4.core.Molecule)  str; Returns rotor type, e.g. RT_ATOM or RT_SYMMETRIC_TOP. run_dftd3(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:29086,Energy Efficiency,energy,energy,29086,"dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:29119,Energy Efficiency,energy,energy,29119,"dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD3 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parame",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:29206,Energy Efficiency,energy,energy,29206,":. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecule",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:29286,Energy Efficiency,energy,energy,29286,"& disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Any or all parameters initialized; from dashcoeff[dashlvl][func] can be overwritten via; dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to override any or all values initialized by func.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (~numpy.ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ~numpy.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficien",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30230,Energy Efficiency,energy,energy-only,30230,"y.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30282,Energy Efficiency,efficient,efficient,30282,"y.ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. run_dftd4(func=None, dashlvl=None, dashparam=None, dertype=None, verbose=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30377,Energy Efficiency,energy,energy,30377,"se=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30410,Energy Efficiency,energy,energy,30410,"se=1)[source]; Compute dispersion correction via Grimmes DFTD4 program. Parameters:. func (Optional[str])  Name of functional (func only, func & disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently comp",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30490,Energy Efficiency,energy,energy,30490," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30563,Energy Efficiency,energy,energy,30563," disp, or disp only) for; which to compute dispersion (e.g., blyp, BLYP-D2, blyp-d3bj,; blyp-d3(bj), hf+d). Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended b",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:31244,Energy Efficiency,energy,energy,31244,"nfluences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both e",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:31309,Energy Efficiency,energy,energy,31309,"nfluences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both e",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:31941,Energy Efficiency,energy,energy-only,31941,"rogram.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:31993,Energy Efficiency,efficient,efficient,31993,"rogram.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:32107,Energy Efficiency,energy,energy,32107,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:32140,Energy Efficiency,energy,energy,32140,"ion to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:32220,Energy Efficiency,energy,energy,32220,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:32293,Energy Efficiency,energy,energy,32293,"; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves an XYZ file to arg0. schoenflies_symbol(self: psi4.core.Molecule)  str; Returns the Schoenflies symbol. scramble(do_shift=True, do_rotate=True, do_resort=True, deflection=1.0, do_mirror=False, do_plot=False, run_to_completion=False, run_resorting=False, verbose=1)[source]; Tester for B787 by shifting, rotating, and atom shuffling ref_mol and; checking that the aligner returns the opposite transformation. Parameters:. ref_mol (Molecule)  Molecule to perturb.; do_shift (Union[bool, ndarray, List])  Whether to generate a random atom shift on interval [-3, 3) in each; dimension (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:36169,Energy Efficiency,charge,charge,36169,"y(self: psi4.core.Molecule, arg0: List[Tuple[int, int, float]])  None; Sets molecule connectivity. set_full_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates (in Bohr) (including dummies. set_geometry(self: psi4.core.Molecule, arg0: psi4.core.Matrix)  None; Sets the geometry, given a (Natom X 3) matrix arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float)  None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float)  None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: f",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:36576,Energy Efficiency,charge,charge,36576," set_ghost_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self: psi4.core.Molecule, arg0: float)  None; Sets unit conversion to [a0] for geometry. set_mass(self: psi4.core.Molecule, atom: int, mass: float)  None; Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self: psi4.core.Molecule, arg0: int)  None; Change the overall molecular charge. Setting in initial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:40090,Energy Efficiency,charge,charge,40090,"ine the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(); Molecule.deactivate_all_fragments(); Molecule.distance_matrix(); Molecule.extract_subsets(); Molecule.fZ(); Molecule.fcharge(); Molecule.find_highest_point_group(); Molecule.find_point_group(); Molecule.fix_com(); Molecule.fix_orientation(); Molecule.flabel(); Molecule.fmass(); Molecule.form_symmetry_information(); Molecule.format_molecule_for_mol(); Molecule.from_arrays(); Molecule.from_dict(); Molecule.from_schema(); Molecule.from_string(); Molecule.fsymbol(); Molecule.ftrue_atomic_number(); Molecule.full_geometry(); Molecule.full_pg_n(); Molecule.fx(); Molecule.fy(); Molecule.fz(); Molecule.geometry(); Molecule.get_fragment_charges(); Molecule.get_fragment_multiplicities(); Molecule.get_fragment_types(); Molecule.get_fragments(); Molecule.get_full_point_group(); Molecule.get_full_point_group_with_n(); Molecule.get_variable(); Molecule.has_zmatrix(); Molec",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:20631,Integrability,wrap,wrapper,20631,"). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classm",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:21172,Integrability,wrap,wrapper,21172,"o_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1). fsymbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including d",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30627,Integrability,wrap,wraps,30627," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30666,Integrability,wrap,wraps,30666," Unlike run_dftd3, func overwrites any; parameter initialized via dashparam.; dashlvl (Optional[str])  Name of dispersion correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:31584,Integrability,interface,interface,31584,"3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:912,Modifiability,extend,extended,912,". Molecule. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Molecule. Molecule. class psi4.core.Molecule; Bases: pybind11_object; Class to store the elements, coordinates, fragmentation pattern, basis sets, charge, multiplicity, etc. of a molecule.; Methods Summary. B787(ref_mol[,do_plot,verbose,atoms_map,...]); Finds shift, rotation, and atom reordering of concern_mol that best aligns with ref_mol. BFS([seed_atoms,bond_threshold,...]); Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Z(self,arg0); Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self); Sets all fragments in the molecule to be active. add_atom(self,Z,x,y,z,symbol,mass,...); Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args,**kwargs); Overloaded function. basis_on_atom(self,arg0); Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self); Computes center of mass of molecule (does not translate molecule). charge(self,atom); Gets charge of atom (0-indexed without dummies). clone(self); Returns a new Molecule identical to arg1. com_fixed(self); Gets whether or not center of mass is fixed. comment(self); Gets molecule comment. connectivity(self); Gets molecule connectivity. create_psi4_string_from_molecule(self); Gets a string re-expressing in input format the current state of the molecule.Contains Cartesian geometry info, fragmentation, charges and multiplicities, and any frame restriction. deactivate_all_fragments(self); Sets all fragments in the molecule to be inactive. distance_matrix(self); Returns Matrix of interatom distances. extract_subsets(*args,**kwargs); Overloaded function. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:2898,Modifiability,variab,variables,2898,"ion. fZ(self,arg0); Nuclear charge of atom arg1 (0-indexed including dummies). fcharge(self,atom); Gets charge of atom (0-indexed including dummies). find_highest_point_group(self[,tolerance]); Finds highest possible computational molecular point group. find_point_group(self[,tolerance]); Finds computational molecular point group, user can override this with the symmetry keyword. fix_com(self,arg0); Sets whether to fix the Cartesian position, or to translate to the C.O.M. fix_orientation(self,arg0); Fix the orientation at its current frame. flabel(self,atom); Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self,atom); Gets mass of atom (0-indexed including dummies). form_symmetry_information(self,arg0); Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2. from_arrays([geom,elea,elez,elem,mass,...]); Construct Molecule from unvalidated arrays and variables. from_dict(arg0); Returns a new Molecule constructed from python dictionary. from_schema(molschema[,return_dict,...]); Construct Molecule from non-Psi4 schema. from_string(molstr[,dtype,name,fix_com,...]). fsymbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self); Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:4450,Modifiability,variab,variable,4450,"; Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:4482,Modifiability,variab,variables,4482,"; Gets n in Cnv, etc.; If there is no n (e.g. Td) it's the highest-order rotation axis. fx(self,arg0); x position of atom arg0 (0-indexed including dummies in Bohr). fy(self,arg0); y position of atom arg0 (0-indexed including dummies in Bohr). fz(self,arg0); z position of atom arg0 (0-indexed including dummies in Bohr). geometry(self); Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nucle",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:4808,Modifiability,variab,variable,4808,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:4843,Modifiability,variab,variables,4843,"as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self); Gets the charge of each fragment. get_fragment_multiplicities(self); Gets the multiplicity of each fragment. get_fragment_types(self); Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self); Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self); Gets point group name such as C3v or S8. get_full_point_group_with_n(self); Gets point group name such as Cnv or Sn. get_variable(self,arg0); Returns the value of variable arg0 in the structural variables list. has_zmatrix(self); Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self); Returns intertial tensor. input_units_to_au(self); Returns unit conversion to [a0] for geometry. irrep_labels(self); Returns Irreducible Representation symmetry labels. is_variable(self,arg0); Checks if variable arg0 is in the structural variables list. label(self,atom); Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self,atom); Returns mass of atom (0-indexed). mass_number(self,arg0); Mass number (A) of atom if known, else -1. molecular_charge(self); Gets the molecular charge. move_to_com(self); Moves molecule to center of mass. multiplicity(self); Gets the multiplicity (defined as 2Ms + 1). nallatom(self); Number of real and dummy atoms. name(self); Gets molecule name. natom(self); Number of real atoms. nfragments(self); Gets the number of fragments in the molecule. nuclear_dipole(*args,**kwargs); Overloaded function. nuclear_repulsion_energy(self[,dipole_field]); Computes nuclear repulsion energy. nuclear_repulsion_energy_deriv1(self[,...]); Returns first derivative of nuclear repulsion energy as a matrix (natom, 3). nuclear_repulsion_energy_deriv2(self); Returns second derivative of nuclear repulsion energy as a matrix (nato",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:9817,Modifiability,variab,variable,9817,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:9856,Modifiability,variab,variables,9856,"x arg0 of coordinates [a0] (excluding dummies). set_ghost_fragment(self,arg0); Sets the specified fragment arg0 to be Ghost. set_ghost_fragments(self,arg0); Sets the specified list arg0 of fragments to be Ghost. set_input_units_to_au(self,arg0); Sets unit conversion to [a0] for geometry. set_mass(self,atom,mass); Sets mass of atom (0-indexed) to mass (good for isotopic substitutions). set_molecular_charge(self,arg0); Change the overall molecular charge. set_multiplicity(self,arg0); Change the multiplicity (defined as 2S + 1). set_name(self,arg0); Sets molecule name. set_nuclear_charge(self,arg0,arg1); Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self,arg0); Sets the molecular point group to the point group object arg0. set_provenance(self,arg0); Sets molecule provenance. set_units(self,arg0); Sets units (Angstrom or Bohr) used to define the geometry. set_variable(self,arg0,arg1); Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Re",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:10863,Modifiability,variab,variable,10863,"e variables, then calls update_geometry(). symbol(self,atom); Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self,arg0); Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self); Returns the symmetry specified in the input. to_arrays([dummy,ghost_as_dummy]); Exports coordinate info into NumPy arrays. to_dict([force_c1,force_units,np_out]); Serializes instance into Molecule dictionary. to_schema(dtype[,units]); Serializes instance into dictionary according to schema dtype. to_string(dtype[,units,atom_format,...]); Format a string representation of QM molecule. translate(self,arg0); Translates molecule by arg0. true_atomic_number(self,atom); Gets atomic number of atom from element (0-indexed without dummies). units(self); Returns units used to define the geometry, i.e. 'Angstrom' or 'Bohr'. update_geometry(self); Reevaluates the geometry with current variable values, orientation directives, etc. x(self,arg0); x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self,i); Return the Vector3 for atom i (0-indexed without dummies). y(self,arg0); y position [Bohr] of atom arg0 (0-indexed without dummies). z(self,arg0); z position [Bohr] of atom arg0 (0-indexed without dummies). Methods Documentation. B787(ref_mol, do_plot=False, verbose=1, atoms_map=False, run_resorting=False, mols_align=False, run_to_completion=False, uno_cutoff=0.001, run_mirror=False)[source]; Finds shift, rotation, and atom reordering of concern_mol that best; aligns with ref_mol.; Wraps qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule])  Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with re",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:15911,Modifiability,extend,extended,15911,"cule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped by Lori A. Burns. Notes; Relies upon van der Waals radii and so faulty for close (especially hydrogen-bonded) fragments. See` seed_atoms`.; Any existing fragmentation info/chgmult encoded in self is lost. Z(self: psi4.core.Molecule, arg0: int)  float; Nuclear charge of atom arg0 (0-indexed without dummies). activate_all_fragments(self: psi4.core.Molecule)  None; Sets all fragments in the molecule to be active. add_atom(self: psi4.core.Molecule, Z: float, x: float, y: float, z: float, symbol: str, mass: float, charge: float, label: str, A: int)  None; Adds to self Molecule an atom with atomic number Z, Cartesian coordinates in Bohr (x, y, z), atomic symbol, mass, and charge, extended atomic label, and mass number A. atom_at_position(*args, **kwargs); Overloaded function. atom_at_position(self: psi4.core.Molecule, coord: float, tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. atom_at_position(self: psi4.core.Molecule, coord: Annotated[List[float], FixedSize(3)], tol: float) -> int. Returns the index of the atom inside tol radius around coord. Returns -1 for no atoms, throws an exception if more than one is found. basis_on_atom(self: psi4.core.Molecule, arg0: int)  str; Gets the label of the orbital basis set on a given atom arg0. center_of_mass(self: psi4.core.Molecule)  psi4.core.Vector3; Computes center of mass of molecule (does not translate molecule). charge(self: psi4.core.Molecule, atom: int)  float; Gets charge of atom (0-indexed without du",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:20613,Modifiability,variab,variables,20613,"; Gets the original label of the atom arg0 as given in the input file (C2, H4)(0-indexed including dummies). fmass(self: psi4.core.Molecule, atom: int)  float; Gets mass of atom (0-indexed including dummies). form_symmetry_information(self: psi4.core.Molecule, arg0: float)  None; Uses the point group object obtain by calling point_group(). format_molecule_for_mol(); Returns a string of Molecule formatted for mol2.; Written by Trent M. Parker 9 Jun 2014. classmethod from_arrays(geom=None, elea=None, elez=None, elem=None, mass=None, real=None, elbl=None, name=None, units='Angstrom', input_units_to_au=None, fix_com=None, fix_orientation=None, fix_symmetry=None, fragment_separators=None, fragment_charges=None, fragment_multiplicities=None, molecular_charge=None, molecular_multiplicity=None, comment=None, provenance=None, connectivity=None, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molec",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:23755,Modifiability,variab,variable,23755,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:23787,Modifiability,variab,variables,23787,"on of atom arg0 (0-indexed including dummies in Bohr). geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (excluding dummies). get_fragment_charges(self: psi4.core.Molecule)  List[int]; Gets the charge of each fragment. get_fragment_multiplicities(self: psi4.core.Molecule)  List[int]; Gets the multiplicity of each fragment. get_fragment_types(self: psi4.core.Molecule)  List[str]; Returns a list describing how to handle each fragment {Real, Ghost, Absent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:24276,Modifiability,variab,variable,24276,"ent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:24311,Modifiability,variab,variables,24311,"ent}. get_fragments(self: psi4.core.Molecule)  List[Tuple[int, int]]; Returns list of pairs of atom ranges defining each fragment from parent molecule(fragments[frag_ind] = <Afirst,Alast+1>). get_full_point_group(self: psi4.core.Molecule)  str; Gets point group name such as C3v or S8. get_full_point_group_with_n(self: psi4.core.Molecule)  str; Gets point group name such as Cnv or Sn. get_variable(self: psi4.core.Molecule, arg0: str)  float; Returns the value of variable arg0 in the structural variables list. has_zmatrix(self: psi4.core.Molecule)  bool; Get whether or not this molecule has at least one zmatrix entry. inertia_tensor(self: psi4.core.Molecule)  psi4.core.Matrix; Returns intertial tensor. input_units_to_au(self: psi4.core.Molecule)  float; Returns unit conversion to [a0] for geometry. irrep_labels(self: psi4.core.Molecule)  List[str]; Returns Irreducible Representation symmetry labels. is_variable(self: psi4.core.Molecule, arg0: str)  bool; Checks if variable arg0 is in the structural variables list. label(self: psi4.core.Molecule, atom: int)  str; Gets the original label of the atom as given in the input file (C2, H4)(0-indexed without dummies). mass(self: psi4.core.Molecule, atom: int)  float; Returns mass of atom (0-indexed). mass_number(self: psi4.core.Molecule, arg0: int)  int; Mass number (A) of atom if known, else -1. molecular_charge(self: psi4.core.Molecule)  int; Gets the molecular charge. move_to_com(self: psi4.core.Molecule)  None; Moves molecule to center of mass. multiplicity(self: psi4.core.Molecule)  int; Gets the multiplicity (defined as 2Ms + 1). nallatom(self: psi4.core.Molecule)  int; Number of real and dummy atoms. name(self: psi4.core.Molecule)  str; Gets molecule name. natom(self: psi4.core.Molecule)  int; Number of real atoms. nfragments(self: psi4.core.Molecule)  int; Gets the number of fragments in the molecule. nuclear_dipole(*args, **kwargs); Overloaded function. nuclear_dipole(self: psi4",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:30822,Modifiability,extend,extending,30822,"correction to be applied (e.g., d, D2,; d3(bj), das2010). Must be key in dashcoeff or alias or; formal to run.; dashparam (Optional[Dict])  Values for the same keys as dashcoeff[dashlvl][default]; used to provide custom values. Unlike run_dftd3, will not have; effect if func given. Must provide all parameters.; Extra parameters will error.; dertype (Union[int, str, None])  Maximum derivative level at which to run DFTD3. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:31536,Modifiability,extend,extended,31536,"3) gradient [Eh/a0]. Notes; This function wraps the QCEngine dftd4 harness which wraps the internal DFTD4 Python API.; As such, the upstream convention of func trumping dashparam holds, rather than the; run_dftd3() behavior of dashparam extending or overriding func. run_gcp(func=None, dertype=None, verbose=1)[source]; Compute geometrical BSSE correction via Grimmes GCP program.; Function to call Grimmes GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dertype is 0, gradient; if dertype is 1, else tuple of energy and gradient if dertype; unspecified. The gcp executable must be independently compiled and; found in PATH or PSIPATH. self may be either a; qcdb.Molecule (sensibly) or a psi4.Molecule (works b/c psi4.Molecule; has been extended by this method py-side and only public interface; fns used) or a string that can be instantiated into a qcdb.Molecule. Parameters:. func (Optional[str])  Name of method/basis combination or composite method for which to compute the correction; (e.g., HF/cc-pVDZ, DFT/def2-SVP, HF3c, PBEh3c).; dertype (Union[int, str, None])  Maximum derivative level at which to run GCP. For large; molecules, energy-only calculations can be significantly more; efficient. Influences return values, see below.; verbose (int)  Amount of printing. Unused at present. Returns:. energy (float)  When dertype=0, energy [Eh].; gradient (ndarray)  When dertype=1, (nat, 3) gradient [Eh/a0].; (energy, gradient) (tuple of float and ndarray)  When dertype=None, both energy [Eh] and (nat, 3) gradient [Eh/a0]. save_string_xyz(self: psi4.core.Molecule)  str; Saves the string of an XYZ file to arg2. save_string_xyz_file(self: psi4.core.Molecule)  str; Saves an XYZ file to arg2. save_xyz_file(self: psi4.core.Molecule, arg0: str, arg1: bool)  None; Saves",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:37185,Modifiability,variab,variable,37185,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:37224,Modifiability,variab,variables,37224,"nitial molecule string or constructor preferred. set_multiplicity(self: psi4.core.Molecule, arg0: int)  None; Change the multiplicity (defined as 2S + 1). Setting in initial molecule string or constructor preferred. set_name(self: psi4.core.Molecule, arg0: str)  None; Sets molecule name. set_nuclear_charge(self: psi4.core.Molecule, arg0: int, arg1: float)  None; Set the nuclear charge of the given atom arg0 to the value arg1 (primarily for ECP). set_point_group(self: psi4.core.Molecule, arg0: psi4.core.PointGroup)  None; Sets the molecular point group to the point group object arg0. set_provenance(self: psi4.core.Molecule, arg0: Dict[str, str])  None; Sets molecule provenance. set_units(self: psi4.core.Molecule, arg0: psi4.core.GeometryUnits)  None; Sets units (Angstrom or Bohr) used to define the geometry. Imposes Psi4 physical constants conversion for input_units_to_au. set_variable(self: psi4.core.Molecule, arg0: str, arg1: float)  None; Sets the value arg1 to the variable arg0 in the list of structure variables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:39233,Modifiability,variab,variable,39233,"ment symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:14245,Safety,detect,detected,14245,"and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragments among real atoms through a breadth-first search (BFS) algorithm. Parameters:. self (qcdb.Molecule or psi4.core.Molecule)  ; seed_atoms (Optional[List])  List of lists of atoms (0-indexed) belonging to independent fragments.; Useful to prompt algorithm or to define intramolecular fragments through; border atoms. Example: [[1, 0], [2]]; bond_threshold (float)  Factor beyond average of covalent radii to determine bond cutoff.; return_arrays (bool)  If True, also return fragments as list of arrays.; return_molecules (bool)  If True, also return fragments as list of Molecules.; return_molecule (bool)  If True, also return one big Molecule with fragmentation encoded. Returns:. bfs_map (list of lists)  Array of atom indices (0-indexed) of detected fragments.; bfs_arrays (tuple of lists of ndarray, optional)  geom, mass, elem info per-fragment.; Only provided if return_arrays is True.; bfs_molecules (list of qcdb.Molecule or psi4.core.Molecule, optional)  List of molecules, each built from one fragment. Center and; orientation of fragments is fixed so orientation info from self is; not lost. Loses chgmult and ghost/dummy info from self and contains; default chgmult.; Only provided if return_molecules is True.; Returned are of same type as self.; bfs_molecule (qcdb.Molecule or psi4.core.Molecule, optional)  Single molecule with same number of real atoms as self with atoms; reordered into adjacent fragments and fragment markers inserted.; Loses ghost/dummy info from self; keeps total charge but not total mult.; Only provided if return_molecule is True.; Returned is of same type as self.; Authors; -; Original code from Michael S. Marshall, linear-scaling algorithm from; Trent M. Parker, revamped b",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:21443,Security,validat,validation,21443,"e, missing_enabled_return='error', tooclose=0.1, zero_ghost_fragments=False, nonphysical=False, mtol=0.001, verbose=1, return_dict=False); Construct Molecule from unvalidated arrays and variables.; Light wrapper around from_arrays(); that is a full-featured constructor to dictionary representa-; tion of Molecule. This follows one step further to return; Molecule instance.; :param See from_arrays().:. Return type:; psi4.core.Molecule. static from_dict(arg0: dict)  psi4.core.Molecule; Returns a new Molecule constructed from python dictionary. In progress: name and capabilities should not be relied upon. classmethod from_schema(molschema, return_dict=False, nonphysical=False, verbose=1); Construct Molecule from non-Psi4 schema.; Light wrapper around from_arrays(). Parameters:. molschema (Dict)  Dictionary form of Molecule following known schema.; return_dict (bool)  Additionally return Molecule dictionary intermediate.; nonphysical (bool)  Do allow masses outside an elements natural range to pass validation?; verbose (int)  Amount of printing. Return type:; Union[Molecule, Tuple[Molecule, Dict]]. Returns:. mol (psi4.core.Molecule); molrec (dict)  Dictionary representation of instance.; Only provided if return_dict is True. classmethod from_string(molstr, dtype=None, name=None, fix_com=None, fix_orientation=None, fix_symmetry=None, return_dict=False, enable_qm=True, enable_efp=True, missing_enabled_return_qm='none', missing_enabled_return_efp='none', verbose=1). fsymbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed including dummies). ftrue_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed including dummies). full_geometry(self: psi4.core.Molecule)  psi4.core.Matrix; Gets the geometry [Bohr] as a (Natom X 3) matrix of coordinates (including dummies). full_pg_n(self: psi4.core.Molecule)  int; Gets n in Cnv, etc.; If there is no n (e.g. ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:38216,Security,hash,hash,38216,"iables, then calls update_geometry(). symbol(self: psi4.core.Molecule, atom: int)  str; Gets the cleaned up label of atom (C2 => C, H4 = H) (0-indexed without dummies). symmetrize(self: psi4.core.Molecule, arg0: float)  None; Finds the highest point Abelian point group within the specified tolerance, and forces the geometry to have that symmetry. symmetry_from_input(self: psi4.core.Molecule)  str; Returns the symmetry specified in the input. to_arrays(dummy=False, ghost_as_dummy=False)[source]; Exports coordinate info into NumPy arrays. Parameters:. dummy (bool)  Whether or not to include dummy atoms in returned arrays.; ghost_as_dummy (bool)  Whether or not to treat ghost atoms as dummies. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray, ndarray]. Returns:. geom, mass, elem, elez, uniq (numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray)  (nat, 3) geometry [a0].; (nat,) mass [u].; (nat,) element symbol.; (nat,) atomic number.; (nat,) hash of element symbol and mass.; Note that coordinate, orientation, and element information is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with cur",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:12486,Testability,test,test,12486," qcelemental.molutil.B787() for psi4.driver.qcdb.Molecule or; psi4.core.Molecule. Employs the Kabsch, Hungarian, and; Uno algorithms to exhaustively locate the best alignment for; non-oriented, non-ordered structures. Parameters:. concern_mol (Union[Molecule, Molecule])  Molecule of concern, to be shifted, rotated, and reordered into; best coincidence with ref_mol.; ref_mol (Union[Molecule, Molecule])  Molecule to match.; atoms_map (bool)  Whether atom1 of ref_mol corresponds to atom1 of concern_mol, etc.; If true, specifying True can save much time.; mols_align (bool)  Whether ref_mol and concern_mol have identical geometries by eye; (barring orientation or atom mapping) and expected final RMSD = 0.; If True, procedure is truncated when RMSD condition met, saving time.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  Run reorderings to completion (past RMSD = 0) even if unnecessary because; mols_align=True. Used to test worst-case timings.; run_resorting (bool)  Run the resorting machinery even if unnecessary because atoms_map=True.; uno_cutoff (float)  TODO; run_mirror (bool)  Run alternate geometries potentially allowing best match to ref_mol; from mirror image of concern_mol. Only run if system confirmed to; be nonsuperimposable upon mirror reflection.; verbose (int)  . Returns:; First item is RMSD [A] between ref_mol and the optimally aligned; geometry computed.; Second item is a AlignmentMill namedtuple with fields; (shift, rotation, atommap, mirror) that prescribe the transformation; from concern_mol and the optimally aligned geometry.; Third item is a crude charge-, multiplicity-, fragment-less Molecule; at optimally aligned (and atom-ordered) geometry. Return type; determined by concern_mol type. Return type:; float, tuple, qcdb.Molecule or psi4.core.Molecule. BFS(seed_atoms=None, bond_threshold=1.2, return_arrays=False, return_molecules=False, return_molecule=False)[source]; Detect fragment",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:34182,Testability,test,test,34182,"on (True) or leave at current origin. To shift by a specified; vector, supply a 3-element list.; do_rotate (Union[bool, ndarray, List[List]])  Whether to generate a random 3D rotation according to algorithm of Arvo.; To rotate by a specified matrix, supply a 9-element list of lists.; do_resort (Union[bool, List])  Whether to shuffle atoms (True) or leave 1st atom 1st, etc. (False).; To specify shuffle, supply a nat-element list of indices.; deflection (float)  If do_rotate, how random a rotation: 0.0 is no change, 0.1 is small; perturbation, 1.0 is completely random.; do_mirror (bool)  Whether to construct the mirror image structure by inverting y-axis.; do_plot (bool)  Pops up a mpl plot showing before, after, and ref geometries.; run_to_completion (bool)  By construction, scrambled systems are fully alignable (final RMSD=0).; Even so, True turns off the mechanism to stop when RMSD reaches zero; and instead proceed to worst possible time.; run_resorting (bool)  Even if atoms not shuffled, test the resorting machinery.; verbose (int)  Print level. Return type:; None. set_active_fragment(self: psi4.core.Molecule, arg0: int)  None; Sets the specified fragment arg0 to be Real. set_active_fragments(self: psi4.core.Molecule, arg0: List[int])  None; Sets the specified list arg0 of fragments to be Real. set_basis_all_atoms(self: psi4.core.Molecule, arg0: str, arg1: str)  None; Sets basis set arg0 to all atoms. set_basis_by_label(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with label (e.g., H4) arg0. set_basis_by_number(self: psi4.core.Molecule, arg0: int, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with number arg0. set_basis_by_symbol(self: psi4.core.Molecule, arg0: str, arg1: str, arg2: str)  None; Sets basis set arg1 to all atoms with symbol (e.g., H) arg0. set_comment(self: psi4.core.Molecule, arg0: str)  None; Sets molecule comment. set_connectivity(self: psi4.core.Molecule,",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html:39282,Usability,clear,clearing,39282,"rmation is; preserved but fragmentation, chgmult, and dummy/ghost is lost.; Usage; ; geom, mass, elem, elez, uniq = molinstance.to_arrays(). to_dict(force_c1=False, force_units=False, np_out=True)[source]; Serializes instance into Molecule dictionary. to_schema(dtype, units='Bohr')[source]; Serializes instance into dictionary according to schema dtype. to_string(dtype, units=None, atom_format=None, ghost_format=None, width=17, prec=12)[source]; Format a string representation of QM molecule. translate(self: psi4.core.Molecule, arg0: psi4.core.Vector3)  None; Translates molecule by arg0. true_atomic_number(self: psi4.core.Molecule, atom: int)  int; Gets atomic number of atom from element (0-indexed without dummies). units(self: psi4.core.Molecule)  str; Returns units used to define the geometry, i.e. Angstrom or Bohr. update_geometry(self: psi4.core.Molecule)  None; Reevaluates the geometry with current variable values, orientation directives, etc. by clearing the atoms list and rebuilding it. Idempotent. Use liberally.Must be called after initial Molecule definition by string. x(self: psi4.core.Molecule, arg0: int)  float; x position [Bohr] of atom arg0 (0-indexed without dummies). xyz(self: psi4.core.Molecule, i: int)  psi4.core.Vector3; Return the Vector3 for atom i (0-indexed without dummies). y(self: psi4.core.Molecule, arg0: int)  float; y position [Bohr] of atom arg0 (0-indexed without dummies). z(self: psi4.core.Molecule, arg0: int)  float; z position [Bohr] of atom arg0 (0-indexed without dummies). table of contents. Molecule; Molecule; Molecule.B787(); Molecule.BFS(); Molecule.Z(); Molecule.activate_all_fragments(); Molecule.add_atom(); Molecule.atom_at_position(); Molecule.basis_on_atom(); Molecule.center_of_mass(); Molecule.charge(); Molecule.clone(); Molecule.com_fixed(); Molecule.comment(); Molecule.connectivity(); Molecule.create_psi4_string_from_molecule(); Molecule.deactivate_all_fragments(); Molecule.distance_matrix(); Molecu",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MOSpace.html:1614,Deployability,update,updated,1614,". MOSpace. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MOSpace. MOSpace. class psi4.core.MOSpace; Bases: pybind11_object; Defines orbital spaces in which to transform integrals; Methods Summary. aIndex(self); Get the alpha orbital indexing array. aOrbs(self); Get the alpha orbitals. all(). bIndex(self); Get the beta orbital indexing array. bOrbs(self); Get the beta orbitals. dum(). fzc(). fzv(). label(self); Get the unique identifier for this space. nil(). occ(). vir(). Methods Documentation. aIndex(self: psi4.core.MOSpace)  List[int]; Get the alpha orbital indexing array. aOrbs(self: psi4.core.MOSpace)  List[int]; Get the alpha orbitals. static all()  psi4.core.MOSpace. bIndex(self: psi4.core.MOSpace)  List[int]; Get the beta orbital indexing array. bOrbs(self: psi4.core.MOSpace)  List[int]; Get the beta orbitals. static dum()  psi4.core.MOSpace. static fzc()  psi4.core.MOSpace. static fzv()  psi4.core.MOSpace. label(self: psi4.core.MOSpace)  str; Get the unique identifier for this space. static nil()  psi4.core.MOSpace. static occ()  psi4.core.MOSpace. static vir()  psi4.core.MOSpace. table of contents. MOSpace; MOSpace; MOSpace.aIndex(); MOSpace.aOrbs(); MOSpace.all(); MOSpace.bIndex(); MOSpace.bOrbs(); MOSpace.dum(); MOSpace.fzc(); MOSpace.fzv(); MOSpace.label(); MOSpace.nil(); MOSpace.occ(); MOSpace.vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MOSpace.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MOSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MOSpace.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MOWriter.html:581,Deployability,update,updated,581,". MOWriter. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MOWriter. MOWriter. class psi4.core.MOWriter; Bases: pybind11_object; Writes the MOs; Methods Summary. write(self); Write the MOs. Methods Documentation. write(self: psi4.core.MOWriter)  None; Write the MOs. table of contents. MOWriter; MOWriter; MOWriter.write(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MOWriter.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MOWriter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MOWriter.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.mrcc_generate_input.html:583,Deployability,update,updated,583,". mrcc_generate_input. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; mrcc_generate_input. mrcc_generate_input. psi4.core.mrcc_generate_input(arg0: psi4.core.Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Generates an input for Kallays MRCC code. table of contents. mrcc_generate_input; mrcc_generate_input(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; mrcc_generate_input.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.mrcc_generate_input.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.mrcc_generate_input.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.mrcc_load_densities.html:595,Deployability,update,updated,595,". mrcc_load_densities. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; mrcc_load_densities. mrcc_load_densities. psi4.core.mrcc_load_densities(arg0: psi4.core.Wavefunction, arg1: dict)  psi4.core.PsiReturnType; Reads in the density matrices from Kallays MRCC code. table of contents. mrcc_load_densities; mrcc_load_densities(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; mrcc_load_densities.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.mrcc_load_densities.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.mrcc_load_densities.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MultipoleInt.html:494,Deployability,update,updated,494,". MultipoleInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MultipoleInt. MultipoleInt. class psi4.core.MultipoleInt; Bases: OneBodyAOInt; Computes arbitrary-order multipole integrals. table of contents. MultipoleInt; MultipoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MultipoleInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MultipoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MultipoleInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.MultipoleSymmetry.html:714,Deployability,update,updated,714,". MultipoleSymmetry. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MultipoleSymmetry. MultipoleSymmetry. class psi4.core.MultipoleSymmetry; Bases: pybind11_object; docstring; Methods Summary. create_matrices(self,arg0); docstring. Methods Documentation. create_matrices(self: psi4.core.MultipoleSymmetry, arg0: str)  List[psi4.core.Matrix]; docstring. table of contents. MultipoleSymmetry; MultipoleSymmetry; MultipoleSymmetry.create_matrices(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; MultipoleSymmetry.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.MultipoleSymmetry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.MultipoleSymmetry.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NablaInt.html:446,Deployability,update,updated,446,". NablaInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NablaInt. NablaInt. class psi4.core.NablaInt; Bases: OneBodyAOInt; Computes nabla integrals. table of contents. NablaInt; NablaInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NablaInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NablaInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NablaInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:668,Deployability,integrat,integration,668,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. P",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:982,Deployability,integrat,integration,982,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. P",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:1313,Deployability,integrat,integration,1313,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:1675,Deployability,integrat,integration,1675,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:2095,Deployability,update,updated,2095,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:668,Integrability,integrat,integration,668,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. P",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:982,Integrability,integrat,integration,982,". NumIntHelper. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper. NumIntHelper. class psi4.core.NumIntHelper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. P",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:1313,Integrability,integrat,integration,1313,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html:1675,Integrability,integrat,integration,1675,"lper; Bases: pybind11_object; Computes numerical integrals using a DFT grid.; Methods Summary. dd_density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. density_integral(self,grid_data,D); Compute an integral int rho(r) f(r) where f is a vector-valued function. numint_grid(self). potential_integral(self,arg0); Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. Methods Documentation. dd_density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Matrix; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_atoms, n_data). density_integral(self: psi4.core.NumIntHelper, grid_data: List[psi4.core.Matrix], D: psi4.core.Matrix)  psi4.core.Vector; Compute an integral int rho(r) f(r) where f is a vector-valued function. f is represented for each block of points of the integration grid as a matrix (n_data, n_points). Return has shape (n_data). numint_grid(self: psi4.core.NumIntHelper)  psi4.core.DFTGrid. potential_integral(self: psi4.core.NumIntHelper, arg0: List[psi4.core.Vector])  psi4.core.Matrix; Compute an integral int chi_mu(r) chi_nu(r) f(r) where f is a scalar function represented for each block of points of the integration grid as a vector of n_points. table of contents. NumIntHelper; NumIntHelper; NumIntHelper.dd_density_integral(); NumIntHelper.density_integral(); NumIntHelper.numint_grid(); NumIntHelper.potential_integral(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; NumIntHelper.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.NumIntHelper.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.NumIntHelper.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.occ.html:455,Deployability,update,updated,455,". occ. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; occ. occ. psi4.core.occ(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the orbital optimized CC codes. table of contents. occ; occ(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; occ.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.occ.html:214,Performance,optimiz,optimized,214,". occ. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; occ. occ. psi4.core.occ(ref_wfn: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the orbital optimized CC codes. table of contents. occ; occ(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; occ.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.occ.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.occ.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:3518,Deployability,update,updated,3518," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:975,Modifiability,variab,variables,975,". OEProp. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp. class psi4.core.OEProp; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self,arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self,Da[,symmetry]); docstring. set_Da_mo(self,arg0); docstring. set_Da_so(self,arg0); docstring. set_Db_ao(self,Db[,symmetry]); docstring. set_Db_mo(self,arg0); docstring. set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  Non",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:2614,Modifiability,variab,variables,2614," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:2883,Modifiability,variab,variables,2883," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:611,Usability,clear,clear,611,". OEProp. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OEProp. OEProp. class psi4.core.OEProp; Bases: pybind11_object; docstring; Attributes Summary. valid_methods. Methods Summary. Exvals(self); The x component of the field (in a.u.) at each grid point. Eyvals(self); The y component of the field (in a.u.) at each grid point. Ezvals(self); The z component of the field (in a.u.) at each grid point. Vvals(self); The electrostatic potential (in a.u.) at each grid point. add(self,arg0); Append the given task to the list of properties to compute. clear(self); Clear the list of properties to compute. compute(self); Compute the properties. set_Da_ao(self,Da[,symmetry]); docstring. set_Da_mo(self,arg0); docstring. set_Da_so(self,arg0); docstring. set_Db_ao(self,Db[,symmetry]); docstring. set_Db_mo(self,arg0); docstring. set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  Non",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:1884,Usability,clear,clear,1884,". set_Db_so(self,arg0); docstring. set_names(self,arg0); Instruct OEProp to save variables under all specified names. set_title(self,title); Title OEProp for print purposes. Attributes Documentation. valid_methods = ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'LOWDIN_CHARGES', 'WIBERG_LOWDIN_INDICES', 'MAYER_INDICES', 'MBIS_CHARGES', 'MBIS_VOLUME_RATIOS', 'MO_EXTENTS', 'GRID_FIELD', 'GRID_ESP', 'ESP_AT_NUCLEI', 'NO_OCCUPATIONS']. Methods Documentation. Exvals(self: psi4.core.OEProp)  List[float]; The x component of the field (in a.u.) at each grid point. Eyvals(self: psi4.core.OEProp)  List[float]; The y component of the field (in a.u.) at each grid point. Ezvals(self: psi4.core.OEProp)  List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html:3138,Usability,clear,clear,3138," List[float]; The z component of the field (in a.u.) at each grid point. Vvals(self: psi4.core.OEProp)  List[float]; The electrostatic potential (in a.u.) at each grid point. add(self: psi4.core.OEProp, arg0: str)  None; Append the given task to the list of properties to compute. clear(self: psi4.core.OEProp)  None; Clear the list of properties to compute. compute(self: psi4.core.OEProp)  None; Compute the properties. set_Da_ao(self: psi4.core.OEProp, Da: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Da_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Da_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_ao(self: psi4.core.OEProp, Db: psi4.core.Matrix, symmetry: int = 0)  None; docstring. set_Db_mo(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_Db_so(self: psi4.core.OEProp, arg0: psi4.core.Matrix)  None; docstring. set_names(self: psi4.core.OEProp, arg0: Set[str])  None; Instruct OEProp to save variables under all specified names. The property name will be inserted at every occurrence of {}, like Python format strings. Wipes other names-to-save-by. set_title(self: psi4.core.OEProp, title: str)  None; Title OEProp for print purposes. As a side effect, saves variables as title + propertyname and only that. Follow up with side names, if the side effect is undesired,. table of contents. OEProp; OEProp; OEProp.valid_methods; OEProp.Exvals(); OEProp.Eyvals(); OEProp.Ezvals(); OEProp.Vvals(); OEProp.add(); OEProp.clear(); OEProp.compute(); OEProp.set_Da_ao(); OEProp.set_Da_mo(); OEProp.set_Da_so(); OEProp.set_Db_ao(); OEProp.set_Db_mo(); OEProp.set_Db_so(); OEProp.set_names(); OEProp.set_title(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OEProp.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OEProp.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OEProp.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OneBodyAOInt.html:1586,Deployability,update,updated,1586,". OneBodyAOInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OneBodyAOInt. OneBodyAOInt. class psi4.core.OneBodyAOInt; Bases: pybind11_object; Basis class for all one-electron integrals; Attributes Summary. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Summary. compute(self,arg0); Compute all integrals over both basis sets, and store them in the provided matrix. compute_shell(self,arg0,arg1); Compute integrals between basis functions in the given shell pair. Attributes Documentation. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. origin; The origin about which the one body ints are being computed. Methods Documentation. compute(self: psi4.core.OneBodyAOInt, arg0: List[psi4.core.Matrix])  None; Compute all integrals over both basis sets, and store them in the provided matrix. compute_shell(self: psi4.core.OneBodyAOInt, arg0: int, arg1: int)  None; Compute integrals between basis functions in the given shell pair. table of contents. OneBodyAOInt; OneBodyAOInt; OneBodyAOInt.basis; OneBodyAOInt.basis1; OneBodyAOInt.basis2; OneBodyAOInt.origin; OneBodyAOInt.compute(); OneBodyAOInt.compute_shell(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OneBodyAOInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OneBodyAOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OneBodyAOInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OneBodySOInt.html:782,Deployability,update,updated,782,". OneBodySOInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OneBodySOInt. OneBodySOInt. class psi4.core.OneBodySOInt; Bases: pybind11_object; Attributes Summary. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. Attributes Documentation. basis; The basis set on center one. basis1; The basis set on center one. basis2; The basis set on center two. table of contents. OneBodySOInt; OneBodySOInt; OneBodySOInt.basis; OneBodySOInt.basis1; OneBodySOInt.basis2. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OneBodySOInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OneBodySOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OneBodySOInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html:4247,Deployability,update,updated,4247,"on. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options)  None; print the global, cross-module options. print_module_options(self: psi4.core.Options)  None; print global and local options prepared for current module. read_globals(self: psi4.core.Options)  bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str)  None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool)  None; set bool option. set_current_module(self: psi4.core.Options, arg0: str)  None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float)  None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int)  None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool)  None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. validate_options(self: psi4.core.Options)  None; validate options for arg0 module. table of contents. Options; Options; Options.add_array(); Options.add_bool(); Options.add_int(); Options.add_str(); Options.add_str_i(); Options.get_bool(); Options.get_current_module(); Options.get_double(); Options.get_int(); Options.get_int_vector(); Options.get_str(); Options.print_global_options(); Options.print_module_options(); Options.read_globals(); Options.set_array(); Options.set_bool(); Options.set_current_module(); Options.set_double(); Options.set_int(); Options.set_read_globals(); Options.set_str(); Options.set_str_i(); Options.validate_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html:1345,Security,validat,validate,1345,"(self,arg0,arg1,arg2); add string option. add_str_i(self,arg0,arg1,arg2); add string option. get_bool(self,arg0); get boolean option. get_current_module(self); gets current module. get_double(self,arg0); get double option. get_int(self,arg0); get integer option. get_int_vector(self,arg0); get int vector option. get_str(*args,**kwargs); Overloaded function. print_global_options(self); print the global, cross-module options. print_module_options(self); print global and local options prepared for current module. read_globals(self); expert. set_array(self,arg0,arg1); set array option. set_bool(self,arg0,arg1,arg2); set bool option. set_current_module(self,arg0); sets arg0 (all CAPS) as current module. set_double(self,arg0,arg1,arg2); set double option. set_int(self,arg0,arg1,arg2); set int option. set_read_globals(self,arg0); expert. set_str(self,arg0,arg1,arg2); set string option. set_str_i(self,arg0,arg1,arg2); set string option. validate_options(self); validate options for arg0 module. Methods Documentation. add_array(self: psi4.core.Options, arg0: str)  None; add array option. add_bool(self: psi4.core.Options, arg0: str, arg1: bool)  None; add bool option. add_int(self: psi4.core.Options, arg0: str, arg1: int)  None; add int option. add_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; add string option. add_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; add string option. get_bool(self: psi4.core.Options, arg0: str)  bool; get boolean option. get_current_module(self: psi4.core.Options)  str; gets current module. get_double(self: psi4.core.Options, arg0: str)  float; get double option. get_int(self: psi4.core.Options, arg0: str)  int; get integer option. get_int_vector(self: psi4.core.Options, arg0: str)  List[int]; get int vector option. get_str(*args, **kwargs); Overloaded function. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. get_str(self: psi4.",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html:3450,Security,validat,validate,3450,"on. get_str(self: psi4.core.Options, arg0: str) -> str. get string option. print_global_options(self: psi4.core.Options)  None; print the global, cross-module options. print_module_options(self: psi4.core.Options)  None; print global and local options prepared for current module. read_globals(self: psi4.core.Options)  bool; expert. set_array(self: psi4.core.Options, arg0: str, arg1: str)  None; set array option. set_bool(self: psi4.core.Options, arg0: str, arg1: str, arg2: bool)  None; set bool option. set_current_module(self: psi4.core.Options, arg0: str)  None; sets arg0 (all CAPS) as current module. set_double(self: psi4.core.Options, arg0: str, arg1: str, arg2: float)  None; set double option. set_int(self: psi4.core.Options, arg0: str, arg1: str, arg2: int)  None; set int option. set_read_globals(self: psi4.core.Options, arg0: bool)  None; expert. set_str(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. set_str_i(self: psi4.core.Options, arg0: str, arg1: str, arg2: str)  None; set string option. validate_options(self: psi4.core.Options)  None; validate options for arg0 module. table of contents. Options; Options; Options.add_array(); Options.add_bool(); Options.add_int(); Options.add_str(); Options.add_str_i(); Options.get_bool(); Options.get_current_module(); Options.get_double(); Options.get_int(); Options.get_int_vector(); Options.get_str(); Options.print_global_options(); Options.print_module_options(); Options.read_globals(); Options.set_array(); Options.set_bool(); Options.set_current_module(); Options.set_double(); Options.set_int(); Options.set_read_globals(); Options.set_str(); Options.set_str_i(); Options.validate_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Options.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.options_to_python.html:534,Deployability,update,updated,534,". options_to_python. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; options_to_python. options_to_python. psi4.core.options_to_python(arg0: str)  dict; Get dictionary of whether options of module have changed. table of contents. options_to_python; options_to_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; options_to_python.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.options_to_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.options_to_python.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.option_exists_in_module.html:581,Deployability,update,updated,581,". option_exists_in_module. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; option_exists_in_module. option_exists_in_module. psi4.core.option_exists_in_module(module: str, key: str)  bool; Whether keyword key is a valid keyword for module. table of contents. option_exists_in_module; option_exists_in_module(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; option_exists_in_module.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.option_exists_in_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.option_exists_in_module.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html:1742,Availability,toler,tolerance,1742,"ons. evals(self); Corresponding eigenvalues of the C matrix. id(self); Unique identifier. integral(self); The integral factory used to create C. name(self); Name of the orbital space. nirrep(self); Returns number of irreps. print_out(self); Print information about the orbital space to the output file. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = ri_space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(combined: psi4.core.BasisSet, lindep_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given combined basis sets, it constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, combined, is the two basis sets together but unorthogonalized The second argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about t",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html:2134,Availability,toler,tolerance,2134,"core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = ri_space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(combined: psi4.core.BasisSet, lindep_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given combined basis sets, it constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, combined, is the two basis sets together but unorthogonalized The second argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C(); OrbitalSpace.basisset(); OrbitalSpace.build_cabs_space(); OrbitalSpace.build_ri_space(); OrbitalSpace.dim(); OrbitalSpace.evals(); OrbitalSpace.id(); OrbitalSpace.integral(); OrbitalSpace.name(); OrbitalSpace.nirrep(); OrbitalSpace.print_out(). ; hide menu. menu",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html:3271,Deployability,update,updated,3271,"pace, linear_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = ri_space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(combined: psi4.core.BasisSet, lindep_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given combined basis sets, it constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, combined, is the two basis sets together but unorthogonalized The second argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C(); OrbitalSpace.basisset(); OrbitalSpace.build_cabs_space(); OrbitalSpace.build_ri_space(); OrbitalSpace.dim(); OrbitalSpace.evals(); OrbitalSpace.id(); OrbitalSpace.integral(); OrbitalSpace.name(); OrbitalSpace.nirrep(); OrbitalSpace.print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OrbitalSpace.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html:1763,Integrability,depend,dependencies,1763,"ons. evals(self); Corresponding eigenvalues of the C matrix. id(self); Unique identifier. integral(self); The integral factory used to create C. name(self); Name of the orbital space. nirrep(self); Returns number of irreps. print_out(self); Print information about the orbital space to the output file. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = ri_space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(combined: psi4.core.BasisSet, lindep_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given combined basis sets, it constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, combined, is the two basis sets together but unorthogonalized The second argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about t",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html:1977,Integrability,depend,dependent,1977,"the orbital space to the output file. Methods Documentation. C(self: psi4.core.OrbitalSpace)  psi4.core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = ri_space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(combined: psi4.core.BasisSet, lindep_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given combined basis sets, it constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, combined, is the two basis sets together but unorthogonalized The second argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C(); OrbitalSpace.basisset(); OrbitalSpace.build_cabs_space(); OrbitalSpace.build_ri_space(); OrbitalSpace.dim(); OrbitalSpace.evals(); OrbitalSpace.id(); OrbitalSpace",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html:2155,Integrability,depend,dependencies,2155,"core.Matrix; MO coefficient matrix, AO->MO or SO->MO transformation matrix. basisset(self: psi4.core.OrbitalSpace)  psi4.core.BasisSet; The AO basis set used to create C. static build_cabs_space(orb_space: psi4.core.OrbitalSpace, ri_space: psi4.core.OrbitalSpace, linear_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given two spaces, it projects out one space from the other and returns the new spaces The first argument (orb_space) is the space to project out. The returned space will be orthogonal to this The second argument (ri_space) is the space that is being projected on. The returned space = ri_space - orb_space The third argument is the tolerance for linear dependencies. static build_ri_space(combined: psi4.core.BasisSet, lindep_tol: float = 1e-06)  psi4.core.OrbitalSpace; Given combined basis sets, it constructs an orthogonalized space with the same span. Linearly dependent orbitals are thrown out. The first argument, combined, is the two basis sets together but unorthogonalized The second argument, lindep_tol, is the tolerance for linear dependencies. dim(self: psi4.core.OrbitalSpace)  psi4.core.Dimension; MO dimensions. evals(self: psi4.core.OrbitalSpace)  psi4.core.Vector; Corresponding eigenvalues of the C matrix. id(self: psi4.core.OrbitalSpace)  str; Unique identifier. integral(self: psi4.core.OrbitalSpace)  psi4.core.IntegralFactory; The integral factory used to create C. name(self: psi4.core.OrbitalSpace)  str; Name of the orbital space. nirrep(self: psi4.core.OrbitalSpace)  int; Returns number of irreps. print_out(self: psi4.core.OrbitalSpace)  None; Print information about the orbital space to the output file. table of contents. OrbitalSpace; OrbitalSpace; OrbitalSpace.C(); OrbitalSpace.basisset(); OrbitalSpace.build_cabs_space(); OrbitalSpace.build_ri_space(); OrbitalSpace.dim(); OrbitalSpace.evals(); OrbitalSpace.id(); OrbitalSpace.integral(); OrbitalSpace.name(); OrbitalSpace.nirrep(); OrbitalSpace.print_out(). ; hide menu. menu",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OrbitalSpace.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.outfile_name.html:468,Deployability,update,updated,468,". outfile_name. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; outfile_name. outfile_name. psi4.core.outfile_name()  str; Returns the name of the output file. table of contents. outfile_name; outfile_name(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; outfile_name.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.outfile_name.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.outfile_name.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.OverlapInt.html:462,Deployability,update,updated,462,". OverlapInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OverlapInt. OverlapInt. class psi4.core.OverlapInt; Bases: OneBodyAOInt; Computes overlap integrals. table of contents. OverlapInt; OverlapInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; OverlapInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.OverlapInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.OverlapInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.PetiteList.html:974,Deployability,update,updated,974,". PetiteList. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PetiteList. PetiteList. class psi4.core.PetiteList; Bases: pybind11_object; Handles symmetry transformations; Methods Summary. aotoso(self); Return the AO->SO coefficient matrix. print(self,arg0); Print to outfile. sotoao(self); Return the SO->AO coefficient matrix. Methods Documentation. aotoso(self: psi4.core.PetiteList)  psi4.core.Matrix; Return the AO->SO coefficient matrix. print(self: psi4.core.PetiteList, arg0: str)  None; Print to outfile. sotoao(self: psi4.core.PetiteList)  psi4.core.Matrix; Return the SO->AO coefficient matrix. table of contents. PetiteList; PetiteList; PetiteList.aotoso(); PetiteList.print(); PetiteList.sotoao(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PetiteList.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.PetiteList.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.PetiteList.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:509,Deployability,update,updated,509,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:3,Modifiability,plugin,plugin,3,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:115,Modifiability,plugin,plugin,115,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:123,Modifiability,plugin,plugin,123,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:142,Modifiability,plugin,plugin,142,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:226,Modifiability,plugin,plugin,226,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:259,Modifiability,plugin,plugin,259,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:298,Modifiability,plugin,plugin,298,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:306,Modifiability,plugin,plugin,306,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html:454,Modifiability,plugin,plugin,454,". plugin. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin. plugin. psi4.core.plugin(arg0: str, arg1: psi4.core.Wavefunction)  psi4.core.Wavefunction; Call the plugin of name arg0. Returns the plugin code result. table of contents. plugin; plugin(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close.html:472,Deployability,update,updated,472,". plugin_close. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close. plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. table of contents. plugin_close; plugin_close(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close.html:203,Modifiability,plugin,plugin,203,". plugin_close. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close. plugin_close. psi4.core.plugin_close(arg0: str)  None; Close the plugin of name arg0. table of contents. plugin_close; plugin_close(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_close.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close_all.html:484,Deployability,update,updated,484,". plugin_close_all. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all. plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. table of contents. plugin_close_all; plugin_close_all(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close_all.html:215,Modifiability,plugin,plugins,215,". plugin_close_all. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all. plugin_close_all. psi4.core.plugin_close_all()  None; Close all open plugins. table of contents. plugin_close_all; plugin_close_all(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_close_all.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_close_all.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_close_all.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html:522,Deployability,update,updated,522,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html:197,Modifiability,plugin,plugin,197,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html:235,Performance,load,loaded,235,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html:248,Performance,load,loaded,248,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html:269,Performance,load,loaded,269,". plugin_load. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load. plugin_load. psi4.core.plugin_load(arg0: str)  int; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. table of contents. plugin_load; plugin_load(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; plugin_load.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.plugin_load.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.plugin_load.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.PMLocalizer.html:481,Deployability,update,updated,481,". PMLocalizer. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer. PMLocalizer. class psi4.core.PMLocalizer; Bases: Localizer; Performs Pipek-Mezey orbital localization. table of contents. PMLocalizer; PMLocalizer. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PMLocalizer.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.PMLocalizer.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.PMLocalizer.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.PointFunctions.html:1803,Deployability,update,updated,1803,". PointFunctions. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PointFunctions. PointFunctions. class psi4.core.PointFunctions; Bases: BasisFunctions; docstring; Methods Summary. ansatz(self); docstring. compute_points(self,block[,force_compute]); docstring. orbital_values(self); docstring. point_values(self); docstring. print_out(self[,out_fname,print]); docstring. set_ansatz(self,arg0); docstring. set_pointers(*args,**kwargs); Overloaded function. Methods Documentation. ansatz(self: psi4.core.PointFunctions)  int; docstring. compute_points(self: psi4.core.PointFunctions, block: psi4.core.BlockOPoints, force_compute: bool = True)  None; docstring. orbital_values(self: psi4.core.PointFunctions)  Dict[str, psi4.core.Matrix]; docstring. point_values(self: psi4.core.PointFunctions)  Dict[str, psi4.core.Vector]; docstring. print_out(self: psi4.core.PointFunctions, out_fname: str = 'outfile', print: int = 2)  None; docstring. set_ansatz(self: psi4.core.PointFunctions, arg0: int)  None; docstring. set_pointers(*args, **kwargs); Overloaded function. set_pointers(self: psi4.core.PointFunctions, arg0: psi4.core.Matrix) -> None. docstring. set_pointers(self: psi4.core.PointFunctions, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix) -> None. docstring. table of contents. PointFunctions; PointFunctions; PointFunctions.ansatz(); PointFunctions.compute_points(); PointFunctions.orbital_values(); PointFunctions.point_values(); PointFunctions.print_out(); PointFunctions.set_ansatz(); PointFunctions.set_pointers(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PointFunctions.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.PointFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.PointFunctions.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.PointGroup.html:1390,Deployability,update,updated,1390,". PointGroup. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PointGroup. PointGroup. class psi4.core.PointGroup; Bases: pybind11_object; Contains information about the point group; Methods Summary. bits(self); Return the bit representation of the point group. char_table(self); Return the CharacterTable of the point group. full_name(self); Return the Schoenflies symbol with direction. order(self); Return the order of the point group. symbol(self); Returns Schoenflies symbol for point group. Methods Documentation. bits(self: psi4.core.PointGroup)  int; Return the bit representation of the point group. char_table(self: psi4.core.PointGroup)  psi4.core.CharacterTable; Return the CharacterTable of the point group. full_name(self: psi4.core.PointGroup)  str; Return the Schoenflies symbol with direction. order(self: psi4.core.PointGroup)  int; Return the order of the point group. symbol(self: psi4.core.PointGroup)  str; Returns Schoenflies symbol for point group. table of contents. PointGroup; PointGroup; PointGroup.bits(); PointGroup.char_table(); PointGroup.full_name(); PointGroup.order(); PointGroup.symbol(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PointGroup.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.PointGroup.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.PointGroup.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.PotentialInt.html:478,Deployability,update,updated,478,". PotentialInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PotentialInt. PotentialInt. class psi4.core.PotentialInt; Bases: OneBodyAOInt; Computes potential integrals. table of contents. PotentialInt; PotentialInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PotentialInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.PotentialInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.PotentialInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.prepare_options_for_module.html:637,Deployability,update,updated,637,". prepare_options_for_module. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module. prepare_options_for_module. psi4.core.prepare_options_for_module(name: str)  None; Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). table of contents. prepare_options_for_module; prepare_options_for_module(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.prepare_options_for_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.prepare_options_for_module.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.prepare_options_for_module.html:323,Modifiability,plugin,plugin,323,". prepare_options_for_module. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module. prepare_options_for_module. psi4.core.prepare_options_for_module(name: str)  None; Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). table of contents. prepare_options_for_module; prepare_options_for_module(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; prepare_options_for_module.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.prepare_options_for_module.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.prepare_options_for_module.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.PrimitiveType.html:818,Deployability,update,updated,818,". PrimitiveType. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PrimitiveType. PrimitiveType. class psi4.core.PrimitiveType; Bases: pybind11_object; May be Normalized or Unnormalized; Members:. Normalized; Unnormalized. Attributes Summary. Normalized. Unnormalized. name. value. Attributes Documentation. Normalized = <PrimitiveType.Normalized: 0>. Unnormalized = <PrimitiveType.Unnormalized: 1>. name. value. table of contents. PrimitiveType; PrimitiveType; PrimitiveType.Normalized; PrimitiveType.Unnormalized; PrimitiveType.name; PrimitiveType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PrimitiveType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.PrimitiveType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.PrimitiveType.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_global_options.html:562,Deployability,update,updated,562,". print_global_options. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_global_options. print_global_options. psi4.core.print_global_options()  None; Prints the currently set global (all modules) options to the output file. table of contents. print_global_options; print_global_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_global_options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.print_global_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_global_options.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_options.html:517,Deployability,update,updated,517,". print_options. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_options. print_options. psi4.core.print_options()  None; Prints the currently set options (to the output file) for the current module. table of contents. print_options; print_options(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_options.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.print_options.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_options.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_out.html:486,Deployability,update,updated,486,". print_out. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_out. print_out. psi4.core.print_out(arg0: str)  None; Prints a string (using sprintf-like notation) to the output file. table of contents. print_out; print_out(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_out.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.print_out.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_out.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_variables.html:528,Deployability,update,updated,528,". print_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_variables. print_variables. psi4.core.print_variables()  None; Prints to output file all QCVariables that have been set in global memory. table of contents. print_variables; print_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; print_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.print_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.print_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Prop.html:406,Deployability,update,updated,406,". Prop. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Prop. Prop. class psi4.core.Prop; Bases: pybind11_object; docstring. table of contents. Prop; Prop. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Prop.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Prop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Prop.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ProtoIntVector.html:465,Deployability,update,updated,465,". ProtoIntVector. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ProtoIntVector. ProtoIntVector. class psi4.core.ProtoIntVector; Bases: pybind11_object. table of contents. ProtoIntVector; ProtoIntVector. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ProtoIntVector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ProtoIntVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ProtoIntVector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ProtoVector.html:444,Deployability,update,updated,444,". ProtoVector. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ProtoVector. ProtoVector. class psi4.core.ProtoVector; Bases: pybind11_object. table of contents. ProtoVector; ProtoVector. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ProtoVector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ProtoVector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ProtoVector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.psimrcc.html:489,Deployability,update,updated,489,". psimrcc. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; psimrcc. psimrcc. psi4.core.psimrcc(arg0: psi4.core.Wavefunction)  psi4.core.Wavefunction; Runs the multireference coupled cluster code. table of contents. psimrcc; psimrcc(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; psimrcc.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.psimrcc.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.psimrcc.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.psio_entry.html:448,Deployability,update,updated,448,". psio_entry. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; psio_entry. psio_entry. class psi4.core.psio_entry; Bases: pybind11_object; docstring. table of contents. psio_entry; psio_entry. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; psio_entry.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.psio_entry.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.psio_entry.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.PsiReturnType.html:759,Deployability,update,updated,759,". PsiReturnType. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType. PsiReturnType. class psi4.core.PsiReturnType; Bases: pybind11_object; Return status.; Members:. Success; Failure. Attributes Summary. Failure. Success. name. value. Attributes Documentation. Failure = <PsiReturnType.Failure: 1>. Success = <PsiReturnType.Success: 0>. name. value. table of contents. PsiReturnType; PsiReturnType; PsiReturnType.Failure; PsiReturnType.Success; PsiReturnType.name; PsiReturnType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; PsiReturnType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.PsiReturnType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.PsiReturnType.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.psi_top_srcdir.html:486,Deployability,update,updated,486,". psi_top_srcdir. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; psi_top_srcdir. psi_top_srcdir. psi4.core.psi_top_srcdir()  str; Returns the location of the source code. table of contents. psi_top_srcdir; psi_top_srcdir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; psi_top_srcdir.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.psi_top_srcdir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.psi_top_srcdir.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.QuadrupoleInt.html:486,Deployability,update,updated,486,". QuadrupoleInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; QuadrupoleInt. QuadrupoleInt. class psi4.core.QuadrupoleInt; Bases: OneBodyAOInt; Computes quadrupole integrals. table of contents. QuadrupoleInt; QuadrupoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; QuadrupoleInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.QuadrupoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.QuadrupoleInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.reopen_outfile.html:471,Deployability,update,updated,471,". reopen_outfile. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; reopen_outfile. reopen_outfile. psi4.core.reopen_outfile()  None; Reopens the output file. table of contents. reopen_outfile; reopen_outfile(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; reopen_outfile.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.reopen_outfile.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.reopen_outfile.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.revoke_global_option_changed.html:911,Deployability,update,updated,911,". revoke_global_option_changed. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; revoke_global_option_changed. revoke_global_option_changed. psi4.core.revoke_global_option_changed(key: str)  None; Clear the touched status for keyword key at global (all-module) scope. Sets the has_changed attribute in the global options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. table of contents. revoke_global_option_changed; revoke_global_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; revoke_global_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.revoke_global_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.revoke_global_option_changed.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.revoke_local_option_changed.html:904,Deployability,update,updated,904,". revoke_local_option_changed. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; revoke_local_option_changed. revoke_local_option_changed. psi4.core.revoke_local_option_changed(module: str, key: str)  None; Clear the touched status for keyword key at module scope. Sets the has_changed attribute in the module options scope to false. Used in python driver when a function sets the value of an option. Before the function exits, this command is called on the option so that has_changed reflects whether the user (not the program) has touched the option. table of contents. revoke_local_option_changed; revoke_local_option_changed(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; revoke_local_option_changed.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.revoke_local_option_changed.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.revoke_local_option_changed.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.RHF.html:1575,Deployability,update,updated,1575,". RHF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; RHF. RHF. class psi4.core.RHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring :rtype: float. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. twoel_Hx_full(self,arg0,arg1,arg2,arg3); Two-electron Hessian-vector products. Methods Documentation. c1_deep_copy(self: psi4.core.RHF, basis: psi4.core.BasisSet)  psi4.core.RHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring; :rtype: float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . Return type:; float. diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.RHF)  psi4.core.MintsHelper; The MintsHelper object. twoel_Hx_full(self: psi4.core.RHF, arg0: List[psi4.core.Matrix], arg1: bool, arg2: str, arg3: bool)  List[psi4.core.Matrix]; Two-electron Hessian-vector products. Triplet supported. table of contents. RHF; RHF; RHF.c1_deep_copy(); RHF.compute_orbital_gradient(); RHF.diis(); RHF.mintshelper(); RHF.twoel_Hx_full(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; RHF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.RHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.RHF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.RKSFunctions.html:461,Deployability,update,updated,461,". RKSFunctions. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; RKSFunctions. RKSFunctions. class psi4.core.RKSFunctions; Bases: PointFunctions; docstring. table of contents. RKSFunctions; RKSFunctions. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; RKSFunctions.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.RKSFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.RKSFunctions.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ROHF.html:2089,Deployability,update,updated,2089,"g; Methods Summary. Ct(self); MO coefficients in the orthogonalized MO basis. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring :rtype: float. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. moFa(self); docstring. moFb(self); docstring. moFeff(self); docstring. soFeff(self); Returns the effective Fock matrix in the orthogonalized SO basis. Methods Documentation. Ct(self: psi4.core.ROHF)  psi4.core.Matrix; MO coefficients in the orthogonalized MO basis. Differs from the standard C matrix by an orthogonalizer matrix. c1_deep_copy(self: psi4.core.ROHF, basis: psi4.core.BasisSet)  psi4.core.ROHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring; :rtype: float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . Return type:; float. diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.ROHF)  psi4.core.MintsHelper; The MintsHelper object. moFa(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. moFb(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. moFeff(self: psi4.core.ROHF)  psi4.core.Matrix; docstring. soFeff(self: psi4.core.ROHF)  psi4.core.Matrix; Returns the effective Fock matrix in the orthogonalized SO basis. See libscf_solver/rohf.cc::form_Cfor technical definition. table of contents. ROHF; ROHF; ROHF.Ct(); ROHF.c1_deep_copy(); ROHF.compute_orbital_gradient(); ROHF.diis(); ROHF.mintshelper(); ROHF.moFa(); ROHF.moFb(); ROHF.moFeff(); ROHF.soFeff(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ROHF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ROHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ROHF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SADGuess.html:1370,Deployability,update,updated,1370,". SADGuess. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SADGuess. SADGuess. class psi4.core.SADGuess; Bases: pybind11_object; docstring; Methods Summary. Ca(self). Cb(self). Da(self). Db(self). build_SAD(arg0,arg1). compute_guess(self). set_atomic_fit_bases(self,arg0). set_debug(self,arg0). set_print(self,arg0). Methods Documentation. Ca(self: psi4.core.SADGuess)  psi4.core.Matrix. Cb(self: psi4.core.SADGuess)  psi4.core.Matrix. Da(self: psi4.core.SADGuess)  psi4.core.Matrix. Db(self: psi4.core.SADGuess)  psi4.core.Matrix. static build_SAD(arg0: psi4.core.BasisSet, arg1: List[psi4.core.BasisSet])  psi4.core.SADGuess. compute_guess(self: psi4.core.SADGuess)  None. set_atomic_fit_bases(self: psi4.core.SADGuess, arg0: List[psi4.core.BasisSet])  None. set_debug(self: psi4.core.SADGuess, arg0: int)  None. set_print(self: psi4.core.SADGuess, arg0: int)  None. table of contents. SADGuess; SADGuess; SADGuess.Ca(); SADGuess.Cb(); SADGuess.Da(); SADGuess.Db(); SADGuess.build_SAD(); SADGuess.compute_guess(); SADGuess.set_atomic_fit_bases(); SADGuess.set_debug(); SADGuess.set_print(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SADGuess.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SADGuess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SADGuess.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SalcComponent.html:981,Deployability,update,updated,981,". SalcComponent. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SalcComponent. SalcComponent. class psi4.core.SalcComponent; Bases: pybind11_object; Component of a Cartesian displacement SALC in the basis of atomic displacements.; Attributes Summary. atom; The index of the atom being displaced. coef; The coefficient of the displacement. xyz; The direction of the displacement, given by x as 0, y as 1, z as 2. Attributes Documentation. atom; The index of the atom being displaced. 0-indexed. coef; The coefficient of the displacement. xyz; The direction of the displacement, given by x as 0, y as 1, z as 2. table of contents. SalcComponent; SalcComponent; SalcComponent.atom; SalcComponent.coef; SalcComponent.xyz. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SalcComponent.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SalcComponent.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SalcComponent.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.sapt.html:532,Deployability,update,updated,532,". sapt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; sapt. sapt. psi4.core.sapt(dimer_wfn: psi4.core.Wavefunction, monoa_wfn: psi4.core.Wavefunction, monob_wfn: psi4.core.Wavefunction)  float; Runs the symmetry adapted perturbation theory code. table of contents. sapt; sapt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; sapt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.sapt.html:274,Energy Efficiency,adapt,adapted,274,". sapt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; sapt. sapt. psi4.core.sapt(dimer_wfn: psi4.core.Wavefunction, monoa_wfn: psi4.core.Wavefunction, monob_wfn: psi4.core.Wavefunction)  float; Runs the symmetry adapted perturbation theory code. table of contents. sapt; sapt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; sapt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.sapt.html:274,Modifiability,adapt,adapted,274,". sapt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; sapt. sapt. psi4.core.sapt(dimer_wfn: psi4.core.Wavefunction, monoa_wfn: psi4.core.Wavefunction, monob_wfn: psi4.core.Wavefunction)  float; Runs the symmetry adapted perturbation theory code. table of contents. sapt; sapt(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; sapt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.sapt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.sapt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SaveType.html:810,Deployability,update,updated,810,". SaveType. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SaveType. SaveType. class psi4.core.SaveType; Bases: pybind11_object; The layout of the matrix for saving; Members:. Full; SubBlocks; LowerTriangle. Attributes Summary. Full. LowerTriangle. SubBlocks. name. value. Attributes Documentation. Full = <SaveType.Full: 0>. LowerTriangle = <SaveType.LowerTriangle: 2>. SubBlocks = <SaveType.SubBlocks: 1>. name. value. table of contents. SaveType; SaveType; SaveType.Full; SaveType.LowerTriangle; SaveType.SubBlocks; SaveType.name; SaveType.value. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SaveType.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SaveType.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SaveType.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variable.html:535,Deployability,update,updated,535,". scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable. scalar_variable. psi4.core.scalar_variable(key: str)  float; Returns the double QCVariable key (case-insensitive); prefer variable(). table of contents. scalar_variable; scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variable.html:266,Modifiability,variab,variable,266,". scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable. scalar_variable. psi4.core.scalar_variable(key: str)  float; Returns the double QCVariable key (case-insensitive); prefer variable(). table of contents. scalar_variable; scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variables.html:538,Deployability,update,updated,538,". scalar_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables. scalar_variables. psi4.core.scalar_variables()  Dict[str, float]; Returns dictionary of all double QCVariables; prefer variables(). table of contents. scalar_variables; scalar_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.scalar_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variables.html:265,Modifiability,variab,variables,265,". scalar_variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables. scalar_variables. psi4.core.scalar_variables()  Dict[str, float]; Returns dictionary of all double QCVariables; prefer variables(). table of contents. scalar_variables; scalar_variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scalar_variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.scalar_variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.scalar_variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.scatter.html:492,Deployability,update,updated,492,". scatter. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scatter. scatter. psi4.core.scatter(arg0: psi4.core.Molecule, arg1: float, arg2: list, arg3: list, arg4: list)  None; New Scatter function. table of contents. scatter; scatter(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scatter.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.scatter.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.scatter.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.scfgrad.html:491,Deployability,update,updated,491,". scfgrad. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scfgrad. scfgrad. psi4.core.scfgrad(ref_wfn: psi4.core.HF)  psi4.core.Matrix; Run scfgrad, which is a specialized DF-SCF gradient program. table of contents. scfgrad; scfgrad(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scfgrad.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.scfgrad.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.scfgrad.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.scfhess.html:490,Deployability,update,updated,490,". scfhess. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scfhess. scfhess. psi4.core.scfhess(ref_wfn: psi4.core.HF)  psi4.core.Matrix; Run scfhess, which is a specialized DF-SCF hessian program. table of contents. scfhess; scfhess(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; scfhess.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.scfhess.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.scfhess.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_active_molecule.html:595,Deployability,update,updated,595,". set_active_molecule. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_active_molecule. set_active_molecule. psi4.core.set_active_molecule(molecule: psi4.core.Molecule)  None; Activates a previously defined molecule in global memory so next computations use it. table of contents. set_active_molecule; set_active_molecule(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_active_molecule.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_active_molecule.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_active_molecule.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_array_variable.html:587,Deployability,update,updated,587,". set_array_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_array_variable. set_array_variable. psi4.core.set_array_variable(key: str, value: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QCVariable; prefer set_variable(). table of contents. set_array_variable; set_array_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_array_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_array_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_array_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_datadir.html:492,Deployability,update,updated,492,". set_datadir. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_datadir. set_datadir. psi4.core.set_datadir(psidatadir: str)  None; Sets the path to shared text resources, PSIDATADIR. table of contents. set_datadir; set_datadir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_datadir.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_datadir.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_datadir.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_global_option.html:895,Deployability,update,updated,895,". set_global_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_global_option. set_global_option. psi4.core.set_global_option(*args, **kwargs); Overloaded function. set_global_option(key: str, value: list) -> bool. Sets value to array keyword key for all modules. set_global_option(key: str, value: int) -> bool. Sets value to integer keyword key for all modules. set_global_option(key: str, value: float) -> bool. Sets value to double keyword key for all modules. set_global_option(key: str, value: str) -> bool. Sets value to string keyword key for all modules. table of contents. set_global_option; set_global_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_global_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_global_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_global_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_global_option_python.html:682,Deployability,update,updated,682,". set_global_option_python. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python. set_global_option_python. psi4.core.set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul. table of contents. set_global_option_python; set_global_option_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_global_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_global_option_python.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_global_option_python.html:311,Integrability,rout,routing,311,". set_global_option_python. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python. set_global_option_python. psi4.core.set_global_option_python(key, EXTERN); This is a fairly hacky way to get around EXTERN issues. Effectively we are routing this option Python side through attributes until the general Options overhaul. table of contents. set_global_option_python; set_global_option_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_global_option_python.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_global_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_global_option_python.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_local_option.html:996,Deployability,update,updated,996,". set_local_option. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_local_option. set_local_option. psi4.core.set_local_option(*args, **kwargs); Overloaded function. set_local_option(module: str, key: str, value: list) -> bool. Sets value to array keyword key scoped only to specific module. set_local_option(module: str, key: str, value: int) -> bool. Sets value to integer keyword key scoped only to specific module. set_local_option(module: str, key: str, value: float) -> bool. Sets value to double keyword key scoped only to specific module. set_local_option(module: str, key: str, value: str) -> bool. Sets value to string keyword key scoped only to specific module. table of contents. set_local_option; set_local_option(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_local_option.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_local_option.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_local_option.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_local_option_python.html:597,Deployability,update,updated,597,". set_local_option_python. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_local_option_python. set_local_option_python. psi4.core.set_local_option_python(key: str, value: object)  None; Sets value to Python keyword key scoped only to a single module. table of contents. set_local_option_python; set_local_option_python(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_local_option_python.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_local_option_python.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_local_option_python.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_memory_bytes.html:248,Availability,avail,available,248,". set_memory_bytes. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes. set_memory_bytes. psi4.core.set_memory_bytes(memory: int, quiet: bool = False)  None; Sets the memory available to Psi (in bytes); prefer psi4.driver.set_memory(). table of contents. set_memory_bytes; set_memory_bytes(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_memory_bytes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_memory_bytes.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_memory_bytes.html:570,Deployability,update,updated,570,". set_memory_bytes. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes. set_memory_bytes. psi4.core.set_memory_bytes(memory: int, quiet: bool = False)  None; Sets the memory available to Psi (in bytes); prefer psi4.driver.set_memory(). table of contents. set_memory_bytes; set_memory_bytes(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_memory_bytes.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_memory_bytes.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_memory_bytes.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_num_threads.html:550,Deployability,update,updated,550,". set_num_threads. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_num_threads. set_num_threads. psi4.core.set_num_threads(nthread: int, quiet: bool = False)  None; Sets the number of threads to use in SMP parallel computations. table of contents. set_num_threads; set_num_threads(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_num_threads.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_num_threads.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_num_threads.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_output_file.html:634,Deployability,update,updated,634,". set_output_file. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_output_file. set_output_file. psi4.core.set_output_file(*args, **kwargs); Overloaded function. set_output_file(arg0: str) -> None; set_output_file(ofname: str, append: bool = False) -> None. Set the name for output file; prefer set_output_file(). table of contents. set_output_file; set_output_file(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_output_file.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_output_file.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_output_file.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_psi_file_prefix.html:511,Deployability,update,updated,511,". set_psi_file_prefix. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_psi_file_prefix. set_psi_file_prefix. psi4.core.set_psi_file_prefix()  None. Deprecated since version 1.4. table of contents. set_psi_file_prefix; set_psi_file_prefix(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_psi_file_prefix.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_psi_file_prefix.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_psi_file_prefix.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_scalar_variable.html:577,Deployability,update,updated,577,". set_scalar_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_scalar_variable. set_scalar_variable. psi4.core.set_scalar_variable(key: str, value: float)  None; Sets the double QCVariable key (case-insensitive); prefer set_variable(). table of contents. set_scalar_variable; set_scalar_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_scalar_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_scalar_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_scalar_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html:1015,Deployability,update,updated,1015,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to val in global memory.; :rtype: None. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html:493,Energy Efficiency,charge,charge,493,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to val in global memory.; :rtype: None. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html:669,Modifiability,variab,variable,669,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to val in global memory.; :rtype: None. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html:737,Modifiability,variab,variable,737,". set_variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable. set_variable. psi4.core.set_variable(key, val); Sets scalar or array QCVariable key to val in global memory.; :rtype: None. Parameters:. key (str)  Case-insensitive key to global double or Matrix; storage maps.; val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. table of contents. set_variable; set_variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; set_variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.set_variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.set_variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ShellInfo.html:430,Deployability,update,updated,430,". ShellInfo. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ShellInfo. ShellInfo. class psi4.core.ShellInfo; Bases: pybind11_object. table of contents. ShellInfo; ShellInfo. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ShellInfo.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ShellInfo.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ShellInfo.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Slice.html:799,Deployability,update,updated,799,". Slice. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Slice. Slice. class psi4.core.Slice; Bases: pybind11_object; Slicing for Matrix and Vector objects; Methods Summary. begin(self); Get the first element of this slice. end(self); Get the past-the-end element of this slice. Methods Documentation. begin(self: psi4.core.Slice)  psi4.core.Dimension; Get the first element of this slice. end(self: psi4.core.Slice)  psi4.core.Dimension; Get the past-the-end element of this slice. table of contents. Slice; Slice; Slice.begin(); Slice.end(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Slice.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Slice.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Slice.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOBasisSet.html:815,Deployability,update,updated,815,". SOBasisSet. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SOBasisSet. SOBasisSet. class psi4.core.SOBasisSet; Bases: pybind11_object; An SOBasis object describes the transformation from an atomic orbital basis to a symmetry orbital basis.; Methods Summary. petite_list(self); Return the PetiteList object used in creating this SO basis. Methods Documentation. petite_list(self: psi4.core.SOBasisSet)  psi4.core.PetiteList; Return the PetiteList object used in creating this SO basis. table of contents. SOBasisSet; SOBasisSet; SOBasisSet.petite_list(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SOBasisSet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SOBasisSet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOBasisSet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html:639,Deployability,update,update,639,". SOMCSCF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF. SOMCSCF. class psi4.core.SOMCSCF; Bases: pybind11_object; docstring; Methods Summary. Ck(self,arg0,arg1). H_approx_diag(self). approx_solve(self). compute_AFock(self,arg0). compute_Hk(self,arg0). compute_Q(self,arg0). compute_Qk(self,arg0,arg1,arg2). current_AFock(self). current_IFock(self). current_ci_energy(self). current_docc_energy(self). current_total_energy(self). form_rotation_matrix(self,x[,order]). gradient(self). gradient_rms(self). rhf_energy(self,arg0). solve(self,arg0,arg1,arg2). update(self,arg0,arg1,arg2,arg3,arg4). zero_redundant(self,arg0). Methods Documentation. Ck(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix)  psi4.core.Matrix. H_approx_diag(self: psi4.core.SOMCSCF)  psi4.core.Matrix. approx_solve(self: psi4.core.SOMCSCF)  psi4.core.Matrix. compute_AFock(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCS",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html:1973,Deployability,update,update,1973,"si4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. table of contents. SOMCSCF; SOMCSCF; SOMCSCF.Ck(); SOMCSCF.H_approx_diag(); SOMCSCF.approx_solve(); SOMCSCF.compute_AFock(); SOMCSCF.compute_Hk(); SOMCSCF.compute_Q(); SOMCSCF.compute_Qk(); SOMCSCF.current_AFock(); SOMCSCF.current_IFock(); SOMCSCF.current_ci_energy(); SOMCSCF.current_docc_energy(); SOMCSCF.current_total_energy(); SOMCSCF.form_rotation_matrix(); SOMCSCF.gradient(); SOMCSCF.gradient_rms(); SOMCSCF.rhf_energy(); SOMCSCF.solve(); SOMCSCF.update(); SOMCSCF.zero_redundant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html:2662,Deployability,update,update,2662,"si4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. table of contents. SOMCSCF; SOMCSCF; SOMCSCF.Ck(); SOMCSCF.H_approx_diag(); SOMCSCF.approx_solve(); SOMCSCF.compute_AFock(); SOMCSCF.compute_Hk(); SOMCSCF.compute_Q(); SOMCSCF.compute_Qk(); SOMCSCF.current_AFock(); SOMCSCF.current_IFock(); SOMCSCF.current_ci_energy(); SOMCSCF.current_docc_energy(); SOMCSCF.current_total_energy(); SOMCSCF.form_rotation_matrix(); SOMCSCF.gradient(); SOMCSCF.gradient_rms(); SOMCSCF.rhf_energy(); SOMCSCF.solve(); SOMCSCF.update(); SOMCSCF.zero_redundant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html:2892,Deployability,update,updated,2892,"si4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Hk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Q(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  psi4.core.Matrix. compute_Qk(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix)  psi4.core.Matrix. current_AFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_IFock(self: psi4.core.SOMCSCF)  psi4.core.Matrix. current_ci_energy(self: psi4.core.SOMCSCF)  float. current_docc_energy(self: psi4.core.SOMCSCF)  float. current_total_energy(self: psi4.core.SOMCSCF)  float. form_rotation_matrix(self: psi4.core.SOMCSCF, x: psi4.core.Matrix, order: int = 2)  psi4.core.Matrix. gradient(self: psi4.core.SOMCSCF)  psi4.core.Matrix. gradient_rms(self: psi4.core.SOMCSCF)  float. rhf_energy(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  float. solve(self: psi4.core.SOMCSCF, arg0: int, arg1: float, arg2: bool)  psi4.core.Matrix. update(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix, arg1: psi4.core.Matrix, arg2: psi4.core.Matrix, arg3: psi4.core.Matrix, arg4: psi4.core.Matrix)  None. zero_redundant(self: psi4.core.SOMCSCF, arg0: psi4.core.Matrix)  None. table of contents. SOMCSCF; SOMCSCF; SOMCSCF.Ck(); SOMCSCF.H_approx_diag(); SOMCSCF.approx_solve(); SOMCSCF.compute_AFock(); SOMCSCF.compute_Hk(); SOMCSCF.compute_Q(); SOMCSCF.compute_Qk(); SOMCSCF.current_AFock(); SOMCSCF.current_IFock(); SOMCSCF.current_ci_energy(); SOMCSCF.current_docc_energy(); SOMCSCF.current_total_energy(); SOMCSCF.form_rotation_matrix(); SOMCSCF.gradient(); SOMCSCF.gradient_rms(); SOMCSCF.rhf_energy(); SOMCSCF.solve(); SOMCSCF.update(); SOMCSCF.zero_redundant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SOMCSCF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SOMCSCF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SOMCSCF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:13183,Deployability,update,updated,13183,"citation(); SuperFunctional.compute_functional(); SuperFunctional.density_tolerance(); SuperFunctional.deriv(); SuperFunctional.description(); SuperFunctional.grac_alpha(); SuperFunctional.grac_beta(); SuperFunctional.grac_shift(); SuperFunctional.is_c_hybrid(); SuperFunctional.is_c_lrc(); SuperFunctional.is_c_scs_hybrid(); SuperFunctional.is_gga(); SuperFunctional.is_libxc_func(); SuperFunctional.is_meta(); SuperFunctional.is_x_hybrid(); SuperFunctional.is_x_lrc(); SuperFunctional.max_points(); SuperFunctional.name(); SuperFunctional.needs_grac(); SuperFunctional.needs_vv10(); SuperFunctional.needs_xc(); SuperFunctional.print_density_threshold(); SuperFunctional.print_detail(); SuperFunctional.print_out(); SuperFunctional.set_c_alpha(); SuperFunctional.set_c_omega(); SuperFunctional.set_c_os_alpha(); SuperFunctional.set_c_ss_alpha(); SuperFunctional.set_citation(); SuperFunctional.set_density_tolerance(); SuperFunctional.set_deriv(); SuperFunctional.set_description(); SuperFunctional.set_do_vv10(); SuperFunctional.set_grac_alpha(); SuperFunctional.set_grac_beta(); SuperFunctional.set_grac_shift(); SuperFunctional.set_lock(); SuperFunctional.set_max_points(); SuperFunctional.set_name(); SuperFunctional.set_vv10_b(); SuperFunctional.set_vv10_c(); SuperFunctional.set_x_alpha(); SuperFunctional.set_x_beta(); SuperFunctional.set_x_omega(); SuperFunctional.set_xclib_description(); SuperFunctional.test_functional(); SuperFunctional.value(); SuperFunctional.values(); SuperFunctional.vv10_b(); SuperFunctional.vv10_c(); SuperFunctional.x_alpha(); SuperFunctional.x_beta(); SuperFunctional.x_functional(); SuperFunctional.x_functionals(); SuperFunctional.x_omega(); SuperFunctional.xclib_description(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SuperFunctional.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:443,Energy Efficiency,allocate,allocate,443,". SuperFunctional. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SuperFunctional. SuperFunctional. class psi4.core.SuperFunctional; Bases: pybind11_object; docstring; Methods Summary. XC_build(name,unpolarized[,tweak]); Builds a SuperFunctional from a XC string. add_c_functional(self,arg0); Add a correlation Functional. add_x_functional(self,arg0); Add a exchange Functional. allocate(self); Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self); SuperFunctional rung. blank(); Initialize a blank SuperFunctional. c_alpha(self); Amount of MP2 correlation. c_functional(self,arg0); Returns the desired C Functional. c_functionals(self); Returns all C Functionals. c_omega(self); Range-seperated correlation parameter. c_os_alpha(self); Amount of SS MP2 correlation. c_ss_alpha(self); Amount of OS MP2 correlation. citation(self); SuperFunctional citation. compute_functional(self,vals[,npoints,...]); Computes the SuperFunctional. density_tolerance(self); Density threshold for LibXC. deriv(self); Maximum derivative to compute. description(self); The description of the SuperFunctional. grac_alpha(self); GRAC Alpha. grac_beta(self); GRAC Beta. grac_shift(self); Shift of the bulk potenital. is_c_hybrid(self); Requires MP2 correlation?. is_c_lrc(self); Contains range-seperated correlation?. is_c_scs_hybrid(self); Requires SCS-MP2 correlation?. is_gga(self); Is this a GGA?. is_libxc_func(self); A full SuperFunctional definition from LibXC. is_meta(self); Is this a MGGA?. is_x_hybrid(self); Requires exact exchange?. is_x_lrc(self); Contains range-seperated exchange?. max_points(self); Maximum number of grid points per block. name(self); The name of the SuperFunctional. needs_grac(self); Does this functional need GRAC. needs_vv10(self); Does this functional need VV10 dispersion. needs_xc(self); Does this functional need XC quantities. print_density_threshold(self); Queries the LibXCFuncti",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:4460,Energy Efficiency,allocate,allocate,4460," LibXC version and citation string. test_functional(self,arg0,arg1,arg2,...); Quick testing capabilities. value(self,arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self,arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(name: str, unpolarized: bool, tweak: Dict[str, float] | None = {})  psi4.core.SuperFunctional; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional)  None; Allocates the vectors, should be called after ansatz or npoint changes. ansatz(self: psi4.core.SuperFunctional)  int; SuperFunctional rung. static blank()  psi4.core.SuperFunctional; Initialize a blank SuperFunctional. c_alpha(self: psi4.core.SuperFunctional)  float; Amount of MP2 correlation. c_functional(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Functional; Returns the desired C Functional. c_functionals(self: psi4.core.SuperFunctional)  List[psi4.core.Functional]; Returns all C Functionals. c_omega(self: psi4.core.SuperFunctional)  float; Range-seperated correlation parameter. c_os_alpha(self: psi4.core.SuperFunctional)  float; Amount of SS MP2 correlation. c_ss_alpha(self: psi4.core.SuperFunctional)  float; Amount of OS MP2 correlation. citation(self: psi4.core.SuperFunctional)  str; SuperFunctional citation. compute_functional(self: psi4.core.SuperFunctional, vals: Dict[str, psi4.core.Vector], npoints: int = -",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:11004,Energy Efficiency,allocate,allocate,11004,"rnal value. values(self: psi4.core.SuperFunctional)  Dict[str, psi4.core.Vector]; Return all internal values. vv10_b(self: psi4.core.SuperFunctional)  float; The VV10 b parameter. vv10_c(self: psi4.core.SuperFunctional)  float; The VV10 c parameter. x_alpha(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_beta(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_functional(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Functional; Returns the desired X Functional. x_functionals(self: psi4.core.SuperFunctional)  List[psi4.core.Functional]; Returns all X Functionals. x_omega(self: psi4.core.SuperFunctional)  float; Range-seperated exchange parameter. xclib_description(self: psi4.core.SuperFunctional)  str; LibXC version and citation string. table of contents. SuperFunctional; SuperFunctional; SuperFunctional.XC_build(); SuperFunctional.add_c_functional(); SuperFunctional.add_x_functional(); SuperFunctional.allocate(); SuperFunctional.ansatz(); SuperFunctional.blank(); SuperFunctional.c_alpha(); SuperFunctional.c_functional(); SuperFunctional.c_functionals(); SuperFunctional.c_omega(); SuperFunctional.c_os_alpha(); SuperFunctional.c_ss_alpha(); SuperFunctional.citation(); SuperFunctional.compute_functional(); SuperFunctional.density_tolerance(); SuperFunctional.deriv(); SuperFunctional.description(); SuperFunctional.grac_alpha(); SuperFunctional.grac_beta(); SuperFunctional.grac_shift(); SuperFunctional.is_c_hybrid(); SuperFunctional.is_c_lrc(); SuperFunctional.is_c_scs_hybrid(); SuperFunctional.is_gga(); SuperFunctional.is_libxc_func(); SuperFunctional.is_meta(); SuperFunctional.is_x_hybrid(); SuperFunctional.is_x_lrc(); SuperFunctional.max_points(); SuperFunctional.name(); SuperFunctional.needs_grac(); SuperFunctional.needs_vv10(); SuperFunctional.needs_xc(); SuperFunctional.print_density_threshold(); SuperFunctional.print_detail(); SuperFunctional.print_out(); SuperFunctional.set_c_alpha(); SuperFun",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:3557,Testability,test,testing,3557,"_deriv(self,arg0); Sets the derivative level. set_description(self,arg0); Sets the SuperFunctional description. set_do_vv10(self,arg0); Sets whether to do VV10 correction. set_grac_alpha(self,arg0); Sets the GRAC alpha parameter. set_grac_beta(self,arg0); Sets the GRAC beta parameter. set_grac_shift(self,arg0); Sets the GRAC bulk shift value. set_lock(self,arg0); Locks the functional to prevent changes. set_max_points(self,arg0); Sets the maximum number of points. set_name(self,arg0); Sets the SuperFunctional name. set_vv10_b(self,arg0); Sets the VV10 b parameter. set_vv10_c(self,arg0); Sets the VV10 c parameter. set_x_alpha(self,arg0); Sets the amount of exact global HF exchange. set_x_beta(self,arg0); Sets how much more long-range exchange than short-range exchange. set_x_omega(self,arg0); Sets the range-seperation exchange parameter. set_xclib_description(self,arg0); Sets the LibXC version and citation string. test_functional(self,arg0,arg1,arg2,...); Quick testing capabilities. value(self,arg0); Returns a given internal value. values(self); Return all internal values. vv10_b(self); The VV10 b parameter. vv10_c(self); The VV10 c parameter. x_alpha(self); Amount of exact HF exchange. x_beta(self); Amount of exact HF exchange. x_functional(self,arg0); Returns the desired X Functional. x_functionals(self); Returns all X Functionals. x_omega(self); Range-seperated exchange parameter. xclib_description(self); LibXC version and citation string. Methods Documentation. static XC_build(name: str, unpolarized: bool, tweak: Dict[str, float] | None = {})  psi4.core.SuperFunctional; Builds a SuperFunctional from a XC string. add_c_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a correlation Functional. add_x_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Functional)  None; Add a exchange Functional. allocate(self: psi4.core.SuperFunctional)  None; Allocates the vectors, should be called after ansatz",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html:9905,Testability,test,testing,9905,"er of points. set_name(self: psi4.core.SuperFunctional, arg0: str)  None; Sets the SuperFunctional name. set_vv10_b(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the VV10 b parameter. set_vv10_c(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the VV10 c parameter. set_x_alpha(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the amount of exact global HF exchange. set_x_beta(self: psi4.core.SuperFunctional, arg0: float)  None; Sets how much more long-range exchange than short-range exchange. set_x_omega(self: psi4.core.SuperFunctional, arg0: float)  None; Sets the range-seperation exchange parameter. set_xclib_description(self: psi4.core.SuperFunctional, arg0: str)  None; Sets the LibXC version and citation string. test_functional(self: psi4.core.SuperFunctional, arg0: psi4.core.Vector, arg1: psi4.core.Vector, arg2: psi4.core.Vector, arg3: psi4.core.Vector, arg4: psi4.core.Vector, arg5: psi4.core.Vector, arg6: psi4.core.Vector)  None; Quick testing capabilities. value(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Vector; Returns a given internal value. values(self: psi4.core.SuperFunctional)  Dict[str, psi4.core.Vector]; Return all internal values. vv10_b(self: psi4.core.SuperFunctional)  float; The VV10 b parameter. vv10_c(self: psi4.core.SuperFunctional)  float; The VV10 c parameter. x_alpha(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_beta(self: psi4.core.SuperFunctional)  float; Amount of exact HF exchange. x_functional(self: psi4.core.SuperFunctional, arg0: str)  psi4.core.Functional; Returns the desired X Functional. x_functionals(self: psi4.core.SuperFunctional)  List[psi4.core.Functional]; Returns all X Functionals. x_omega(self: psi4.core.SuperFunctional)  float; Range-seperated exchange parameter. xclib_description(self: psi4.core.SuperFunctional)  str; LibXC version and citation string. table of contents. SuperFunctional; SuperFunctional; SuperFunctional.",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SuperFunctional.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SuperFunctional.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html:3683,Deployability,update,updated,3683,"e matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation)  psi4.core.SymmetryOperation; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int)  None; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float)  None; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation)  None; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation)  float; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation)  psi4.core.SymmetryOperation; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation)  None; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation)  None; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation)  None; Zero out the symmetry operation. table of contents. SymmetryOperation; SymmetryOperation; SymmetryOperation.E(); SymmetryOperation.c2_x(); SymmetryOperation.c2_y(); SymmetryOperation.c2_z(); SymmetryOperation.i(); SymmetryOperation.matrix(); SymmetryOperation.operate(); SymmetryOperation.rotate_n(); SymmetryOperation.rotate_theta(); SymmetryOperation.sigma_xy(); SymmetryOperation.sigma_xz(); SymmetryOperation.sigma_yz(); SymmetryOperation.trace(); SymmetryOperation.transform(); SymmetryOperation.transpose(); SymmetryOperation.unit(); SymmetryOperation.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.test_matrix_dpd_interface.html:523,Deployability,update,updated,523,". test_matrix_dpd_interface. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; test_matrix_dpd_interface. test_matrix_dpd_interface. psi4.core.test_matrix_dpd_interface()  bool. table of contents. test_matrix_dpd_interface; test_matrix_dpd_interface(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; test_matrix_dpd_interface.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.test_matrix_dpd_interface.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.test_matrix_dpd_interface.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.ThreeCenterOverlapInt.html:845,Deployability,update,updated,845,". ThreeCenterOverlapInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ThreeCenterOverlapInt. ThreeCenterOverlapInt. class psi4.core.ThreeCenterOverlapInt; Bases: pybind11_object; Three center overlap integrals; Methods Summary. compute_shell(self,arg0,arg1,arg2); Compute the integrals of the form (a|b|c). Methods Documentation. compute_shell(self: psi4.core.ThreeCenterOverlapInt, arg0: int, arg1: int, arg2: int)  None; Compute the integrals of the form (a|b|c). table of contents. ThreeCenterOverlapInt; ThreeCenterOverlapInt; ThreeCenterOverlapInt.compute_shell(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; ThreeCenterOverlapInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.ThreeCenterOverlapInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.ThreeCenterOverlapInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.timer_off.html:444,Deployability,update,updated,444,". timer_off. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; timer_off. timer_off. psi4.core.timer_off(label: str)  None; Stop timer with label. table of contents. timer_off; timer_off(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; timer_off.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.timer_off.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.timer_off.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.timer_on.html:485,Deployability,update,updated,485,". timer_on. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; timer_on. timer_on. psi4.core.timer_on(label: str)  None; Start timer with label. Needs to be paired with psi4.core.timer_off(). table of contents. timer_on; timer_on(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; timer_on.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.timer_on.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.timer_on.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.TLaplaceDenominator.html:1326,Deployability,update,updated,1326,". TLaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator. TLaplaceDenominator. class psi4.core.TLaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the six-index energy denominator in coupled-cluster theory; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). table of contents. TLaplaceDenominator; TLaplaceDenominator; TLaplaceDenominator.denominator_occ(); TLaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.TLaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.TLaplaceDenominator.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.TLaplaceDenominator.html:293,Energy Efficiency,energy,energy,293,". TLaplaceDenominator. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator. TLaplaceDenominator. class psi4.core.TLaplaceDenominator; Bases: pybind11_object; Computer class for a Laplace factorization of the six-index energy denominator in coupled-cluster theory; Methods Summary. denominator_occ(self); Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self); Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). Methods Documentation. denominator_occ(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the occupied orbital Laplace weights of the factorized triples denominator (nweights * nocc). denominator_vir(self: psi4.core.TLaplaceDenominator)  psi4.core.Matrix; Returns the virtual orbital Laplace weights of the factorized triples denominator (nweights * nvirt). table of contents. TLaplaceDenominator; TLaplaceDenominator; TLaplaceDenominator.denominator_occ(); TLaplaceDenominator.denominator_vir(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TLaplaceDenominator.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.TLaplaceDenominator.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.TLaplaceDenominator.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.TracelessQuadrupoleInt.html:559,Deployability,update,updated,559,". TracelessQuadrupoleInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TracelessQuadrupoleInt. TracelessQuadrupoleInt. class psi4.core.TracelessQuadrupoleInt; Bases: OneBodyAOInt; Computes traceless quadrupole integrals. table of contents. TracelessQuadrupoleInt; TracelessQuadrupoleInt. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TracelessQuadrupoleInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.TracelessQuadrupoleInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.TracelessQuadrupoleInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.triplet.html:1108,Deployability,update,updated,1108,". triplet. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; triplet. triplet. psi4.core.triplet(A: psi4.core.Matrix, B: psi4.core.Matrix, C: psi4.core.Matrix, transA: bool = False, transB: bool = False, transC: bool = False)  psi4.core.Matrix; Returns the multiplication of three matrices, with options to transpose each beforehand. Parameters:. A  First matrix to multiply.; B  Second matrix to multiply.; C  Third matrix to multiply.; transA  Transpose the first matrix before operations?; transB  Transpose the second matrix before operations?; transC  Transpose the third matrix before operations?. Returns:; New matrix of ABC. Return type:; Matrix. Notes. (AB)C vs. A(BC) selected by cost analysis of overall (not per-irrep) dimensions.; If A, B, C not of the the same symmetry, always computed as (AB)C. table of contents. triplet; triplet(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; triplet.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.triplet.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.triplet.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.tstart.html:441,Deployability,update,updated,441,". tstart. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; tstart. tstart. psi4.core.tstart()  None; Start module-level timer. Only one active at once. table of contents. tstart; tstart(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; tstart.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.tstart.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.tstart.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.tstop.html:457,Deployability,update,updated,457,". tstop. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; tstop. tstop. psi4.core.tstop()  None; Stop module-level timer. Prints user, system, and total times to outfile. table of contents. tstop; tstop(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; tstop.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.tstop.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.tstop.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.TwoBodyAOInt.html:1363,Deployability,update,updated,1363,". TwoBodyAOInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TwoBodyAOInt. TwoBodyAOInt. class psi4.core.TwoBodyAOInt; Bases: pybind11_object; Two body integral base class; Methods Summary. compute_shell(self,arg0,arg1,arg2,arg3); Compute ERIs between 4 shells. shell_significant(self,arg0,arg1,arg2,arg3); Determines if the P,Q,R,S shell combination is significant. update_density(self,arg0); Update density matrix (c1 symmetry) for Density-matrix based integral screening. Methods Documentation. compute_shell(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; Compute ERIs between 4 shells. shell_significant(self: psi4.core.TwoBodyAOInt, arg0: int, arg1: int, arg2: int, arg3: int)  bool; Determines if the P,Q,R,S shell combination is significant. update_density(self: psi4.core.TwoBodyAOInt, arg0: List[psi4.core.Matrix])  None; Update density matrix (c1 symmetry) for Density-matrix based integral screening. table of contents. TwoBodyAOInt; TwoBodyAOInt; TwoBodyAOInt.compute_shell(); TwoBodyAOInt.shell_significant(); TwoBodyAOInt.update_density(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TwoBodyAOInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.TwoBodyAOInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.TwoBodyAOInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.TwoElectronInt.html:1090,Deployability,update,updated,1090,". TwoElectronInt. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TwoElectronInt. TwoElectronInt. class psi4.core.TwoElectronInt; Bases: TwoBodyAOInt; Computes two-electron repulsion integrals; Methods Summary. compute_shell(self,arg0,arg1,arg2,arg3); Compute ERIs between 4 shells. shell_significant(self,arg0,arg1,arg2,arg3); Determines if the P,Q,R,S shell combination is significant. Methods Documentation. compute_shell(self: psi4.core.TwoElectronInt, arg0: int, arg1: int, arg2: int, arg3: int)  int; Compute ERIs between 4 shells. shell_significant(self: psi4.core.TwoElectronInt, arg0: int, arg1: int, arg2: int, arg3: int)  bool; Determines if the P,Q,R,S shell combination is significant. table of contents. TwoElectronInt; TwoElectronInt; TwoElectronInt.compute_shell(); TwoElectronInt.shell_significant(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; TwoElectronInt.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.TwoElectronInt.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.TwoElectronInt.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.UHF.html:1481,Deployability,update,updated,1481,". UHF. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; UHF. UHF. class psi4.core.UHF; Bases: HF; docstring; Methods Summary. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock,...); docstring :rtype: float. diis(self,arg0); docstring. mintshelper(self); The MintsHelper object. stability_analysis(self); Assess wfn stability and correct if requested. Methods Documentation. c1_deep_copy(self: psi4.core.UHF, basis: psi4.core.BasisSet)  psi4.core.UHF; Returns a new wavefunction with internal data converted to C_1 symmetry, using pre-c1-constructed BasisSet basis. compute_orbital_gradient(save_fock, max_diis_vectors); docstring; :rtype: float. Parameters:. save_fock (bool)  ; max_diis_vectors (int)  . Return type:; float. diis(self: psi4.core.HF, arg0: float)  bool; docstring. mintshelper(self: psi4.core.UHF)  psi4.core.MintsHelper; The MintsHelper object. stability_analysis(self: psi4.core.HF)  bool; Assess wfn stability and correct if requested. table of contents. UHF; UHF; UHF.c1_deep_copy(); UHF.compute_orbital_gradient(); UHF.diis(); UHF.mintshelper(); UHF.stability_analysis(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; UHF.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.UHF.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.UHF.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.UKSFunctions.html:461,Deployability,update,updated,461,". UKSFunctions. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; UKSFunctions. UKSFunctions. class psi4.core.UKSFunctions; Bases: PointFunctions; docstring. table of contents. UKSFunctions; UKSFunctions. ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; UKSFunctions.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.UKSFunctions.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.UKSFunctions.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:1370,Deployability,update,updated,1370,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:474,Energy Efficiency,charge,charges,474,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:3,Modifiability,variab,variable,3,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:117,Modifiability,variab,variable,117,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:127,Modifiability,variab,variable,127,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:148,Modifiability,variab,variable,148,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:377,Modifiability,variab,variables,377,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:418,Modifiability,variab,variables,418,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:548,Modifiability,variab,variables,548,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:778,Modifiability,variab,variable,778,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:836,Modifiability,variab,variable,836,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:906,Modifiability,variab,variable,906,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:987,Modifiability,variab,variable,987,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:1153,Modifiability,variab,variable,1153,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:1163,Modifiability,variab,variable,1163,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html:1313,Modifiability,variab,variable,1313,". variable. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable. variable. psi4.core.variable(key); Return copy of scalar or array QCVariable; key from global memory. Parameters:; key (str)  Case-insensitive key to global double or Matrix; storage maps. Returns:; Requested QCVariable from global memory. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> psi4.gradient(""hf/cc-pvdz""); >>> psi4.variable(""CURRENT ENERGY""); -100.00985995185668; >>> psi4.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> psi4.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> psi4.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). table of contents. variable; variable(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variable.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variable.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variable.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:985,Deployability,update,updated,985,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:524,Energy Efficiency,charge,charges,524,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:3,Modifiability,variab,variables,3,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:118,Modifiability,variab,variables,118,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:129,Modifiability,variab,variables,129,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:151,Modifiability,variab,variables,151,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:427,Modifiability,variab,variables,427,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:468,Modifiability,variab,variables,468,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:598,Modifiability,variab,variables,598,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:765,Modifiability,variab,variables,765,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:776,Modifiability,variab,variables,776,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html:927,Modifiability,variab,variables,927,". variables. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables. variables. psi4.core.variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from global memory. Parameters:; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. table of contents. variables; variables(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; variables.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.variables.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.variables.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html:4464,Deployability,update,updated,4464,"; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int)  psi4.core.BlockOPoints; Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects.; :rtype: Tuple[ndarray, ndarray, ndarray, ndarray]. Parameters:; self (VBase)  VBase instance. Return type:; Tuple[ndarray, ndarray, ndarray, ndarray]. grid(self: psi4.core.VBase)  psi4.core.DFTGrid; Returns the grid object. initialize(*args, **kwargs); Overloaded function. initialize(self: psi4.core.VBase) -> None. doctsring. initialize(self: psi4.core.VBase) -> None. Initializes the V object. nblocks(self: psi4.core.VBase)  int; Total number of blocks. print_header(self: psi4.core.VBase)  None; Prints the objects header. properties(self: psi4.core.VBase)  List[psi4.core.PointFunctions]; Returns the properties computer. quadrature_values(self: psi4.core.VBase)  Dict[str, float]; Returns the quadrature values. set_D(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Sets the internal density. set_debug(self: psi4.core.VBase, arg0: int)  None; Sets the debug level of the object. set_print(self: psi4.core.VBase, arg0: int)  None; Sets the print level of the object. table of contents. VBase; VBase; VBase.Dao(); VBase.basis(); VBase.build(); VBase.build_collocation_cache(); VBase.clear_collocation_cache(); VBase.compute_V(); VBase.compute_Vx(); VBase.compute_gradient(); VBase.compute_hessain(); VBase.finalize(); VBase.functional(); VBase.get_block(); VBase.get_np_xyzw(); VBase.grid(); VBase.initialize(); VBase.nblocks(); VBase.print_header(); VBase.properties(); VBase.quadrature_values(); VBase.set_D(); VBase.set_debug(); VBase.set_print(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; VBase.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html:383,Performance,cache,cache,383,". VBase. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; VBase. VBase. class psi4.core.VBase; Bases: pybind11_object; docstring; Methods Summary. Dao(self,arg0); Returns internal AO density. basis(self); Returns the internal basis set. build(arg0,arg1,arg2). build_collocation_cache(self,arg0); Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self); Clears the collocation cache. compute_V(self,arg0); doctsring. compute_Vx(self,arg0,arg1); doctsring. compute_gradient(self); Compute the DFT nuclear gradient contribution. compute_hessain(self); Compute the DFT nuclear Hessian contribution. finalize(*args,**kwargs); Overloaded function. functional(self); Returns the interal superfunctional. get_block(self,arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(se",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html:469,Performance,cache,cache,469,". VBase. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; VBase. VBase. class psi4.core.VBase; Bases: pybind11_object; docstring; Methods Summary. Dao(self,arg0); Returns internal AO density. basis(self); Returns the internal basis set. build(arg0,arg1,arg2). build_collocation_cache(self,arg0); Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self); Clears the collocation cache. compute_V(self,arg0); doctsring. compute_Vx(self,arg0,arg1); doctsring. compute_gradient(self); Compute the DFT nuclear gradient contribution. compute_hessain(self); Compute the DFT nuclear Hessian contribution. finalize(*args,**kwargs); Overloaded function. functional(self); Returns the interal superfunctional. get_block(self,arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(se",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html:1787,Performance,cache,cache,1787," superfunctional. get_block(self,arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix])  None; doctsring. compute_gradient(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs); Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase)  psi4.core.SuperFunctional; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int)  psi4.core.BlockOPoints; Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array ob",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html:1898,Performance,cache,cache,1898,", y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args,**kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self,arg0); Sets the internal density. set_debug(self,arg0); Sets the debug level of the object. set_print(self,arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; Returns internal AO density. basis(self: psi4.core.VBase)  psi4.core.BasisSet; Returns the internal basis set. static build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str)  psi4.core.VBase. build_collocation_cache(self: psi4.core.VBase, arg0: int)  None; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase)  None; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix])  None; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix])  None; doctsring. compute_gradient(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase)  psi4.core.Matrix; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs); Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase)  psi4.core.SuperFunctional; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int)  psi4.core.BlockOPoints; Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects.; :rtype: Tuple[ndarray, ndarray, ndarray, ndarray]. Parameters:; self (VBase)  VBase instance. Re",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.VBase.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.VBase.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:8860,Deployability,update,updated,8860,"dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(); Vector.get_block(); Vector.init(); Vector.load(); Vector.nirrep(); Vector.np_read(); Vector.np_write(); Vector.print_out(); Vector.save(); Vector.scale(); Vector.set(); Vector.set_block(); Vector.to_array(); Vector.to_serial(); Vector.vector_dot(); Vector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Vector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:7415,Integrability,depend,depending,7415,"ore.IO, file: int)  None; Save the vector to disk. scale(self: psi4.core.Vector, sc: float)  None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector)  None; Set a vector block. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:1239,Performance,load,load,1239," Vector. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Summary. add(*args,**kwargs); Overloaded function. array_interface(self). axpby(self,a,b,other); Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self,a,other); Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self); Clone the vector. copy(self,arg0); Copy another vector into this. dim(self[,h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name,dim1,dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type :rtype: Union[Matrix, Vector]. get(*args,**kwargs); Overloaded function. get_block(self,slice); Get a vector block. init(self,arg0); Reallocate the data of the Vector. load(self,psio,file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self,psio,file); Save the vector to disk. scale(self,sc); Scales the elements of a vector by sc. set(*args,**kwargs); Overloaded function. set_block(self,slice,block); Set a vector block. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self,other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name; The name of the Vector. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs); Overload",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:1425,Performance,load,load,1425,"nterface(self). axpby(self,a,b,other); Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self,a,other); Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self); Clone the vector. copy(self,arg0); Copy another vector into this. dim(self[,h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name,dim1,dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type :rtype: Union[Matrix, Vector]. get(*args,**kwargs); Overloaded function. get_block(self,slice); Get a vector block. init(self,arg0); Reallocate the data of the Vector. load(self,psio,file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self,psio,file); Save the vector to disk. scale(self,sc); Scales the elements of a vector by sc. set(*args,**kwargs); Overloaded function. set_block(self,slice,block); Set a vector block. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self,other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name; The name of the Vector. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs); Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: fl",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:5189,Performance,load,load,5189,"data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x). classmethod from_serial(); Converts serialized data to the correct Psi4 data type; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; json_data (Dict[str, Any])  Serialization of class. See to_serial() for data layout. Return type:; Matrix | Vector. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice)  psi4.core.Vector; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Load the vector from disk. nirrep(self: psi4.core.Vector)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When fi",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:5459,Performance,load,load,5459,"lized data to the correct Psi4 data type; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; json_data (Dict[str, Any])  Serialization of class. See to_serial() for data layout. Return type:; Matrix | Vector. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice)  psi4.core.Vector; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension)  None; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Load the vector from disk. nirrep(self: psi4.core.Vector)  int; Returns the number of irreps. classmethod np_read(prefix=''); Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self  Pointer to which class to be constructed.; filename (str)  File name to read.; prefix (str)  Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix=''); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector])  Instance to be serialized.; filename (Optional[str])  File name where the data will be saved.; prefix (str)  Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector)  None; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Save the vector to disk. scale(self:",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:8445,Performance,load,load,8445,"dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(); Vector.get_block(); Vector.init(); Vector.load(); Vector.nirrep(); Vector.np_read(); Vector.np_write(); Vector.print_out(); Vector.save(); Vector.scale(); Vector.set(); Vector.set_block(); Vector.to_array(); Vector.to_serial(); Vector.vector_dot(); Vector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Vector.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:1914,Security,access,accessor,1914,"rays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type :rtype: Union[Matrix, Vector]. get(*args,**kwargs); Overloaded function. get_block(self,slice); Get a vector block. init(self,arg0); Reallocate the data of the Vector. load(self,psio,file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename,prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self,psio,file); Save the vector to disk. scale(self,sc); Scales the elements of a vector by sc. set(*args,**kwargs); Overloaded function. set_block(self,slice,block); Set a vector block. to_array([copy,dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self,other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name; The name of the Vector. Used in printing. np; View with single irrep. nph; View with irreps. shape; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs); Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Add to a single element value located at m in irrep h. array_interface(self: psi4.core.Vector)  list. axpby(self: psi4.core.Vector, a: float, b: float, other: psi4.core.Vector)  None; Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self: psi4.core.Vector, a: float, other: psi4.core.Vector)  None; Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self: psi4.core.Vector)  psi4.core.Vector; ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:7710,Security,access,accessor,7710,", val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector)  None; Set a vector block. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot product of two vectors. zero(self: psi4.core.Vector)  None; Zeros the vector. table of contents. Vector; Vector; Vector.name; Vector.np; Vector.nph; Vector.shape; Vector.add(); Vector.array_interface(); Vector.axpby(); Vector.axpy(); Vector.clone(); Vector.copy(); Vector.dim(); Vector.dimpi(); Vector.from_array(); Vector.from_list(); Vector.from_serial(); Vector.get(); Vector.get_block(); Vector.init(); Vector.load(); Vector.nirrep(); Vector.np_read(); Vector.np_write(); Vector.print_out(); Vector.save(); Vector.scale(); Vector.set(); Vector.set_block(); Vector.to_array(); Vector.to_serial(); Vector.vector_dot(); Vector.zero(). ; hide menu. menu; sidebar; ; . Navigation. Index. module",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:7032,Usability,simpl,simply,7032," Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector)  None; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int)  None; Save the vector to disk. scale(self: psi4.core.Vector, sc: float)  None; Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.ProtoVector)  None; Set a vector block. to_array(copy=True, dense=False); Converts a PSI4 Matrix or Vector to a NumPy array. Either copies the; data or simply constructs a view. Parameters:. matrix (Union[Matrix, Vector])  Pointers to which Psi4 core class should be used in the construction.; copy (bool)  Copy the data if True, return a view otherwise; dense (bool)  Converts irrepped Psi4 objects to diagonally blocked dense arrays if; True. Returns a list of arrays otherwise. Returns:; Returns a single or list of NumPy arrays depending on options. Return type:; ndarray or List[ndarray]. Notes; This is a generalized function to convert a Psi4 object to a NumPy array; Examples; >>> data = psi4.core.Matrix(3, 3); >>> data.to_array(); [[ 0. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. 0.]]. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. Parameters:; self (Union[Matrix, Vector])  Matrix or Vector instance. Returns:; Serialized dictionary with keys:. shape; data : List[str]; type : {matrix, vector}. Return type:; Dict[str, Any]. vector_dot(self: psi4.core.Vector, other: psi4.core.Vector)  float; Take the dot pr",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector3.html:1479,Deployability,update,updated,1479,". Vector3. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Vector3. Vector3. class psi4.core.Vector3; Bases: pybind11_object; Class for vectors of length three, often Cartesian coordinate vectors, and their common operations; Methods Summary. cross(self,arg0); Returns cross product of arg1 and arg2. distance(self,arg0); Returns distance between two points represented by arg1 and arg2. dot(self,arg0); Returns dot product of arg1 and arg2. norm(self); Returns Euclidean norm of arg1. normalize(self); Returns vector of unit length and arg1 direction. Methods Documentation. cross(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  psi4.core.Vector3; Returns cross product of arg1 and arg2. distance(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns distance between two points represented by arg1 and arg2. dot(self: psi4.core.Vector3, arg0: psi4.core.Vector3)  float; Returns dot product of arg1 and arg2. norm(self: psi4.core.Vector3)  float; Returns Euclidean norm of arg1. normalize(self: psi4.core.Vector3)  None; Returns vector of unit length and arg1 direction. table of contents. Vector3; Vector3; Vector3.cross(); Vector3.distance(); Vector3.dot(); Vector3.norm(); Vector3.normalize(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Vector3.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Vector3.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector3.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.version.html:427,Deployability,update,updated,427,". version. Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; version. version. psi4.core.version()  None. Deprecated since version 1.4. table of contents. version; version(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; version.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.version.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.version.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:32935,Deployability,update,updated,32935," Wavefunction.get_basisset(); Wavefunction.get_density(); Wavefunction.get_dipole_field_strength(); Wavefunction.get_print(); Wavefunction.get_scratch_filename(); Wavefunction.get_variable(); Wavefunction.gradient(); Wavefunction.has_array_variable(); Wavefunction.has_potential_variable(); Wavefunction.has_scalar_variable(); Wavefunction.has_variable(); Wavefunction.hessian(); Wavefunction.lagrangian(); Wavefunction.mintshelper(); Wavefunction.mo_extents(); Wavefunction.module(); Wavefunction.molecule(); Wavefunction.nalpha(); Wavefunction.nalphapi(); Wavefunction.name(); Wavefunction.nbeta(); Wavefunction.nbetapi(); Wavefunction.nfrzc(); Wavefunction.nirrep(); Wavefunction.nmo(); Wavefunction.nmopi(); Wavefunction.no_occupations(); Wavefunction.nso(); Wavefunction.nsopi(); Wavefunction.options(); Wavefunction.potential_variable(); Wavefunction.potential_variables(); Wavefunction.reference_wavefunction(); Wavefunction.same_a_b_dens(); Wavefunction.same_a_b_orbs(); Wavefunction.scalar_variable(); Wavefunction.scalar_variables(); Wavefunction.set_array(); Wavefunction.set_array_variable(); Wavefunction.set_basisset(); Wavefunction.set_energy(); Wavefunction.set_external_potential(); Wavefunction.set_gradient(); Wavefunction.set_hessian(); Wavefunction.set_lagrangian(); Wavefunction.set_module(); Wavefunction.set_name(); Wavefunction.set_potential_variable(); Wavefunction.set_print(); Wavefunction.set_reference_wavefunction(); Wavefunction.set_scalar_variable(); Wavefunction.set_variable(); Wavefunction.shallow_copy(); Wavefunction.sobasisset(); Wavefunction.soccpi(); Wavefunction.to_file(); Wavefunction.variable(); Wavefunction.variables(); Wavefunction.write_molden(); Wavefunction.write_nbo(). ; hide menu. menu; sidebar; ; . Navigation. Index. modules  .  .  .  . ; 1.9.1; . PSI4. PSI4 API: Linking C++ and Python; Wavefunction.  Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:1562,Energy Efficiency,charge,charges,1562,"sted Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self,arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self,arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self,arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) doubl",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:2043,Energy Efficiency,energy,energy,2043,"ation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subs",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:2761,Energy Efficiency,energy,energy,2761,",arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:2769,Energy Efficiency,energy,energy,2769,"sis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:2810,Energy Efficiency,energy,energy,2810,"sis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:6513,Energy Efficiency,energy,energy,6513,". nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmet",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:11716,Energy Efficiency,charge,charges,11716,"e name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set.; :rtype: Wavefunction. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:12958,Energy Efficiency,energy,energy,12958,"sset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set.; :rtype: Wavefunction. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet)  psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavef",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:14307,Energy Efficiency,energy,energy,14307,"eep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:14315,Energy Efficiency,energy,energy,14315,"ay_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Beta orbital energies ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:14389,Energy Efficiency,energy,energy,14389,"g0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbital energies should be returned?. Returns:; A Pitzer-ordered vector of the orbitals. Return type:; Vector. epsilon_b(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Beta orbital energies subset. Parameters:. basis  {AO, SO, ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:22593,Energy Efficiency,energy,energy,22593,". same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefuncti",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24695,Energy Efficiency,charge,charge,24695,"on is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key)",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:26052,Energy Efficiency,charge,charges,26052," Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:27137,Energy Efficiency,charge,charges,27137," are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or d",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:27667,Energy Efficiency,energy,energy,27667,"np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NOs. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool)  Write natural orbitals determined from density on wavefunction.; self (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:28451,Energy Efficiency,energy,energy,28451,"to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NOs. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool)  Write natural orbitals determined from density on wavefunction.; self (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; properties or gradient must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:28606,Energy Efficiency,energy,energy,28606,"he density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.; do_virtual (Optional[bool])  Do write all the MOs to the MOLDEN file (True) or discard the unoccupied; MOs (False). Not valid for NOs. If unspecified (None), value taken from; MOLDEN_WITH_VIRTUAL.; use_natural (bool)  Write natural orbitals determined from density on wavefunction.; self (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; properties or gradient must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name); Write wavefunction information in wfn to name in NBO format. Parameters:; name (str)  ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:29328,Energy Efficiency,energy,energy,29328,"elf (Wavefunction)  . Examples:. Molden file with the Kohn-Sham orbitals of a DFT calculation.; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> wfn.molden('mycalc.molden'). Molden file with the natural orbitals of a CCSD computation. For correlated methods, an energy call will not compute the density.; properties or gradient must be called.; >>> E, wfn = properties('ccsd', return_wfn=True); >>> wfn.molden('ccsd_no.molden', use_natural=True). To supply a custom density matrix, manually set the Da and Db of the wavefunction.; This is used, for example, to write natural orbitals coming from a root computed; by a CIWavefunction computation, e.g., detci, fci, casscf.; The first two arguments of get_opdm(); can be set to n, n where n => 0 selects the root to; write out, provided these roots were computed, see NUM_ROOTS. The; third argument controls the spin (""A"", ""B"" or ""SUM"") and the final; boolean option determines whether inactive orbitals are included.; >>> E, wfn = energy('detci', return_wfn=True); >>> wfn.Da() = wfn.get_opdm(0, 0, ""A"", True); >>> wfn.Db() = wfn.get_opdm(0, 0, ""B"", True); >>> molden(wfn, 'no_root1.molden', use_natural=True). write_nbo(name); Write wavefunction information in wfn to name in NBO format. Parameters:; name (str)  Destination file name for NBO file. table of contents. Wavefunction; Wavefunction; Wavefunction.Ca(); Wavefunction.Ca_subset(); Wavefunction.Cb(); Wavefunction.Cb_subset(); Wavefunction.Da(); Wavefunction.Da_subset(); Wavefunction.Db(); Wavefunction.Db_subset(); Wavefunction.Fa(); Wavefunction.Fa_subset(); Wavefunction.Fb(); Wavefunction.Fb_subset(); Wavefunction.H(); Wavefunction.PCM_enabled(); Wavefunction.S(); Wavefunction.alpha_orbital_space(); Wavefunction.aotoso(); Wavefunction.array_variable(); Wavefunction.array_variables(); Wavefunction.arrays(); Wavefunction.atomic_point_charges(); Wavefunction.basis_projection(); Wavefunction.basisset(); Wavefunction.beta_orbital_space(); Wavefunction.build(); Wavefunction.c1",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:30674,Energy Efficiency,energy,energy,30674,efunction; Wavefunction.Ca(); Wavefunction.Ca_subset(); Wavefunction.Cb(); Wavefunction.Cb_subset(); Wavefunction.Da(); Wavefunction.Da_subset(); Wavefunction.Db(); Wavefunction.Db_subset(); Wavefunction.Fa(); Wavefunction.Fa_subset(); Wavefunction.Fb(); Wavefunction.Fb_subset(); Wavefunction.H(); Wavefunction.PCM_enabled(); Wavefunction.S(); Wavefunction.alpha_orbital_space(); Wavefunction.aotoso(); Wavefunction.array_variable(); Wavefunction.array_variables(); Wavefunction.arrays(); Wavefunction.atomic_point_charges(); Wavefunction.basis_projection(); Wavefunction.basisset(); Wavefunction.beta_orbital_space(); Wavefunction.build(); Wavefunction.c1_deep_copy(); Wavefunction.compute_energy(); Wavefunction.compute_gradient(); Wavefunction.compute_hessian(); Wavefunction.deep_copy(); Wavefunction.del_array_variable(); Wavefunction.del_potential_variable(); Wavefunction.del_scalar_variable(); Wavefunction.del_variable(); Wavefunction.doccpi(); Wavefunction.efzc(); Wavefunction.energy(); Wavefunction.epsilon_a(); Wavefunction.epsilon_a_subset(); Wavefunction.epsilon_b(); Wavefunction.epsilon_b_subset(); Wavefunction.esp_at_nuclei(); Wavefunction.external_pot(); Wavefunction.force_occpi(); Wavefunction.frequencies(); Wavefunction.from_file(); Wavefunction.frzcpi(); Wavefunction.frzvpi(); Wavefunction.get_array(); Wavefunction.get_basisset(); Wavefunction.get_density(); Wavefunction.get_dipole_field_strength(); Wavefunction.get_print(); Wavefunction.get_scratch_filename(); Wavefunction.get_variable(); Wavefunction.gradient(); Wavefunction.has_array_variable(); Wavefunction.has_potential_variable(); Wavefunction.has_scalar_variable(); Wavefunction.has_variable(); Wavefunction.hessian(); Wavefunction.lagrangian(); Wavefunction.mintshelper(); Wavefunction.mo_extents(); Wavefunction.module(); Wavefunction.molecule(); Wavefunction.nalpha(); Wavefunction.nalphapi(); Wavefunction.name(); Wavefunction.nbeta(); Wavefunction.nbetapi(); Wavefunction.nfrzc(); Wavefunction.nirrep(); Wa,MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:1381,Modifiability,variab,variable,1381,"t. Cb(self); Returns the Beta Orbitals. Cb_subset(self,arg0,arg1); Returns the requested Beta orbital subset. Da(self); Returns the Alpha Density Matrix. Da_subset(self,arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self,arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self,arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self,arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC va",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:1454,Modifiability,variab,variables,1454,"sted Beta orbital subset. Da(self); Returns the Alpha Density Matrix. Da_subset(self,arg0); Returns the requested Alpha Density subset. Db(self); Returns the Beta Density Matrix. Db_subset(self,arg0); Returns the requested Beta Density subset. Fa(self); Returns the Alpha Fock Matrix. Fa_subset(self,arg0); Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self); Returns the Beta Fock Matrix. Fb_subset(self,arg0); Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self); Returns the 'Core' Matrix (Potential + Kinetic) Integrals. PCM_enabled(self); Whether running a PCM calculation. S(self); Returns the One-electron Overlap Matrix. alpha_orbital_space(self,id,basis,subset); Creates OrbitalSpace with information about the requested alpha orbital space. aotoso(self); Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:2340,Modifiability,variab,variable,2340,"riable(self,arg0); Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:2448,Modifiability,variab,variable,2448,"les(self); Returns the dictionary of all Matrix QC variables. arrays(). Deprecated since version 1.4. atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:2542,Modifiability,variab,variable,2542," atomic_point_charges(self); Returns the set atomic point charges. basis_projection(self,arg0,arg1,arg2,arg3); Projects a orbital matrix from one basis to another. basisset(self); Returns the current orbital basis. beta_orbital_space(self,arg0,arg1,arg2); docstring. build(mol[,basis,quiet]); Build a wavefunction from minimal inputs, molecule and basis set. c1_deep_copy(self,basis); Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self); Computes the energy of the Wavefunction. compute_gradient(self); Computes the gradient of the Wavefunction. compute_hessian(self); Computes the Hessian of the Wavefunction. deep_copy(self,arg0); Deep copies the internal data. del_array_variable(self,arg0); Removes the requested (case-insensitive) Matrix QC variable. del_potential_variable(self,arg0); Removes the requested (case-insensitive) ExternalPotential QC variable. del_scalar_variable(self,arg0); Removes the requested (case-insensitive) double QC variable. del_variable(key); Removes scalar or array QCVariable key from self if present. doccpi(self[,assume_socc_alpha]); Returns the number of doubly occupied orbitals per irrep. efzc(self); Returns the frozen-core energy. energy(self); Returns the Wavefunction's energy. epsilon_a(self); Returns the Alpha Eigenvalues. epsilon_a_subset(self,basis,subset); Returns the requested Alpha orbital energies subset. epsilon_b(self); Returns the Beta Eigenvalues. epsilon_b_subset(self,basis,subset); Returns the requested Beta orbital energies subset. esp_at_nuclei(self); returns electrostatic potentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:4138,Modifiability,variab,variable,4138,"otentials at nuclei. external_pot(self); Gets the requested external potential. force_occpi(self,arg0,arg1); Specialized expert use only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self,arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self,arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self,arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:4258,Modifiability,variab,variable,4258,"only. frequencies(); Returns the results of a frequency analysis. from_file(wfn_data); Build Wavefunction from data laid out like to_file(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self,arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self,arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self,arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); N",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:4409,Modifiability,variab,variable,4409,"(). frzcpi(self); Returns the number of frozen core orbitals per irrep. frzvpi(self); Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4. get_basisset(self,arg0); Returns the requested auxiliary basis. get_density(self,arg0); Experimental!. get_dipole_field_strength(self); Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self); Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self. get_variable(key). Deprecated since version 1.4. gradient(self); Returns the Wavefunction's gradient. has_array_variable(self,arg0); Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self,arg0); Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self,arg0); Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self. hessian(self); Returns the Wavefunction's Hessian. lagrangian(self); Returns the Lagrangian Matrix. mintshelper(self); Returns the current MintsHelper object. mo_extents(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:5757,Modifiability,variab,variable,5757,"ts(self); returns the wavefunction's electronic orbital extents. module(self); Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian.",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:5849,Modifiability,variab,variables,5849,"t level of theory module (internal or external) touching the wavefunction. molecule(self); Returns the Wavefunction's molecule. nalpha(self); Number of Alpha electrons. nalphapi(self); Returns the number of alpha orbitals per irrep. name(self); The level of theory this wavefunction corresponds to. nbeta(self); Number of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name o",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:6165,Modifiability,variab,variable,6165,"ber of Beta electrons. nbetapi(self); Returns the number of beta orbitals per irrep. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets th",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:6239,Modifiability,variab,variables,6239,"p. nfrzc(self); Number of frozen core electrons. nirrep(self); Number of irreps in the system. nmo(self); Number of molecule orbitals. nmopi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstrin",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:6387,Modifiability,variab,variable,6387,"opi(self); Returns the number of molecular orbitals per irrep. no_occupations(self); returns the natural orbital occupations on the wavefunction. nso(self); Number of symmetry orbitals. nsopi(self); Returns the number of symmetry orbitals per irrep. options(self); Returns the Wavefunction's options object. potential_variable(self,key); Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. potential_variables(self); Returns the dictionary of all ExternalPotential QC variables. reference_wavefunction(self); Returns the reference wavefunction. same_a_b_dens(self); Returns true if the alpha and beta densities are the same. same_a_b_orbs(self); Returns true if the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:7089,Modifiability,variab,variable,7089," the alpha and beta orbitals are the same. scalar_variable(self,arg0); Returns the requested (case-insensitive) double QC variable. scalar_variables(self); Returns the dictionary of all double QC variables. set_array(key,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(s",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:7302,Modifiability,variab,variable,7302,"y,val). Deprecated since version 1.4. set_array_variable(self,arg0,arg1); Sets the requested (case-insensitive) Matrix QC variable. set_basisset(self,arg0,arg1); Sets the requested auxiliary basis. set_energy(self,arg0); Sets the Wavefunction's energy. set_external_potential(self,arg0); Sets the requested external potential. set_gradient(self,arg0); Sets the Wavefunction's gradient. set_hessian(self,arg0); Sets the Wavefunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha orbital subset. Parameters:. ba",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:7658,Modifiability,variab,variable,7658,"efunction's Hessian. set_lagrangian(self,arg0); Sets the orbital Lagrangian matrix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha orbital subset. Parameters:. basis (str)  {SO, AO}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str)  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type:; Matr",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:7730,Modifiability,variab,variables,7730,"rix. set_module(self,module); Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self,arg0); Sets the level of theory this wavefunction corresponds to. set_potential_variable(self,arg0,arg1); Sets the requested (case-insensitive) ExternalPotential QC variable. set_print(self,arg0); Sets the print level of the Wavefunction. set_reference_wavefunction(self,arg0); docstring. set_scalar_variable(self,arg0,arg1); Sets the requested (case-insensitive) double QC variable. set_variable(key,val); Sets scalar or array QCVariable key to val on self. shallow_copy(self,arg0); Copies the pointers to the internal data. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self[,assume_socc_alpha]); Returns the number of singly occupied orbitals per irrep. to_file([filename]); Serialize a Wavefunction object. variable(key); Return copy of scalar or array QCVariable key from self. variables([include_deprecated_keys]); Return all scalar or array QCVariables from self. write_molden([filename,do_virtual,use_natural]); Writes wavefunction information in wfn to filename in molden format. write_nbo(name); Write wavefunction information in wfn to name in NBO format. Methods Documentation. Ca(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str)  psi4.core.Matrix; Returns the requested Alpha orbital subset. Parameters:. basis (str)  {SO, AO}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str)  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; A Pitzer-ordered matrix of the orbitals, (# basis functions, # orbitals in the subset).; Pitzer-ordering is with respect to c1 symmetry if basis is AO. Return type:; Matrix. Cb(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Beta Orbit",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:11287,Modifiability,variab,variable,11287,"the Core Matrix (Potential + Kinetic) Integrals. PCM_enabled(self: psi4.core.Wavefunction)  bool; Whether running a PCM calculation. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, mo",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:11304,Modifiability,variab,variable,11304,"s. PCM_enabled(self: psi4.core.Wavefunction)  bool; Whether running a PCM calculation. S(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set.; :rtype: Wavefunction. Par",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:11434,Modifiability,variab,variables,11434,"vefunction)  psi4.core.Matrix; Returns the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set.; :rtype: Wavefunction. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, B",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:11452,Modifiability,variab,variables,11452," the One-electron Overlap Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, id: str, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set.; :rtype: Wavefunction. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:11533,Modifiability,variab,variables,11533,"tr, basis: str, subset: str)  psi4.core.OrbitalSpace; Creates OrbitalSpace with information about the requested alpha orbital space. Parameters:. id  Unique name for the orbital space.; basis  {SO, AO}; Should the subspace be of symmetry orbitals or atomic orbitals?; subset  {ALL, ACTIVE, FROZEN, OCC, VIR, FROZEN_OCC, ACTIVE_OCC, ACTIVE_VIR, FROZEN_VIR}; Which subspace of orbitals should be returned?. Returns:; Information on subset alpha orbitals. Return type:; OrbitalSpace. aotoso(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Returns copy of the requested (case-insensitive) Matrix QC variable. Prefer variable(). array_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.Matrix]; Returns the dictionary of all Matrix QC variables. Prefer variables(). arrays(). Deprecated since version 1.4: Use psi4.core.Wavefunction.variables() instead. Changed in version 1.9: Errors rather than warn-and-forward. atomic_point_charges(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the set atomic point charges. basis_projection(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix, arg1: psi4.core.Dimension, arg2: psi4.core.BasisSet, arg3: psi4.core.BasisSet)  psi4.core.Matrix; Projects a orbital matrix from one basis to another. basisset(self: psi4.core.Wavefunction)  psi4.core.BasisSet; Returns the current orbital basis. beta_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str)  psi4.core.OrbitalSpace; docstring. static build(mol, basis=None, *, quiet=False); Build a wavefunction from minimal inputs, molecule and basis set.; :rtype: Wavefunction. Parameters:. mol (Molecule)  Molecule for which to build the wavefunction instance.; basis (Union[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:13435,Modifiability,variab,variable,13435,"nion[None, str, BasisSet])  Basis set for which to build the wavefunction instance. If a; BasisSet, taken as-is. If a string, taken as a name for the; primary basis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet)  psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. e",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:13602,Modifiability,variab,variable,13602,"sis. If None, name taken from BASIS.; quiet (bool)  When True, do not print to the output file. Return type:; Wavefunction. c1_deep_copy(self: psi4.core.Wavefunction, basis: psi4.core.BasisSet)  psi4.core.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:13800,Modifiability,variab,variable,13800,"ore.Wavefunction; Returns a new wavefunction with internal data converted to \(C_1\) symmetry, using pre-c1-constructed basis. compute_energy(self: psi4.core.Wavefunction)  float; Computes the energy of the Wavefunction. compute_gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the gradient of the Wavefunction. compute_hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Computes the Hessian of the Wavefunction. deep_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Deep copies the internal data. del_array_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) Matrix QC variable. Prefer del_variable(). del_potential_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). del_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  int; Removes the requested (case-insensitive) double QC variable. Prefer del_variable(). del_variable(key); Removes scalar or array QCVariable key from self if present.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; None. doccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of doubly occupied orbitals per irrep. efzc(self: psi4.core.Wavefunction)  float; Returns the frozen-core energy. energy(self: psi4.core.Wavefunction)  float; Returns the Wavefunctions energy. epsilon_a(self: psi4.core.Wavefunction)  psi4.core.Vector; Returns the Alpha Eigenvalues. epsilon_a_subset(self: psi4.core.Wavefunction, basis: str, subset: str)  psi4.core.Vector; Returns the requested Alpha orbital energies subset. Parameters:. basis  {AO, SO, MO}; MO or SO select for Pitzer-ordering the return vector in the full computational point g",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:17161,Modifiability,variab,variable,17161,"oubly and singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies(); Returns the results of a frequency analysis. Parameters:; self  Wavefunction instance. Returns:; A dictionary of vibrational information. See psi4.driver.qcdb.vib.harmonic_analysis(). Return type:; Optional[Dict[str, ndarray]]. static from_file(wfn_data); Build Wavefunction from data laid out like; to_file(). Parameters:; wfn_data (Union[str, Dict, Path])  If a dict, use data directly. Otherwise, path-like passed to; numpy.load() to read from disk. Returns:; A deserialized Wavefunction object. Return type:; Wavefunction. frzcpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of frozen virtual orbitals per irrep. get_array(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  Annotated[List[float], FixedSize(3)]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: ps",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18073,Modifiability,variab,variable,18073,"rep. get_array(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. get_basisset(self: psi4.core.Wavefunction, arg0: str)  psi4.core.BasisSet; Returns the requested auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  Annotated[List[float], FixedSize(3)]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessi",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18337,Modifiability,variab,variable,18337,"d auxiliary basis. get_density(self: psi4.core.Wavefunction, arg0: str)  psi4.core.Matrix; Experimental!. get_dipole_field_strength(self: psi4.core.Wavefunction)  Annotated[List[float], FixedSize(3)]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. lagrangian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction)  psi4.core.MintsHelper; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction)  List[psi",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18494,Modifiability,variab,variable,18494,"ed[List[float], FixedSize(3)]; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction)  int; Get the print level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. lagrangian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction)  psi4.core.MintsHelper; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction)  List[psi4.core.Vector]; returns the wavefunctions electronic orbital extents. module(self: psi4.core.Wavefunction)  str; Name of the last/highest level of theory module (interna",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:18682,Modifiability,variab,variable,18682,"nt level of the Wavefunction. get_scratch_filename(filenumber); Return canonical path to scratch file filenumber based on molecule on self.; :rtype: str. Parameters:. self (Wavefunction)  Wavefunction instance.; filenumber (int)  Scratch file number from psi4/psi4/include/psi4/psifiles.h. Return type:; str. get_variable(key). Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. gradient(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions gradient. has_array_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the Matrix QC variable (case-insensitive) set? Prefer has_variable(). has_potential_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the ExternalPotential QC variable (case-insensitive) set? (This function is provisional and might be removed in the future.). has_scalar_variable(self: psi4.core.Wavefunction, arg0: str)  bool; Is the double QC variable (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set on self.; :rtype: bool. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or; Matrix storage maps. Return type:; bool. hessian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Wavefunctions Hessian. lagrangian(self: psi4.core.Wavefunction)  psi4.core.Matrix; Returns the Lagrangian Matrix. mintshelper(self: psi4.core.Wavefunction)  psi4.core.MintsHelper; Returns the current MintsHelper object. mo_extents(self: psi4.core.Wavefunction)  List[psi4.core.Vector]; returns the wavefunctions electronic orbital extents. module(self: psi4.core.Wavefunction)  str; Name of the last/highest level of theory module (internal or external) touching the wavefunction. molecule(self: psi4.core.Wavefunction)  psi4.core.Molecule; Returns the Wavefunctions molecule. nalpha(self: psi4.core.Wavefunc",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21035,Modifiability,variab,variable,21035,"trons. nbetapi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of beta orbitals per irrep. nfrzc(self: psi4.core.Wavefunction)  int; Number of frozen core electrons. nirrep(self: psi4.core.Wavefunction)  int; Number of irreps in the system. nmo(self: psi4.core.Wavefunction)  int; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction)  List[List[Tuple[float, int, int]]]; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction)  int; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of symmetry orbitals per irrep. options(self: psi4.core.Wavefunction)  psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21261,Modifiability,variab,variables,21261,"t; Number of irreps in the system. nmo(self: psi4.core.Wavefunction)  int; Number of molecule orbitals. nmopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of molecular orbitals per irrep. no_occupations(self: psi4.core.Wavefunction)  List[List[Tuple[float, int, int]]]; returns the natural orbital occupations on the wavefunction. nso(self: psi4.core.Wavefunction)  int; Number of symmetry orbitals. nsopi(self: psi4.core.Wavefunction)  psi4.core.Dimension; Returns the number of symmetry orbitals per irrep. options(self: psi4.core.Wavefunction)  psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21797,Modifiability,variab,variable,21797,"bitals per irrep. options(self: psi4.core.Wavefunction)  psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets th",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21814,Modifiability,variab,variable,21814," psi::Options; Returns the Wavefunctions options object. potential_variable(self: psi4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.c",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21934,Modifiability,variab,variables,21934,"i4.core.Wavefunction, key: str)  psi4.core.ExternalPotential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. S",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:21952,Modifiability,variab,variables,21952,"otential; Returns copy of the requested (case-insensitive) ExternalPotential QC variable key. (This function is provisional and might be removed in the future.). potential_variables(self: psi4.core.Wavefunction)  Dict[str, psi4.core.ExternalPotential]; Returns the dictionary of all ExternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIEN",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:22270,Modifiability,variab,variable,22270,"ternalPotential QC variables. (This function is provisional and might be removed in the future.). reference_wavefunction(self: psi4.core.Wavefunction)  psi4.core.Wavefunction; Returns the reference wavefunction. same_a_b_dens(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta densities are the same. same_a_b_orbs(self: psi4.core.Wavefunction)  bool; Returns true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_modu",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:22630,Modifiability,variab,variable,22630,"s true if the alpha and beta orbitals are the same. scalar_variable(self: psi4.core.Wavefunction, arg0: str)  float; Returns the requested (case-insensitive) double QC variable. Prefer variable(). scalar_variables(self: psi4.core.Wavefunction)  Dict[str, float]; Returns the dictionary of all double QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; S",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:22930,Modifiability,variab,variable,22930,"le QC variables. Prefer variables(). set_array(key, val). Deprecated since version 1.4: Use psi4.core.Wavefunction.set_variable() instead. Changed in version 1.9: Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:23094,Modifiability,variab,variable,23094," Errors rather than warn-and-forward. set_array_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.Matrix)  None; Sets the requested (case-insensitive) Matrix QC variable. Syncs with Wavefunction.gradient_ or hessian_ if CURRENT GRADIENT or HESSIAN. Prefer set_variable(). set_basisset(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.BasisSet)  None; Sets the requested auxiliary basis. set_energy(self: psi4.core.Wavefunction, arg0: float)  None; Sets the Wavefunctions energy. Syncs with Wavefunctions QC variable CURRENT ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive)",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:23685,Modifiability,variab,variable,23685," ENERGY. set_external_potential(self: psi4.core.Wavefunction, arg0: psi4.core.ExternalPotential)  None; Sets the requested external potential. set_gradient(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions gradient. Syncs with Wavefunctions QC variable CURRENT GRADIENT. set_hessian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the Wavefunctions Hessian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; dat",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24103,Modifiability,variab,variable,24103,"ian. Syncs with Wavefunctions QC variable CURRENT HESSIAN. set_lagrangian(self: psi4.core.Wavefunction, arg0: psi4.core.Matrix)  None; Sets the orbital Lagrangian matrix. set_module(self: psi4.core.Wavefunction, module: str)  None; Sets name of the last/highest level of theory module (internal or external) touching the wavefunction. set_name(self: psi4.core.Wavefunction, arg0: str)  None; Sets the level of theory this wavefunction corresponds to. set_potential_variable(self: psi4.core.Wavefunction, arg0: str, arg1: psi4.core.ExternalPotential)  None; Sets the requested (case-insensitive) ExternalPotential QC variable. (This function is provisional and might be removed in the future.). set_print(self: psi4.core.Wavefunction, arg0: int)  None; Sets the print level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies th",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24871,Modifiability,variab,variable,24871,"int level of the Wavefunction. set_reference_wavefunction(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:24939,Modifiability,variab,variable,24939,"nction, arg0: psi4.core.Wavefunction)  None; docstring. set_scalar_variable(self: psi4.core.Wavefunction, arg0: str, arg1: float)  None; Sets the requested (case-insensitive) double QC variable. Syncs with Wavefunction.energy_ if CURRENT ENERGY. Prefer set_variable(). set_variable(key, val); Sets scalar or array QCVariable key to val on self.; :rtype: None. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. If CURRENT ENERGY, syncs with self.energy_.; If CURRENT GRADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:25481,Modifiability,inherit,inherited,25481,"RADIENT, syncs with gradient_.; If CURRENT HESSIAN, syncs with self.hessian_. val (Union[Matrix, ndarray, float])  Scalar or array to be stored in key. If ndarray and; data key does not naturally fit in 2D Matrix (often charge and; multipole QCVariables), it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:25694,Modifiability,variab,variable,25694," it will be reshaped, as all; ndarray are stored as Matrix. Raises:; ValidationError  If val is a scalar but key already exists as an array variable. Or; if val is an array but key already exists as a scalar variable. Return type:; None. shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:25955,Modifiability,variab,variables,25955,". shallow_copy(self: psi4.core.Wavefunction, arg0: psi4.core.Wavefunction)  None; Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecat",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:25996,Modifiability,variab,variables,25996," Copies the pointers to the internal data. sobasisset(self: psi4.core.Wavefunction)  psi4.core.SOBasisSet; Returns the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:26126,Modifiability,variab,variables,26126,"s the symmetry orbitals basis. soccpi(self: psi4.core.Wavefunction, assume_socc_alpha: bool = True)  psi4.core.Dimension; Returns the number of singly occupied orbitals per irrep. to_file(filename=None); Serialize a Wavefunction object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as nd",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:26381,Modifiability,variab,variable,26381,"object. Opposite of; from_file(). Parameters:. wfn (Wavefunction)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:26438,Modifiability,variab,variable,26438,"tion)  Wavefunction or inherited class instance.; filename (Optional[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information ",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:26507,Modifiability,variab,variable,26507,"l[str])  An optional filename to which to write the data. Returns:; A dictionary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals fr",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:26587,Modifiability,variab,variable,26587,"onary and NumPy representation of the Wavefunction. Return type:; Dict[str, Dict[str, Any]]. variable(key); Return copy of scalar or array QCVariable; key from self. Parameters:. self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do n",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:26734,Modifiability,variab,variables,26734," self (Wavefunction)  Wavefunction instance.; key (str)  Case-insensitive key to instances double or Matrix; storage maps. Returns:; Requested QCVariable from self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transform",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html:27040,Modifiability,variab,variables,27040,"charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; float or ndarray or Matrix. Raises:; KeyError  If key not set on self. Example; >>> g, wfn = psi4.gradient(""hf/cc-pvdz"", return_wfn=True); >>> wfn.variable(""CURRENT ENERGY""); -100.00985995185668; >>> wfn.variable(""CURRENT DIPOLE""); array([ 0. , 0. , -0.83217802]); >>> wfn.variable(""CURRENT GRADIENT""); <psi4.core.Matrix object at 0x12d884fc0>; >>> wfn.variable(""CURRENT GRADIENT"").np; array([[ 6.16297582e-33, 6.16297582e-33, -9.41037138e-02],; [-6.16297582e-33, -6.16297582e-33, 9.41037138e-02]]). variables(include_deprecated_keys=False); Return all scalar or array QCVariables; from self. Parameters:. self  Wavefunction instance.; include_deprecated_keys (bool)  Also return duplicate entries with keys that have been deprecated. Returns:; Map of all QCVariables that have been set on self. Scalar variables are returned as floats.; Array variables not naturally 2D (like multipoles or per-atom charges); are returned as ndarray of natural dimensionality.; Other array variables are returned as Matrix and; may have an extra dimension with symmetry information. Return type:; Dict[str, Union[float, ndarray, Matrix]. write_molden(filename=None, do_virtual=None, use_natural=False); Writes wavefunction information in wfn to filename in; molden format. Will write natural orbitals from density (MO basis) if supplied.; Warning! most post-SCF wavefunctions do not build the density as this is often; much more costly than the energy. In addition, the wavefunction density attributes; (Da and Db) return the SO density and must be transformed to the MO basis; to use with this function. New in version 0.5: wfn parameter passed explicitly. Returns:; None. Parameters:. filename (Optional[str])  Destination file name for MOLDEN file. If unspecified (None), a file; name will be generated from the molecule name.;",MatchSource.WIKI,psi4manual/1.9.x/api/psi4.core.Wavefunction.html,psi4,psi4,v1.9.1,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Wavefunction.html
