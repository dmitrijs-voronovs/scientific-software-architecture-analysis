id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html534/TGColorPick.html:16863,Availability,mask,mask,16863,,MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
https://root.cern/root/html534/TGColorPick.html:19993,Availability,error,error,19993,". Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page",MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
https://root.cern/root/html534/TGColorPick.html:19674,Energy Efficiency,allocate,allocate,19674,"ton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pix",MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
https://root.cern/root/html534/TGColorPick.html:19786,Energy Efficiency,allocate,allocated,19786,"UserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col",MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
https://root.cern/root/html534/TGColorPick.html:19947,Energy Efficiency,reduce,reduced,19947,"ormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 199",MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
https://root.cern/root/html534/TGColorPick.html:20045,Integrability,rout,routine,20045,"0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggesti",MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
https://root.cern/root/html534/TGColorPopup.html:769,Availability,down,down,769,". TGColorPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorPopup. class TGColorPopup: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorPopup(const TGWindow* p = 0, const TGWindow* m = 0, Pixel_t color = 0); virtual~TGColorPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_",MatchSource.WIKI,root/html534/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPopup.html
https://root.cern/root/html534/TGColorPopup.html:4806,Availability,error,error,4806,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPopup.html
https://root.cern/root/html534/TGColorPopup.html:4890,Availability,error,error,4890,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPopup.html
https://root.cern/root/html534/TGColorPopup.html:17419,Availability,mask,mask,17419,,MatchSource.WIKI,root/html534/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPopup.html
https://root.cern/root/html534/TGColorPopup.html:18241,Integrability,message,messages,18241,"orcurrently selected color value; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Int_tfLaunchDialogflag used for launching color dialog; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html534/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPopup.html
https://root.cern/root/html534/TGColorPopup.html:20228,Integrability,message,messages,20228,"C*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPopup(const TGWindow* p = 0, const TGWindow* m = 0, Pixel_t color = 0); TGColorPopup constructor.; The TGColorPopup is a popup containing a TG16ColorSelector and a ""More...""; button which popups up a TGColorDialog allowing custom color selection. ~TGColorPopup(); TGColorPopup destructor. void EndPopup(); Ungrab pointer and unmap window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Popup TGColorPopup at x,y position. Bool_t HandleButton(Event_t* event); Handle mouse button events for TGColorPopup. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorPopup. void PreviewColor(Pixel_t color); Emit a signal to see preview. void PreviewAlphaColor(ULong_t color); Emit a signal to see preview. TGColorFrame& operator=(const TGColorPopup& ). TGColorPopup(const TGColorPopup& ). » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPopup.html
https://root.cern/root/html534/TGColorSelect.html:769,Availability,down,down,769,". TGColorSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorSelect. class TGColorSelect: public TGCheckButton. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); virtual~TGColorSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidAlphaColorSelected(ULong_t colptr = 0)SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Cl",MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColorSelect.html:4954,Availability,error,error,4954,"nal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelected",MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColorSelect.html:5038,Availability,error,error,5038,"ject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetD",MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColorSelect.html:19928,Availability,mask,mask,19928,,MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColorSelect.html:21771,Availability,down,down,21771, frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGPositionfPressPospsotion of frame on button press event; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColorSelect.html:23742,Availability,down,down,23742,"me::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); TGColorSelect constructor.; The TGColorSelect widget is like a checkbutton but instead of the check; mark there is color area with a little down arrow.; When clicked on the arrow the TGColorPopup pops up. ~TGColorSelect(); TGColorSelect destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorSelect. Bool_t HandleButton(Event_t* event); Handle button events for TGColorSelect. void Enable(Bool_t on = kTRUE); Set state of widget as enabled. void Disable(); Set state of widget as disabled. void DoRedraw(); Redraw TGColorSelect widget. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw triangle (arrow) on which user can click to open TGColorPopup. void SetColor(Pixel_t color, Bool_t emit = kTRUE); Set color. void SetAlphaColor(ULong_t color, Bool_t emit = kTRUE); Set color. void SavePrimitive(ostream& out, Option_t* = """"); Save a color select widget as a C++ statement(s) on output stream out. TGColorFrame& operator=(const TGColorSelect& ). Pixel_t GetColor() const; { return fColor; }. TGColorSelect(const TGColorSelect& ). voi",MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColorSelect.html:23273,Deployability,release,released,23273,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColorSelect.html:23922,Integrability,message,messages,23922,"ound; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); TGColorSelect constructor.; The TGColorSelect widget is like a checkbutton but instead of the check; mark there is color area with a little down arrow.; When clicked on the arrow the TGColorPopup pops up. ~TGColorSelect(); TGColorSelect destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorSelect. Bool_t HandleButton(Event_t* event); Handle button events for TGColorSelect. void Enable(Bool_t on = kTRUE); Set state of widget as enabled. void Disable(); Set state of widget as disabled. void DoRedraw(); Redraw TGColorSelect widget. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw triangle (arrow) on which user can click to open TGColorPopup. void SetColor(Pixel_t color, Bool_t emit = kTRUE); Set color. void SetAlphaColor(ULong_t color, Bool_t emit = kTRUE); Set color. void SavePrimitive(ostream& out, Option_t* = """"); Save a color select widget as a C++ statement(s) on output stream out. TGColorFrame& operator=(const TGColorSelect& ). Pixel_t GetColor() const; { return fColor; }. TGColorSelect(const TGColorSelect& ). void SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); dummy methods just to remove from context menu. { TGButton::SetDown(on, emit); }. void Rename(const char* title); { TGTextButton::SetTitle(title); }. void Se",MatchSource.WIKI,root/html534/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorSelect.html
https://root.cern/root/html534/TGColumnLayout.html:787,Availability,down,downward,787,". TGColumnLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColumnLayout. class TGColumnLayout: public TGRowLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGColumnLayout(const TGColumnLayout&); TGColumnLayout(TGCompositeFrame* main, Int_t s = 0); ~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(O",MatchSource.WIKI,root/html534/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColumnLayout.html
https://root.cern/root/html534/TGColumnLayout.html:2329,Availability,error,error,2329,"umnLayout&); TGColumnLayout(TGCompositeFrame* main, Int_t s = 0); ~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html534/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColumnLayout.html
https://root.cern/root/html534/TGColumnLayout.html:2413,Availability,error,error,2413," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html534/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColumnLayout.html
https://root.cern/root/html534/TGComboBox.html:377,Availability,down,down,377,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:614,Availability,down,down,614,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:5231,Availability,error,error,5231,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefa",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:5315,Availability,error,error,5315,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TD",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:18969,Availability,down,down,18969,,MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:19124,Availability,mask,mask,19124,,MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:22472,Deployability,update,update,22472," static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a combo box widget. TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create an editable combo box widget. ~TGComboBox(); Delete a combo box widget. void Init(); Initiate the internal classes of a combo box. void DrawBorder(); Draw border of combo box widget. void EnableTextInput(Bool_t on); Switch text input or readonly mode of combobox (not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t wi",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:23290,Integrability,message,messages,23290,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBoxPopup& operator=(const TGComboBox& ). TGComboBox(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); ",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:23337,Integrability,message,messages,23337,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBoxPopup& operator=(const TGComboBox& ). TGComboBox(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); ",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBox.html:23362,Integrability,message,message,23362,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBoxPopup& operator=(const TGComboBox& ). TGComboBox(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); ",MatchSource.WIKI,root/html534/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBox.html
https://root.cern/root/html534/TGComboBoxPopup.html:375,Availability,down,down,375,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBoxPopup(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); ~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObj",MatchSource.WIKI,root/html534/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBoxPopup.html
https://root.cern/root/html534/TGComboBoxPopup.html:612,Availability,down,down,612,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBoxPopup(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); ~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObj",MatchSource.WIKI,root/html534/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBoxPopup.html
https://root.cern/root/html534/TGComboBoxPopup.html:4824,Availability,error,error,4824,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBoxPopup.html
https://root.cern/root/html534/TGComboBoxPopup.html:4908,Availability,error,error,4908,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBoxPopup.html
https://root.cern/root/html534/TGComboBoxPopup.html:17363,Availability,mask,mask,17363,,MatchSource.WIKI,root/html534/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGComboBoxPopup.html
https://root.cern/root/html534/TGCommandPlugin.html:4359,Availability,error,error,4359,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCommandPlugin.html
https://root.cern/root/html534/TGCommandPlugin.html:4443,Availability,error,error,4443,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCommandPlugin.html
https://root.cern/root/html534/TGCommandPlugin.html:18694,Availability,mask,mask,18694,,MatchSource.WIKI,root/html534/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCommandPlugin.html
https://root.cern/root/html534/TGCommandPlugin.html:20212,Deployability,update,update,20212,tions! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tfPidcurrent process id; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGTextView*fStatusoutput capture view; TTimer*fTimerfor local/remote update; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby;,MatchSource.WIKI,root/html534/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCommandPlugin.html
https://root.cern/root/html534/TGCompositeFrame.html:5277,Availability,error,error,5277,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html534/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCompositeFrame.html
https://root.cern/root/html534/TGCompositeFrame.html:5361,Availability,error,error,5361,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html534/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCompositeFrame.html
https://root.cern/root/html534/TGCompositeFrame.html:16901,Availability,mask,mask,16901,,MatchSource.WIKI,root/html534/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCompositeFrame.html
https://root.cern/root/html534/TGCompositeFrame.html:19839,Performance,load,load,19839,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root/html534/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCompositeFrame.html
https://root.cern/root/html534/TGCompositeFrame.html:1364,Testability,log,logically,1364,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); virtual voidChangeSubframesBackground(Pixel_t back); stat",MatchSource.WIKI,root/html534/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCompositeFrame.html
https://root.cern/root/html534/TGCompositeFrame.html:19821,Testability,test,test,19821,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root/html534/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCompositeFrame.html
https://root.cern/root/html534/TGCompositeFrame.html:566,Usability,simpl,simple,566,". TGCompositeFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCompositeFrame. class TGCompositeFrame: public TGFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSigna",MatchSource.WIKI,root/html534/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCompositeFrame.html
https://root.cern/root/html534/TGContainer.html:6042,Availability,error,error,6042," signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); ",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:6126,Availability,error,error,6126,"TQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:12341,Availability,mask,mask,12341,"tual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual voidInvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidKeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLayout(); virtual voidLineDown(Bool_t select = kFALSE); virtual voidLineLeft(Bool_t select = kFALSE); virtual voidLineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual Int_tNumItems() const; virtual ",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:20361,Availability,mask,mask,20361,,MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:24229,Availability,mask,mask,24229,":fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicke",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:24339,Availability,mask,mask,24339,"tation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGFrame* f, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGFrame* f, Int_t btn, Int_t x",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:24359,Availability,mask,mask,24359,"tation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGFrame* f, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGFrame* f, Int_t btn, Int_t x",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:28623,Availability,down,down,28623,"The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); Find frame located int container at position x,y. void * FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE). TGHScrollBar * GetHScrollbar() const; returns pointer to hor. scroll bar. TGVScrollBar * GetVScrollbar() const; returns pointer to vert. scroll bar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetHsbPosition(Int_t newPos); set new hor. position. void AdjustPosition(); Move content to position of highlighted/activated frame. void LineLeft(Bool_t select = kFALSE); Move current position one column left. void LineRight(Bool_t select = kFALSE); Move current position one column right. void LineUp(Bool_t select = kFALSE); Make current position first line in window by scrolling up. void LineDown(Bool_t select = kFALSE); Move one line down. void PageUp(Bool_t select = kFALSE); Move position one page up. void PageDown(Bool_t select = kFALSE); Move position one page down. void Home(Bool_t select = kFALSE); Move to upper-left corner of container. void End(Bool_t select = kFALSE); Move to the bottom-right corner of container. const TGGC & GetLineGC(); Get graphics context for line drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas container as a C++ statement(s) on output stream out. TGContainer(const TGContainer& ). TGContainer& operator=(const TGContainer& ). void Associate(const TGWindow* w); { fMsgWindow = w; }. TGCanvas * GetCanvas() const; { return fCanvas; }. const TGWindow * GetMessageWindow() const; { return fMsgWindow; }. Int_t NumSelected() const; { return fSelected; }. Int_t NumItems() const; { return fTotal; }. TGFrame * GetLastActive() const; { return fLastActiveEl ? fLastActiveEl->fFrame : 0; }. Bool_t HandleDNDFinished(); { fBdown = kFALSE; return kTRU",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:28755,Availability,down,down,28755,"ment * FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); Find frame located int container at position x,y. void * FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE). TGHScrollBar * GetHScrollbar() const; returns pointer to hor. scroll bar. TGVScrollBar * GetVScrollbar() const; returns pointer to vert. scroll bar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetHsbPosition(Int_t newPos); set new hor. position. void AdjustPosition(); Move content to position of highlighted/activated frame. void LineLeft(Bool_t select = kFALSE); Move current position one column left. void LineRight(Bool_t select = kFALSE); Move current position one column right. void LineUp(Bool_t select = kFALSE); Make current position first line in window by scrolling up. void LineDown(Bool_t select = kFALSE); Move one line down. void PageUp(Bool_t select = kFALSE); Move position one page up. void PageDown(Bool_t select = kFALSE); Move position one page down. void Home(Bool_t select = kFALSE); Move to upper-left corner of container. void End(Bool_t select = kFALSE); Move to the bottom-right corner of container. const TGGC & GetLineGC(); Get graphics context for line drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas container as a C++ statement(s) on output stream out. TGContainer(const TGContainer& ). TGContainer& operator=(const TGContainer& ). void Associate(const TGWindow* w); { fMsgWindow = w; }. TGCanvas * GetCanvas() const; { return fCanvas; }. const TGWindow * GetMessageWindow() const; { return fMsgWindow; }. Int_t NumSelected() const; { return fSelected; }. Int_t NumItems() const; { return fTotal; }. TGFrame * GetLastActive() const; { return fLastActiveEl ? fLastActiveEl->fFrame : 0; }. Bool_t HandleDNDFinished(); { fBdown = kFALSE; return kTRUE; }. » Author: Fons Rademakers 11/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:21539,Integrability,message,messages,21539,; TStringfKeyInputkeyboard input (buffer); TTimer*fKeyTimerkeyboard timer; Bool_tfKeyTimerActivekTRUE - keyboard timer is active; TGFrameElement*fLastActiveEllast active item; Bool_tfLastCasecase sensetivity of last search; Bool_tfLastDirdirection of last search; TStringfLastNamethe name of object of last search; Bool_tfLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tfOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*fScrollTimerautoscroll timer; Bool_tfScrollingkTRUE - when scrolling is ON; Int_tfSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfTotaltotal items; TGViewPort*fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tfX0; Int_tfXDND; Int_tfXf; Int_tfXp; Int_tTGFrame::fYframe y position; Int_tfY0corner of rubber band box; Int_tfYDND; Int_tfYfother corner of rubber band box; Int_tfYpprevious pointer position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; stati,MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGContainer.html:26754,Security,expose,expose,26754,"m from container. const TGFrame * GetNextSelected(void** current); Return the next selected item. If the ""current"" pointer is 0, the first; selected item will be returned. void ActivateItem(TGFrameElement* el); Activate item. void DeActivateItem(TGFrameElement* el); DeActivate item. TGPosition GetPagePosition() const; Returns page position. TGDimension GetPageDimension() const; Returns page dimension. void SetPagePosition(const TGPosition& pos); Set page position. void SetPagePosition(Int_t x, Int_t y); Set page position. void SetPageDimension(const TGDimension& dim); Set page dimension. void SetPageDimension(UInt_t w, UInt_t h); Set page dimension. void DoRedraw(); Redraw content of container in the viewport region. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw a region of container in viewport.; x, y, w, h are position and dimension of area to be; redrawn in viewport coordinates. void ClearViewPort(); Clear view port and redraw full content. Bool_t HandleExpose(Event_t* event); Handle expose events. Do not use double buffer. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. const TGPicture * GetObjPicture(TGFrame* f); Retrieve icons associated with class ""name"". Association is made; via the user's ~/.root.mimes file or via $ROOTSYS/etc/root.mimes. void SetDragPixmap(const TGPicture* pic); Set drag window pixmaps and hotpoint. Bool_t HandleDoubleClick(Event_t* event); Handle double click mouse event. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. TGFrame * FindFrameByName(const char* name); Find frame by name. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void OnAutoScroll(); Autoscroll while close to & beyond The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFr",MatchSource.WIKI,root/html534/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGContainer.html
https://root.cern/root/html534/TGDMLParse.html:1307,Availability,error,error,1307,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLParse.html:1391,Availability,error,error,1391,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLParse.html:10800,Integrability,depend,depending,10800,"nd the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. TString GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces it wi",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLParse.html:10784,Modifiability,variab,variable,10784,"nd the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. TString GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces it wi",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLParse.html:1717,Testability,test,test,1717,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLParse.html:10177,Testability,test,test,10177,"dium names and the TGeoMedium for it; TGDMMapHelper<TGeoMixture>fmixmap!Map containing mixture names and the TGeoMixture for it; TGDMMapHelper<TGeoTranslation>fposmap!Map containing position names and the TGeoTranslation for it; map<string,string>freflectmap!Map containing reflection names and the Solid name ir references to; TGDMMapHelper<TGDMLRefl>freflsolidmap!Map containing reflection names and the TGDMLRefl for it - containing refl matrix; map<string,string>freflvolmap!Map containing reflected volume names and the solid ref for it; TGDMMapHelper<TGeoRotation>frotmap!Map containing rotation names and the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePoin",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLParse.html:17064,Usability,simpl,simple,17064,"the original assembly using TGeoVolume->AddNode. XMLNodePointer_t TopProcess(TXMLEngine* gdml, XMLNodePointer_t node); In the setup section of the GDML file, the top volume need to be; declared. when the setup keyword is found, this function is called,; and the top volume ref is taken and 'world' is set. XMLNodePointer_t Box(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a box may be declared.; when the box keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Ellipsoid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an ellipsoid may be declared.; Unfortunately, the ellipsoid is not supported under ROOT so,; when the ellipsoid keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t ElCone(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an elliptical cone may be declared.; Unfortunately, the elliptical cone is not supported under ROOT so,; when the elcone keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Paraboloid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a Paraboloid may be declared.; when the paraboloid keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TG",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLParse.html:17570,Usability,simpl,simple,17570,"called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Ellipsoid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an ellipsoid may be declared.; Unfortunately, the ellipsoid is not supported under ROOT so,; when the ellipsoid keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t ElCone(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an elliptical cone may be declared.; Unfortunately, the elliptical cone is not supported under ROOT so,; when the elcone keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Paraboloid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a Paraboloid may be declared.; when the paraboloid keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoParaboloid and stored in fsolmap map using the name; as its key. XMLNodePointer_t Arb8(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an Arb8 may be declared.; when the arb8 keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoArb8 and stored in fsolmap map using the name; as its key. XMLNodePointer_t Tube(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttr",MatchSource.WIKI,root/html534/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLParse.html
https://root.cern/root/html534/TGDMLRefl.html:1496,Availability,error,error,1496,"LRefl(const char* name, const char* solid, TGeoMatrix* matrix); virtual~TGDMLRefl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(co",MatchSource.WIKI,root/html534/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLRefl.html
https://root.cern/root/html534/TGDMLRefl.html:1580,Availability,error,error,1580," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) co",MatchSource.WIKI,root/html534/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLRefl.html
https://root.cern/root/html534/TGDMLRefl.html:5687,Security,access,accessor,5687,"(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TGeoMatrix*fMatrix!matrix of reflected solid; const char*fNameS!reflected solid name; const char*fSolid!solid name being reflected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix); this constructor method stores the values brought in as params. TGeoMatrix* GetMatrix(); this accessor method returns the matrix. TGDMLRefl(). virtual ~TGDMLRefl(); {}. TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix). » Last changed: Fri Mar 13 19:24:29 2015 » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLRefl.html
https://root.cern/root/html534/TGDMLWrite.html:4786,Availability,error,error,4786,,MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:4870,Availability,error,error,4870," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:12355,Availability,error,errors,12355,"oVolume* volume); TStringGenName(TString oldname); TStringGenName(TString oldname, TString objPointer); TStringGetPattAxis(Int_t divAxis, const char* pattName, TString& unit); TGDMLWrite::XyzGetXYZangles(const Double_t* rotationMatrix); Bool_tIsInList(TGDMLWrite::NameList list, TString name2check); Bool_tIsNullParam(Double_t parValue, TString parName, TString objName); XMLNodePointer_tStartAssemblyN(const char* name); XMLNodePointer_tStartVolumeN(const char* name, const char* solid, const char* material); voidUnsetTemporaryBits(TGeoManager* geoMng). Data Members; public:. enum ENamingType { kelegantButSlow; kwithoutSufixNotUniq; kfastButUglySufix; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TGDMLWrite::StructLst*fAccPattlist of accepted patterns for division; UInt_tfActNameErrcount of name errors; XMLNodePointer_tfDefineNodemain <define> node...; TGDMLWrite::StructLst*fElementListlist of elements; TXMLEngine*fGdmlExml engine pointer; XMLDocPointer_tfGdmlFilepointer storing xml file; TGDMLWrite::StructLst*fIsotopeListlist of isotopes; XMLNodePointer_tfMaterialsNodemain <materials> node...; TGDMLWrite::NameLst*fNameListlist of names (pointer mapped); Int_tfPhysVolCntcount of physical volumes; TGDMLWrite::StructLst*fRejShapelist of rejected shapes; UInt_tfSolCntcount of name solids; XMLNodePointer_tfSolidsNodemain <solids> node...; XMLNodePointer_tfStructureNodemain <structure> node...; TStringfTopVolumeNamename of top volume; Int_tfVolCntcount of volumes; Bool_tfgG4Compatibilityinput option for Geant4 compatibility; static TGDMLWrite*fgGDMLWritepointer to gdml writer; Int_tfgNamingSpeedinput option for volume and solid naming; static const UInt_tfgkMaxNameErrmaximum number of errors for naming; static const UInt_tfgkProcBit14th bit is set when solid",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:13257,Availability,error,errors,13257,"e; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TGDMLWrite::StructLst*fAccPattlist of accepted patterns for division; UInt_tfActNameErrcount of name errors; XMLNodePointer_tfDefineNodemain <define> node...; TGDMLWrite::StructLst*fElementListlist of elements; TXMLEngine*fGdmlExml engine pointer; XMLDocPointer_tfGdmlFilepointer storing xml file; TGDMLWrite::StructLst*fIsotopeListlist of isotopes; XMLNodePointer_tfMaterialsNodemain <materials> node...; TGDMLWrite::NameLst*fNameListlist of names (pointer mapped); Int_tfPhysVolCntcount of physical volumes; TGDMLWrite::StructLst*fRejShapelist of rejected shapes; UInt_tfSolCntcount of name solids; XMLNodePointer_tfSolidsNodemain <solids> node...; XMLNodePointer_tfStructureNodemain <structure> node...; TStringfTopVolumeNamename of top volume; Int_tfVolCntcount of volumes; Bool_tfgG4Compatibilityinput option for Geant4 compatibility; static TGDMLWrite*fgGDMLWritepointer to gdml writer; Int_tfgNamingSpeedinput option for volume and solid naming; static const UInt_tfgkMaxNameErrmaximum number of errors for naming; static const UInt_tfgkProcBit14th bit is set when solid is processed; static const UInt_tfgkProcBitVol19th bit is set when volume is processed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLWrite(); Default constructor. ~TGDMLWrite(); Destructor. void SetNamingSpeed(TGDMLWrite::ENamingType naming); Set convetion of naming solids and volumes. void WriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.gdml"", TString option = """"); Wrapper of all exporting methods; Creates blank GDML file and fills it with gGeoManager structure converted; to GDML structure of xml nodes. XMLNodePointer_t ExtractMaterials(TList* materialsLst); Method exporting materials. TString ExtractSolid(TGeoShape* volShape); Method creating solid to xml file and returning its name. void ExtractVolumes(TGeoVolume* volume); Method extracting geometry structure recursively. ",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:1062,Deployability,update,updated,1062,"e; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GDML; » TGDMLWrite. class TGDMLWrite: public TObject. TGDMLWrite Class. This class contains implementation of converting ROOT's gGeoManager; geometry to GDML file. gGeoManager is the instance of TGeoManager class; containing tree of geometries creating resulting geometry. GDML is xml; based format of file mirroring the tree of geometries according to GDML; schema rules. For more information about GDML see http://gdml.web.cern.ch.; Each object in ROOT is represented by xml tag (=xml node/element) in GDML. This class is not needed to be instanciated. It should always be called; by gGeoManager->Export(""xyz.gdml"") method. Export is driven by extenstion; that is why "".gdml"" is important in resulting name. Whenever a new ROOT geometry object is implemented or there is a change; in GDML schema this class is needed to be updated to ensure proper mapping; between ROOT objects and GDML elements. Current status of mapping ROOT -> GDML is implemented in method called; TGDMLWrite::ChooseObject and it contains following ""map"":. Solids:; TGeoBBox -> <box ... >; TGeoParaboloid -> <paraboloid ...>; TGeoSphere -> <sphere ...>; TGeoArb8 -> <arb8 ...>; TGeoConeSeg -> <cone ...>; TGeoCone -> <cone ...>; TGeoPara -> <para ...>; TGeoTrap -> <trap ...> or; - -> <arb8 ...>; TGeoGtra -> <twistedtrap ...> or; - -> <trap ...> or; - -> <arb8 ...>; TGeoTrd1 -> <trd ...>; TGeoTrd2 -> <trd ...>; TGeoTubeSeg -> <tube ...>; TGeoCtub -> <cutTube ...>; TGeoTube -> <tube ...>; TGeoPcon -> <polycone ...>; TGeoTorus -> <torus ...>; TGeoPgon -> <polyhedra ...>; TGeoEltu -> <eltube ...>; TGeoHype -> <hype ...>; TGeoXtru -> <xtru ...>; TGeoCompositeShape -> <union ...> or; - -> <subtraction ...> or; - -> <intersection ...>. Special cases of solids:; TGeoScaledShape -> <elcone ...> if scaled TGeoCone or; - -> elemen",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:3136,Security,secur,secured,3136,"; - -> <intersection ...>. Special cases of solids:; TGeoScaledShape -> <elcone ...> if scaled TGeoCone or; - -> element without scale; TGeoCompositeShape -> <ellipsoid ...>; - intersection of:; - scaled TGeoSphere and TGeoBBox. Materials:; TGeoIsotope -> <isotope ...>; TGeoElement -> <element ...>; TGeoMaterial -> <material ...>; TGeoMixture -> <material ...>. Structure; TGeoVolume -> <volume ...> or; - -> <assembly ...>; TGeoNode -> <physvol ...>; TGeoPatternFinder -> <divisionvol ...>. There are options that can be set to change resulting document; Options:; g - is set by default in gGeoManager, this option ensures compatibility; - with Geant4. It means:; - -> atomic number of material will be changed if <1 to 1; - -> if polycone is set badly it will try to export it correctly; - -> if widht * ndiv + offset is more then width of object being divided; - (in divisions) then it will be rounded so it will not exceed or; - if kPhi divsion then it will keep range of offset in -360 -> 0; f - if this option is set then names of volumes and solids will have; - pointer as a suffix to ensure uniqness of names; n - if this option is set then names will not have suffix, but uniqness is; - of names is not secured; - - if none of this two options (f,n) is set then default behaviour is so; - that incremental suffix is added to the names.; - (eg. TGeoBBox_0x1, TGeoBBox_0x2 ...). USAGE:; gGeoManager->Export(""output.gdml"");; gGeoManager->Export(""output.gdml"","""",""vg""); //the same as previous just; options are set explicitly; gGeoManager->Export(""output.gdml"","""",""vgf"");; gGeoManager->Export(""output.gdml"","""",""gn"");; gGeoManager->Export(""output.gdml"","""",""f"");. NB:; Options discussed above are used only for TGDMLWrite class. There are; other options in the TGeoManager::Export(...) method that can be used.; See that function for details. Function Members (Methods); public:. TGDMLWrite(); TGDMLWrite(const TGDMLWrite&); virtual~TGDMLWrite(); voidTObject::AbstractMethod(const char* method) c",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:20210,Security,secur,secured,20210,"ML. XMLNodePointer_t ChooseObject(TGeoShape* geoShape); Chooses the object and method that should be used for processing object. TGeoCompositeShape* CreateFakeCtub(TGeoCtub* geoShape); Method creating cutTube as an intersection of tube and two boxes; - not used anymore because cutube is supported in Geant4 9.5. Bool_t IsInList(TGDMLWrite::NameList list, TString name2check); Checks whether name2check is in (NameList) list. TString GenName(TString oldname); NCNAME basic restrictions; Replace ""$"" character with empty character etc. TString GenName(TString oldname, TString objPointer); Important function which is responsible for naming volumes, solids and materials. Bool_t CanProcess(TObject* pointer); Method which tests whether solids can be processed. TString GetPattAxis(Int_t divAxis, const char* pattName, TString& unit); Method that retrieves axis and unit along which object is divided. Bool_t IsNullParam(Double_t parValue, TString parName, TString objName); Check for null parameter to skip the NULL objects. void UnsetTemporaryBits(TGeoManager* geoMng); Unsetting bits that were changed in gGeoManager during export so that export; can be run more times with the same instance of gGeoManager. TGDMLWrite(). void StartGDMLWriting(TGeoManager* geomanager, const char* filename, TString option); static function -; options:; g - set by default - geant4 compatibility; f,n - if none of this two is set then naming convention is; with incremental suffix, if ""f"" then suffix is pointer; if ""n"" then there is no suffix, but uniqness of names; is not secured. void SetG4Compatibility(Bool_t G4Compatible). Xyz GetXYZangles(const Double_t* rotationMatrix); II. Utility methods. » Author: Anton Pytel 15/9/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/gdml:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:8394,Testability,test,test,8394,"onst; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGDMLWrite&operator=(const TGDMLWrite&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetG4Compatibility(Bool_t G4Compatible); voidSetNamingSpeed(TGDMLWrite::ENamingType naming); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); static voidStartGDMLWriting(TGeoManager* geomanager, const char* filename, TString option); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidWriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:13738,Testability,test,test,13738,"inter mapped); Int_tfPhysVolCntcount of physical volumes; TGDMLWrite::StructLst*fRejShapelist of rejected shapes; UInt_tfSolCntcount of name solids; XMLNodePointer_tfSolidsNodemain <solids> node...; XMLNodePointer_tfStructureNodemain <structure> node...; TStringfTopVolumeNamename of top volume; Int_tfVolCntcount of volumes; Bool_tfgG4Compatibilityinput option for Geant4 compatibility; static TGDMLWrite*fgGDMLWritepointer to gdml writer; Int_tfgNamingSpeedinput option for volume and solid naming; static const UInt_tfgkMaxNameErrmaximum number of errors for naming; static const UInt_tfgkProcBit14th bit is set when solid is processed; static const UInt_tfgkProcBitVol19th bit is set when volume is processed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLWrite(); Default constructor. ~TGDMLWrite(); Destructor. void SetNamingSpeed(TGDMLWrite::ENamingType naming); Set convetion of naming solids and volumes. void WriteGDMLfile(TGeoManager* geomanager, const char* filename = ""test.gdml"", TString option = """"); Wrapper of all exporting methods; Creates blank GDML file and fills it with gGeoManager structure converted; to GDML structure of xml nodes. XMLNodePointer_t ExtractMaterials(TList* materialsLst); Method exporting materials. TString ExtractSolid(TGeoShape* volShape); Method creating solid to xml file and returning its name. void ExtractVolumes(TGeoVolume* volume); Method extracting geometry structure recursively. XMLNodePointer_t CreateAtomN(Double_t atom, const char* unit = ""g/mole""); Creates ""atom"" node for GDML. XMLNodePointer_t CreateDN(Double_t density, const char* unit = ""g/cm3""); Creates ""D"" density node for GDML. XMLNodePointer_t CreateFractionN(Double_t percentage, const char* refName); Creates ""fraction"" node for GDML. XMLNodePointer_t CreateIsotopN(TGeoIsotope* isotope, const char* name); Creates ""isotope"" node for GDML. XMLNodePointer_t CreateElementN(TGeoElement* element, XMLNodePointer_t materials, const ch",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDMLWrite.html:19372,Testability,test,tests,19372,"st char* volref, const char* posref, const char* rotref, XMLNodePointer_t scaleN); Creates ""physvol"" node for GDML. XMLNodePointer_t CreateDivisionN(Double_t offset, Double_t width, Int_t number, const char* axis, const char* unit, const char* volref); Creates ""divisionvol"" node for GDML. XMLNodePointer_t ChooseObject(TGeoShape* geoShape); Chooses the object and method that should be used for processing object. TGeoCompositeShape* CreateFakeCtub(TGeoCtub* geoShape); Method creating cutTube as an intersection of tube and two boxes; - not used anymore because cutube is supported in Geant4 9.5. Bool_t IsInList(TGDMLWrite::NameList list, TString name2check); Checks whether name2check is in (NameList) list. TString GenName(TString oldname); NCNAME basic restrictions; Replace ""$"" character with empty character etc. TString GenName(TString oldname, TString objPointer); Important function which is responsible for naming volumes, solids and materials. Bool_t CanProcess(TObject* pointer); Method which tests whether solids can be processed. TString GetPattAxis(Int_t divAxis, const char* pattName, TString& unit); Method that retrieves axis and unit along which object is divided. Bool_t IsNullParam(Double_t parValue, TString parName, TString objName); Check for null parameter to skip the NULL objects. void UnsetTemporaryBits(TGeoManager* geoMng); Unsetting bits that were changed in gGeoManager during export so that export; can be run more times with the same instance of gGeoManager. TGDMLWrite(). void StartGDMLWriting(TGeoManager* geomanager, const char* filename, TString option); static function -; options:; g - set by default - geant4 compatibility; f,n - if none of this two is set then naming convention is; with incremental suffix, if ""f"" then suffix is pointer; if ""n"" then there is no suffix, but uniqness of names; is not secured. void SetG4Compatibility(Bool_t G4Compatible). Xyz GetXYZangles(const Double_t* rotationMatrix); II. Utility methods. » Author: Anton Pytel 15/9/201",MatchSource.WIKI,root/html534/TGDMLWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDMLWrite.html
https://root.cern/root/html534/TGDNDManager.html:1477,Availability,error,error,1477,"ctMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDrag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Bool_tDrop(); virtual voidTObject::Dump() constMENU ; Bool_tEndDrag(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static Atom_tGetDNDActionAsk(); static Atom_tGetDNDActionCopy(); static Atom_tGetDNDActionDescrip(); static Atom_tGetDNDActionLink(); static Atom_tGetDNDActionList(); static Atom_tGetDNDActionMove(); static Atom_tGetDNDActionPrivate(); static Atom_tGetDNDAware(); static Atom_tGetDNDDrop(); static Atom_tGetDNDEnter(); static Atom_tGetDNDFinished(); static Atom_tGetDNDLeave(); static Atom_tGetDNDPosition(); static Atom_tGetDNDProxy(); static Atom_tGetDNDSelection(); static Atom_tGetDNDStatus(); static Atom_tGetDNDTypeList(); static Atom_tGetDNDVersion(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:1561,Availability,error,error,1561,"= """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDrag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Bool_tDrop(); virtual voidTObject::Dump() constMENU ; Bool_tEndDrag(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static Atom_tGetDNDActionAsk(); static Atom_tGetDNDActionCopy(); static Atom_tGetDNDActionDescrip(); static Atom_tGetDNDActionLink(); static Atom_tGetDNDActionList(); static Atom_tGetDNDActionMove(); static Atom_tGetDNDActionPrivate(); static Atom_tGetDNDAware(); static Atom_tGetDNDDrop(); static Atom_tGetDNDEnter(); static Atom_tGetDNDFinished(); static Atom_tGetDNDLeave(); static Atom_tGetDNDPosition(); static Atom_tGetDNDProxy(); static Atom_tGetDNDSelection(); static Atom_tGetDNDStatus(); static Atom_tGetDNDTypeList(); static Atom_tGetDNDVersion(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGFrame*GetMainFrame() const; v",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:4902,Availability,mask,mask,4902,"ar* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRemoveRootProxy(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMainFrame(TGFrame* main); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRootProxy(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); Bool_tStartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:7548,Availability,mask,mask,7548,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:11581,Availability,mask,mask,11581," to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start dragging. Bool_t Drop(); Drop. Bool_t EndDrag(); End dragging. Bool_t Drag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); Process drag event. Bool_t SetRootProxy(); Set root window proxy. Bool_t RemoveRootProxy(); Remove root window proxy. TDNDData& operator=(const TGDNDManager& ). TGDNDManager(const TGDNDManager& ). Bool_t IsTopLevel(Window_t win). TGFrame * GetMainFrame() const; --- called by widgets. { return fMain; }. void SetMainFrame(TGFrame* main); { fMain = main; }. Bool_t IsDragging() const; { return fDragging; }. Window_t GetSource() const; { return fSource; }. Window_t GetTarget() const; { return fTarget; }. Atom_t * GetTypeList() const; { return fTypelist; }. » Author: Bertrand Bellenot 19/04/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10267,Integrability,message,messages,10267,"gDNDStatus; }. Atom_t GetDNDDrop(); { return fgDNDDrop; }. Atom_t GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND s",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10380,Integrability,message,message,10380,"n(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target)",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10457,Integrability,message,message,10457,"nCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); H",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10587,Integrability,message,message,10587,"DNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void Set",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10681,Integrability,message,message,10681,"gDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t ",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10756,Integrability,message,message,10756,"DNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start ",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10836,Integrability,message,message,10836,"return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start dragging. Bool_t Drop(); Drop. Bool_t EndDrag(); End dragging. Bool_t Drag(In",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:7474,Safety,timeout,timeout,7474,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDNDManager.html:10320,Safety,timeout,timeout,10320,"GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp);",MatchSource.WIKI,root/html534/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDNDManager.html
https://root.cern/root/html534/TGDockableFrame.html:4760,Availability,error,error,4760,"am); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::",MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:4844,Availability,error,error,4844,"t char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; vir",MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:18112,Availability,mask,mask,18112,,MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:21236,Integrability,message,messages,21236,"efault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-20",MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:393,Usability,undo,undocked,393,". TGDockableFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockableFrame. class TGDockableFrame: public TGCompositeFrame, public TGWidget. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); virtual~TGDockableFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* hints); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::C",MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:18055,Usability,undo,undocked,18055,,MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:18212,Usability,undo,undocked,18212,,MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:21286,Usability,undo,undocking,21286,"lectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$",MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockableFrame.html:21426,Usability,undo,undock,21426,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }. » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-04-23 20:07; This page has been automatically generated. For comments or suggestions regarding t",MatchSource.WIKI,root/html534/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockableFrame.html
https://root.cern/root/html534/TGDockButton.html:4384,Availability,error,error,4384,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html534/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockButton.html
https://root.cern/root/html534/TGDockButton.html:4468,Availability,error,error,4468,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Optio",MatchSource.WIKI,root/html534/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockButton.html
https://root.cern/root/html534/TGDockButton.html:17331,Availability,mask,mask,17331,,MatchSource.WIKI,root/html534/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockButton.html
https://root.cern/root/html534/TGDockButton.html:18551,Availability,down,down,18551,HighColorhighlight color; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Bool_tfMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tfNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static con,MatchSource.WIKI,root/html534/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockButton.html
https://root.cern/root/html534/TGDockButton.html:19773,Deployability,release,released,19773, frame width; Bool_tfMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tfNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockButton.html
https://root.cern/root/html534/TGDockButton.html:359,Usability,undo,undocked,359,". TGDockButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockButton. class TGDockButton: public TGButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockButton(const TGCompositeFrame* p = 0, Int_t id = 1); virtual~TGDockButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal,",MatchSource.WIKI,root/html534/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockButton.html
https://root.cern/root/html534/TGDockHideButton.html:4387,Availability,error,error,4387,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html534/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockHideButton.html
https://root.cern/root/html534/TGDockHideButton.html:4471,Availability,error,error,4471,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Optio",MatchSource.WIKI,root/html534/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockHideButton.html
https://root.cern/root/html534/TGDockHideButton.html:17430,Availability,mask,mask,17430,,MatchSource.WIKI,root/html534/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockHideButton.html
https://root.cern/root/html534/TGDockHideButton.html:18692,Availability,down,down,18692,ndle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Bool_tTGDockButton::fMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tTGDockButton::fNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static con,MatchSource.WIKI,root/html534/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockHideButton.html
https://root.cern/root/html534/TGDockHideButton.html:19914,Deployability,release,released,19914,tton::fMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tTGDockButton::fNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockHideButton.html
https://root.cern/root/html534/TGDockHideButton.html:375,Usability,undo,undocked,375,". TGDockHideButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGDockHideButton. class TGDockHideButton: public TGDockButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockHideButton(const TGCompositeFrame* p = 0); ~TGDockHideButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* sign",MatchSource.WIKI,root/html534/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDockHideButton.html
https://root.cern/root/html534/TGDoubleHSlider.html:5340,Availability,error,error,5340,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html534/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleHSlider.html
https://root.cern/root/html534/TGDoubleHSlider.html:5424,Availability,error,error,5424,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html534/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleHSlider.html
https://root.cern/root/html534/TGDoubleHSlider.html:17561,Availability,mask,mask,17561,,MatchSource.WIKI,root/html534/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleHSlider.html
https://root.cern/root/html534/TGDoubleHSlider.html:18961,Availability,down,downright,18961,"t_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGDoubleSlider::fMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tTGDoubleSlider::fPoslogical position between fVmin and fVmax; Int_tTGDoubleSlider::fPressPointmouse position at button press event; Float_tTGDoubleSlider::fPressSmaxlogical max position at button press event; Float_tTGDoubleSlider::fPressSminlogical min position at button press event; Int_tTGDoubleSlider::fRelPosslider position in pixel coordinates; Bool_tTGDoubleSlider::fReversedScalereverse which end is min and max; Int_tTGDoubleSlider::fScaletick mark scale; Int_tTGDoubleSlider::fScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*TGDoubleSlider::fSliderPicpicture to draw slider ends; Float_tTGDoubleSlider::fSmaxlogical position of max value of Slider; Float_tTGDoubleSlider::fSminlogical position of min value of Slider; Float_tTGDoubleSlider::fVmaxlogical upper limit of slider; Float_tTGDoubleSlider::fVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tfXphorizontal slider x position in pixel coordinates; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTG",MatchSource.WIKI,root/html534/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleHSlider.html
https://root.cern/root/html534/TGDoubleSlider.html:1681,Availability,avail,available,1681,"nge the max value press the mouse near to the right / top; edge of the slider.; To change both values simultaneously press the mouse near to the; center of the slider. TGDoubleSlider is an abstract base class. Use the concrete; TGDoubleVSlider and TGDoubleHSlider. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POS, slider id, 0 (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Use the functions GetMinPosition(), GetMaxPosition() and; GetPosition() to retrieve the position of the slider. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGDoubleSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQ",MatchSource.WIKI,root/html534/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleSlider.html
https://root.cern/root/html534/TGDoubleSlider.html:5259,Availability,error,error,5259,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html534/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleSlider.html
https://root.cern/root/html534/TGDoubleSlider.html:5343,Availability,error,error,5343,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html534/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleSlider.html
https://root.cern/root/html534/TGDoubleSlider.html:17291,Availability,mask,mask,17291,,MatchSource.WIKI,root/html534/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleSlider.html
https://root.cern/root/html534/TGDoubleSlider.html:18531,Availability,down,downright,18531,"ls! list of signals from this object; Bool_tfMarkEndslines marking where stretch zones begin; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tfMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tfPoslogical position between fVmin and fVmax; Int_tfPressPointmouse position at button press event; Float_tfPressSmaxlogical max position at button press event; Float_tfPressSminlogical min position at button press event; Int_tfRelPosslider position in pixel coordinates; Bool_tfReversedScalereverse which end is min and max; Int_tfScaletick mark scale; Int_tfScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*fSliderPicpicture to draw slider ends; Float_tfSmaxlogical position of max value of Slider; Float_tfSminlogical position of min value of Slider; Float_tfVmaxlogical upper limit of slider; Float_tfVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFram",MatchSource.WIKI,root/html534/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleSlider.html
https://root.cern/root/html534/TGDoubleSlider.html:20173,Integrability,depend,depending,20173," for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FixBounds(Float_t& min, Float_t& max); Avoid boundaries to be equal. TString GetSString() const; Returns the slider type as a string - used in SavePrimitive(). void ChangeCursor(Event_t* event); Change the cursor shape depending on the slider area. TGDoubleSlider& operator=(const TGDoubleSlider& ). virtual ~TGDoubleSlider(); { }. Bool_t HandleButton(Event_t* event). Bool_t HandleMotion(Event_t* event). void SetScale(Int_t scale); { fScale = scale; }. void SetRange(Float_t min, Float_t max). void SetPosition(Float_t min, Float_t max). Float_t GetMinPosition() const. Float_t GetMaxPosition() const. void GetPosition(Float_t& min, Float_t& max) const. void GetPosition(Float_t* min, Float_t* max) const. void MapSubwindows(); { TGWindow::MapSubwindows(); }. void PositionChanged(); { Emit(""PositionChanged()""); }. void Pressed(); { Emit(""Pressed()""); }. void Released(); { Emit(""Released()""); }. » Author: Reiner Rohlfs 30/09/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-04 16:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root/html534/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleSlider.html
https://root.cern/root/html534/TGDoubleVSlider.html:5338,Availability,error,error,5338,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html534/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleVSlider.html
https://root.cern/root/html534/TGDoubleVSlider.html:5422,Availability,error,error,5422,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html534/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleVSlider.html
https://root.cern/root/html534/TGDoubleVSlider.html:17559,Availability,mask,mask,17559,,MatchSource.WIKI,root/html534/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleVSlider.html
https://root.cern/root/html534/TGDoubleVSlider.html:18959,Availability,down,downright,18959,"t_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGDoubleSlider::fMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tTGDoubleSlider::fPoslogical position between fVmin and fVmax; Int_tTGDoubleSlider::fPressPointmouse position at button press event; Float_tTGDoubleSlider::fPressSmaxlogical max position at button press event; Float_tTGDoubleSlider::fPressSminlogical min position at button press event; Int_tTGDoubleSlider::fRelPosslider position in pixel coordinates; Bool_tTGDoubleSlider::fReversedScalereverse which end is min and max; Int_tTGDoubleSlider::fScaletick mark scale; Int_tTGDoubleSlider::fScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*TGDoubleSlider::fSliderPicpicture to draw slider ends; Float_tTGDoubleSlider::fSmaxlogical position of max value of Slider; Float_tTGDoubleSlider::fSminlogical position of min value of Slider; Float_tTGDoubleSlider::fVmaxlogical upper limit of slider; Float_tTGDoubleSlider::fVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Int_tfYpvertical slider y position in pixel coordinates; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFr",MatchSource.WIKI,root/html534/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDoubleVSlider.html
https://root.cern/root/html534/TGDragWindow.html:459,Availability,mask,mask,459," TGDragWindow(const TGWindow* p, Pixmap_t pic, Pixmap_t mask, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); virtual~TGDragWindow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual",MatchSource.WIKI,root/html534/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDragWindow.html
https://root.cern/root/html534/TGDragWindow.html:4018,Availability,error,error,4018,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html534/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDragWindow.html
https://root.cern/root/html534/TGDragWindow.html:4102,Availability,error,error,4102,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static Long_tTO",MatchSource.WIKI,root/html534/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDragWindow.html
https://root.cern/root/html534/TGDragWindow.html:15146,Availability,mask,mask,15146,,MatchSource.WIKI,root/html534/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDragWindow.html
https://root.cern/root/html534/TGDragWindow.html:17083,Availability,mask,mask,17083,"or suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Cursor_tfgDefaultCursorDefault Cursor; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDragWindow(const TGWindow* p, Pixmap_t pic, Pixmap_t mask, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); TGDragWindow constructor. ~TGDragWindow(); TGDragWindow destructor. void MapWindow(); Map TGDragWindow. void UnmapWindow(); Unmap TGDragWindow. void RaiseWindow(); Raise TGDragWindow. void LowerWindow(); Lower TGDragWindow. void MapRaised(); Map and Raise TGDragWindow. void Layout(); Layout TGDragWindow. void DoRedraw(); Redraw TGDragWindow. TGDimension GetDefaultSize() const; { return TGDimension(fPw, fPh); }. Window_t GetInputId() const; { return fInput; }. Bool_t HasWindow(Window_t w) const; { return (w == fId || w == fInput); }. » Author: Bertrand Bellenot 19/04/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGDragWindow.html
https://root.cern/root/html534/TGedEditor.html:6571,Availability,error,error,6571,"ram); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtu",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:6655,Availability,error,error,6655," char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefau",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:22883,Availability,mask,mask,22883,,MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:23025,Availability,avail,available,23025,,MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:1394,Integrability,interface,interface,1394,"ts editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UI",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:26772,Integrability,depend,dependent,26772,"(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static TStringTVirtualPadEditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* ",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:1551,Performance,load,loaded,1551,"he; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:1595,Performance,cache,cached,1595," follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const ",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:9589,Performance,load,load,9589,"Name() const; const char*TGMainFrame::GetIconPixmap() const; Handle_tTGObject::GetId() const; virtual TGLayoutManager*TGCompositeFrame::GetLayoutManager() const; virtual TList*TGCompositeFrame::GetList() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const TGWindow*TGWindow::GetMainFrame() const; UInt_tTGFrame::GetMaxHeight() const; UInt_tTGFrame::GetMaxWidth() const; UInt_tTGFrame::GetMinHeight() const; UInt_tTGFrame::GetMinWidth() const; virtual TObject*GetModel() const; voidTGMainFrame::GetMWMHints(UInt_t& value, UInt_t& funcs, UInt_t& input) const; virtual const char*TGWindow::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; virtual TVirtualPad*GetPad() const; static TVirtualPadEditor*TVirtualPadEditor::GetPadEditor(Bool_t load = kTRUE); const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; TGTab*GetTab() const; TGCanvas*GetTGCanvas() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual voidGlobalClosed(); virtual voidGlobalSetModel(TVirtualPad*, TObject*, Int_t); virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual Bool_tTGMainFrame::H",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:617,Usability,simpl,simple,617,". TGedEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedEditor. class TGedEditor: public TVirtualPadEditor, public TGMainFrame. TGedEditor. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Member",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:950,Usability,simpl,simple,950,". TGedEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedEditor. class TGedEditor: public TVirtualPadEditor, public TGMainFrame. TGedEditor. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Member",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedEditor.html:26811,Usability,simpl,simply,26811,"ditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* obj, Int_t event); Activate object editors according to the selected object. void ",MatchSource.WIKI,root/html534/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedEditor.html
https://root.cern/root/html534/TGedFrame.html:491,Availability,avail,available,491,". TGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedFrame. class TGedFrame: public TGCompositeFrame. TGedFrame. Base frame for implementing GUI - a service class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidAddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root/html534/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedFrame.html
https://root.cern/root/html534/TGedFrame.html:4415,Availability,error,error,4415,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedFrame.html
https://root.cern/root/html534/TGedFrame.html:4499,Availability,error,error,4499,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedFrame.html
https://root.cern/root/html534/TGedFrame.html:17129,Availability,mask,mask,17129,,MatchSource.WIKI,root/html534/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedFrame.html
https://root.cern/root/html534/TGedMarkerPopup.html:494,Availability,down,down,494,". TGedMarkerPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerPopup. class TGedMarkerPopup: public TGedPopup. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); virtual~TGedMarkerPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, v",MatchSource.WIKI,root/html534/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerPopup.html
https://root.cern/root/html534/TGedMarkerPopup.html:4548,Availability,error,error,4548,"it(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerPopup.html
https://root.cern/root/html534/TGedMarkerPopup.html:4632,Availability,error,error,4632,"t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerPopup.html
https://root.cern/root/html534/TGedMarkerPopup.html:17035,Availability,mask,mask,17035,,MatchSource.WIKI,root/html534/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerPopup.html
https://root.cern/root/html534/TGedMarkerPopup.html:19382,Integrability,message,messages,19382,"Window*TGedPopup::fMsgWindow; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); Create marker popup window. ~TGedMarkerPopup(); Destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the marker popup window. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerPopup.html
https://root.cern/root/html534/TGedMarkerSelect.html:498,Availability,down,down,498,". TGedMarkerSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedMarkerSelect. class TGedMarkerSelect: public TGedSelect. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); virtual~TGedMarkerSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html534/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerSelect.html
https://root.cern/root/html534/TGedMarkerSelect.html:4585,Availability,error,error,4585,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html534/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerSelect.html
https://root.cern/root/html534/TGedMarkerSelect.html:4669,Availability,error,error,4669,"); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virt",MatchSource.WIKI,root/html534/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerSelect.html
https://root.cern/root/html534/TGedMarkerSelect.html:19499,Availability,mask,mask,19499,,MatchSource.WIKI,root/html534/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerSelect.html
https://root.cern/root/html534/TGedMarkerSelect.html:21399,Availability,down,down,21399,ame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; const TGPicture*fPictureimage used for popup window; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html534/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerSelect.html
https://root.cern/root/html534/TGedMarkerSelect.html:22901,Deployability,release,released,22901,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerSelect.html
https://root.cern/root/html534/TGedMarkerSelect.html:23334,Integrability,message,messages,23334,"unter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); Create and show marker popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages according to the user input. void DoRedraw(); Draw selected marker type as current one. void SetMarkerStyle(Style_t pattern); Set marker. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. virtual ~TGedMarkerSelect(); { if(fPicture) gClient->FreePicture(fPicture);}. Style_t GetMarkerStyle() const; { return fMarkerStyle; }. void MarkerSelected(Style_t marker = 0); { Emit(""MarkerSelected(Style_t)"", marker ? marker : GetMarkerStyle()); }. TGDimension GetDefaultSize() const; { return TGDimension(38, 21); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedMarkerSelect.html
https://root.cern/root/html534/TGedNameFrame.html:4461,Availability,error,error,4461,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedNameFrame.html
https://root.cern/root/html534/TGedNameFrame.html:4545,Availability,error,error,4545,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedNameFrame.html
https://root.cern/root/html534/TGedNameFrame.html:17386,Availability,mask,mask,17386,,MatchSource.WIKI,root/html534/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedNameFrame.html
https://root.cern/root/html534/TGedPatternFrame.html:710,Availability,down,down,710,". TGedPatternFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternFrame. class TGedPatternFrame: public TGFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternFrame(const TGWindow* p, Style_t pattern, Int_t width = 40, Int_t height = 20); virtual~TGedPatternFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls);",MatchSource.WIKI,root/html534/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternFrame.html
https://root.cern/root/html534/TGedPatternFrame.html:4643,Availability,error,error,4643,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html534/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternFrame.html
https://root.cern/root/html534/TGedPatternFrame.html:4727,Availability,error,error,4727,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static",MatchSource.WIKI,root/html534/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternFrame.html
https://root.cern/root/html534/TGedPatternFrame.html:15886,Availability,mask,mask,15886,,MatchSource.WIKI,root/html534/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternFrame.html
https://root.cern/root/html534/TGedPatternPopup.html:712,Availability,down,down,712,". TGedPatternPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternPopup. class TGedPatternPopup: public TGedPopup. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); virtual~TGedPatternPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Clea",MatchSource.WIKI,root/html534/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternPopup.html
https://root.cern/root/html534/TGedPatternPopup.html:4858,Availability,error,error,4858,"it(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternPopup.html
https://root.cern/root/html534/TGedPatternPopup.html:4942,Availability,error,error,4942,"t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternPopup.html
https://root.cern/root/html534/TGedPatternPopup.html:17323,Availability,mask,mask,17323,,MatchSource.WIKI,root/html534/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternPopup.html
https://root.cern/root/html534/TGedPatternPopup.html:19691,Integrability,message,messages,19691,"fMsgWindow; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); Pattern popup constructor. ~TGedPatternPopup(); Destructor of pattern popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by pattern popup window. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternPopup.html
https://root.cern/root/html534/TGedPatternSelect.html:716,Availability,down,down,716,". TGedPatternSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelect. class TGedPatternSelect: public TGedSelect. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); virtual~TGedPatternSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* =",MatchSource.WIKI,root/html534/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelect.html
https://root.cern/root/html534/TGedPatternSelect.html:4895,Availability,error,error,4895,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html534/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelect.html
https://root.cern/root/html534/TGedPatternSelect.html:4979,Availability,error,error,4979,"); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virt",MatchSource.WIKI,root/html534/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelect.html
https://root.cern/root/html534/TGedPatternSelect.html:19824,Availability,mask,mask,19824,,MatchSource.WIKI,root/html534/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelect.html
https://root.cern/root/html534/TGedPatternSelect.html:21655,Availability,down,down,21655,Widthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Style_tfPattern; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html534/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelect.html
https://root.cern/root/html534/TGedPatternSelect.html:23157,Deployability,release,released,23157,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelect.html
https://root.cern/root/html534/TGedPatternSelect.html:23591,Integrability,message,message,23591,"el; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); Create and pop up pattern select window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message according to the user input. void DoRedraw(); Draw selected pattern as current one. void SetPattern(Style_t pattern, Bool_t emit = kTRUE); Set pattern. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. Style_t GetPattern() const; { return fPattern; }. virtual ~TGedPatternSelect(); {}. TGDimension GetDefaultSize() const; { return TGDimension(55, 21); }. void PatternSelected(Style_t pattern = 0); { Emit(""PatternSelected(Style_t)"", pattern ? pattern : GetPattern()); }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelect.html
https://root.cern/root/html534/TGedPatternSelector.html:728,Availability,down,down,728,". TGedPatternSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPatternSelector. class TGedPatternSelector: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelector(const TGWindow* p); virtual~TGedPatternSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual",MatchSource.WIKI,root/html534/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelector.html
https://root.cern/root/html534/TGedPatternSelector.html:4817,Availability,error,error,4817,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::",MatchSource.WIKI,root/html534/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelector.html
https://root.cern/root/html534/TGedPatternSelector.html:4901,Availability,error,error,4901,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_t",MatchSource.WIKI,root/html534/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelector.html
https://root.cern/root/html534/TGedPatternSelector.html:17286,Availability,mask,mask,17286,,MatchSource.WIKI,root/html534/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelector.html
https://root.cern/root/html534/TGedPatternSelector.html:19669,Integrability,message,message,19669,"Cleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelector(const TGWindow* p); Create pattern popup window. ~TGedPatternSelector(); Delete pattern popup window. void SetActive(Int_t newat); Set selected the current style. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message generated by pattern popup window. Int_t GetActive() const; { return fActive; }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPatternSelector.html
https://root.cern/root/html534/TGedPopup.html:698,Availability,down,down,698,". TGedPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedPopup. class TGedPopup: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGedPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root/html534/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPopup.html
https://root.cern/root/html534/TGedPopup.html:4886,Availability,error,error,4886,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPopup.html
https://root.cern/root/html534/TGedPopup.html:4970,Availability,error,error,4970,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPopup.html
https://root.cern/root/html534/TGedPopup.html:17305,Availability,mask,mask,17305,,MatchSource.WIKI,root/html534/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPopup.html
https://root.cern/root/html534/TGedPopup.html:19894,Integrability,message,messages,19894,"nst TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a popup frame. void EndPopup(); Ungrab pointer and unmap popup window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Place popup window at the specified place. Bool_t HandleButton(Event_t* event); Handle mouse button event in popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by popup window. virtual ~TGedPopup(); { }. » Author: Marek Biskup, Ilka Antcheva 24/07/03 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedPopup.html
https://root.cern/root/html534/TGedSelect.html:698,Availability,down,down,698,". TGedSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TGedSelect. class TGedSelect: public TGCheckButton. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedSelect(const TGWindow* p, Int_t id); virtual~TGedSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; vir",MatchSource.WIKI,root/html534/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedSelect.html
https://root.cern/root/html534/TGedSelect.html:4822,Availability,error,error,4822,"t::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html534/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedSelect.html
https://root.cern/root/html534/TGedSelect.html:4906,Availability,error,error,4906,"Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCheckButton::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidt",MatchSource.WIKI,root/html534/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedSelect.html
https://root.cern/root/html534/TGedSelect.html:19595,Availability,mask,mask,19595,,MatchSource.WIKI,root/html534/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedSelect.html
https://root.cern/root/html534/TGedSelect.html:21397,Availability,down,down,21397,e height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGedPopup*fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html534/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedSelect.html
https://root.cern/root/html534/TGedSelect.html:22899,Deployability,release,released,22899,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGedSelect.html
https://root.cern/root/html534/TGenCollectionProxy.html:4311,Energy Efficiency,allocate,allocate,4311,"unctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allo",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:9368,Energy Efficiency,allocate,allocated,9368,"of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void **dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If ",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:9865,Energy Efficiency,allocate,allocated,9865,"tWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void **dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); typedef void (*DeleteIterator_t)(void *iter);; typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; If the size of the iterator is greater than fgIteratorArenaSize, call d",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:3964,Performance,cache,cache,3964,"virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionPro",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:6640,Safety,avoid,avoid,6640," of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). Method & operator=(const TGenCollectionProxy& ); { call = m.call; return *this; }. void Resize(size_t nelement). TGenCollectionProxy* Initialize(Bool_t silent) const; Late initialization of collection proxy. TGenCollectionProxy* InitializeEx(Bool_t silent); Some hack to avoid const-ness. void CheckFunctions() const; Allow to check function pointers. TGenCollectionProxy(). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TGenCollectionProxy(const TGenCollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass() const; Return a pointer to the TClass representing the container. Int_t GetCollectionType() const; Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement() const; Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:489,Security,access,access,489,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE)",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:3984,Security,access,accessors,3984,"virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionPro",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:4092,Security,access,accessors,4092,"virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionPro",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:4368,Security,access,accessors,4368,"enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContaine",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:4500,Security,access,accessors,4500,"enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContaine",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:4566,Security,access,accessors,4566,"enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContaine",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:4900,Security,access,accessors,4900,"::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). Method & operator=(const TGenCo",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:5498,Security,access,accessors,5498,"::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). Method & operator=(const TGenCo",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:5601,Security,access,accessors,5601,"::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type; TStreamerInfoActions::TActionSequence*fWriteMemberWise. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). Method & operator=(const TGenCo",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:629,Usability,clear,clear,629,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE)",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:3995,Usability,clear,clear,3995,"virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionPro",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy.html:7866,Usability,simpl,simple,7866,"y constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass() const; Return a pointer to the TClass representing the container. Int_t GetCollectionType() const; Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement() const; Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. void SetValueClass(TClass* newcl); Set pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void operator()(TBuffer& refBuffer, void* pObject); TClassStreamer I/O overload. void ReadBuffer(TBuffer& b, void* obj); Routine to read the content of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bo",MatchSource.WIKI,root/html534/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html
https://root.cern/root/html534/TGenCollectionProxy__Method.html:481,Security,access,access,481,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method& m). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. Method & operator=(const TGenCollectionProxy::Method& m); { call = m.call; return *this; }. void* invoke(void* obj) const; { return (*call)(obj); }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy__Method.html
https://root.cern/root/html534/TGenCollectionProxy__Method.html:621,Usability,clear,clear,621,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method& m). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. Method & operator=(const TGenCollectionProxy::Method& m); { call = m.call; return *this; }. void* invoke(void* obj) const; { return (*call)(obj); }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy__Method.html
https://root.cern/root/html534/TGenCollectionProxy__Value.html:1050,Performance,cache,cache,1050,"eader file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). Method & operator=(const TGenCollectionProxy::Value& ); { call = m.call; return *this; }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy__Value.html
https://root.cern/root/html534/TGenCollectionProxy__Value.html:1102,Performance,cache,cache,1102,"eader file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). Method & operator=(const TGenCollectionProxy::Value& ); { call = m.call; return *this; }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy__Value.html
https://root.cern/root/html534/TGenCollectionProxy__Value.html:1147,Performance,cache,cache,1147,"eader file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). Method & operator=(const TGenCollectionProxy::Value& ); { call = m.call; return *this; }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy__Value.html
https://root.cern/root/html534/TGenCollectionProxy__Value.html:478,Security,access,access,478,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). Method & operator=(const TGenCollectionProxy::Value& ); { call = m.call; return *this; }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For c",MatchSource.WIKI,root/html534/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy__Value.html
https://root.cern/root/html534/TGenCollectionProxy__Value.html:618,Usability,clear,clear,618,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const string& info, Bool_t silent); Default copy constructor has the correct implementation.; Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). Method & operator=(const TGenCollectionProxy::Value& ); { call = m.call; return *this; }. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For c",MatchSource.WIKI,root/html534/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy__Value.html
https://root.cern/root/html534/TGenerator.html:4637,Availability,error,error,4637,,MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:4721,Availability,error,error,4721,"""); virtual~TGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerateEvent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjArray*GetListOfParticles() const; virtual const char*TNamed::GetName() const; Int_tGetNumberOfParticles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetParameter(const char*) const; virtual TParticle*GetParticle(Int_t i) const; virtual TObjArray*GetPrimaries(Option_t* option = """"); Float_tGetPtCut() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqu",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:341,Integrability,interface,interface,341,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various; event generators. Every event generator should inherit from; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgI",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:1748,Integrability,interface,interfaces,1748,"Particles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerat",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:10244,Integrability,rout,routine,10244,"ts { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TObjArray*fParticles->static container of the primary particles; Float_tfPtCut!Pt cut. Do not show primaries below; Bool_tfShowNeutrons!display neutrons if true; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenerator(const char* name, const char* title = ""Generator class""); Event generator default constructor. ~TGenerator(); Event generator default destructor. void GenerateEvent(); must be implemented in concrete class (see eg TPythia6). TObjArray* ImportParticles(Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The default action is to store only the stable particles (ISTHEP =; 1) This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles. The default; action is to store only the stable particles (ISTHEP = 1) This can; be demanded explicitly by setting the option = ""Final"" If the; option = ""All"", all the particles are stored. void Browse(TBrowser* b); browse generator. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*Compute distance from point px,py to objects in event; *-* =============",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:10707,Integrability,rout,routine,10707,"eobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenerator(const char* name, const char* title = ""Generator class""); Event generator default constructor. ~TGenerator(); Event generator default destructor. void GenerateEvent(); must be implemented in concrete class (see eg TPythia6). TObjArray* ImportParticles(Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The default action is to store only the stable particles (ISTHEP =; 1) This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles. The default; action is to store only the stable particles (ISTHEP = 1) This can; be demanded explicitly by setting the option = ""Final"" If the; option = ""All"", all the particles are stored. void Browse(TBrowser* b); browse generator. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*Compute distance from point px,py to objects in event; *-* =====================================================; -. void Draw(Option_t* option = """"). Insert one event in the pad list. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================. Int_t GetNumberOfParticles() const; Return the number of particles in the stack. TParticle * GetParticle(Int_t i) const; Returns pointer to primary number i;. void Paint(Option_t* option = """"). ",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:418,Modifiability,inherit,inherit,418,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various; event generators. Every event generator should inherit from; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgI",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:2634,Performance,load,loaded,2634,"meter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially useful for example with TVirtualMC or similar. Function Members (Methods); public:. T",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:2593,Safety,safe,safe,2593,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenerator.html:2552,Security,access,accessing,2552,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html534/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenerator.html
https://root.cern/root/html534/TGenericTable.html:4959,Availability,error,error,4959,"ed) const; Int_tTTable::CopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorend(); TGenericTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:5043,Availability,error,error,5043,"stRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorend(); TGenericTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:16782,Energy Efficiency,allocate,allocated,16782,"st char*TTable::fgTypeName[13]. protected:. TTableDescriptor*fColDescriptors; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; Long_tTTable::fMaxIndexThe used capacity of this array; Int_tTTable::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:17017,Energy Efficiency,allocate,allocated,17017,"::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTab",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:17239,Energy Efficiency,allocate,allocated,17239,"f (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. T",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:17452,Energy Efficiency,allocate,allocated,17452,"ricTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < G",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:17683,Energy Efficiency,allocate,allocated,17683," Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator b",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:2088,Modifiability,variab,variable,2088,"the generic table for 1000 rows (it may grow then); ! TGenericTable *allStaff = new TGenericTable(""staff_t"",""Staff-data"",1000);; !; ! // Fill the memory resident table; ! while (fgets(&line,80,fp)) {; ! sscanf(&line[0] ,""%d%d%d%d"", &staff.cat,&staff.division,&staff.flag,&staff.age);; ! sscanf(&line[13],""%d%d%d%d"", &staff.service,&staff.children,&staff.grade,&staff.step);; ! sscanf(&line[24],""%d%d%d"", &staff.nation,&staff.hrweek,&staff.cost);; ! allStaff->AddAt(&staff);; ! }; ! fclose(fp);; ! // Delete unused space;; ! allStaff->Purge();; !; ! allStaff->Print(0,10);; !; !// Create ROOT file; ! TFile *f = new TFile(""aptuple.root"",""RECREATE"");; ! allStaff->Write();; ! f->Write();; !; ! // We should close TFile otherwise all histograms we create below; ! // may be written to the file too occasionaly; ! f->Close();; !; !// Create ROOT Browser; ! new TBrowser(""staff"",allStaff);; !; !// Create couple of the histograms; ! TCanvas *canva = new TCanvas(""Staff"",""CERN Population"",600,600);; ! canva->Divide(1,2);; !; !; !// one can use 2 meta variable:; !// n$ - the total number of the rows in the table; !// i$ - stands for the current row index i = [0 -> (n$-1)]; !; ! gStyle->SetHistFillColor(10);; ! gStyle->SetHistFillStyle(3013);; ! canva->cd(1);; ! allStaff->Draw(""age"");; ! canva->Update();; ! canva->cd(2);; ! allStaff->Draw(""cost"");; ! canva->Update();; !}. Function Members (Methods); public:. TGenericTable(); TGenericTable(const TGenericTable&); TGenericTable(const char* structName, const char* name); TGenericTable(const char* structName, Int_t n); TGenericTable(const TTableDescriptor& dsc, const char* name); TGenericTable(const TTableDescriptor& dsc, Int_t n); TGenericTable(const char* structName, const char* name, Int_t n); TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n); virtual~TGenericTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tTTable::AddAt(const void* c); virtual void",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:18391,Testability,assert,assert,18391,"by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*this, *GetTable(0)):end();}. iterator end(); { return ((const TGenericTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*this, *GetTable(i)):iterator(*this);}. » Last changed: root/table:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenericTable.html:18489,Testability,assert,assert,18489,"by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*this, *GetTable(0)):end();}. iterator end(); { return ((const TGenericTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*this, *GetTable(i)):iterator(*this);}. » Last changed: root/table:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenericTable.html
https://root.cern/root/html534/TGenPhaseSpace.html:1873,Availability,error,error,1873,"enPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGenerate(); TLorentzVector*GetDecay(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWtMax() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html534/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html
https://root.cern/root/html534/TGenPhaseSpace.html:1957,Availability,error,error,1957," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGenerate(); TLorentzVector*GetDecay(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWtMax() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char",MatchSource.WIKI,root/html534/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html
https://root.cern/root/html534/TGenPhaseSpace.html:400,Energy Efficiency,energy,energy,400,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. TGenPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEven",MatchSource.WIKI,root/html534/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html
https://root.cern/root/html534/TGenPhaseSpace.html:6109,Energy Efficiency,energy,energy,6109,"od, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. TGenPhaseSpace& operator=(const TGenPhaseSpace& gen); Assignment operator. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass:",MatchSource.WIKI,root/html534/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html
https://root.cern/root/html534/TGenPhaseSpace.html:7114,Energy Efficiency,energy,energy,7114,"le_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. TGenPhaseSpace& operator=(const TGenPhaseSpace& gen); Assignment operator. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section; ""Fermi"" -> Fermi energy dependece; return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics. TGenPhaseSpace(); {}. virtual ~TGenPhaseSpace(); {}. Int_t GetNt() const; { return fNt;}. Double_t GetWtMax() const; { return fWtMax;}. » Last changed: root/physics:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html
https://root.cern/root/html534/TGenPhaseSpace.html:407,Integrability,depend,dependence,407,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. TGenPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEven",MatchSource.WIKI,root/html534/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html
https://root.cern/root/html534/TGenPhaseSpace.html:7121,Integrability,depend,dependece,7121,"le_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. TGenPhaseSpace& operator=(const TGenPhaseSpace& gen); Assignment operator. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section; ""Fermi"" -> Fermi energy dependece; return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics. TGenPhaseSpace(); {}. virtual ~TGenPhaseSpace(); {}. Int_t GetNt() const; { return fNt;}. Double_t GetWtMax() const; { return fWtMax;}. » Last changed: root/physics:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGenPhaseSpace.html
https://root.cern/root/html534/TGeoArb8.html:4235,Availability,error,error,4235,"act = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() ",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:4319,Availability,error,error,4319,"stFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetAr",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:3008,Safety,safe,safe,3008,"dData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidComputeTwist(); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; vi",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:3291,Safety,safe,safe,3291," norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidComputeTwist(); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, T",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:9504,Safety,safe,safe,9504,"uble_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const c",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:15598,Safety,safe,safe,15598,"anti-clockwise. Double_t GetTwist(Int_t iseg) const; Get twist for segment I in range [0,3]. Double_t GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Doubl",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:15805,Safety,safe,safe,15805,"he quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface o",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:17390,Safety,safe,safety,17390,"e_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t InsidePolygon(Double_t x, Double_t y, Double_t* pts); Finds if a point in XY plane is inside the polygon defines by PTS. void InspectShape() const; Prints shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. Double_t SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; Estimate safety to lateral plane defined by segment iseg in range [0,3]; Might be negative: plane seen only from inside. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPlaneVertices(Double_t zpl, Double_t* vertices) const; Computes intersection points between plane at zpl and non-horizontal edges. void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = x0; param[2] = y0. void SetPoints(Double_t* points) const; Creates arb8 mesh points. void SetPoints(Float_t* points) const; Creates arb8 mesh points. void SetVertex(Int_t vnum, Double_t x, Double_t y); Set values for a given vertex. void Sizeof3D() const; Fill size of this 3-D object. void Streamer(TBuffer& ); Stream an object of class TGeoManager. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Outpu",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:19255,Safety,safe,safe,19255,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:19291,Safety,safe,safe,19291,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &fXY[0][0];}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsSamePoint(const Double_t* p1, const Double_t* p2); {return (TMath::Abs(p1[0]-p2[0])<1.E-16 && TMath::Abs(p1[1]-p2[1])<1.E-16)?kTRUE:kFALSE;}. Bool_t IsTwisted() const; {return (fTwist==0)?kFALSE:kTRUE;}. void SetDz(Double_t dz); {fDz = dz;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoArb8.html:1801,Testability,test,testNo,1801," TGeoArb8(); TGeoArb8(Double_t dz, Double_t* vertices = 0); TGeoArb8(const char* name, Double_t dz, Double_t* vertices = 0); virtual~TGeoArb8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::C",MatchSource.WIKI,root/html534/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoArb8.html
https://root.cern/root/html534/TGeoAtt.html:3143,Performance,optimiz,optimization,3143,"{ kUseBoundingBox; kUseVoxels; kUseGsord; };; enum EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. UInt_tfGeoAttoption flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoAtt(); Default constructor. TGeoAtt(Option_t* vis_opt, Option_t* activity_opt = """", Option_t* optimization_opt = """"); Constructor. ~TGeoAtt(); Destructor. void SetVisBranch(); Set branch type visibility. void SetVisContainers(Bool_t flag = kTRUE); Set branch type visibility. void SetVisLeaves(Bool_t flag = kTRUE); Set branch type visibility. void SetVisOnly(Bool_t flag = kTRUE); Set branch type visibility. void SetVisibility(Bool_t vis = kTRUE); Set visibility for this object. void SetVisDaughters(Bool_t vis = kTRUE); Set visibility for the daughters. void SetVisStreamed(Bool_t vis = kTRUE); Mark attributes as ""streamed to file"". void SetVisTouched(Bool_t vis = kTRUE); Mark visualization attributes as ""modified"". void SetOptimization(Option_t* option); Set optimization flags. TGeoAtt(); constructors. void SetAttBit(UInt_t f); methods. {fGeoAtt |= f & kBitMask;}. void SetAttBit(UInt_t f, Bool_t set); {(set)?SetAttBit(f):ResetAttBit(f);}. void ResetAttBit(UInt_t f); {fGeoAtt &= ~(f & kBitMask);}. Bool_t TestAttBit(UInt_t f) const; {return (Bool_t)((fGeoAtt & f) != 0);}. void SetVisRaytrace(Bool_t flag = kTRUE); {SetAttBit(kVisRaytrace, flag);}. void SetActivity(Bool_t flag = kTRUE); {SetAttBit(kActThis, flag);}. void SetActiveDaughters(Bool_t flag = kTRUE); {SetAttBit(kActDaughters,flag);}. Bool_t IsActive() const; {return TestAttBit(kActThis);}. Bool_t IsActiveDaughters() const; {return TestAttBit(kActDaughters);}. Bool_t IsVisRaytrace() const; {return TestAttBit(kVisRaytrace);}. Bool_t IsVisible() const; {return TestAttBit(kVisThis);}. Bool_t IsVisDaughters() const; {return TestAttBit(kVisDaughters);}. Bool_t IsVisBranch() const; {return TestAttBit(kVisBranch);}. Bool_t IsVisContainers() const; {return TestAttBit(kVisContain",MatchSource.WIKI,root/html534/TGeoAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoAtt.html
https://root.cern/root/html534/TGeoBatemanSol.html:1849,Availability,error,error,1849,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tConcentration(Double_t time) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindSolution(const TObjArray* array); voidGetCoeff(Int_t i, Double_t& cn, Double_t& lambda) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElementRN*GetElement() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMark",MatchSource.WIKI,root/html534/TGeoBatemanSol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBatemanSol.html
https://root.cern/root/html534/TGeoBatemanSol.html:1933,Availability,error,error,1933,"owser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tConcentration(Double_t time) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindSolution(const TObjArray* array); voidGetCoeff(Int_t i, Double_t& cn, Double_t& lambda) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElementRN*GetElement() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; Int_tGetNcoeff() const",MatchSource.WIKI,root/html534/TGeoBatemanSol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBatemanSol.html
https://root.cern/root/html534/TGeoBBox.html:5448,Availability,error,error,5448,"_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoM",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:5532,Availability,error,error,5532,"dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObj",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:330,Modifiability,inherit,inherit,330,". TGeoBBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoBBox. class TGeoBBox: public TGeoShape. TGeoBBox - box class. All shape primitives inherit from this, their; constructor filling automatically the parameters of the box that bounds; the given shape. Defined by 6 parameters :; fDX, fDY, fDZ - half lengths on X, Y and Z axis; fOrigin[3] - position of box origin. --- Building boxes. Normally a box has to be build only with 3 parameters : dx, dy, dz; representing the half lengths on X, Y and Z axis. In this case, the origin; of the box will match the one of its reference frame. The translation of the; origin is used only by the constructors of all other shapes in order to; define their own bounding boxes. Users should be aware that building a; translated box that will represent a physical shape by itself will affect any; further positioning of other shapes inside. Therefore in order to build a; positioned box one should follow the recipe described in class TGeoNode. Creation of boxes; 1. TGeoBBox *box = new TGeoBBox(""BOX"", 20, 30, 40);. /*. */. 2. A volume having a box shape can be built in one step:; TGeoVolume *vbox = gGeoManager->MakeBox(""vbox"", ptrMed, 20,30,40);. Divisions of boxes. Volumes having box shape can be divided with equal-length slices on; X, Y or Z axis. The following options are supported:; a) Dividing the full range of one axis in N slices; TGeoVolume *divx = vbox->Divide(""SLICEX"", 1, N);; - here 1 stands for the division axis (1-X, 2-Y, 3-Z). /*. */. b) Dividing in a limited range - general case.; TGeoVolume *divy = vbox->Divide(""SLICEY"",2,N,start,step);; - start = starting offset within (-fDY, fDY); - step = slicing step. /*. */. Both cases are supported by all shapes.; See also class TGeoShape for utility methods provided by any particular; shape. Function ",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:3963,Safety,safe,safe,3963,") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* vo",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:4421,Safety,safe,safe,4421,"e_t dz, const Double_t* origin); virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, con",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:10243,Safety,safe,safe,10243,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoBBox&operator=(const TGeoBBox&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidSetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points)",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:15884,Safety,safe,safe,15884," if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& ",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:15969,Safety,safe,safe,15969,"istance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector para",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:16222,Safety,safe,safe,16222,", from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:16367,Safety,safe,safe,16367,"on axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) co",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:16453,Safety,safe,safe,16453," do in this case. Bool_t Contains(const Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Static method to check if point[3] is located inside a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided w",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:16708,Safety,safe,safe,16708," a box of having dx, dy, dz; as half-lengths. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n ran",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:20917,Safety,safe,safe,20917,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:20953,Safety,safe,safe,20953,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoBBox(); constructors. Int_t GetByteCount() const; {return 36;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetDX() const; {return fDX;}. Double_t GetDY() const; {return fDY;}. Double_t GetDZ() const; {return fDZ;}. const Double_t * GetOrigin() const; {return fOrigin;}. Bool_t IsCylType() const; {return kFALSE;}. Bool_t IsValidBox() const; {return ((fDX<0)||(fDY<0)||(fDZ<0))?kFALSE:kTRUE;}. Bool_t IsNullBox() const; {return ((fDX<1.E-16)&&(fDY<1.E-16)&&(fDZ<1.E-16))?kTRUE:kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBox.html:2687,Testability,test,testNo,2687,,MatchSource.WIKI,root/html534/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBox.html
https://root.cern/root/html534/TGeoBBoxEditor.html:4607,Availability,error,error,4607,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBoxEditor.html
https://root.cern/root/html534/TGeoBBoxEditor.html:4691,Availability,error,error,4691,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBoxEditor.html
https://root.cern/root/html534/TGeoBBoxEditor.html:18037,Availability,mask,mask,18037,,MatchSource.WIKI,root/html534/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBoxEditor.html
https://root.cern/root/html534/TGeoBBoxEditor.html:21445,Usability,undo,undoing,21445,"lag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBBoxEditor.html
https://root.cern/root/html534/TGeoBoolNode.html:1341,Availability,avail,available,1341,"n operations between two shapes. A Boolean node describes a Boolean operation between 'left' and 'right'; shapes positioned with respect to an ARBITRARY reference frame. The boolean; node is referenced by a mother composite shape and its shape components may; be primitive but also composite shapes. The later situation leads to a binary; tree hierarchy. When the parent composite shape is used to create a volume,; the reference frame of the volume is chosen to match the frame in which; node shape components were defined. The positioned shape components may or may not be disjoint. The specific; implementations for Boolean nodes are:. TGeoUnion - representing the Boolean union of two positioned shapes. TGeoSubtraction - representing the Boolean subtraction of two positioned; shapes. TGeoIntersection - representing the Boolean intersection of two positioned; shapes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(c",MatchSource.WIKI,root/html534/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html
https://root.cern/root/html534/TGeoBoolNode.html:2932,Availability,error,error,2932,"ble_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*GetRightMatrix() const; TGeoShape*GetRightShape() const; TGeoBoolNode::ThreadData_t&GetThreadData() const; virtual const char*TObject::GetTitle() co",MatchSource.WIKI,root/html534/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html
https://root.cern/root/html534/TGeoBoolNode.html:3016,Availability,error,error,3016,"ble_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*GetRightMatrix() const; TGeoShape*GetRightShape() const; TGeoBoolNode::ThreadData_t&GetThreadData() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(",MatchSource.WIKI,root/html534/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html
https://root.cern/root/html534/TGeoBoolNode.html:2422,Safety,safe,safe,2422,"od(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root/html534/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html
https://root.cern/root/html534/TGeoBoolNode.html:2560,Safety,safe,safe,2560,"ss*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtua",MatchSource.WIKI,root/html534/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html
https://root.cern/root/html534/TGeoBoolNode.html:9525,Safety,safe,safe,9525,"turns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. Bool_t ReplaceMatrix(TGeoMatrix* mat, TGeoMatrix* newmat); Replace one of the matrices. Does not work with TGeoIdentity. Returns true; if replacement was successful. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. ThreadData_t& GetThreadData() const. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). Bool_t Contains(const Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. TGeoBoolNode * MakeClone() const. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html
https://root.cern/root/html534/TGeoBoolNode.html:10034,Safety,safe,safe,10034,"turns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. Bool_t ReplaceMatrix(TGeoMatrix* mat, TGeoMatrix* newmat); Replace one of the matrices. Does not work with TGeoIdentity. Returns true; if replacement was successful. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. ThreadData_t& GetThreadData() const. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). Bool_t Contains(const Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. TGeoBoolNode * MakeClone() const. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBoolNode.html
https://root.cern/root/html534/TGeoBranchArray.html:1908,Availability,error,error,1908," """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCopyTo(TGeoBranchArray* dest); size_tDataSize() const; void*DataStart() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoNode**GetArray() const; TGeoNode*GetCurrentNode() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; size_tGetLevel() const; const TGeoHMatrix*GetMatrix() const; size_tGetMaxLevel() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(Int_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virt",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:1992,Availability,error,error,1992,"nchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCopyTo(TGeoBranchArray* dest); size_tDataSize() const; void*DataStart() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoNode**GetArray() const; TGeoNode*GetCurrentNode() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; size_tGetLevel() const; const TGeoHMatrix*GetMatrix() const; size_tGetMaxLevel() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(Int_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const;",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:5866,Availability,down,down,5866,"size_t sz, void* vp); Bool_toperator!=(const TGeoBranchArray& other) const; Bool_toperator<(const TGeoBranchArray& other) const; Bool_toperator<=(const TGeoBranchArray& other) const; TGeoBranchArray&operator=(const TGeoBranchArray&); Bool_toperator==(const TGeoBranchArray& other) const; Bool_toperator>(const TGeoBranchArray& other) const; Bool_toperator>=(const TGeoBranchArray& other) const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static voidReleaseInstance(TGeoBranchArray* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); size_tSizeOf() const; static size_tSizeOf(size_t maxlevel); static size_tSizeOfInstance(size_t maxlevel); static voidSort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateArray(size_t nobj); voidUpdateNavigator(TGeoNavigator* nav) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:9940,Availability,down,down,9940," the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. void Init(TGeoNode** branch, TGeoMatrix* global, Int_t level); Init the branch array from an array of nodes, the global matrix for the path and; the level. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of branch array pointers. void UpdateNavigator(TGeoNavigator* nav) const; Update the navigator to reflect the branch. TGeoBranchArray(Int_t level). size_t SizeOf(size_t maxlevel); Equivalent of sizeof function. { return (sizeof(TGeoBranchArray)+sizeof(TGeoBranchArray*)*(maxlevel)); }. size_t SizeOfInstance(size_t maxlevel); Equivalent of sizeof function. { return (sizeof(TGeoBranchArray)+sizeof(TGeoBranchArray*)*(maxlevel)); }. size_t SizeOf() const; { return (sizeof(TGeoBranchArray)+sizeof(TGeoBranchArray*)*(fMaxLevel)); }. void * DataStart() const; The data start should point to the address of the first data member,; after the virtual table. {return (void*)&fLevel;}. size_t DataSize() const; The actual size of the data for an instance, excluding the virtual table. {return SizeOf()-size_t(&fLevel)+(size_t)this;}. virtual ~TGeoBranchArray(); Destructor. Release instance to be called instead. {}. TGeoNode ** GetArray() const; {return fArray;}. size_",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:620,Deployability,update,updated,620,". TGeoBranchArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoBranchArray. class TGeoBranchArray: public TObject. TGeoBranchArray - An array of daughter indices making a geometry path.; Can be used to backup/restore a state. To setup an object of this type,; one should use:; TGeoBranchArray *array = new TGeoBranchArray(level);; array->InitFromNavigator(nav); (To initialize from current navigator state); The navigator can be updated to reflect this path array:; array->UpdateNavigator();. Function Members (Methods); public:. TGeoBranchArray(TRootIOCtor*); virtual~TGeoBranchArray(); voidTObject::AbstractMethod(const char* method) const; voidAddLevel(Int_t dindex); virtual voidTObject::AppendPad(Option_t* option = """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCopyTo(TGeoBranchArray* dest); size_tDataSize() const; void*DataStart() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:7551,Deployability,release,released,7551," char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGeoBranchArray(Int_t level); TGeoBranchArray(const TGeoBranchArray&). Data Members; public:. enum EGeoBATypes { kBASelfAlloc; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:7835,Deployability,release,released,7835,"vas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. Not valid anymore. Use",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:7518,Energy Efficiency,allocate,allocates,7518,"fsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGeoBranchArray(Int_t level); TGeoBranchArray(const TGeoBranchArray&). Data Members; public:. enum EGeoBATypes { kBASelfAlloc; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal add",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:7802,Energy Efficiency,allocate,allocates,7802," kBASelfAlloc; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoNode**fArray![fMaxLevel+1] Array of nodes; Int_tfLevelBranch depth; TGeoHMatrixfMatrixGlobal matrix (owned); Int_tfMaxLevelArray length; TGeoNode*fRealArray[1]Beginning address of the array of nodes. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(Int_t level); Constructor. Alocates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoB",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:8407,Energy Efficiency,allocate,allocated,8407,"locates the array with a size given by level. TGeoBranchArray * MakeInstance(size_t maxlevel); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeInstanceAt(size_t maxlevel, void* addr); Make an instance of the class which allocates the node array. To be; released using ReleaseInstance. If addr is non-zero, the user promised that; addr contains at least that many bytes: size_t needed = SizeOf(maxlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. Not valid anymore. Use TGeoBranchArray::MakeCopy instead. void AddLevel(Int_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equa",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBranchArray.html:8980,Performance,perform,performed,8980,"axlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. Not valid anymore. Use TGeoBranchArray::MakeCopy instead. void AddLevel(Int_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. void Init(TGeoNode** branch, TGeoMatrix* global, Int_t level); Init the branch array from an array of nodes, the global matrix for the path and; the level. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of",MatchSource.WIKI,root/html534/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html
https://root.cern/root/html534/TGeoBuilder.html:1814,Availability,error,error,1814,"ject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:1898,Availability,error,error,1898,"atic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:17603,Deployability,continuous,continuous,17603,"Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY fl",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:17526,Energy Efficiency,energy,energy,17526,"erial * Mixture(const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation ",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:4428,Integrability,rout,rout,4428,"TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz); TGeoVolume*MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoVolume*MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoVolume*MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoVolume*MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); TGeoVolume*MakeGtra(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolume*MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoVolume*MakePara(const char* name, TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoVolume*MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); TGeoVolume*MakePcon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nz); TGeoVolume*MakePgon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoVolume*MakeSphere(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t themin = 0, Double_t themax = 180, Double_t phimin = 0, Double_t phimax = 360); TGeoVolume*MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoVolume*MakeTrap(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, ",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:12335,Integrability,rout,rout,12335,"hemax = 180, Double_t phimin = 0, Double_t phimax = 360); Make in one step a volume pointing to a sphere shape with given medium. TGeoVolume * MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); Make in one step a volume pointing to a torus shape with given medium. TGeoVolume * MakeTube(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeTubs(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Make in one step a volume pointing to a cone shape with given medium. TGeoVolume * MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a cone segment ",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:17727,Performance,perform,performed,17727," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:17775,Performance,perform,performed,17775," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoBuilder.html:17822,Performance,perform,performed,17822," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html534/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoBuilder.html
https://root.cern/root/html534/TGeoCacheState.html:1363,Availability,error,error,1363," TGeoCacheState(); TGeoCacheState(Int_t capacity); virtual~TGeoCacheState(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root/html534/TGeoCacheState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCacheState.html
https://root.cern/root/html534/TGeoCacheState.html:1447,Availability,error,error,1447," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetState(Int_t& level, Int_t& nmany, Double_t* point) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_",MatchSource.WIKI,root/html534/TGeoCacheState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCacheState.html
https://root.cern/root/html534/TGeoChecker.html:4304,Availability,error,error,4304," = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Double_tCheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:4388,Availability,error,error,4388,"pe* shape, Int_t testNo, Int_t nsamples, Option_t* option); Double_tCheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:11175,Availability,error,errors,11175,"e checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking. Opional overlap checkings (by sampling and by mesh). Optional; boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mi",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:17286,Deployability,update,updated,17286,"ate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double_t dirz, Double_t* array, Int_t& nelem, Int_t& dim, Double_t* enpoint = 0) const; Shoot one ray from start point with direction (dirx,diry,dirz). Fills input array; with points just after boundary crossings.; Int_t array_dimension = 3*dim;. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""v""); Estimate weight of top level volume with a precision SIGMA(W)/W; better than PRECISION. Option can be ""v"" - verbose (default). Double_t CheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); count voxel timing. Bool_t TestVoxels(TGeoVolume* vol, Int_t npoints = 1000000); Returns optimal voxelization type for volume vol.; kFALSE - cartesian; kTRUE -",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:446,Performance,perform,performed,446,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:1147,Safety,safe,safety,1147," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. T",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:10406,Safety,safe,safety,10406,"opagateInGeom(Double_t*, Double_t*); voidScore(TGeoVolume*, Int_t, Double_t); Double_tTimingPerVolume(TGeoVolume*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TBuffer3D*fBuff1Buffer containing mesh vertices for first volume; TBuffer3D*fBuff2Buffer containing mesh vertices for second volume; Bool_t*fFlags! Array of flags per volume.; Bool_tfFullCheckFull overlap checking; TGeoManager*fGeoManagerpointer to geometry manager; Int_tfNchecks! Number of checks for current volume; Int_tfNmeshPoints! Number of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void Check",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:15037,Safety,safe,safety,15037,"er of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:15169,Safety,safe,safety,15169,"""); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the n",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:15826,Safety,safe,safe,15826,"shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. ",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:15913,Safety,safe,safety,15913,"t with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* t",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:16045,Safety,safe,safety,16045,"and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:16297,Safety,safe,safety,16297,"ions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootR",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:428,Testability,test,tests,428,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:3408,Testability,test,testNo,3408,,MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:14639,Testability,test,testNo,14639," Double_t ovlp); Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:14729,Testability,test,test,14729,"s overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void Sha",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoChecker.html:14985,Testability,test,test,14985,"ecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compu",MatchSource.WIKI,root/html534/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoChecker.html
https://root.cern/root/html534/TGeoCombiTrans.html:6234,Availability,error,error,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:8349,Availability,error,error,8349,"name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*GetRotation() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() con",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:8433,Availability,error,error,8433,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*GetRotation() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslati",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:3106,Integrability,interface,interface,3106," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:6240,Integrability,message,message,6240,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:6985,Modifiability,variab,variable,6985,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRotation& rot); TGeoCombiTrans(Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); TGeoCombiTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual ",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:490,Performance,optimiz,optimize,490,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:499,Performance,perform,performance,499,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:984,Performance,perform,performed,984,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:1710,Performance,perform,performed,1710,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:6217,Performance,perform,performed,6217,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTrans.html:1723,Usability,simpl,simple,1723,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTrans.html
https://root.cern/root/html534/TGeoCombiTransEditor.html:4726,Availability,error,error,4726,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTransEditor.html
https://root.cern/root/html534/TGeoCombiTransEditor.html:4810,Availability,error,error,4810,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTransEditor.html
https://root.cern/root/html534/TGeoCombiTransEditor.html:17995,Availability,mask,mask,17995,,MatchSource.WIKI,root/html534/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTransEditor.html
https://root.cern/root/html534/TGeoCombiTransEditor.html:22298,Usability,undo,undoing,22298,"ic Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCombiTransEditor.html
https://root.cern/root/html534/TGeoCompositeShape.html:1115,Availability,down,down,1115,"eader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent bas",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:6076,Availability,error,error,6076,"GeoTranslation *t2 = new TGeoTranslation(""T2"",0,0, 20);; TGeoRotation *r1 = new TGeoRotation(""R1""); // transformations need names; r1->SetAngles(90,30,90,120,0,0); // rotation with 30 degrees about Z; TGeoTube *a = new TGeoTube(0, 10,20);; a->SetName(""A""); // shapes need names too; TGeoTube *b = new TGeoTube(0, 20,20);; b->SetName(""B"");; TGeoBBox *c = new TGeoBBox(10,10,50);; c->SetName(""C"");; TGeoBBox *d = new TGeoBBox(50,10,10);; d->SetName(""D"");. TGeoCompositeShape *cs;; cs = new TGeoCompositeShape(""CS"", ""(A:t1+B:t2)\(C+D:r1)"");. The newly created composite looks like 2 cylinders of different radii sitting; one on top of the other and having 2 rectangular holes : a longitudinal one; along Z axis corresponding to C and an other one in the XY plane due to D.; One should have in mind that the same shape or matrix identifier can be; used many times in the same expression. For instance:. (A:t1-A:t2)*B:t1. is a valid expression. Expressions that cannot be parsed or identifiers that; cannot be substituted by existing objects generate error messages.; Composite shapes can be subsequently used for defining volumes. Moreover,; these volumes may have daughters but these have to obbey overlapping/extruding; rules (see TGeoVolume). Volumes created based on composite shapes cannot be; divided. Visualization of such volumes is currently not implemented. Function Members (Methods); public:. TGeoCompositeShape(); TGeoCompositeShape(const char* expression); TGeoCompositeShape(const char* name, const char* expression); TGeoCompositeShape(const char* name, TGeoBoolNode* node); virtual~TGeoCompositeShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() ",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:9367,Availability,error,error,9367,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; TGeoBoolNode*GetBoolNode() const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Doubl",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:9451,Availability,error,error,9451,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; TGeoBoolNode*GetBoolNode() const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingB",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:18860,Availability,error,error,18860,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. TGeoBoolNode*fNodetop boolean node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const; Needed just for cleanup. void CreateThreadData(Int_t nthreads); Needed just for cleanup. TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(const Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:2292,Integrability,interface,interface,2292,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression split:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right""; ",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:6082,Integrability,message,messages,6082,"GeoTranslation *t2 = new TGeoTranslation(""T2"",0,0, 20);; TGeoRotation *r1 = new TGeoRotation(""R1""); // transformations need names; r1->SetAngles(90,30,90,120,0,0); // rotation with 30 degrees about Z; TGeoTube *a = new TGeoTube(0, 10,20);; a->SetName(""A""); // shapes need names too; TGeoTube *b = new TGeoTube(0, 20,20);; b->SetName(""B"");; TGeoBBox *c = new TGeoBBox(10,10,50);; c->SetName(""C"");; TGeoBBox *d = new TGeoBBox(50,10,10);; d->SetName(""D"");. TGeoCompositeShape *cs;; cs = new TGeoCompositeShape(""CS"", ""(A:t1+B:t2)\(C+D:r1)"");. The newly created composite looks like 2 cylinders of different radii sitting; one on top of the other and having 2 rectangular holes : a longitudinal one; along Z axis corresponding to C and an other one in the XY plane due to D.; One should have in mind that the same shape or matrix identifier can be; used many times in the same expression. For instance:. (A:t1-A:t2)*B:t1. is a valid expression. Expressions that cannot be parsed or identifiers that; cannot be substituted by existing objects generate error messages.; Composite shapes can be subsequently used for defining volumes. Moreover,; these volumes may have daughters but these have to obbey overlapping/extruding; rules (see TGeoVolume). Volumes created based on composite shapes cannot be; divided. Visualization of such volumes is currently not implemented. Function Members (Methods); public:. TGeoCompositeShape(); TGeoCompositeShape(const char* expression); TGeoCompositeShape(const char* name, const char* expression); TGeoCompositeShape(const char* name, TGeoBoolNode* node); virtual~TGeoCompositeShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() ",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:944,Modifiability,extend,extend,944,". TGeoCompositeShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are n",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:1284,Performance,perform,performance,1284,"lass TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:8233,Safety,safe,safe,8233,"on = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:8516,Safety,safe,safe,8516,", const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:14378,Safety,safe,safe,14378,"od, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual Bool_tPaintComposite(Option_t* option = """") const; virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRegisterYourself(); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Dou",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:19375,Safety,safe,safe,19375,"adData() const; Needed just for cleanup. void CreateThreadData(Int_t nthreads); Needed just for cleanup. TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(const Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t Paint",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:19650,Safety,safe,safe,19650,"t constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(const Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t* option = """") const; Paint this composite shape into the current 3D viewer; Returns bool flag indicating if the caller should continue to; paint child objects. void RegisterYourself(); Register the shape and all components to TGeoManager class. Double_t Safety(",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:22275,Safety,safe,safe,22275,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:22311,Safety,safe,safe,22311,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCompositeShape(const TGeoCompositeShape& gcs); { }. TGeoCompositeShape& operator=(const TGeoCompositeShape& gcs). TGeoBoolNode * GetBoolNode() const; {return fNode;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsComposite() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void SetDimensions(Double_t* ); {;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROO",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:7069,Testability,test,testNo,7069,,MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCompositeShape.html:2335,Usability,simpl,simple,2335,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression split:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right""; ",MatchSource.WIKI,root/html534/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCompositeShape.html
https://root.cern/root/html534/TGeoCone.html:4249,Availability,error,error,4249,"st; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:4333,Availability,error,error,4333,"le_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatr",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:2672,Safety,safe,safe,2672,"virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:3108,Safety,safe,safe,3108,"Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual void",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:9301,Safety,safe,safe,9301,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCone&operator=(const TGeoCone&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:14959,Safety,safe,safe,14959,"TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute dist",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:15103,Safety,safe,safe,15103," [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. ",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:15188,Safety,safe,safe,15188," [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. ",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:15421,Safety,safe,safe,15421,"ere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position wi",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:15597,Safety,safe,safe,15597,"e_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to;",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:15682,Safety,safe,safe,15682,"e_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to;",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:20294,Safety,safe,safe,20294," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:20330,Safety,safe,safe,20330," reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoCone(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDz() const; {return fDz;}. Double_t GetRmin1() const; {return fRmin1;}. Double_t GetRmax1() const; {return fRmax1;}. Double_t GetRmin2() const; {return fRmin2;}. Double_t GetRmax2() const; {return fRmax2;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:1331,Testability,test,testNo,1331," TGeoCone(); TGeoCone(Double_t* params); TGeoCone(const TGeoCone&); TGeoCone(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoCone.html:14700,Testability,test,test,14700,"oCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Default constructor specifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius.",MatchSource.WIKI,root/html534/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCone.html
https://root.cern/root/html534/TGeoConeEditor.html:4623,Availability,error,error,4623,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeEditor.html
https://root.cern/root/html534/TGeoConeEditor.html:4707,Availability,error,error,4707,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeEditor.html
https://root.cern/root/html534/TGeoConeEditor.html:18054,Availability,mask,mask,18054,,MatchSource.WIKI,root/html534/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeEditor.html
https://root.cern/root/html534/TGeoConeEditor.html:21598,Usability,undo,undoing,21598,"ition; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeEditor.html
https://root.cern/root/html534/TGeoConeSeg.html:4759,Availability,error,error,4759,"c voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoCone::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoCone::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:4843,Availability,error,error,4843,"Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoCone::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoCone::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:2833,Safety,safe,safe,2833,":ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Dou",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:3362,Safety,safe,safe,3362,"ool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(const Double_t* point, const Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virt",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:9937,Safety,safe,safe,9937,"; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoConeSeg&operator=(const TGeoConeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidTGeoCone::SetConeDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidSetConsDimensions(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2,",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:16988,Safety,safe,safe,16988,"le_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given st",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:17508,Safety,safe,safe,17508,"dius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmi",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:17593,Safety,safe,safe,17593,"dius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmi",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:21898,Safety,safe,safe,21898,"reference. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 56;}. TGeoConeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:21934,Safety,safe,safe,21934,"reference. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n random points located on the line segments of the shape mesh.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation is implemented. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 56;}. TGeoConeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:1440,Testability,test,testNo,1440," TGeoConeSeg(); TGeoConeSeg(Double_t* params); TGeoConeSeg(const TGeoConeSeg&); TGeoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Dou",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSeg.html:16183,Testability,test,test,16183," Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2; param[5] = phi1; param[6] = phi2. ~TGeoConeSeg(); destructor. void AfterStreamer(); Function called after streaming an object of this class. void InitTrigonometry(); Init frequently used trigonometric values. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(const Double_t* point, const Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t dz, Double_t rmin1, Double_",MatchSource.WIKI,root/html534/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSeg.html
https://root.cern/root/html534/TGeoConeSegEditor.html:4796,Availability,error,error,4796,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSegEditor.html
https://root.cern/root/html534/TGeoConeSegEditor.html:4880,Availability,error,error,4880,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSegEditor.html
https://root.cern/root/html534/TGeoConeSegEditor.html:18490,Availability,mask,mask,18490,"t changes; Bool_tTGedFrame::fAvoidSignalflag for executing slots; TGCompositeFrame*TGeoConeEditor::fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoConeEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoConeEditor::fDelayedCheck button for delayed draw; Double_tTGeoConeEditor::fDziInitial box dz; TGNumberEntry*TGeoConeEditor::fEDzNumber entry for DZ; TGNumberEntry*fEPhi1Number entry for phi1; TGNumberEntry*fEPhi2Number entry for phi2 ; TGNumberEntry*TGeoConeEditor::fERmax1Number entry for rmax1; TGNumberEntry*TGeoConeEditor::fERmax2Number entry for rmax2; TGNumberEntry*TGeoConeEditor::fERmin1Number entry for rmin1; TGNumberEntry*TGeoConeEditor::fERmin2Number entry for rmin2; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoConeEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoConeEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfLockPhi lock; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UIn",MatchSource.WIKI,root/html534/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSegEditor.html
https://root.cern/root/html534/TGeoConeSegEditor.html:22262,Usability,undo,undoing,22262," of the ged-editor; TGeoTabManager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoConeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cone segment editor. ~TGeoConeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for Phi1. void DoPhi2(); Slot for Phi2. void DoPhi(); Slot for Phi. void DoApply(); Slot for applying current parameters. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoConeSegEditor.html
https://root.cern/root/html534/TGeoCtub.html:4978,Availability,error,error,4978,"e_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tT",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:5062,Availability,error,error,5062," c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(c",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:3269,Safety,safe,safe,3269,"eoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTubeSeg::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2,",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:3777,Safety,safe,safe,3777,"oints, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTubeSeg::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() ",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:10274,Safety,safe,safe,10274,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoCtub&operator=(const TGeoCtub&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTubeSeg::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; voidSetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual voidSetDimensions(Double_t* par",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:16486,Safety,safe,safe,16486,"in, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); constructor. TGeoCtub(Double_t* params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, D",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:16695,Safety,safe,safe,16695,"Ctub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); set dimensions of a cut tube. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream """,MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:19583,Safety,safe,safe,19583,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:19619,Safety,safe,safe,19619,"nd polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoCtub(); constructors. const Double_t * GetNlow() const; {return &fNlow[0];}. const Double_t * GetNhigh() const; {return &fNhigh[0];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtub.html:1884,Testability,test,testNo,1884," TGeoCtub(); TGeoCtub(Double_t* params); TGeoCtub(const TGeoCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoTubeSeg::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName(",MatchSource.WIKI,root/html534/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtub.html
https://root.cern/root/html534/TGeoCtubEditor.html:4830,Availability,error,error,4830,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtubEditor.html
https://root.cern/root/html534/TGeoCtubEditor.html:4914,Availability,error,error,4914,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtubEditor.html
https://root.cern/root/html534/TGeoCtubEditor.html:18627,Availability,mask,mask,18627,"GeoTubeEditor::fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoTubeEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoTubeEditor::fDelayedCheck button for delayed draw; Double_tTGeoTubeEditor::fDziInitial box dz; TGNumberEntry*TGeoTubeEditor::fEDzNumber entry for DZ; TGNumberEntry*fEPhhiNumber entry for phhi; TGNumberEntry*TGeoTubeSegEditor::fEPhi1Number entry for phi1; TGNumberEntry*TGeoTubeSegEditor::fEPhi2Number entry for phi2 ; TGNumberEntry*fEPhloNumber entry for phlo; TGNumberEntry*TGeoTubeEditor::fERmaxNumber entry for rmax; TGNumberEntry*TGeoTubeEditor::fERminNumber entry for rmin; TGNumberEntry*fEThhiNumber entry for thhi; TGNumberEntry*fEThloNumber entry for thlo; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoTubeEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoTubeEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGeoTubeSegEditor::fLockPhi lock; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminima",MatchSource.WIKI,root/html534/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtubEditor.html
https://root.cern/root/html534/TGeoCtubEditor.html:22547,Usability,undo,undoing,22547,"ouble_tfThhiTheta angle of the normal to the upper plane (0, 90); Double_tfThloTheta angle of the normal to the lower plane (90, 180); TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCtubEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cut tube editor. ~TGeoCtubEditor(); Destructor. void SetModel(TObject* obj); Connect to the selected object. void DoThlo(); Slot for phi1. void DoPhlo(); Slot for phi1. void DoThhi(); Slot for phi1. void DoPhhi(); Slot for phi1. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoCtubEditor.html
https://root.cern/root/html534/TGeoDecayChannel.html:1895,Availability,error,error,1895,"nst; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoElementRN*Daughter() const; UInt_tDecay() const; static voidDecayName(UInt_t decay, TString& name); virtual voidDecayShift(Int_t& dA, Int_t& dZ, Int_t& dI) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeltaIso() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* ",MatchSource.WIKI,root/html534/TGeoDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoDecayChannel.html
https://root.cern/root/html534/TGeoDecayChannel.html:1979,Availability,error,error,1979,"char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoElementRN*Daughter() const; UInt_tDecay() const; static voidDecayName(UInt_t decay, TString& name); virtual voidDecayShift(Int_t& dA, Int_t& dZ, Int_t& dI) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeltaIso() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtu",MatchSource.WIKI,root/html534/TGeoDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoDecayChannel.html
https://root.cern/root/html534/TGeoElement.html:1852,Availability,error,error,1852,"bstractMethod(const char* method) const; voidAddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual Double_tGetSpecificActivity() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::G",MatchSource.WIKI,root/html534/TGeoElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElement.html
https://root.cern/root/html534/TGeoElement.html:1936,Availability,error,error,1936,"_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual Double_tGetSpecificActivity() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong",MatchSource.WIKI,root/html534/TGeoElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElement.html
https://root.cern/root/html534/TGeoElementRN.html:2202,Availability,error,error,2202,"s); public:. TGeoElementRN(); TGeoElementRN(Int_t A, Int_t Z, Int_t iso, Double_t level, Double_t deltaM, Double_t halfLife, const char* JP, Double_t natAbun, Double_t th_f, Double_t tg_f, Double_t th_s, Double_t tg_s, Int_t status); virtual~TGeoElementRN(); Double_tTGeoElement::A() const; voidTObject::AbstractMethod(const char* method) const; voidAddDecay(TGeoDecayChannel* dc); voidAddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue); voidTGeoElement::AddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); voidAddRatio(TGeoBatemanSol& ratio); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAtomicNo() const; virtual voidTObject::Browse(TBrowser* b); Bool_tCheckDecays() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecayResult(TGeoDecayChannel* dc) const; TObjArray*Decays() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Int_tENDF(Int_t a, Int_t z, Int_t iso); virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillPopulation(TObjArray* population, Double_t precision = 0.001, Double_",MatchSource.WIKI,root/html534/TGeoElementRN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElementRN.html
https://root.cern/root/html534/TGeoElementRN.html:2286,Availability,error,error,2286,"s); public:. TGeoElementRN(); TGeoElementRN(Int_t A, Int_t Z, Int_t iso, Double_t level, Double_t deltaM, Double_t halfLife, const char* JP, Double_t natAbun, Double_t th_f, Double_t tg_f, Double_t th_s, Double_t tg_s, Int_t status); virtual~TGeoElementRN(); Double_tTGeoElement::A() const; voidTObject::AbstractMethod(const char* method) const; voidAddDecay(TGeoDecayChannel* dc); voidAddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue); voidTGeoElement::AddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); voidAddRatio(TGeoBatemanSol& ratio); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAtomicNo() const; virtual voidTObject::Browse(TBrowser* b); Bool_tCheckDecays() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecayResult(TGeoDecayChannel* dc) const; TObjArray*Decays() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Int_tENDF(Int_t a, Int_t z, Int_t iso); virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillPopulation(TObjArray* population, Double_t precision = 0.001, Double_",MatchSource.WIKI,root/html534/TGeoElementRN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElementRN.html
https://root.cern/root/html534/TGeoElementTable.html:1900,Availability,error,error,1900,"le_t a); voidAddElementRN(TGeoElementRN* elem); voidAddIsotope(TGeoIsotope* isotope); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildDefaultElements(); Bool_tCheckTable() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExportElementsRN(const char* filename = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoElement*FindElement(const char* name) const; TGeoIsotope*FindIsotope(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElement*GetElement(Int_t z); TGeoElementRN*GetElementRN(Int_t ENDFcode) const; TGeoElementRN*GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; TObjArray*GetElementsRN() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNelements() const; Int_tGetNelementsRN() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_",MatchSource.WIKI,root/html534/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElementTable.html
https://root.cern/root/html534/TGeoElementTable.html:1984,Availability,error,error,1984,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildDefaultElements(); Bool_tCheckTable() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExportElementsRN(const char* filename = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoElement*FindElement(const char* name) const; TGeoIsotope*FindIsotope(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElement*GetElement(Int_t z); TGeoElementRN*GetElementRN(Int_t ENDFcode) const; TGeoElementRN*GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; TObjArray*GetElementsRN() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNelements() const; Int_tGetNelementsRN() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual cons",MatchSource.WIKI,root/html534/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElementTable.html
https://root.cern/root/html534/TGeoElementTable.html:7812,Performance,optimiz,optimized,7812," TGeoElementTable& ); assignment operator. ~TGeoElementTable(); destructor. void AddElement(const char* name, const char* title, Int_t z, Double_t a); Add an element to the table. Obsolete. void AddElement(const char* name, const char* title, Int_t z, Int_t n, Double_t a); Add an element to the table. void AddElement(TGeoElement* elem); Add a custom element to the table. void AddElementRN(TGeoElementRN* elem); Add a radionuclide to the table and map it. void AddIsotope(TGeoIsotope* isotope); Add isotope to the table. void BuildDefaultElements(); Creates the default element table. void ImportElementsRN(); Creates the list of radionuclides. Bool_t CheckTable() const; Checks status of element table. void ExportElementsRN(const char* filename = """"); Export radionuclides in a file. TGeoElement * FindElement(const char* name) const; Search an element by symbol or full name; Exact matching. TGeoIsotope * FindIsotope(const char* name) const; Find existing isotope by name. Not optimized for a big number of isotopes. TGeoElementRN * GetElementRN(Int_t ENDFcode) const; Retreive a radionuclide by ENDF code. TGeoElementRN * GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; Retreive a radionuclide by a, z, and isomeric state. void Print(Option_t* option = """") const; Print table of elements. The accepted options are:; """" - prints everything by default; ""D"" - prints default elements only; ""I"" - prints isotopes; ""R"" - prints radio-nuclides only if imported; ""U"" - prints user-defined elements only. TGeoElementRN * GetElement(); {return fElem;}. TObjArray * GetElementsRN() const; {return fListRN;}. Bool_t HasDefaultElements() const; {return TObject::TestBit(kETDefaultElements);}. Bool_t HasRNElements() const; {return TObject::TestBit(kETRNElements);}. Int_t GetNelements() const; {return fNelements;}. Int_t GetNelementsRN() const; {return fNelementsRN;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Las",MatchSource.WIKI,root/html534/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElementTable.html
https://root.cern/root/html534/TGeoElemIter.html:1993,Availability,down,down,1993,"oElemIter&operator=(const TGeoElemIter& iter); virtual voidPrint(Option_t* option = """") const; voidSetLimitRatio(Double_t limit); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGeoElemIter(); TGeoElementRN*Down(Int_t ibranch); TGeoElementRN*Up(). Data Members; private:. TObjArray*fBranchCurrent branch; const TGeoElementRN*fElemCurrent element; Int_tfLevelCurrent level; Double_tfLimitRatioMinimum cumulative branching ratio; Double_tfRatioCurrent ratio; const TGeoElementRN*fTopTop element of the iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.e-4); Default constructor. TGeoElemIter(const TGeoElemIter& iter); Copy ctor. ~TGeoElemIter(); Destructor. TGeoElemIter & operator=(const TGeoElemIter& iter); Assignment. TGeoElementRN * operator()(); () operator. TGeoElementRN * Up(); Go upwards from the current location until the next branching, then down. TGeoElementRN * Down(Int_t ibranch); Go downwards from current level via ibranch as low in the tree as possible.; Return value flags if the operation was successful. TGeoElementRN * Next(); Return next element. void Print(Option_t* option = """") const; Print info about the current decay branch. TGeoElementRN * GetElement() const; {return fElem;}. TGeoElemIter(); {}. TObjArray * GetBranch() const; {return fBranch;}. const TGeoElementRN * GetTop() const; {return fTop;}. Int_t GetLevel() const; {return fLevel;}. Double_t GetRatio() const; {return fRatio;}. void SetLimitRatio(Double_t limit); {fLimitRatio = limit;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoElemIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElemIter.html
https://root.cern/root/html534/TGeoElemIter.html:2039,Availability,down,downwards,2039,"oElemIter&operator=(const TGeoElemIter& iter); virtual voidPrint(Option_t* option = """") const; voidSetLimitRatio(Double_t limit); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGeoElemIter(); TGeoElementRN*Down(Int_t ibranch); TGeoElementRN*Up(). Data Members; private:. TObjArray*fBranchCurrent branch; const TGeoElementRN*fElemCurrent element; Int_tfLevelCurrent level; Double_tfLimitRatioMinimum cumulative branching ratio; Double_tfRatioCurrent ratio; const TGeoElementRN*fTopTop element of the iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.e-4); Default constructor. TGeoElemIter(const TGeoElemIter& iter); Copy ctor. ~TGeoElemIter(); Destructor. TGeoElemIter & operator=(const TGeoElemIter& iter); Assignment. TGeoElementRN * operator()(); () operator. TGeoElementRN * Up(); Go upwards from the current location until the next branching, then down. TGeoElementRN * Down(Int_t ibranch); Go downwards from current level via ibranch as low in the tree as possible.; Return value flags if the operation was successful. TGeoElementRN * Next(); Return next element. void Print(Option_t* option = """") const; Print info about the current decay branch. TGeoElementRN * GetElement() const; {return fElem;}. TGeoElemIter(); {}. TObjArray * GetBranch() const; {return fBranch;}. const TGeoElementRN * GetTop() const; {return fTop;}. Int_t GetLevel() const; {return fLevel;}. Double_t GetRatio() const; {return fRatio;}. void SetLimitRatio(Double_t limit); {fLimitRatio = limit;}. » Author: Andrei Gheata 17/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoElemIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoElemIter.html
https://root.cern/root/html534/TGeoEltu.html:3933,Availability,error,error,3933,", Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz(",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:4017,Availability,error,error,4017,"nst Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacet",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:2416,Safety,safe,safe,2416,"st TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTube::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual ",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:2828,Safety,safe,safe,2828,", Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, c",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:9064,Safety,safe,safe,9064,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoEltu&operator=(const TGeoEltu&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEltuDimensions(Double_t a, Double_t b, Double_t dz); voidTGeoShape::SetId(Int_t id); vi",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:14235,Safety,safe,safe,14235,"des; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, acco",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:14440,Safety,safe,safe,14440,"ouble_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:14520,Safety,safe,safe,14520,"ouble_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:17122,Safety,safe,safe,17122,"e mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoEltu(); constructors. Double_t GetA() const; {return fRmin;}. Double_t GetB() const; {return fRmax;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 05/06/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:17158,Safety,safe,safe,17158,"e mesh. void SetPoints(Float_t* points) const; Create eliptical tube mesh points. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoEltu(); constructors. Double_t GetA() const; {return fRmin;}. Double_t GetB() const; {return fRmax;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 05/06/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:1099,Testability,test,testNo,1099," TGeoEltu(); TGeoEltu(Double_t* params); TGeoEltu(const TGeoEltu&); TGeoEltu(Double_t a, Double_t b, Double_t dz); TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); virtual~TGeoEltu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTube::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTName",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltu.html:13957,Testability,test,test,13957,"rigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negat",MatchSource.WIKI,root/html534/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltu.html
https://root.cern/root/html534/TGeoEltuEditor.html:4569,Availability,error,error,4569,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltuEditor.html
https://root.cern/root/html534/TGeoEltuEditor.html:4653,Availability,error,error,4653,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltuEditor.html
https://root.cern/root/html534/TGeoEltuEditor.html:17902,Availability,mask,mask,17902,,MatchSource.WIKI,root/html534/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltuEditor.html
https://root.cern/root/html534/TGeoEltuEditor.html:21262,Usability,undo,undoing,21262,"TGTextButton*fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoEltuEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoName(); Slot for name. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoA(); Slot for A. void DoB(); Slot for B. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoEltuEditor.html
https://root.cern/root/html534/TGeoExtension.html:673,Availability,avail,available,673,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html534/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoExtension.html
https://root.cern/root/html534/TGeoExtension.html:832,Availability,avail,available,832,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html534/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoExtension.html
https://root.cern/root/html534/TGeoExtension.html:1778,Availability,error,error,1778," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html534/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoExtension.html
https://root.cern/root/html534/TGeoExtension.html:1862,Availability,error,error,1862," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TGeoExtension*Grab(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* ",MatchSource.WIKI,root/html534/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoExtension.html
https://root.cern/root/html534/TGeoExtension.html:461,Deployability,release,release,461,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html534/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoExtension.html
https://root.cern/root/html534/TGeoExtension.html:383,Integrability,interface,interface,383,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html534/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoExtension.html
https://root.cern/root/html534/TGeoExtension.html:583,Testability,log,logical,583,". TGeoExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoExtension. class TGeoExtension: public TObject. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ",MatchSource.WIKI,root/html534/TGeoExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoExtension.html
https://root.cern/root/html534/TGeoGedFrame.html:497,Availability,avail,available,497,". TGeoGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoGedFrame. class TGeoGedFrame: public TGedFrame. TGeoGedFrame. Common base class for geombuilder editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TGeoGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* r",MatchSource.WIKI,root/html534/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGedFrame.html
https://root.cern/root/html534/TGeoGedFrame.html:4461,Availability,error,error,4461,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGedFrame.html
https://root.cern/root/html534/TGeoGedFrame.html:4545,Availability,error,error,4545,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGedFrame.html
https://root.cern/root/html534/TGeoGedFrame.html:17355,Availability,mask,mask,17355,,MatchSource.WIKI,root/html534/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGedFrame.html
https://root.cern/root/html534/TGeoGenTrans.html:6232,Availability,error,error,6232,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:8296,Availability,error,error,8296,"e_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*TGeoCombiTrans::GetRotation() const; virtual const Double_t*TGeoCombiTrans::GetRotationMatrix() const; virtu",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:8380,Availability,error,error,8380,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*TGeoCombiTrans::GetRotation() const; virtual const Double_t*TGeoCombiTrans::GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; vir",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:3104,Integrability,interface,interface,3104," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:6238,Integrability,message,message,6238,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:6983,Modifiability,variab,variable,6983,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t p",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:488,Performance,optimiz,optimize,488,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:497,Performance,perform,performance,497,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:982,Performance,perform,performed,982,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:1708,Performance,perform,performed,1708,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:6215,Performance,perform,performed,6215,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:1721,Usability,simpl,simple,1721,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGenTrans.html:15836,Usability,clear,clear,15836,"tity; kGeoShared; kGeoTranslation; kGeoRotation; kGeoScale; kGeoReflection; kGeoRegistered; kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans(). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGenTrans.html
https://root.cern/root/html534/TGeoGlobalMagField.html:1903,Availability,error,error,1903," TGeoGlobalMagField(); virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); vi",MatchSource.WIKI,root/html534/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGlobalMagField.html
https://root.cern/root/html534/TGeoGlobalMagField.html:1987,Availability,error,error,1987," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidField(const Double_t* x, Double_t* B); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualMagField*GetField() const; virtual const char*TObject::GetIconName() const; static TGeoGlobalMagField*GetInstance(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html534/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGlobalMagField.html
https://root.cern/root/html534/TGeoGlobalMagField.html:376,Security,access,access,376,". TGeoGlobalMagField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGlobalMagField. class TGeoGlobalMagField: public TObject. TGeoGlobalMagField - Global magnetic field manager. Provides access to; and owns the actual magnetic field set via SetField(). The field is deleted; upon destruction of the field manager at the end of ROOT session or; by calling: TGeoGlobalMagField::Instance()->SetField(0). The previous; global field is deleted upon replacement with notification. The global field manager provides access to the global field via:; TGeoGlobalMagField::Instance()->GetField(); One can directly call the Field() method of a field via the global field manager:. TGeoGlobalMagField::Instance()->Field(x,B). Function Members (Methods); public:. TGeoGlobalMagField(); virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); vi",MatchSource.WIKI,root/html534/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGlobalMagField.html
https://root.cern/root/html534/TGeoGlobalMagField.html:698,Security,access,access,698,". TGeoGlobalMagField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoGlobalMagField. class TGeoGlobalMagField: public TObject. TGeoGlobalMagField - Global magnetic field manager. Provides access to; and owns the actual magnetic field set via SetField(). The field is deleted; upon destruction of the field manager at the end of ROOT session or; by calling: TGeoGlobalMagField::Instance()->SetField(0). The previous; global field is deleted upon replacement with notification. The global field manager provides access to the global field via:; TGeoGlobalMagField::Instance()->GetField(); One can directly call the Field() method of a field via the global field manager:. TGeoGlobalMagField::Instance()->Field(x,B). Function Members (Methods); public:. TGeoGlobalMagField(); virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); vi",MatchSource.WIKI,root/html534/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGlobalMagField.html
https://root.cern/root/html534/TGeoGlobalMagField.html:7065,Security,access,access,7065,"rtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoGlobalMagField(const TGeoGlobalMagField&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoGlobalMagField&operator=(const TGeoGlobalMagField&); voidUnlock(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TVirtualMagField*fFieldMagnetic field; Bool_tfLockLock flag for global field.; static TGeoGlobalMagField*fgInstanceStatic pointer to the field manager;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGlobalMagField(); Global field default constructor. ~TGeoGlobalMagField(); Global field destructor. void SetField(TVirtualMagField* field); Field setter. Deletes previous field if any. Acts only if fLock=kFALSE. TGeoGlobalMagField * GetInstance(); Static getter that does not create the object. TGeoGlobalMagField * Instance(); Returns always a valid static pointer to the field manager. void Lock(); Locks the global magnetic field if this is set. Cannot be unlocked. TGeoGlobalMagField(const TGeoGlobalMagField& ). TGeoGlobalMagField& operator=(const TGeoGlobalMagField& ). void Unlock(); {fLock = kFALSE;}. TVirtualMagField * GetField() const; Using SetField() makes a given field global. The field manager owns it from now on. {return fField;}. Bool_t IsLocked(); {return fLock;}. void Field(const Double_t* x, Double_t* B); Inline access to Field() method. {if (fField) fField->Field(x,B);}. » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGlobalMagField.html
https://root.cern/root/html534/TGeoGtra.html:4628,Availability,error,error,4628,"ep = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; vi",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:4712,Availability,error,error,4712,"t Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); ",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:3381,Safety,safe,safe,3381,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option ",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:3664,Safety,safe,safe,3664,"mal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execut",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:10435,Safety,safe,safe,10435,"uble_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:16023,Safety,safe,safe,16023,"StringTNamed::fTitleobject title; Double_tTGeoTrap::fTl1half length in x at low z and y high edge; Double_tTGeoTrap::fTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist.",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:16229,Safety,safe,safe,16229,"f twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. ",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:17523,Safety,safe,safe,17523,"t Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:17559,Safety,safe,safe,17559,"t Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtra.html:2114,Testability,test,testNo,2114," TGeoGtra(); TGeoGtra(const TGeoGtra&); TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoGtra(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtu",MatchSource.WIKI,root/html534/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtra.html
https://root.cern/root/html534/TGeoGtraEditor.html:4864,Availability,error,error,4864,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtraEditor.html
https://root.cern/root/html534/TGeoGtraEditor.html:4948,Availability,error,error,4948,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtraEditor.html
https://root.cern/root/html534/TGeoGtraEditor.html:18939,Availability,mask,mask,18939,"Frame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoTrapEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoTrapEditor::fDelayedCheck button for delayed draw; Double_tTGeoTrapEditor::fDziInitial Dz; TGNumberEntry*TGeoTrapEditor::fEAlpha1Number entry for Alpha1; TGNumberEntry*TGeoTrapEditor::fEBl1Number entry for Bl1; TGNumberEntry*TGeoTrapEditor::fEDzNumber entry for DZ; TGNumberEntry*TGeoTrapEditor::fEH1Number entry for H1 ; TGNumberEntry*TGeoTrapEditor::fEPhiNumber entry for Theta ; TGNumberEntry*TGeoTrapEditor::fESc1Number entry for lower scale; TGNumberEntry*TGeoTrapEditor::fESc2Number entry for upper scale; TGNumberEntry*TGeoTrapEditor::fEThetaNumber entry for Theta ; TGNumberEntry*TGeoTrapEditor::fETl1Number entry for Tl1; TGNumberEntry*fETwistNumber entry for H1 ; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; Double_tTGeoTrapEditor::fH1iInitial half length in y at low z; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoTrapEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoTrapEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTG",MatchSource.WIKI,root/html534/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtraEditor.html
https://root.cern/root/html534/TGeoGtraEditor.html:22534,Usability,undo,undoing,22534,"fTabMgrtab manager corresponding to ged-editor; Double_tTGeoTrapEditor::fThetaiInitial theta; Double_tTGeoTrapEditor::fTl1iInitial half length in x at low z and y high edge; Double_tfTwistiInitial twist angle; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoGtraEditor.html
https://root.cern/root/html534/TGeoHalfSpace.html:3468,Availability,error,error,3468,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t in",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:3552,Availability,error,error,3552,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoM",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:2334,Safety,safe,safe,2334,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:2617,Safety,safe,safe,2617,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:8463,Safety,safe,safe,8463,"idTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHalfSpace&operator=(const TGeoHalfSpace&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:12996,Safety,safe,safe,12996,"lf-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); ",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:13191,Safety,safe,safe,13191,"le. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameters as stored in an array. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input:",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:15059,Safety,safe,safe,15059,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:15095,Safety,safe,safe,15095,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetNorm(); {return fN;}. void GetBoundingCylinder(Double_t* ) const; {;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsCylType() const; {return kFALSE;}. void SetPoints(Double_t* ) const; {;}. void SetPoints(Float_t* ) const; {;}. void Sizeof3D() const; {;}. » Author: Mihaela Gheata 03/08/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:1157,Testability,test,testNo,1157," TGeoHalfSpace(); TGeoHalfSpace(Double_t* params); TGeoHalfSpace(const TGeoHalfSpace&); TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); virtual~TGeoHalfSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHalfSpace.html:12736,Testability,test,test,12736,"Object; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, ",MatchSource.WIKI,root/html534/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHalfSpace.html
https://root.cern/root/html534/TGeoHelix.html:2449,Availability,error,error,2449,"rge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetCurrentDirection() const; const Double_t*GetCurrentPoint() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStep() const; virtual const char*TObject::GetTitle() const; Double_tGetTotalCurvature() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXYcurvature() const; virtual Bool_tTObject::HandleTimer(TTimer* timer",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:2533,Availability,error,error,2533,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetCurrentDirection() const; const Double_t*GetCurrentPoint() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStep() const; virtual const char*TObject::GetTitle() const; Double_tGetTotalCurvature() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXYcurvature() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:7875,Availability,error,error,7875," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. P",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:9155,Deployability,update,update,9155,"RUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » La",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:666,Energy Efficiency,charge,charged,666,". TGeoHelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHelix. class TGeoHelix: public TObject. TGeoHelix - class representing a helix curve. A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. TGeoHelix(); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:765,Energy Efficiency,charge,charge,765,". TGeoHelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHelix. class TGeoHelix: public TObject. TGeoHelix - class representing a helix curve. A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. TGeoHelix(); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:914,Energy Efficiency,charge,charge,914,". TGeoHelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHelix. class TGeoHelix: public TObject. TGeoHelix - class representing a helix curve. A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. TGeoHelix(); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:1449,Energy Efficiency,charge,charge,1449," TGeoHelix(); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:5453,Energy Efficiency,charge,charge,5453,", const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetStep(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCharge(Int_t charge); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); voidSetHelixStep(Double_t hstep); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetXYcurvature(Double_t curvature); virtual voidShowMembers(TMemberInspector&); voidStep(Double_t step); Double_tStepToPlane(Double_t* point, Double_t* norm); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateHelix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* n",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:7457,Energy Efficiency,charge,charge,7457,"char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGeoHelix(const TGeoHelix&); TGeoHelix&operator=(const TGeoHelix&). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bo",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:7705,Energy Efficiency,charge,charge,7705,"&operator=(const TGeoHelix&). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRU",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:8565,Energy Efficiency,charge,charge,8565,"ncludes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape b",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:8583,Energy Efficiency,charge,charge,8583,"ncludes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape b",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:9233,Energy Efficiency,charge,charge,9233,"RUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » La",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:7827,Safety,safe,safe,7827," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. P",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:9113,Safety,safe,safety,9113,"n(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHelix.html:9266,Safety,safe,safety,9266,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(const TGeoHelix& ). TGeoHelix & operator=(const TGeoHelix& ). const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}. » Author: Andrei Gheata 28/04/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically ge",MatchSource.WIKI,root/html534/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHelix.html
https://root.cern/root/html534/TGeoHMatrix.html:6225,Availability,error,error,6225,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:8151,Availability,error,error,8151,"virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyFrom(const TGeoMatrix* other); virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(const Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual Double_t*GetRotationMatri",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:8235,Availability,error,error,8235,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyFrom(const TGeoMatrix* other); virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(const Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual Double_t*GetRotationMatrix(); virtual const Double_t*GetScale() const; virtual Double_t*GetScale(); virtual c",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:3097,Integrability,interface,interface,3097," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:6231,Integrability,message,message,6231,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:6976,Modifiability,variab,variable,6976,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyFrom(const TGeoMatrix* other); virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Opti",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:481,Performance,optimiz,optimize,481,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:490,Performance,perform,performance,490,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:975,Performance,perform,performed,975,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:1701,Performance,perform,performed,1701,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:6208,Performance,perform,performed,6208,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:1714,Usability,simpl,simple,1714,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHMatrix.html:15528,Usability,clear,clear,15528," kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfRotationMatrix[9]rotation matrix; Double_tfScale[3]scale component; Double_tfTranslation[3]translation component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHMatrix(); dummy ctor. TGeoHMatrix(const char* name); constructor. TGeoHMatrix(const TGeoMatrix& matrix); assignment. ~TGeoHMatrix(); destructor. TGeoHMatrix & operator=(const TGeoMatrix* matrix); assignment. TGeoHMatrix & operator=(const TGeoMatrix& matrix); assignment. void CopyFrom(const TGeoMatrix* other); Fast copy method. void Clear(Option_t* option = """"); clear the data for this matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void FastRotZ(const Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Double_t Determinant() const; computes determinant of the rotation matrix. void Multiply(const TGeoMatrix* right); multiply to the right with an other transformation; if right is identity matrix, just return. void MultiplyLeft(const TGeoMatrix* left); multiply to the left with an other transformation; if right is identity matrix, just return. void RotateX(Double_t angle); Rotate about X axis with angle expressed in degrees. void RotateY(Double_t angle); Rotate about Y axis with angle expressed in degrees. void RotateZ(Double_t angle); Rotate about Z axis with angle expressed in degrees. void ReflectX(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to YZ. void ReflectY(Bool_t leftside, Bool_t",MatchSource.WIKI,root/html534/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHMatrix.html
https://root.cern/root/html534/TGeoHype.html:5018,Availability,error,error,5018,"const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:5102,Availability,error,error,5102,"st Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:983,Integrability,rout,rout,983,". TGeoHype. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TB",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:1039,Integrability,rout,rout,1039,". TGeoHype. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TB",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:1092,Integrability,rout,rout,1092," function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const ",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:1100,Integrability,rout,rout,1100," function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const ",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:1133,Integrability,rout,rout,1133," function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const ",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:1500,Integrability,rout,rout,1500," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TB",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:1601,Integrability,rout,rout,1601," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TB",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:11233,Integrability,rout,rout,11233,"Shape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3D& buff) const; voidTGeoShape::SetShapeBit(UInt_t f); voidTGeoShape::SetShapeBit(UInt_t f, Bool_t set); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidTGeoShape::SetTransform(TGeoMatrix* matrix); voidTGeoTube::SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); virtual voidTObject::SetUniqueID(UInt_t uid); Int_tTGeoShape::ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtua",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:14936,Integrability,rout,rout,14936,"; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; Double_tTGeoTube::fDzhalf length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute d",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:15084,Integrability,rout,rout,15084," Double_tTGeoBBox::fDZZ half-length; Double_tTGeoTube::fDzhalf length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact =",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:15304,Integrability,rout,rout,15304,"e_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(const",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:18165,Integrability,rout,rout,18165,"a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t RadiusHypeSq(Double_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager->GetNsegments();; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4;; painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D bu",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:18391,Integrability,rout,rout,18391,"e_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager->GetNsegments();; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4;; painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:3396,Safety,safe,safe,3396,"st TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidTGeoTube::ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistTo",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:3808,Safety,safe,safe,3808,", Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoTube::DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:10188,Safety,safe,safe,10188,"t char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHype&operator=(const TGeoHype&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; Double_tRadiusHypeSq(Double_t z, Bool_t inner) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToHype(const Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensi",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:15927,Safety,safe,safe,15927,"e_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. T",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:16139,Safety,safe,safe,16139,"dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape p",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:20245,Safety,safe,safe,20245,"D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHype(); constructors. Int_t GetByteCount() const; {return 64;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetStIn() const; {return fStIn;}. Double_t GetStOut() const; {return fStOut;}. Bool_t HasInner() const; {return !TestShapeBit(kGeoRSeg);}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 20/11/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:20281,Safety,safe,safe,20281,"D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoHype(); constructors. Int_t GetByteCount() const; {return 64;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetStIn() const; {return fStIn;}. Double_t GetStOut() const; {return fStOut;}. Bool_t HasInner() const; {return !TestShapeBit(kGeoRSeg);}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 20/11/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:2079,Testability,test,testNo,2079," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TB",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHype.html:15659,Testability,test,test,15659,"ToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(const Double_t* point, const Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t ia",MatchSource.WIKI,root/html534/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHype.html
https://root.cern/root/html534/TGeoHypeEditor.html:4603,Availability,error,error,4603,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHypeEditor.html
https://root.cern/root/html534/TGeoHypeEditor.html:4687,Availability,error,error,4687,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHypeEditor.html
https://root.cern/root/html534/TGeoHypeEditor.html:17926,Availability,mask,mask,17926,,MatchSource.WIKI,root/html534/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHypeEditor.html
https://root.cern/root/html534/TGeoHypeEditor.html:21468,Usability,undo,undoing,21468,"Frame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoHypeEditor.html
https://root.cern/root/html534/TGeoIdentity.html:6228,Availability,error,error,6228,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(O",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:8060,Availability,error,error,8060,"tity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:8144,Availability,error,error,8144,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:3100,Integrability,interface,interface,3100," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:6234,Integrability,message,message,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(O",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:6979,Modifiability,variab,variable,6979,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Er",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:484,Performance,optimiz,optimize,484,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:493,Performance,perform,performance,493,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:978,Performance,perform,performed,978,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:1704,Performance,perform,performed,1704,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:6211,Performance,perform,performed,6211,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(O",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIdentity.html:1717,Usability,simpl,simple,1717,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIdentity.html
https://root.cern/root/html534/TGeoIntersection.html:3023,Availability,error,error,3023,"const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; TGeoBoolNode::ThreadData_t&TGeoBool",MatchSource.WIKI,root/html534/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html
https://root.cern/root/html534/TGeoIntersection.html:3107,Availability,error,error,3107,"const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; TGeoBoolNode::ThreadData_t&TGeoBoolNode::GetThreadData() const; virtual const char*TObject::GetTitle() const; virtual U",MatchSource.WIKI,root/html534/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html
https://root.cern/root/html534/TGeoIntersection.html:2513,Safety,safe,safe,2513,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root/html534/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html
https://root.cern/root/html534/TGeoIntersection.html:2651,Safety,safe,safe,2651,"ar*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root/html534/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html
https://root.cern/root/html534/TGeoIntersection.html:9396,Safety,safe,safe,9396,"e preserved. void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ",MatchSource.WIKI,root/html534/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html
https://root.cern/root/html534/TGeoIntersection.html:9593,Safety,safe,safe,9593,"t(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html
https://root.cern/root/html534/TGeoIntersection.html:9844,Safety,safe,safety,9844,"t(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html
https://root.cern/root/html534/TGeoIsotope.html:1612,Availability,error,error,1612,"GeoIsotope(const char* name, Int_t z, Int_t n, Double_t a); virtual~TGeoIsotope(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TGeoIsotope*FindIsotope(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetA() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNa",MatchSource.WIKI,root/html534/TGeoIsotope.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIsotope.html
https://root.cern/root/html534/TGeoIsotope.html:1696,Availability,error,error,1696,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TGeoIsotope*FindIsotope(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetA() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html534/TGeoIsotope.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIsotope.html
https://root.cern/root/html534/TGeoIterator.html:3929,Modifiability,plugin,plugin,3929,"r, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector&); voidSkip(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Char",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:4476,Modifiability,plugin,plugin,4476, TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector&); voidSkip(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; Returns the path for the current node. void IncreaseArray(); Increase by 30 the size of the array. void Reset(TGeoVolume* top = 0); Resets the iterator for volume TOP. void SetTopName(const char* name); Set the top name for path. void Skip(); Stop iterating the current branch. The ,MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:5704,Modifiability,plugin,plugin,5704,"pPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; Returns the path for the current node. void IncreaseArray(); Increase by 30 the size of the array. void Reset(TGeoVolume* top = 0); Resets the iterator for volume TOP. void SetTopName(const char* name); Set the top name for path. void Skip(); Stop iterating the current branch. The iteration of the next node will; behave as if the branch starting from the current node (included) is not existing. void SetUserPlugin(TGeoIteratorPlugin* plugin); Set a plugin. Int_t GetIndex(); {return 0;}. TGeoIterator(); { }. Int_t GetLevel() const; {return fLevel;}. * GetUserPlugin() const; {return fPlugin;}. TGeoVolume * GetTopVolume() const; {return fTop;}. Int_t GetType() const; {return fType;}. void SetPluginAutoexec(Bool_t mode); {fPluginAutoexec = mode;}. void SetType(Int_t type); {fType = type;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:5719,Modifiability,plugin,plugin,5719,"pPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; Returns the path for the current node. void IncreaseArray(); Increase by 30 the size of the array. void Reset(TGeoVolume* top = 0); Resets the iterator for volume TOP. void SetTopName(const char* name); Set the top name for path. void Skip(); Stop iterating the current branch. The iteration of the next node will; behave as if the branch starting from the current node (included) is not existing. void SetUserPlugin(TGeoIteratorPlugin* plugin); Set a plugin. Int_t GetIndex(); {return 0;}. TGeoIterator(); { }. Int_t GetLevel() const; {return fLevel;}. * GetUserPlugin() const; {return fPlugin;}. TGeoVolume * GetTopVolume() const; {return fTop;}. Int_t GetType() const; {return fType;}. void SetPluginAutoexec(Bool_t mode); {fPluginAutoexec = mode;}. void SetType(Int_t type); {fType = type;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:2874,Performance,perform,perform,2874,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:1263,Testability,log,logical,1263," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:1344,Testability,log,logical,1344," TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a po",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:1504,Testability,log,logical,1504," will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-ov",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:1712,Testability,log,logical,1712," created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::Ad",MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIterator.html:4338,Usability,resume,resume,4338,GeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector&); voidSkip(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const;,MatchSource.WIKI,root/html534/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIterator.html
https://root.cern/root/html534/TGeoIteratorPlugin.html:2212,Availability,avail,available,2212,"A1_1 and the iteration type was 0, one can do:. next.SetType(1);; The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retreived:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. TGeoIterator::Reset(TGeoVolume *top);. Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=next())); if (name == node->GetVolume()->GetName()) return node->GetVolume();. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoIteratorPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html534/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIteratorPlugin.html
https://root.cern/root/html534/TGeoIteratorPlugin.html:3188,Availability,error,error,3188,,MatchSource.WIKI,root/html534/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIteratorPlugin.html
https://root.cern/root/html534/TGeoIteratorPlugin.html:3272,Availability,error,error,3272," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIteratorPlugin.html
https://root.cern/root/html534/TGeoIteratorPlugin.html:630,Performance,perform,perform,630,". TGeoIteratorPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoIteratorPlugin. class TGeoIteratorPlugin: public TObject. TGeoIterator. A geometry iterator that sequentially follows all nodes of the geometrical; hierarchy of a volume. The iterator has to be initiated with a top volume; pointer:. TGeoIterator next(myVolume);. One can use the iterator as any other in ROOT:. TGeoNode *node;; while ((node=next())) {. }. The iterator can perform 2 types of iterations that can be selected via:. next.SetType(Int_t type);. Here TYPE can be:; 0 (default) - 'first daughter next' behavior; 1 - iteration at the current level only. Supposing the tree structure looks like:. TOP ___ A_1 ___ A1_1 ___ A11_1; | | |___ A12_1; | |_____A2_1 ___ A21_1; | |___ A21_2; |___ B_1 ... The order of iteration for TYPE=0 is: A_1, A1_1, A11_1, A12_1, A2_1, A21_1,; A21_2, B_1, ...; The order of iteration for TYPE=1 is: A_1, B_1, ...; At any moment during iteration, TYPE can be changed. If the last iterated node; is for instance A1_1 and the iteration type was 0, one can do:. next.SetType(1);; The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retreived:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. TGeoIterator::Reset(TGeoVolume *top);. Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=ne",MatchSource.WIKI,root/html534/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoIteratorPlugin.html
https://root.cern/root/html534/TGeoManager.html:8219,Availability,down,down,8219,"*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt).",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:8485,Availability,down,down,8485,"rting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coo",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:10223,Availability,down,down,10223,"nates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. Only points; in visible nodes will be drawn. /*. */. 3. Raytracing.; Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; will shoot rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes will appear as segments; having the color of the touched node. Drawn geometry will be then made invisible; in order to enhance rays. /*. */. Function Members (Methods); public:. TGeoManager(); TGeoManager(const char* name, const char",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:13501,Availability,down,downwards,13501," 0, Double_t y = 0, Double_t z = 0, Option_t* option = """")MENU ; voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanGarbage(); virtual voidTNamed::Clear(Option_t* option = """"); voidClearAttributes()MENU ; voidClearNavigators(); voidClearOverlaps(); voidClearPhysicalNodes(Bool_t mustdelete = kFALSE); voidClearShape(const TGeoShape* shape); voidClearThreadData() const; static voidClearThreadsMap(); voidClearTracks(); virtual TObject*TNamed::Clone(const char* newname = """") const; voidCloseGeometry(Option_t* option = ""d""); virtual Int_tTNamed::Compare(const TObject* obj) const; voidConvertReflections(); virtual voidTNamed::Copy(TObject& named) const; voidCountLevels(); Int_tCountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); TGeoParallelWorld*CreateParallelWorld(const char* name); voidCreateThreadData() const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); voidDefaultAngles()MENU ; voidDefaultColors()MENU ; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableInactiveVolumes(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawCurrentPoint(Int_t color = 2)MENU ; voidDrawPath(const char* path, Option_t* option = """"); voidDrawTracks(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidEdit(Option_t* option = """")MENU ; voidEnableInactiveVolumes(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* ",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:14506,Availability,error,error,14506,"s, TGeoNode* skipnode); voidDefaultAngles()MENU ; voidDefaultColors()MENU ; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableInactiveVolumes(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawCurrentPoint(Int_t color = 2)MENU ; voidDrawPath(const char* path, Option_t* option = """"); voidDrawTracks(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidEdit(Option_t* option = """")MENU ; voidEnableInactiveVolumes(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExport(const char* filename, const char* name = """", Option_t* option = ""vg""); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoMaterial*FindDuplicateMaterial(const TGeoMaterial* mat) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObje",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:14590,Availability,error,error,14590,"voidTObject::Delete(Option_t* option = """")MENU ; voidDisableInactiveVolumes(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawCurrentPoint(Int_t color = 2)MENU ; voidDrawPath(const char* path, Option_t* option = """"); voidDrawTracks(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidEdit(Option_t* option = """")MENU ; voidEnableInactiveVolumes(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExport(const char* filename, const char* name = """", Option_t* option = ""vg""); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoMaterial*FindDuplicateMaterial(const TGeoMaterial* mat) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualGeoTrack*FindTrackWithId(I",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:28118,Availability,down,downwards,28118,", const char* target_vol = 0, Bool_t check_norm = kFALSE); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRefreshPhysicalNodes(Bool_t lock = kTRUE); voidRegisterMatrix(const TGeoMatrix* matrix); voidRemoveMaterial(Int_t index); voidRemoveNavigator(const TGeoNavigator* nav); Int_tReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); voidTObject::ResetBit(UInt_t f); voidResetState(); voidResetUserData(); voidRestoreMasterVolume()MENU ; Double_tSafety(Bool_t inside = kFALSE); TGeoNode*SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil = 1E-5, const char* g3path = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; voidSaveAttributes(const char* filename = ""tgeoatt.C"")MENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidSelectTrackingMedia(); TGeoPNEntry*SetAlignableEntry(const char* unique_name, const char* path, Int_t uid = -1); voidSetAllIndex(); voidSetAnimateTracks(Bool_t flag = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3)MENU ; voidSetCheckedNode(TGeoNode* node); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetClipping(Bool_t flag = kTRUE)MENU ; voidSetClippingShape(TGeoShape* clip); voidSetCurrentDirection(Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); Bool_tSetCurrentNavigator(Int_t index); voidSetCurrentPoint(Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); voidSetCurrentTrack(Int_t i); voidSetCurrentTrack(TVirtualGeoTrack* track); voidSetDrawExtraPaths(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetExplodedView(Int_t iopt =",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:47701,Availability,down,down,47701,"e the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*""); Draw animation of tracks. void DrawTracks(Option_t* option = """"); Draw tracks over the geometry, according to option. By default, only; primaries are drawn. See TGeoTrack::Draw() for additional options. void DrawPath(const char* path, Option_t* option = """"); Draw current path. void RandomPoints(const TGeoVolume* vol, Int_t npoints = 10000, Option_t* option = """"); Draw random points in the bounding box of a volume. void Test(Int_t npoints = 1000000, Option_t* option = """"); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path = """"); Geometry overlap checker based on sampling. void GetBranchNames(Int_t* names) const; Fill volume names of curr",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:51727,Availability,down,down,51727," the current point. This represent the distance; from POINT to the closest boundary. void SetVolumeAttribute(const char* name, const char* att, Int_t val); Set volume attributes in G3 style. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); Set factors that will ""bomb"" all translations in cartesian and cylindrical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expressio",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:52114,Availability,down,down,52114,"rical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attribute",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:52663,Availability,error,error,52663,"el; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (d",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:53151,Availability,down,downwards,53151,"reasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represen",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:53315,Availability,down,downwards,53315,"in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:66960,Availability,error,errors,66960,"""); return;}; Int_t *media = new Int_t[nmat];; memset(media, 0, nmat*sizeof(Int_t));; Int_t imedia = 1;; TGeoMaterial *mat, *matref;; mat = (TGeoMaterial*)fMaterials->At(0);; if (mat->GetMedia()) {; for (Int_t i=0; i<nmat; i++) {; mat = (TGeoMaterial*)fMaterials->At(i);; mat->Print();; }; return;; }; mat->SetMedia(imedia);; media[0] = imedia++;; mat->Print();; for (Int_t i=0; i<nmat; i++) {; mat = (TGeoMaterial*)fMaterials->At(i);; for (Int_t j=0; j<i; j++) {; matref = (TGeoMaterial*)fMaterials->At(j);; if (mat->IsEq(matref)) {; mat->SetMedia(media[j]);; break;; }; if (j==(i-1)) {; // different material; mat->SetMedia(imedia);; media[i] = imedia++;; mat->Print();; }; }; }. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); Classify a given point. See TGeoChecker::CheckPoint(). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optio",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:9713,Deployability,update,updates,9713,"e will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. ",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:43293,Deployability,continuous,continuous,43293,"Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY fl",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:43216,Energy Efficiency,energy,energy,43216,"erial * Mixture(const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation ",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:8565,Integrability,depend,depending,8565,"panded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visi",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:22843,Integrability,rout,rout,22843,"TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz); TGeoVolume*MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoVolume*MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoVolume*MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoVolume*MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); TGeoVolume*MakeGtra(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolume*MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoVolume*MakePara(const char* name, TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoVolume*MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); TGeoVolume*MakePcon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nz); TGeoVolume*MakePgon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoPhysicalNode*MakePhysicalNode(const char* path = 0); TGeoVolume*MakeSphere(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t themin = 0, Double_t themax = 180, Double_t phimin = 0, Double_t phimax = 360); TGeoVolume*MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TVirtualGeoTrack*MakeTrack(Int_t id, Int_t pdgcode, TObject* particle); TGeoVolume*MakeTrap(const char* name, TGeoMedium* medium,",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:33208,Integrability,message,messages,33208,"t_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoManager(const TGeoManager&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoManager&operator=(const TGeoManager&). private:. voidInit(); Bool_tInitArrayPNE() const; Bool_tInsertPNEId(Int_t uid, Int_t ientry); Bool_tIsLoopingVolumes() const; voidSetLoopVolumes(Bool_t flag = kTRUE); voidUpdateElements(); voidVoxelize(Option_t* option = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgLock! Lock preventing a second geometry to be loaded; static Int_tfgMaxDaughters! Maximum number of daughters; static Int_tfgMaxLevel! Maximum level in geometry; static Int_tfgMaxXtruVert! Maximum number of Xtru vertices; static Int_tfgVerboseLevel! Verbosity level for Info messages (no IO). private:. Bool_tfActivity! switch ON/OFF volume activity (default OFF - all volumes active)); TObjArray*fArrayPNE! array of phisical node entries; UChar_t*fBits! bits used for voxelization; TGeoShape*fClippingShape! clipping shape for raytracing; Bool_tfClosed! flag that geometry is closed; TGeoNavigator*fCurrentNavigator! current navigator; TVirtualGeoTrack*fCurrentTrack! current track; TGeoVolume*fCurrentVolume! current volume; Bool_tfDrawExtra! flag that the list of physical nodes has to be drawn; TGeoElementTable*fElementTable! table of elements; Int_tfExplodedViewexploded view mode; TGeoHMatrix*fGLMatrixmatrix to be used for view transformations; TObjArray*fGShapes! list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes provid",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:60181,Integrability,rout,rout,60181,"e pointing to a sphere shape with given medium. TGeoVolume * MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); Make in one step a volume pointing to a torus shape with given medium. TGeoVolume * MakeTube(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeTubs(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a tube segment shape with given medium.; The segment will be from phiStart to phiEnd, the angles are expressed in degree. TGeoVolume * MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Make in one step a volume pointing to a cone shape with given medium. TGeoVolume * MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a cone segment ",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:70565,Integrability,message,messages,70565,"ream an object of class TGeoManager. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this manager. Int_t Export(const char* filename, const char* name = """", Option_t* option = ""vg""); Export this geometry to a file. -Case 1: root file or root/xml file; if filename end with "".root"". The key will be named name; By default the geometry is saved without the voxelisation info.; Use option 'v"" to save the voxelisation info.; if filename end with "".xml"" a root/xml file is produced. -Case 2: C++ script; if filename end with "".C"". -Case 3: gdml file; if filename end with "".gdml""; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/geom/gdml. void LockGeometry(); Lock current geometry so that no other geometry can be imported. void UnlockGeometry(); Unlock current geometry. Bool_t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Bool",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:3985,Modifiability,inherit,inherits,3985," several other volumes),; every volume becoming a branch in this graph. Any volume in the logical graph; can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; All functionalities of the modeler will behave in this case as if only the; corresponding branch starting from this volume is the registered geometry. /*. */. A given volume can be positioned several times in the geometry. A volume; can be divided according default or user-defined patterns, creating automatically; the list of division nodes inside. The elementary volumes created during the; dividing process follow the same scheme as usual volumes, therefore it is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the sam",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:11103,Modifiability,enhance,enhance,11103,"oManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. Only points; in visible nodes will be drawn. /*. */. 3. Raytracing.; Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; will shoot rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes will appear as segments; having the color of the touched node. Drawn geometry will be then made invisible; in order to enhance rays. /*. */. Function Members (Methods); public:. TGeoManager(); TGeoManager(const char* name, const char* title); virtual~TGeoManager(); voidTObject::AbstractMethod(const char* method) const; Int_tAddMaterial(const TGeoMaterial* material); TGeoNavigator*AddNavigator(); Int_tAddOverlap(const TNamed* ovlp); Int_tAddShape(const TGeoShape* shape); Int_tAddTrack(TVirtualGeoTrack* track); Int_tAddTrack(Int_t id, Int_t pdgcode, TObject* particle = 0); Int_tAddTransformation(const TGeoMatrix* matrix); Int_tAddVolume(TGeoVolume* volume); voidAnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidBrowse(TBrowser* b); voidBuildDefaultMaterials(); virtual Bool_tcd(const char* path = """")MENU ; voidCdDown(Int_t index); voidCdNext(); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); voidCheckB",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:5617,Performance,cache,cache,5617," providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. Ther",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:5758,Performance,load,loaded,5758,"the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:6576,Performance,load,loaded,6576,"mes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will dis",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:32979,Performance,load,loaded,32979,"t_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoManager(const TGeoManager&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoManager&operator=(const TGeoManager&). private:. voidInit(); Bool_tInitArrayPNE() const; Bool_tInsertPNEId(Int_t uid, Int_t ientry); Bool_tIsLoopingVolumes() const; voidSetLoopVolumes(Bool_t flag = kTRUE); voidUpdateElements(); voidVoxelize(Option_t* option = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgLock! Lock preventing a second geometry to be loaded; static Int_tfgMaxDaughters! Maximum number of daughters; static Int_tfgMaxLevel! Maximum level in geometry; static Int_tfgMaxXtruVert! Maximum number of Xtru vertices; static Int_tfgVerboseLevel! Verbosity level for Info messages (no IO). private:. Bool_tfActivity! switch ON/OFF volume activity (default OFF - all volumes active)); TObjArray*fArrayPNE! array of phisical node entries; UChar_t*fBits! bits used for voxelization; TGeoShape*fClippingShape! clipping shape for raytracing; Bool_tfClosed! flag that geometry is closed; TGeoNavigator*fCurrentNavigator! current navigator; TVirtualGeoTrack*fCurrentTrack! current track; TGeoVolume*fCurrentVolume! current volume; Bool_tfDrawExtra! flag that the list of physical nodes has to be drawn; TGeoElementTable*fElementTable! table of elements; Int_tfExplodedViewexploded view mode; TGeoHMatrix*fGLMatrixmatrix to be used for view transformations; TObjArray*fGShapes! list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes provid",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:34897,Performance,multi-thread,multi-threading,34897," list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes providing fast search; THashList*fHashPNE-> hash list of phisical node entries; THashList*fHashVolumes! hash list of volumes providing fast search; Bool_tfIsGeomCleaning! flag to notify that the manager is being destructed; Bool_tfIsGeomReading! flag set when reading geometry; Bool_tfIsNodeSelectable! flag that nodes are the selected objects in pad rather than volumes; Int_t*fKeyPNEId[fSizePNEId] array of uid values for PN entries; Bool_tfLoopVolumes! flag volume lists loop; TGeoVolume*fMasterVolumemaster volume; TList*fMaterials-> list of materials; TObjArray*fMatrices-> list of local transformations; Bool_tfMatrixReflection! flag for GL reflections; Bool_tfMatrixTransform! flag for using GL matrix; Int_tfMaxThreads! Max number of threads; Int_tfMaxVisNodesmaximum number of visible nodes; TList*fMedia-> list of tracking media; Bool_tfMultiThread! Flag for multi-threading; Int_tfNLevelmaximum accepted level in geometry; Int_tfNNodestotal number of physical nodes; Int_tfNPNEIdnumber of PN entries having a unique ID; map<long,TGeoNavigatorArray*>fNavigators! Map between thread id's and navigator arrays; Int_t*fNodeIdArray! array of node id's; TObjArray*fNodes-> current branch of nodes; Int_tfNpdgnumber of different pdg's stored; Int_tfNsegmentsnumber of segments to approximate circles; Int_tfNtracksnumber of tracks; TObjArray*fOverlaps-> list of geometrical overlaps; TGeoVolume*fPaintVolume! volume currently painted; TVirtualGeoPainter*fPainter! current painter; TGeoParallelWorld*fParallelWorldParallel world; TStringfParticleName! particles to be drawn; TStringfPath! path to current node; Int_tfPdgId[1024]pdg conversion table; TObjArray*fPdgNames-> list of pdg names for tracks; Bool_tfPhiCutflag for phi cuts; Double_tfPhimax! highest range for phi cut; Double_tfPhimin! lowest range for phi cut; TObjArray*fPhysicalNodes-> list of physical nodes; TO",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:40100,Performance,cache,cache,40100,"r of threads for navigation. void ClearThreadData() const. void CreateThreadData() const; Create thread private data for all geometry objects. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread.; static __thread Int_t tid = -1;; if (tid > -1) return tid;. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START;",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:40184,Performance,cache,cache,40184,"const; Create thread private data for all geometry objects. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread.; static __thread Int_t tid = -1;; if (tid > -1) return tid;. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START; and having size STEP. The created volumes will have tracking; media ID=NUMED (if N",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:43417,Performance,perform,performed,43417," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:43465,Performance,perform,performed,43465," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:43512,Performance,perform,performed,43512," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:46014,Performance,cache,cache,46014,".; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accord",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:46503,Performance,perform,performance,46503," NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nod",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:46660,Performance,cache,cache,46660,"all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of ",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:46779,Performance,cache,cache,46779,"sualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPo",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:46983,Performance,cache,cache,46983,"n-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. void CountLevels(); Count maximum number of nodes per volume, maximum depth and maximum; number of xtru vertices. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*""); Draw animation of tracks. void DrawTra",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:52145,Performance,perform,performed,52145,"rical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attribute",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:71477,Performance,load,loaded,71477,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. TGeoParallelWorld * CreateParallelWorld(const char* name); Create a parallel world for prioritized navigation. This can be populated; with physical nodes and can be navigated independently using its API.; In case the flag SetUseParallelWorldNav is set, any navigation query in the; main geometry is checked against the parallel geometry, which gets priority; in case of overlaps with the ",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:80945,Performance,cache,cache,80945,"le_t* local, Double_t* master) const; --- point/vector reference frame conversion. {GetCurrentNavigator()->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return GetCurrentNavigator()->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return GetCurrentNavigator()->PushPath(startlevel);}. Bool_t PopPath(); {return GetCurrentNavigator()->PopPath();}. Bool_t PopPath(Int_t index); {return GetCurrentNavigator()->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return GetCurrentNavigator()->PushPoint(startlevel);}. Bool_t PopPoint(); {return GetCurrentNavigator()->PopPoint();}. Bool_t PopPoint(Int_t index); {return GetCurrentNavigator()->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return GetCurrentNavigator()->PopDummy(ipop);}. TGeoParallelWorld * GetParallelWorld() const; {return fParallelWorld;}. Bool_t IsParallelWorldNav() const; {return fUsePWNav;}. » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:80978,Performance,cache,cache,80978,"le_t* local, Double_t* master) const; --- point/vector reference frame conversion. {GetCurrentNavigator()->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {GetCurrentNavigator()->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {GetCurrentNavigator()->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return GetCurrentNavigator()->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return GetCurrentNavigator()->PushPath(startlevel);}. Bool_t PopPath(); {return GetCurrentNavigator()->PopPath();}. Bool_t PopPath(Int_t index); {return GetCurrentNavigator()->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return GetCurrentNavigator()->PushPoint(startlevel);}. Bool_t PopPoint(); {return GetCurrentNavigator()->PopPoint();}. Bool_t PopPoint(Int_t index); {return GetCurrentNavigator()->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return GetCurrentNavigator()->PopDummy(ipop);}. TGeoParallelWorld * GetParallelWorld() const; {return fParallelWorld;}. Bool_t IsParallelWorldNav() const; {return fUsePWNav;}. » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:416,Safety,detect,detector,416,". TGeoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoManager. class TGeoManager: public TNamed. General architecture. The new ROOT geometry package is a tool designed for building, browsing,; tracking and visualizing a detector geometry. The code is independent from; other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic c",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:1451,Safety,detect,detector,1451," other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic components used for building the logical hierarchy of the geometry; are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing;",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:50720,Safety,safe,safe,50720,"nst; Returns current depth to which geometry is drawn. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. TVirtualGeoTrack * FindTrackWithId(Int_t id) const; Search the track hierarchy to find the track with the; given id. if 'primsFirst' is true, then:; first tries TGeoManager::GetTrackOfId, then does a; recursive search if that fails. this would be faster; if the track is somehow known to be a primary. TVirtualGeoTrack * GetTrackOfId(Int_t id) const; Get track with a given ID. TVirtualGeoTrack * GetParentTrackOfId(Int_t id) const; Get parent track with a given ID. Int_t GetTrackIndex(Int_t id) const; Get index for track id, -1 if not found. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void DefaultColors(); Set default volume colors according to A of material. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SetVolumeAttribute(const char* name, const char* att, Int_t val); Set volume attributes in G3 style. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); Set factors that will ""bomb"" all translations in cartesian and cylindrical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:52890,Safety,avoid,avoid,52890,"et visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """",",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:54376,Safety,safe,safe,54376,"and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the ",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:54487,Safety,safe,safety,54487,"oundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNorma",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:54518,Safety,safe,safety,54518," boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a strai",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:4939,Security,access,accessible,4939,"th eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandat",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:5973,Security,validat,validated,5973,"to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference f",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:7686,Security,access,access,7686,"trude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:7977,Security,access,accessed,7977," TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *p",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:9802,Security,access,accessible,9802,"he clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. Only points; in visible nodes will be drawn. /*. */. 3. Raytracing.; Can be called from TGeoVol",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:34001,Security,hash,hash,34001,,MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:34072,Security,hash,hash,34072,,MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:34132,Security,hash,hash,34132,,MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:71556,Security,access,access,71556,"unction).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. TGeoParallelWorld * CreateParallelWorld(const char* name); Create a parallel world for prioritized navigation. This can be populated; with physical nodes and can be navigated independently using its API.; In case the flag SetUseParallelWorldNav is set, any navigation query in the; main geometry is checked against the parallel geometry, which gets priority; in case of overlaps with the main geometry volumes. void SetUseParallelWorldNav(Bool_t flag); Activate/deactivate u",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:2033,Testability,log,logical,2033,"d; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic components used for building the logical hierarchy of the geometry; are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing; a volume. The geometrical transformation hold by nodes is always defined with; respect to their mother (relative positioning). Reflection matrices are allowed.; All volumes have to be fully aware of their containees when the geometry is; closed. They will build aditional structures (voxels) in order to fasten-up; the search algorithms. Finally, nodes can be regarded as bidirectional links; between containers and containees objects. The structure defined in this way is a graph structure since volumes are; replicable (same volume can become daughter node of several other volu",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:3116,Testability,log,logical,3116,"ned geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing; a volume. The geometrical transformation hold by nodes is always defined with; respect to their mother (relative positioning). Reflection matrices are allowed.; All volumes have to be fully aware of their containees when the geometry is; closed. They will build aditional structures (voxels) in order to fasten-up; the search algorithms. Finally, nodes can be regarded as bidirectional links; between containers and containees objects. The structure defined in this way is a graph structure since volumes are; replicable (same volume can become daughter node of several other volumes),; every volume becoming a branch in this graph. Any volume in the logical graph; can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; All functionalities of the modeler will behave in this case as if only the; corresponding branch starting from this volume is the registered geometry. /*. */. A given volume can be positioned several times in the geometry. A volume; can be divided according default or user-defined patterns, creating automatically; the list of division nodes inside. The elementary volumes created during the; dividing process follow the same scheme as usual volumes, therefore it is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:5494,Testability,log,logical,5494,"ne; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is clo",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:7367,Testability,log,logical,7367,"volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method.",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:7564,Testability,log,logical,7564,"ld not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the curren",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:7888,Testability,log,logical,7888,"rence frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a giv",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:12610,Testability,test,testNo,12610,,MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:67360,Testability,test,testNo,67360,"ials->At(i);; for (Int_t j=0; j<i; j++) {; matref = (TGeoMaterial*)fMaterials->At(j);; if (mat->IsEq(matref)) {; mat->SetMedia(media[j]);; break;; }; if (j==(i-1)) {; // different material; mat->SetMedia(imedia);; media[i] = imedia++;; mat->Print();; }; }; }. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); Classify a given point. See TGeoChecker::CheckPoint(). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per v",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:67450,Testability,test,test,67450," if (mat->IsEq(matref)) {; mat->SetMedia(media[j]);; break;; }; if (j==(i-1)) {; // different material; mat->SetMedia(imedia);; media[i] = imedia++;; mat->Print();; }; }; }. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); Classify a given point. See TGeoChecker::CheckPoint(). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optional boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing compute",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManager.html:4680,Usability,simpl,simple,4680,"is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class;",MatchSource.WIKI,root/html534/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManager.html
https://root.cern/root/html534/TGeoManagerEditor.html:7344,Availability,error,error,7344,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:7428,Availability,error,error,7428,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:21926,Availability,mask,mask,21926,"tton*fBSelShape2Button for selecting a shape; TGPictureButton*fBSelTopButton for selecting top volume; TGPictureButton*fBSelVolumeButton for selecting a volume; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGShutter*fCategoriesCategories shutter; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseGeometryButton for closing the geometry; TCanvas*fConnectedCanvasCanvas connected to SelectedSlot(); Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGTextButton*fEditMaterialButton for editing a material; TGTextButton*fEditMatrixButton for editing a matrix; TGTextButton*fEditMediumButton for editing a medium; TGTextButton*fEditShapeButton for editing selected shape; TGTextButton*fEditVolumeButton for editing a volume; TGComboBox*fElementListCombo box for elements; TGNumberEntry*fEntryDensityNumber entry for material density; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGTextButton*fExportButtonButton to export geometry; TGRadioButton*fExportOption[2]Export option buttons; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGeoManager*fGeometrySelected geometry manager; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tfIsModifiedFlag that manager was modified; TGLabel*fLSelMaterialSelected material label; TGLabel*fLSelMaterial2Selected material label; TGLabel*fLSelMatrixSelected matrix label; TGLabel*fLSelMediumSelected medium label; TGLabel*fLSelMedium2Selected medium label; TGLabel*fLSelShapeSelected shape label; TGLabel*fLSelShape2Selected shape label; TGLabel*fLSelTopSelected top volume; TGLabel*fLSelVolumeSelected volume label; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayou",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:1282,Integrability,depend,depending,1282,"GedFrame. TGeoManagerEditor. Editor for TGeoManager class. Provides also builder functionality for the; main TGeo objects: TGeoVolume, TGeoShape - derived classes, TGeoMaterial,; TGeoMatrix - derived transformations and TGeoMedium.; The GUI represents the main entry point for editing geometry classes. It; can be started either by:; 1. TGeoManager::Edit(). The method must be used when starting from a new; geometry.; 2. Left-click on the 40x40 pixels top-right corner of a pad containing a; drawn volume. The region is always accesible when drawing geometry elements; and allows also restoring the manager editor in the ""Style"" tab of the GED; editor anytime. The TGeoManager editor is vertically split by a TGShutter widget into the; following categories:. - General. This allows changing the name/title of the geometry, setting the; top volume, closing the geometry and saving the geometry in a file. The name; of the geometry file is formed by geometry_name.C/.root depending if the geometry; need to be saved as a C macro or a .root file.; - Shapes. The category provide buttons for creation of all supported shapes. The; new shape name is chosen by the interface, but can be changed from the shape; editor GUI. Existing shapes can be browsed and edited from the same category.; - Volumes. The category allows the creation of a new volume having a given name,; shape and medium. For creating a volume assembly only the name is relevant.; Existing volumes can be browsed or edited from this category.; - Materials. Allows creation of new materials/mixtures or editing existing ones.; - Media. The same for creation/editing of tracking media (materials having a set; of properties related to tracking); - Matrices. Allows creation of translations, rotations or combined transformations.; Existing matrices can also be browser/edited. Function Members (Methods); public:. TGeoManagerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = G",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:1471,Integrability,interface,interface,1471,"aterial,; TGeoMatrix - derived transformations and TGeoMedium.; The GUI represents the main entry point for editing geometry classes. It; can be started either by:; 1. TGeoManager::Edit(). The method must be used when starting from a new; geometry.; 2. Left-click on the 40x40 pixels top-right corner of a pad containing a; drawn volume. The region is always accesible when drawing geometry elements; and allows also restoring the manager editor in the ""Style"" tab of the GED; editor anytime. The TGeoManager editor is vertically split by a TGShutter widget into the; following categories:. - General. This allows changing the name/title of the geometry, setting the; top volume, closing the geometry and saving the geometry in a file. The name; of the geometry file is formed by geometry_name.C/.root depending if the geometry; need to be saved as a C macro or a .root file.; - Shapes. The category provide buttons for creation of all supported shapes. The; new shape name is chosen by the interface, but can be changed from the shape; editor GUI. Existing shapes can be browsed and edited from the same category.; - Volumes. The category allows the creation of a new volume having a given name,; shape and medium. For creating a volume assembly only the name is relevant.; Existing volumes can be browsed or edited from this category.; - Materials. Allows creation of new materials/mixtures or editing existing ones.; - Media. The same for creation/editing of tracking media (materials having a set; of properties related to tracking); - Matrices. Allows creation of translations, rotations or combined transformations.; Existing matrices can also be browser/edited. Function Members (Methods); public:. TGeoManagerEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TGeoManagerEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual v",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:29288,Integrability,interface,interface,29288,"ateTranslation(); Create a new translation. void DoCreateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:29373,Integrability,interface,interface,29373,"ateTranslation(); Create a new translation. void DoCreateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:29461,Integrability,interface,interface,29461,"ateTranslation(); Create a new translation. void DoCreateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:29549,Integrability,interface,interface,29549,"ateTranslation(); Create a new translation. void DoCreateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoManagerEditor.html:29635,Integrability,interface,interface,29635,"ateTranslation(); Create a new translation. void DoCreateRotation(); Create a new rotation. void DoCreateVolume(); Create a new volume. void DoCreateAssembly(); Create a new volume assembly. void DoCreateCombi(); Create a new translation + rotation. void DoSetTopVolume(); Set top volume for the geometry. void DoEditShape(); Slot for editing selected shape. void DoEditVolume(); Slot for editing selected volume. void DoEditMedium(); Slot for editing selected medium. void DoEditMaterial(); Slot for editing selected material. void DoEditMatrix(); Slot for editing selected matrix. void DoSelectMatrix(); Slot for selecting an existing matrix. void DoSelectShape(); Slot for selecting an existing shape. void DoSelectShape2(); Slot for selecting a shape for making a volume. void DoSelectMaterial(); Slot for selecting an existing material. void DoSelectMaterial2(); Slot for selecting an existing material and making a medium. void DoSelectMedium(); Slot for selecting an existing medium. void DoSelectMedium2(); Slot for selecting an existing medium for making a volume. void DoSelectVolume(); Slot for selecting an existing volume. void DoSelectTopVolume(); Slot for seting top geometry volume. void DoCloseGeometry(); Slot for closing the geometry. void ShowSelectShape(Bool_t show = kTRUE); Show/hide interface for shape selection. void ShowSelectVolume(Bool_t show = kTRUE); Show/hide interface for volume selection. void ShowSelectMaterial(Bool_t show = kTRUE); Show/hide interface for material selection. void ShowSelectMedium(Bool_t show = kTRUE); Show/hide interface for medium selection. void ShowSelectMatrix(Bool_t show = kTRUE); Show/hide interface for matrix selection. void LoadLib(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoManagerEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoManagerEditor.html
https://root.cern/root/html534/TGeoMaterial.html:1819,Availability,error,error,1819,"re); virtual~TGeoMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tCoulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; TGeoElement*GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*GetCerenkovProperties() const; virtual Int_tGetDefaultColor() const; virtual Double_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoElement*GetElement(Int_t i = 0) const; virtual voidGetElementProp(Double_t& a, Double_t& z, Double_t& w, Int_t i = 0); virtual ",MatchSource.WIKI,root/html534/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html
https://root.cern/root/html534/TGeoMaterial.html:1903,Availability,error,error,1903,"re); virtual~TGeoMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tCoulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; TGeoElement*GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*GetCerenkovProperties() const; virtual Int_tGetDefaultColor() const; virtual Double_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoElement*GetElement(Int_t i = 0) const; virtual voidGetElementProp(Double_t& a, Double_t& z, Double_t& w, Int_t i = 0); virtual ",MatchSource.WIKI,root/html534/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html
https://root.cern/root/html534/TGeoMaterial.html:9916,Deployability,release,released,9916,"tle; TGeoExtension*fUserExtension! Transient user-defined extension to materials; Double_tfZZ of material. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterial(); Default constructor. TGeoMaterial(const char* name); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, Double_t radlen = 0, Double_t intlen = 0); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, TGeoMaterial::EGeoMaterialState state, Double_t temperature = STP_temperature, Double_t pressure = STP_pressure); Constructor with state, temperature and pressure. TGeoMaterial(const char* name, TGeoElement* elem, Double_t rho); constructor. TGeoMaterial(const TGeoMaterial& ); copy constructor. TGeoMaterial& operator=(const TGeoMaterial& ); assignment operator. ~TGeoMaterial(); Destructor. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPo",MatchSource.WIKI,root/html534/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html
https://root.cern/root/html534/TGeoMaterial.html:10244,Deployability,release,released,10244,"e_t z, Double_t rho, Double_t radlen = 0, Double_t intlen = 0); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, TGeoMaterial::EGeoMaterialState state, Double_t temperature = STP_temperature, Double_t pressure = STP_pressure); Constructor with state, temperature and pressure. TGeoMaterial(const char* name, TGeoElement* elem, Double_t rho); constructor. TGeoMaterial(const TGeoMaterial& ); copy constructor. TGeoMaterial& operator=(const TGeoMaterial& ); assignment operator. ~TGeoMaterial(); Destructor. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengths. If the values are negative, their absolute value; is taken, otherwise radlen is recomputed using G3 formula. Double_t Coulomb(Double_t z); static function; Compute Coulomb correctio",MatchSource.WIKI,root/html534/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html
https://root.cern/root/html534/TGeoMaterial.html:10005,Integrability,interface,interface,10005," Members; Includes; Libraries. Function documentation; TGeoMaterial(); Default constructor. TGeoMaterial(const char* name); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, Double_t radlen = 0, Double_t intlen = 0); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, TGeoMaterial::EGeoMaterialState state, Double_t temperature = STP_temperature, Double_t pressure = STP_pressure); Constructor with state, temperature and pressure. TGeoMaterial(const char* name, TGeoElement* elem, Double_t rho); constructor. TGeoMaterial(const TGeoMaterial& ); copy constructor. TGeoMaterial& operator=(const TGeoMaterial& ); assignment operator. ~TGeoMaterial(); Destructor. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengt",MatchSource.WIKI,root/html534/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html
https://root.cern/root/html534/TGeoMaterial.html:10333,Integrability,interface,interface,10333,"erial::EGeoMaterialState state, Double_t temperature = STP_temperature, Double_t pressure = STP_pressure); Constructor with state, temperature and pressure. TGeoMaterial(const char* name, TGeoElement* elem, Double_t rho); constructor. TGeoMaterial(const TGeoMaterial& ); copy constructor. TGeoMaterial& operator=(const TGeoMaterial& ); assignment operator. ~TGeoMaterial(); Destructor. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengths. If the values are negative, their absolute value; is taken, otherwise radlen is recomputed using G3 formula. Double_t Coulomb(Double_t z); static function; Compute Coulomb correction for pair production and Brem; REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78; FORMULA 2.7.17. Bool_t IsEq(const TGeoMaterial* other) const; return tru",MatchSource.WIKI,root/html534/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html
https://root.cern/root/html534/TGeoMaterial.html:11899,Integrability,interface,interface,11899,"g new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengths. If the values are negative, their absolute value; is taken, otherwise radlen is recomputed using G3 formula. Double_t Coulomb(Double_t z); static function; Compute Coulomb correction for pair production and Brem; REFERENCE : EGS MANUAL SLAC 210 - UC32 - JUNE 78; FORMULA 2.7.17. Bool_t IsEq(const TGeoMaterial* other) const; return true if the other material has the same physical properties. void Print(Option_t* option = """") const; print characteristics of this material. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". Int_t GetDefaultColor() const; Get some default color related to this material. TGeoElement * GetElement(Int_t i = 0) const; Get a pointer to the element this material is made of. void GetElementProp(Double_t& a, Double_t& z, Double_t& w, Int_t i = 0); Single interface to get element properties. Int_t GetIndex(); Retreive material index in the list of materials. TGeoMaterial * DecayMaterial(Double_t time, Double_t precision = 0.001); Create the material representing the decay product of this material at a; given time. The precision represent the minimum cumulative branching ratio for; which decay products are still taken into account. void FillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); Fills a user array with all the elements deriving from the possible; decay of the top element composing the mixture. Each element contained; by <population> may be a radionuclide having a Bateman solution attached.; The precision represent the minimum cumulative branching ratio for; which decay products are still taken into account.; To visualize the time evolution of each decay product one can use:; TGeoElement *elem = population->At(index);; TGeoElementRN *elemrn = 0;; if (elem->IsRadioNuclide()) elemrn = (TG",MatchSource.WIKI,root/html534/TGeoMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html
https://root.cern/root/html534/TGeoMaterialDialog.html:5142,Availability,error,error,5142,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TGeoMaterialDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterialDialog.html
https://root.cern/root/html534/TGeoMaterialDialog.html:5226,Availability,error,error,5226,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TGeoMaterialDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterialDialog.html
https://root.cern/root/html534/TGeoMaterialDialog.html:19825,Availability,mask,mask,19825,,MatchSource.WIKI,root/html534/TGeoMaterialDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterialDialog.html
https://root.cern/root/html534/TGeoMaterialEditor.html:4718,Availability,error,error,4718,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterialEditor.html
https://root.cern/root/html534/TGeoMaterialEditor.html:4802,Availability,error,error,4802,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterialEditor.html
https://root.cern/root/html534/TGeoMaterialEditor.html:17821,Availability,mask,mask,17821,,MatchSource.WIKI,root/html534/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterialEditor.html
https://root.cern/root/html534/TGeoMaterialEditor.html:21608,Energy Efficiency,charge,charge,21608,"GFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMaterialEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for material editor. ~TGeoMaterialEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected material. void DoName(); Perform name change. void DoA(); Slot for atomic mass. void DoZ(); Slot for charge. void DoState(Int_t state); Slot for material state. void DoTemperature(); Slot for material temperature. void DoPressure(); Slot for material pressure. void DoDensity(); Slot for density.; fMatDensity->SetNumber(fDensityi);. void DoRadAbs(); Slot for radiation/absorbtion length. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for cancelling current modifications. void DoModified(); Slot for signaling modifications. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoMaterialEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMaterialEditor.html
https://root.cern/root/html534/TGeoMatrix.html:6218,Availability,error,error,6218,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* m",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:7126,Availability,avail,available,7126,"ruction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voi",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:8096,Availability,error,error,8096,,MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:8180,Availability,error,error,8180,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidGetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_t",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:3090,Integrability,interface,interface,3090," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:6224,Integrability,message,message,6224,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* m",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:6969,Modifiability,variab,variable,6969,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObje",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:474,Performance,optimiz,optimize,474,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:483,Performance,perform,performance,483,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:968,Performance,perform,performed,968,". TGeoMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMatrix. class TGeoMatrix: public TNamed. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sca",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:1694,Performance,perform,performed,1694,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:6201,Performance,perform,performed,6201,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoMatrix(); voidTObject::AbstractMethod(const char* m",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrix.html:1707,Usability,simpl,simple,1707,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrix.html
https://root.cern/root/html534/TGeoMatrixDialog.html:5132,Availability,error,error,5132,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TGeoMatrixDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrixDialog.html
https://root.cern/root/html534/TGeoMatrixDialog.html:5216,Availability,error,error,5216,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TGeoMatrixDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrixDialog.html
https://root.cern/root/html534/TGeoMatrixDialog.html:19815,Availability,mask,mask,19815,,MatchSource.WIKI,root/html534/TGeoMatrixDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMatrixDialog.html
https://root.cern/root/html534/TGeoMCGeometry.html:1487,Availability,error,error,1487,"st char* title, Bool_t g3CompatibleVolumeNames = false); virtual~TGeoMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); virtual Bool_tGetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); virtual const char*TNamed::GetName() const;",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:1571,Availability,error,error,1571,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Bool_tGetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); virtual Bool_tGetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:19436,Availability,error,error,19436," i-th daughters of the volume specified by volName; According to A. Morsch' G3toRoot class. Int_t VolId2Mate(Int_t id) const. Return material number for a given volume id. Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Returns the Transformation matrix between the volume specified; by the path volumePath and the Top or mater volume. The format; of the path volumePath is as follows (assuming ALIC is the Top volume); ""/ALIC_1/DDIP_1/S05I_2/S05H_1/S05G_3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume na",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:19868,Availability,error,error,19868,"3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& ",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:20785,Availability,error,errors,20785,"he; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Re",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:21808,Availability,error,errors,21808,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:12499,Deployability,continuous,continuous,12499,"le_t* a, Double_t* z, Double_t dens, Int_t nlmat, Double_t* wmat). Defines mixture OR COMPOUND IMAT as composed by; THE BASIC NLMAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 i",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:21570,Deployability,continuous,continuous,21570,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:12422,Energy Efficiency,energy,energy,12422," weigths. void Mixture(Int_t& kmat, const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nlmat, Double_t* wmat). Defines mixture OR COMPOUND IMAT as composed by; THE BASIC NLMAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; if",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:13222,Energy Efficiency,energy,energy,13222,"ensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const cha",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:21540,Energy Efficiency,energy,energy,21540,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:360,Integrability,interface,interface,360,". TGeoMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TGeoMCGeometry. class TGeoMCGeometry: public TVirtualMCGeometry. Implementation of the TVirtualMCGeometry interface; for building TGeo geometry. Function Members (Methods); public:. TGeoMCGeometry(); TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false); virtual~TGeoMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:12623,Performance,perform,performed,12623,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:12671,Performance,perform,performed,12671,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:12718,Performance,perform,performed,12718,"MAT materials defined by arrays A,Z and WMAT. If NLMAT > 0 then wmat contains the proportion by; weights of each basic material in the mixture. If nlmat < 0 then WMAT contains the number of atoms; of a given kind into the molecule of the COMPOUND; In this case, WMAT in output is changed to relative; weigths. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Dou",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:13422,Performance,perform,performed,13422,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:13470,Performance,perform,performed,13470,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:13517,Performance,perform,performed,13517,"t in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Double_t* ubuf, Int_t nbuf). kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuos processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ). krot rotation matrix number assigned; theta1 polar angle for axis i; phi1 azimuthal angle for axis i; theta2 polar angle for axis ii; phi2 azimuthal angle for axis ii; theta3 polar angle for axis iii; phi3 azimuthal angle for axis iii. it defines the rotation matrix number irot. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. It creates a new volume in the JVOLUM data structure. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t np). NAME Volume name; SHAPE Volume type; NUMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector conta",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:15624,Performance,perform,performed,15624,"eate a new volume by dividing an existing one. NAME Volume name; MOTHER Mother volume name; NDIV Number of divisions; IAXIS Axis value. X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.; It divides a previously defined volume. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed). Create a new volume by dividing an existing one. Divides mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char*",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:16097,Performance,perform,performed,16097,"lue c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly). Position a volume into an existing one. NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ONLY ONLY/MANY flag. It positions a previously defined vol",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:15614,Testability,test,tests,15614,"eate a new volume by dividing an existing one. NAME Volume name; MOTHER Mother volume name; NDIV Number of divisions; IAXIS Axis value. X,Y,Z of CAXIS will be translated to 1,2,3 for IAXIS.; It divides a previously defined volume. void Gsdvn2(const char* name, const char* mother, Int_t ndiv, Int_t iaxis, Double_t c0i, Int_t numed). Create a new volume by dividing an existing one. Divides mother into ndiv divisions called name; along axis iaxis starting at coordinate value c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char*",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:16087,Testability,test,tests,16087,"lue c0.; the new volume created will be medium number numed. void Gsdvt(const char* name, const char* mother, Double_t step, Int_t iaxis, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS in steps of STEP. If not exactly divisible; will make as many as possible and will centre them; with respect to the mother. Divisions will have medium; number NUMED. If NUMED is 0, NUMED of MOTHER is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsdvt2(const char* name, const char* mother, Double_t step, Int_t iaxis, Double_t c0, Int_t numed, Int_t ndvmx). Create a new volume by dividing an existing one. Divides MOTHER into divisions called NAME along; axis IAXIS starting at coordinate value C0 with step; size STEP.; The new volume created will have medium number NUMED.; If NUMED is 0, NUMED of mother is taken.; NDVMX is the expected maximum number of divisions; (If 0, no protection tests are performed). void Gsord(const char* name, Int_t iax). Flags volume CHNAME whose contents will have to be ordered; along axis IAX, by setting the search flag to -IAX; IAX = 1 X axis; IAX = 2 Y axis; IAX = 3 Z axis; IAX = 4 Rxy (static ordering only -> GTMEDI); IAX = 14 Rxy (also dynamic ordering -> GTNEXT); IAX = 5 Rxyz (static ordering only -> GTMEDI); IAX = 15 Rxyz (also dynamic ordering -> GTNEXT); IAX = 6 PHI (PHI=0 => X axis); IAX = 7 THETA (THETA=0 => Z axis). void Gspos(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, const char* konly). Position a volume into an existing one. NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ONLY ONLY/MANY flag. It positions a previously defined vol",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:19404,Testability,log,logical,19404," i-th daughters of the volume specified by volName; According to A. Morsch' G3toRoot class. Int_t VolId2Mate(Int_t id) const. Return material number for a given volume id. Bool_t GetTransformation(const TString& volumePath, TGeoHMatrix& matrix); Returns the Transformation matrix between the volume specified; by the path volumePath and the Top or mater volume. The format; of the path volumePath is as follows (assuming ALIC is the Top volume); ""/ALIC_1/DDIP_1/S05I_2/S05H_1/S05G_3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume na",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMCGeometry.html:19828,Testability,log,logical,19828,"3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& ",MatchSource.WIKI,root/html534/TGeoMCGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html
https://root.cern/root/html534/TGeoMedium.html:2132,Availability,error,error,2132,"_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); virtual~TGeoMedium(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetId() const; TGeoMaterial*GetMaterial() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParam(Int_t i) const; char*GetPointerName() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handl",MatchSource.WIKI,root/html534/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMedium.html
https://root.cern/root/html534/TGeoMedium.html:2216,Availability,error,error,2216,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetId() const; TGeoMaterial*GetMaterial() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParam(Int_t i) const; char*GetPointerName() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Inf",MatchSource.WIKI,root/html534/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMedium.html
https://root.cern/root/html534/TGeoMedium.html:861,Integrability,interface,interfaces,861,". TGeoMedium. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoMedium. class TGeoMedium: public TNamed. Media are used to store properties related to tracking and which are useful; only when using geometry with a particle transport MC package (via VMC). One; may define several tracking media for a given material. The media ID are user; defined values that are not used by the geometry package. In case geometry; is used via VMC (in GEANT) these numbers are overwritten, so one can only; rely on these values after gMC->FinishGeometry() is called.; The media parameters are inspired from GEANT3 and the values defined make sense; in context of GEANT (3 but also 4) or FLUKA interfaces. Function Members (Methods); public:. TGeoMedium(); TGeoMedium(const char* name, Int_t numed, const TGeoMaterial* mat, Double_t* params = 0); TGeoMedium(const char* name, Int_t numed, Int_t imat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); virtual~TGeoMedium(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject",MatchSource.WIKI,root/html534/TGeoMedium.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMedium.html
https://root.cern/root/html534/TGeoMediumDialog.html:5132,Availability,error,error,5132,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TGeoMediumDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMediumDialog.html
https://root.cern/root/html534/TGeoMediumDialog.html:5216,Availability,error,error,5216,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TGeoMediumDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMediumDialog.html
https://root.cern/root/html534/TGeoMediumDialog.html:19815,Availability,mask,mask,19815,,MatchSource.WIKI,root/html534/TGeoMediumDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMediumDialog.html
https://root.cern/root/html534/TGeoMediumEditor.html:4769,Availability,error,error,4769,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMediumEditor.html
https://root.cern/root/html534/TGeoMediumEditor.html:4853,Availability,error,error,4853,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMediumEditor.html
https://root.cern/root/html534/TGeoMediumEditor.html:17890,Availability,mask,mask,17890,,MatchSource.WIKI,root/html534/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMediumEditor.html
https://root.cern/root/html534/TGeoMediumEditor.html:22153,Usability,undo,undoing,22153,"ackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoMediumEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMediumEditor.html
https://root.cern/root/html534/TGeometry.html:3337,Availability,error,error,3337,"try(const char* name, const char* title); virtual~TGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; Int_tGeomLevel() const; static TObjArray*Get(const char* name); Float_tGetBomb() const; TRotMatrix*GetCurrentMatrix() const; TNode*GetCurrentNode() const; TRotMatrix*GetCurrentPosition(Double_t* x, Double_t* y, Double_t* z) const; TRotMatrix*GetCurrentPosition(Float_t* x, Float_t* y, Float_t* z) const; Bool_tGetCurrentReflection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; THashList*GetListOfMaterials() const; THashList*GetListOfMatrices() const; TList*GetListOfNodes() const; THashList*GetListOfShapes() cons",MatchSource.WIKI,root/html534/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeometry.html
https://root.cern/root/html534/TGeometry.html:3421,Availability,error,error,3421,"Method(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; Int_tGeomLevel() const; static TObjArray*Get(const char* name); Float_tGetBomb() const; TRotMatrix*GetCurrentMatrix() const; TNode*GetCurrentNode() const; TRotMatrix*GetCurrentPosition(Double_t* x, Double_t* y, Double_t* z) const; TRotMatrix*GetCurrentPosition(Float_t* x, Float_t* y, Float_t* z) const; Bool_tGetCurrentReflection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; THashList*GetListOfMaterials() const; THashList*GetListOfMatrices() const; TList*GetListOfNodes() const; THashList*GetListOfShapes() const; TMaterial*GetMaterial(const char* name) const; TMaterial*GetMaterialByNumber(Int_",MatchSource.WIKI,root/html534/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeometry.html
https://root.cern/root/html534/TGeometry.html:366,Safety,detect,detector,366,". TGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a ",MatchSource.WIKI,root/html534/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeometry.html
https://root.cern/root/html534/TGeometry.html:550,Safety,detect,detector,550,". TGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a ",MatchSource.WIKI,root/html534/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeometry.html
https://root.cern/root/html534/TGeometry.html:1030,Safety,detect,detector,1030,"ks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TGeometry. class TGeometry: public TNamed. T G E O M E T R Y description. The Geometry class describes the geometry of a detector.; The current implementation supports the GEANT3 style description.; A special program provided in the ROOT utilities (toroot) can be used; to automatically translate a GEANT detector geometry into a ROOT geometry. a Geometry object is entered into the list of geometries into the; ROOT main object (see TROOT description) when the TGeometry; constructor is invoked.; Several geometries may coexist in memory. A Geometry object consist of the following linked lists:; - the TMaterial list (material definition only).; - the TRotmatrix list (Rotation matrices definition only).; - the TShape list (volume definition only).; - the TNode list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a subsequent session, s",MatchSource.WIKI,root/html534/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeometry.html
https://root.cern/root/html534/TGeometry.html:2021,Usability,simpl,simply,2021," list assembling all detector elements. Only the Build and Draw functions for a geometry are currently supported. The conversion program from Geant to Root has been added in the list; of utilities in utils directory.(see g2root); The executable module of g2root can be found in $ROOTSYS/bin/g2root. To use this conversion program, type the shell command:; g2root geant_rzfile macro_name. for example; g2root na49.geom na49.C; will convert the GEANT RZ file na49.geom into a ROOT macro na49.C. To generate the Geometry structure within Root, do:; Root > .x na49.C; Root > na49.Draw(); Root > wh.x3d() (this invokes the 3-d Root viewver); Root > TFile gna49(""na49.root"",""NEW"") //open a new root file; Root > na49.Write() //Write the na49 geometry structure; Root > gna49.Write() //Write all keys (in this case only one); Note: all keys are also written on closing of the file, gna49.Close or; when the program exits, Root closes all open files correctly.; Once this file has been written, in a subsequent session, simply do:; Root > TFile gna49(""na49.root""); Root > na49.Draw(). The figure below shows the geometry above using the x3d viewer.; This x3d viewver is invoked by selecting ""View x3d"" in the View menu; of a canvas (See example of this tool bar in TCanvas). /*. */. Function Members (Methods); public:. TGeometry(); TGeometry(const char* name, const char* title); virtual~TGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Op",MatchSource.WIKI,root/html534/TGeometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeometry.html
https://root.cern/root/html534/TGeoMixture.html:1886,Availability,error,error,1886,"ndPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tTGeoMaterial::Coulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); voidDefineElement(Int_t iel, TGeoElement* elem, Double_t weight); voidDefineElement(Int_t iel, Int_t z, Int_t natoms); voidDefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTGeoMaterial::GetA() const; Double_t*GetAmixt() const; TGeoElement*TGeoMaterial::GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*TGeoMaterial::GetCerenkovProperties() const; virtual Int_tTGeoMaterial::GetDefaultColor() const; virtual Double_tTGeoMaterial::GetDensity() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html534/TGeoMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMixture.html
https://root.cern/root/html534/TGeoMixture.html:1970,Availability,error,error,1970,"ndPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static Double_tTGeoMaterial::Coulomb(Double_t z); virtual TGeoMaterial*DecayMaterial(Double_t time, Double_t precision = 0.001); voidDefineElement(Int_t iel, TGeoElement* elem, Double_t weight); voidDefineElement(Int_t iel, Int_t z, Int_t natoms); voidDefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillMaterialEvolution(TObjArray* population, Double_t precision = 0.001); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTGeoMaterial::GetA() const; Double_t*GetAmixt() const; TGeoElement*TGeoMaterial::GetBaseElement() const; virtual Int_tGetByteCount() const; virtual TObject*TGeoMaterial::GetCerenkovProperties() const; virtual Int_tTGeoMaterial::GetDefaultColor() const; virtual Double_tTGeoMaterial::GetDensity() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html534/TGeoMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMixture.html
https://root.cern/root/html534/TGeoMixtureEditor.html:5093,Availability,error,error,5093,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMixtureEditor.html
https://root.cern/root/html534/TGeoMixtureEditor.html:5177,Availability,error,error,5177,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMixtureEditor.html
https://root.cern/root/html534/TGeoMixtureEditor.html:18553,Availability,mask,mask,18553,,MatchSource.WIKI,root/html534/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMixtureEditor.html
https://root.cern/root/html534/TGeoMixtureEditor.html:23142,Usability,undo,undo,23142,"Blockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. virtual ~TGeoMixtureEditor(); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMixtureEditor.html
https://root.cern/root/html534/TGeoMixtureEditor.html:23223,Usability,undo,undoing,23223,"Blockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMixtureEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for mixture editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected mixture. void DoChkFraction(); Check button state changed for fraction. void DoChkNatoms(); Check button state changed for natoms. void DoFraction(); Fraction changed. void DoNatoms(); Natoms changed. void DoSelectElement(Int_t iel); Slot for selecting an element. void DoAddElem(); Slot for adding an element. No undo. void DoApply1(); Slot for applying modifications. void DoUndo1(); Slot for undoing all changes. void UpdateElements(); Update the list of elements in the TGCanvas. virtual ~TGeoMixtureEditor(); {}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoMixtureEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoMixtureEditor.html
https://root.cern/root/html534/TGeoNavigator.html:1609,Availability,down,downwards,1609," TGeoNavigator(); TGeoNavigator(TGeoManager* geom); virtual~TGeoNavigator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Bool_tcd(const char* path = """"); voidCdDown(Int_t index); voidCdDown(TGeoNode* node); voidCdNext(); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); Bool_tCheckPath(const char* path) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() cons",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:2159,Availability,error,error,2159,"TGeoNode* node); voidCdNext(); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); Bool_tCheckPath(const char* path) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) co",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:2243,Availability,error,error,2243,"ol_tCheckPath(const char* path) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) const; TGeoNodeCache*GetCache() const; const Double_t*GetCldir() const; const Double_t",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:7660,Availability,down,downwards,7660,"or delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidPopDummy(Int_t ipop = 9999); Bool_tPopPath(); Bool_tPopPath(Int_t index); Bool_tPopPoint(); Bool_tPopPoint(Int_t index); virtual voidTObject::Print(Option_t* option = """") const; Int_tPushPath(Int_t startlevel = 0); Int_tPushPoint(Int_t startlevel = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); voidSetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); TGeoNode*Step(Bool_t is_geom = kTRUE, Bo",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:12948,Availability,failure,failure,12948,"de; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volum",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:14361,Availability,down,downwards,14361,"eoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the c",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:17492,Availability,down,downwards,17492,"xt surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori.; Check if parallel world navigation is enabled. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLeve",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:10071,Performance,cache,cache,10071,,MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:10688,Performance,cache,cached,10688,,MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:12709,Performance,cache,cache,12709,"current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:13221,Performance,perform,performance,13221,"direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * Cr",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:13378,Performance,cache,cache,13378,"ion; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* s",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:13534,Performance,cache,cache,13534,"Navigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:13603,Performance,cache,cache,13603,"eoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr =",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:13736,Performance,cache,cache,13736,"global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified,",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:19517,Performance,cache,cache,19517,"t also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Int_t GetThreadId() const; {return fThreadId;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsS",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:19601,Performance,cache,cache,19601,"current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Int_t GetThreadId() const; {return fThreadId;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsStartSafe() const; {return fStartSafe;}. void SetStartSafe(Bool_t flag = kTRUE); {fS",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:24031,Performance,cache,cache,24031,"fety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel, fNmany);}. Bool_t PopPath(); {fCurrentOverlapping=fCache->PopState(fNmany); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPath(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Int_t PushPoint(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel,fNmany,fPoint);}. Bool_t PopPoint(); {fCurrentOverlapping=fCache->PopState(fNmany,fPoint); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel(); fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPoint(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index, f",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:24064,Performance,cache,cache,24064,"fety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel, fNmany);}. Bool_t PopPath(); {fCurrentOverlapping=fCache->PopState(fNmany); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPath(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel();fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Int_t PushPoint(Int_t startlevel = 0); {return fCache->PushState(fCurrentOverlapping, startlevel,fNmany,fPoint);}. Bool_t PopPoint(); {fCurrentOverlapping=fCache->PopState(fNmany,fPoint); fCurrentNode=fCache->GetNode(); fLevel=fCache->GetLevel(); fGlobalMatrix=fCache->GetCurrentMatrix();return fCurrentOverlapping;}. Bool_t PopPoint(Int_t index); {fCurrentOverlapping=fCache->PopState(fNmany,index, f",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:8275,Safety,safe,safe,8275,"tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); voidSetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t buf",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:8340,Safety,safe,safe,8340,"onst char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidResetAll(); voidTObject::ResetBit(UInt_t f); voidResetState(); Double_tSafety(Bool_t inside = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetCurrentDirection(const Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); voidSetCurrentPoint(const Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLastPoint(Double_t x, Double_t y, Double_t z); voidSetLastSafetyForPoint(Double_t safe, const Double_t* point); voidSetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); static voidTObject::SetObjectStat(Bool_t stat); voidSetOutside(Bool_t flag = kTRUE); voidSetStartSafe(Bool_t flag = kTRUE); voidSetStep(Double_t step); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); TGeoNode*Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTopToMaster(const Double_t* top, Double_t* master) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:11355,Safety,safe,safety,11355,ent node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoHMatrix*fDivMatrix! current local matrix of the selected division cell; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:11411,Safety,safe,safety,11411,ent node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoHMatrix*fDivMatrix! current local matrix of the selected division cell; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:11978,Safety,safe,safety,11978,ent node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoHMatrix*fDivMatrix! current local matrix of the selected division cell; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:12110,Safety,safe,safe,12110,ent node ; Bool_tfCurrentOverlapping! flags the type of the current node; TGeoVolume*fCurrentVolume! current volume; Double_tfDirection[3]! current direction; TGeoHMatrix*fDivMatrix! current local matrix of the selected division cell; TGeoNode*fForcedNode! current point is supposed to be inside this node; TGeoManager*fGeometry! current geometry; TGeoHMatrix*fGlobalMatrix! current pointer to cached global matrix; Bool_tfIsEntering! flag if current step just got into a new node; Bool_tfIsExiting! flag that current track is about to leave current node; Bool_tfIsNullStep! flag that last geometric step was null; Bool_tfIsOnBoundary! flag that current point is on some boundary; Bool_tfIsOutside! flag that current point is outside geometry; Bool_tfIsSameLocation! flag that a new point is in the same node as previous; Bool_tfIsStepEntering! flag that next geometric step will enter new volume; Bool_tfIsStepExiting! flaag that next geometric step will exit current volume; TGeoNode*fLastNode! last searched node; Double_tfLastPoint[3]! last point for which safety was computed; Double_tfLastSafety! last computed safety radius; Int_tfLevel! current geometry level;; Int_tfNextDaughterIndex! next daughter index after FindNextBoundary; TGeoNode*fNextNode! next node that will be crossed; Int_tfNmany! number of overlapping nodes on current branch; Double_tfNormal[3]! cosine of incident angle on current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node.,MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:15084,Safety,safe,safe,15084," into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. T",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:15195,Safety,safe,safety,15195,"y. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNo",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:15226,Safety,safe,safety,15226,"TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast norm",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:17264,Safety,safe,safe,17264,"g current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori.; Check if parallel world navigation is enabled. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; dir",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:17398,Safety,safe,safe,17398,". Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a straight line from a given point/direction.; Returns the normal vector cosines in the MASTER coordinate system. The dot; product of the normal and the current direction is positive defined. TGeoNode * InitTrack(const Double_t* point, const Double_t* dir); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. TGeoNode * InitTrack(Double_t x, Double_t y, Double_t z, Double_t nx, Double_t ny, Double_t nz); Initialize current point and current direction vector (normalized); in MARS. Return corresponding node. void ResetState(); Reset current state flags. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SafetyOverlaps(); Compute safe distance from the current point within an overlapping node. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori.; Check if parallel world navigation is enabled. TGeoNode * FindInCluster(Int_t* cluster, Int_t nc); Find a node inside a cluster of overlapping nodes. Current node must; be on top of all the nodes in cluster. Always nc>1. Int_t GetTouchedCluster(Int_t start, Double_t* point, Int_t* check_list, Int_t ncheck, Int_t* result); Make the cluster of overlapping nodes in a voxel, containing point in reference; of the mother. Returns number of nodes containing the point. Nodes should not be; offsets. TGeoNode * Step(Bool_t is_geom = kTRUE, Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed i",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:19138,Safety,safe,safety,19138,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:19178,Safety,safe,safety,19178,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:19202,Safety,safe,safe,19202,", Bool_t cross = kTRUE); Make a rectiliniar step of length fStep from current point (fPoint) on current; direction (fDirection). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t ",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:19299,Safety,safe,safe,19299,"n). If the step is imposed by geometry, is_geom flag; must be true (default). The cross flag specifies if the boundary should be; crossed in case of a geometry step (default true). Returns new node after step.; Set also on boundary condition. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() co",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:22990,Safety,safe,safe,22990,"urrentNode->GetVolume();}. const Double_t * GetCldirChecked() const; {return fCldirChecked;}. const Double_t * GetCldir() const; {return fCldir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGe",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:23033,Safety,safe,safe,23033,"urrentNode->GetVolume();}. const Double_t * GetCldirChecked() const; {return fCldirChecked;}. const Double_t * GetCldir() const; {return fCldir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGe",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:23122,Safety,safe,safe,23122,"ir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return ",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigator.html:23178,Safety,safe,safe,23178,"ir;}. TGeoHMatrix * GetDivMatrix() const; Double_t GetNormalChecked() const {return fNormalChecked;}. {return fDivMatrix;}. const Double_t * GetNormal() const; {return fNormal;}. Int_t GetLevel() const; {return fLevel;}. Int_t GetStackLevel() const; {return fCache->GetStackLevel();}. void SetCurrentPoint(const Double_t* point); {memcpy(fPoint,point,3*sizeof(Double_t));}. void SetCurrentPoint(Double_t x, Double_t y, Double_t z). void SetLastPoint(Double_t x, Double_t y, Double_t z). void SetCurrentDirection(const Double_t* dir); {memcpy(fDirection,dir,3*sizeof(Double_t));}. void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz). void SetCldirChecked(Double_t* dir); void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}. {memcpy(fCldirChecked, dir, 3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, const Double_t* point); {fLastSafety=safe; memcpy(fLastPoint,point,3*sizeof(Double_t));}. void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); {fLastSafety=safe; fLastPoint[0]=x; fLastPoint[1]=y, fLastPoint[2]=z;}. void LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCache->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCache->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCache->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCache->MasterToLocalBomb(master, local);}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}; --- stack manipulation. {return fCache;}. Int_t PushPath(Int_t startlevel = 0); {return ",MatchSource.WIKI,root/html534/TGeoNavigator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html
https://root.cern/root/html534/TGeoNavigatorArray.html:2935,Availability,error,error,2935,"lection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); TGeoNavigator*GetCurrentNavigator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetO",MatchSource.WIKI,root/html534/TGeoNavigatorArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigatorArray.html
https://root.cern/root/html534/TGeoNavigatorArray.html:3019,Availability,error,error,3019,"ame() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); TGeoNavigator*GetCurrentNavigator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const",MatchSource.WIKI,root/html534/TGeoNavigatorArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNavigatorArray.html
https://root.cern/root/html534/TGeoNode.html:3380,Availability,avail,available,3380,"efore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawOnly(Option_t* option = """"); voidDrawOverlaps(); virtual voidTObject::",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:4542,Availability,error,error,4542,,MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:4626,Availability,error,error,4626,,MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:14309,Deployability,release,released,14309,"ent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this volume. char * GetObjectInfo(Int_t px, Int_t py) const; Get node info for the browser. Bool_t IsOnScreen() const; check if this node is drawn. Assumes that this node is current. void InspectNode() const; Inspect this node. void CheckShapes(); check for wrong parameters in shapes. void DrawOnly(Option_t* option = """"); draw only this node independently of its vis options. void Draw(Option_t* option = """"); draw current node according to option. void DrawOverlaps(); Method drawing the overlap candidates with this node. void FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Fill array with node id. Recursive on node branch. Int_t FindNode(const TGeoNode* node, Int_t level); Search for a node within the branch of this one. void SaveAttributes(ostream& out); save attributes for this node. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the node. The node ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the node. The node ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). Bool_t MayOverlap(Int_",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:14629,Deployability,release,released,14629," wrong parameters in shapes. void DrawOnly(Option_t* option = """"); draw only this node independently of its vis options. void Draw(Option_t* option = """"); draw current node according to option. void DrawOverlaps(); Method drawing the overlap candidates with this node. void FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Fill array with node id. Recursive on node branch. Int_t FindNode(const TGeoNode* node, Int_t level); Search for a node within the branch of this one. void SaveAttributes(ostream& out); save attributes for this node. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the node. The node ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the node. The node ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). Bool_t MayOverlap(Int_t iother) const; Check the overlab between the bounding box of the node overlaps with the one; the brother with index IOTHER. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert the point coordinates from mother reference to local reference system. void MasterToLocalVect(const Double_t* master, D",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:16039,Deployability,A/B,A/B,16039,"delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). Bool_t MayOverlap(Int_t iother) const; Check the overlab between the bounding box of the node overlaps with the one; the brother with index IOTHER. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert the point coordinates from mother reference to local reference system. void MasterToLocalVect(const Double_t* master, Double_t* local) const; Convert a vector from mother reference to local reference system. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert the point coordinates from local reference system to mother reference. void LocalToMasterVect(const Double_t* local, Double_t* master) const; Convert a vector from local reference system to mother reference. void ls(Option_t* option = """") const; Print the path (A/B/C/...) to this node on stdout. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void PrintCandidates() const; print daughters candidates for containing current point; cd();. void PrintOverlaps() const; print possible overlapping nodes; if (!IsOverlapping()) {printf(""node %s is ONLY\n"", GetName()); return;}. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape. void SetOverlaps(Int_t* ovlp, Int_t novlp); set the list of overlaps for this node (ovlp must be created with operator new). void SetVisibility(Bool_t vis = kTRUE); Set visibility of the node (obsolete). void VisibleDaughters(Bool_t vis = kTRUE); Set visibility of the daughters (obsolete). void cd() const; {;}. Int_t GetByteCount() const; {return 44;}. TGeoNode * GetDaughter(Int_t ind) const; {return fVolume->GetNode(ind);}. TGeoMatrix * GetMatrix() const. Int_t GetColour() co",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:14398,Integrability,interface,interface,14398," the browser. Bool_t IsOnScreen() const; check if this node is drawn. Assumes that this node is current. void InspectNode() const; Inspect this node. void CheckShapes(); check for wrong parameters in shapes. void DrawOnly(Option_t* option = """"); draw only this node independently of its vis options. void Draw(Option_t* option = """"); draw current node according to option. void DrawOverlaps(); Method drawing the overlap candidates with this node. void FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Fill array with node id. Recursive on node branch. Int_t FindNode(const TGeoNode* node, Int_t level); Search for a node within the branch of this one. void SaveAttributes(ostream& out); save attributes for this node. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the node. The node ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the node. The node ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). Bool_t MayOverlap(Int_t iother) const; Check the overlab between the bounding box of the node overlaps with the one; the brother with index IOTHER. void MasterToLo",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:14718,Integrability,interface,interface,14718,"""); draw current node according to option. void DrawOverlaps(); Method drawing the overlap candidates with this node. void FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Fill array with node id. Recursive on node branch. Int_t FindNode(const TGeoNode* node, Int_t level); Search for a node within the branch of this one. void SaveAttributes(ostream& out); save attributes for this node. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the node. The node ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the node. The node ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). Bool_t MayOverlap(Int_t iother) const; Check the overlab between the bounding box of the node overlaps with the one; the brother with index IOTHER. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert the point coordinates from mother reference to local reference system. void MasterToLocalVect(const Double_t* master, Double_t* local) const; Convert a vector from mother reference to local reference system. void LocalToMaster(const Double_t* local, Double_t* master) con",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:2893,Performance,perform,perform,2893,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual voidcd() const; voidCheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:1282,Testability,log,logical,1282," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:1363,Testability,log,logical,1363," TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a po",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:1523,Testability,log,logical,1523," will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-ov",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNode.html:1731,Testability,log,logical,1731," created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::Ad",MatchSource.WIKI,root/html534/TGeoNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNode.html
https://root.cern/root/html534/TGeoNodeCache.html:1552,Availability,error,error,1552,"dTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildIdArray(); voidBuildInfoBranch(); Bool_tCdDown(Int_t index); Bool_tCdDown(TGeoNode* node); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillIdBranch(const Int_t* br, Int_t startlevel = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetBranch() const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) const; TGeoHMatrix*GetCurrentMatrix() const; Int_tGetCurrentNodeId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const Int_t*GetIdBranch() const; TGeoStateInfo*GetInfo(); Int_tGetLevel() const; TGeoStateInfo*GetMakePWInfo(Int_t nd); void*GetMatrices() const; TGeoNode*GetMother(Int_t up = 1) const; TGeoHMatrix*GetMoth",MatchSource.WIKI,root/html534/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeCache.html
https://root.cern/root/html534/TGeoNodeCache.html:1636,Availability,error,error,1636,"; voidBuildIdArray(); voidBuildInfoBranch(); Bool_tCdDown(Int_t index); Bool_tCdDown(TGeoNode* node); voidCdNode(Int_t nodeid); voidCdTop(); voidCdUp(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillIdBranch(const Int_t* br, Int_t startlevel = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetBranch() const; voidGetBranchNames(Int_t* names) const; voidGetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; voidGetBranchOnlys(Int_t* isonly) const; TGeoHMatrix*GetCurrentMatrix() const; Int_tGetCurrentNodeId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const Int_t*GetIdBranch() const; TGeoStateInfo*GetInfo(); Int_tGetLevel() const; TGeoStateInfo*GetMakePWInfo(Int_t nd); void*GetMatrices() const; TGeoNode*GetMother(Int_t up = 1) const; TGeoHMatrix*GetMotherMatrix(Int_t up = 1) const; virtual const char*TObject::GetName() const; TGeoNode*",MatchSource.WIKI,root/html534/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeCache.html
https://root.cern/root/html534/TGeoNodeCache.html:8870,Integrability,interface,interface,8870,"ntation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. TGeoStateInfo * GetMakePWInfo(Int_t nd); Get the PW info, if none create one. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active state. Compute global matrix. Bool_t CdDown(TGeoNode* node); Make daughter INDEX of current node the active state. Compute global matrix. void CdUp(); Make mother of current node the active state. Int_t GetCurrentNodeId() const; Returns a fixed ID for current physical node. Int_t GetNodeId() const; Get unique node id. void GetBranchNames(Int_t* names) const; Fill names with current branch volume names (4 char - used by GEANT3 interface). void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill copy numbers of current branch nodes. void GetBranchOnlys(Int_t* isonly) const; Fill copy numbers of current branch nodes. TGeoStateInfo * GetInfo(); Get next state info pointer. void ReleaseInfo(); Release last used state info pointer. const char * GetPath(); Returns the current geometry path. Int_t PushState(Bool_t ovlp, Int_t ntmany = 0, Int_t startlevel = 0, Double_t* point = 0); Push current state into heap. Bool_t PopState(Int_t& nmany, Double_t* point = 0); Pop next state/point from heap. Bool_t PopState(Int_t& nmany, Int_t level, Double_t* point = 0); Pop next state/point from heap and restore matrices starting from LEVEL. Bool_t RestoreState(Int_t& nmany, TGeoCacheState* state, Double_t* point = 0); Pop next state/point from a backed-up state. void LocalToMaster(const Double_t* local, Double_t* master) const; Local point converted to master ",MatchSource.WIKI,root/html534/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeCache.html
https://root.cern/root/html534/TGeoNodeCache.html:7657,Performance,cache,cache,7657,"nt_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TGeoNodeCache(const TGeoNodeCache&); TGeoNodeCache&operator=(const TGeoNodeCache&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCurrentIDunique ID of current node; Int_tfGeoCacheMaxLevelsmaximum supported number of levels; Int_tfGeoCacheStackSizemaximum size of the stack; Int_tfGeoInfoStackSizemaximum size of the stack of info states; Int_tfIdBranch[100]current branch of indices; Int_tfIndexindex in array of ID's; TGeoStateInfo**fInfoBranchcurrent branch of nodes; Int_tfInfoLevelcurrent level in the stack; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TGeoStateInfo*fPWInfo! State info for the parallel world; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. TGeoStateInfo * GetMakePWInfo(Int_t nd); Get the PW info, if none create one. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has",MatchSource.WIKI,root/html534/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeCache.html
https://root.cern/root/html534/TGeoNodeCache.html:8343,Performance,perform,performance,8343,"TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TGeoStateInfo*fPWInfo! State info for the parallel world; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. TGeoStateInfo * GetMakePWInfo(Int_t nd); Get the PW info, if none create one. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daughter INDEX of current node the active state. Compute global matrix. Bool_t CdDown(TGeoNode* node); Make daughter INDEX of current node the active state. Compute global matrix. void CdUp(); Make mother of current node the active state. Int_t GetCurrentNodeId() const; Returns a fixed ID for current physical node. Int_t GetNodeId() const; Get unique node id. void GetBranchNames(Int_t* names) const; Fill names with current branch volume names (4 char - used by GEANT3 interface). void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill copy numbers of current branch nodes. void GetBranchOnlys(Int_t* isonly) const; Fill copy numbers of current branch nodes. TGeoStateInfo * GetInfo(); Get next state info pointer. void ReleaseInfo(); Release last used state info pointer. const char * GetPath(); Returns the current geometry path. Int_t PushState(Bool_t ovlp, Int_t ntmany = 0, Int_t startlevel = 0, D",MatchSource.WIKI,root/html534/TGeoNodeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeCache.html
https://root.cern/root/html534/TGeoNodeEditor.html:4687,Availability,error,error,4687,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeEditor.html
https://root.cern/root/html534/TGeoNodeEditor.html:4771,Availability,error,error,4771,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeEditor.html
https://root.cern/root/html534/TGeoNodeEditor.html:18079,Availability,mask,mask,18079,,MatchSource.WIKI,root/html534/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeEditor.html
https://root.cern/root/html534/TGeoNodeEditor.html:21850,Usability,undo,undoing,21850,"tion; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeEditor.html
https://root.cern/root/html534/TGeoNodeMatrix.html:1713,Availability,error,error,1713,"1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); vo",MatchSource.WIKI,root/html534/TGeoNodeMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeMatrix.html
https://root.cern/root/html534/TGeoNodeMatrix.html:1797,Availability,error,error,1797,"hapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Int_tTGeoNode::FindNode(const TGeoNode* node, Int_t level); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tTGeoNode::GetColour() const; TGeoNode*TGeoNode::GetDaughter(Int_t ind) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoPatternFinder*TGeoNode::GetFinder() const; TGeoExtension*TGeoNode::GetFWExtension() const; virtual const char*TObject::GetIconName() const; virtual Int_tTGeoNode::GetIndex() const; virtual TGeoMatrix*GetMatrix() const; TGeoMedium*TGeoNode::GetMedium() const; TGeoVolume*TGeoNode::GetMotherVolume() const; virtual const char*T",MatchSource.WIKI,root/html534/TGeoNodeMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeMatrix.html
https://root.cern/root/html534/TGeoNodeOffset.html:4588,Availability,error,error,4588,,MatchSource.WIKI,root/html534/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeOffset.html
https://root.cern/root/html534/TGeoNodeOffset.html:4672,Availability,error,error,4672,"hapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Int_tTGeoNode::FindNode(const TGeoNode* node, Int_t level); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoNode::GetByteCount() const; Int_tTGeoNode::GetColour() const; TGeoNode*TGeoNode::GetDaughter(Int_t ind) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoPatternFinder*GetFinder() const; TGeoExtension*TGeoNode::GetFWExtension() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetIndex() const; virtual TGeoMatrix*GetMatrix() const; TGeoMedium*TGeoNode::GetMedium() const; TGeoVolume*TGeoNode::GetMotherVolume() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html534/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeOffset.html
https://root.cern/root/html534/TGeoNodeOffset.html:2897,Performance,perform,perform,2897,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoNodeOffset(); TGeoNodeOffset(const TGeoVolume* vol, Int_t index, Double_t offset); virtual~TGeoNodeOffset(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGeoNode::Browse(TBrowser* b); virtual voidcd() const; voidTGeoNode::CheckOverlaps(Double_t ovlp = 0.1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TO",MatchSource.WIKI,root/html534/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeOffset.html
https://root.cern/root/html534/TGeoNodeOffset.html:1286,Testability,log,logical,1286," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html534/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeOffset.html
https://root.cern/root/html534/TGeoNodeOffset.html:1367,Testability,log,logical,1367," TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a po",MatchSource.WIKI,root/html534/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeOffset.html
https://root.cern/root/html534/TGeoNodeOffset.html:1527,Testability,log,logical,1527," will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-ov",MatchSource.WIKI,root/html534/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeOffset.html
https://root.cern/root/html534/TGeoNodeOffset.html:1735,Testability,log,logical,1735," created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::Ad",MatchSource.WIKI,root/html534/TGeoNodeOffset.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoNodeOffset.html
https://root.cern/root/html534/TGeoOverlap.html:1778,Availability,error,error,1778,"ap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoHMatrix*GetFirstMatrix() const; TGeoVolume*GetFirstVolume() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t",MatchSource.WIKI,root/html534/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoOverlap.html
https://root.cern/root/html534/TGeoOverlap.html:1862,Availability,error,error,1862,"pendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoHMatrix*GetFirstMatrix() const; TGeoVolume*GetFirstVolume() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetOverlap() const; TPolyMarker3D*GetPolyMarker",MatchSource.WIKI,root/html534/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoOverlap.html
https://root.cern/root/html534/TGeoOverlap.html:9086,Energy Efficiency,green,green,9086,"me; TGeoHMatrix*fMatrix2positioning matrix for second volume; TStringTNamed::fNameobject identifier; Double_tfOverlapoverlap distance; TStringTNamed::fTitleobject title; TGeoVolume*fVolume1first volume; TGeoVolume*fVolume2second volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoOverlap(); Default ctor. TGeoOverlap(const char* name, TGeoVolume* vol1, TGeoVolume* vol2, const TGeoMatrix* matrix1, const TGeoMatrix* matrix2, Bool_t isovlp = kTRUE, Double_t ovlp = 0.01); Creates a named overlap belonging to volume VOL and having the size OVLP. ~TGeoOverlap(); Destructor. void Browse(TBrowser* b); Define double-click action. Int_t Compare(const TObject* obj) const; Method to compare this overlap with another. Returns :; -1 - this is smaller than OBJ; 0 - equal; 1 - greater. Int_t DistancetoPrimitive(Int_t px, Int_t py); Distance to primitive for an overlap. void Draw(Option_t* option = """"); Draw the overlap. One daughter will be blue, the other green,; extruding points red. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Event interception. void Paint(Option_t* option = """"); Paint the overlap. void Print(Option_t* option = """") const; Print detailed info. void PrintInfo() const; Print some info. void SetNextPoint(Double_t x, Double_t y, Double_t z); Set next overlapping point. void SampleOverlap(Int_t npoints = 1000000); Draw overlap and sample with random points the overlapping region. void Sizeof3D() const; Get 3D size of this. void Validate() const; Validate this overlap. TGeoOverlap(const TGeoOverlap& ). TGeoOverlap& operator=(const TGeoOverlap& ). TPolyMarker3D * GetPolyMarker() const; {return fMarker;}. TGeoVolume * GetFirstVolume() const; {return fVolume1;}. TGeoVolume * GetSecondVolume() const; {return fVolume2;}. TGeoHMatrix * GetFirstMatrix() const; {return fMatrix1;}. TGeoHMatrix * GetSecondMatrix() const; {return fMatrix2;}. Double_t GetOverlap() const; {return fOverlap;}. Bool_t IsExtrusion() const; {retur",MatchSource.WIKI,root/html534/TGeoOverlap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoOverlap.html
https://root.cern/root/html534/TGeoPainter.html:3270,Availability,error,error,3270," Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path, Option_t* option = """"); virtual voidDrawPolygon(const TGeoPolygon* poly); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*TVirtualGeoPainter::GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual TGeoNode*GetCheckedNode(); TGeoChecker*GetChecker(); virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:3354,Availability,error,error,3354,"anSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path, Option_t* option = """"); virtual voidDrawPolygon(const TGeoPolygon* poly); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*TVirtualGeoPainter::GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual TGeoNode*GetCheckedNode(); TGeoChecker*GetChecker(); virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDto",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:13613,Availability,error,errors,13613,"Geometry painter default constructor; *-* ====================================. ~TGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); --- Add numpoints, numsegs, numpolys to the global 3D size. TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject* part); Create a primary TGeoTrack. void AddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); Average center of view of all painted tracklets and compute view box. void BombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'bombed' translation vector according current exploded view mode. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFrom",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:15651,Availability,down,down,15651,"side. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawPolygon(const TGeoPolygon* poly); Draw a polygon in 3D. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path, Option_t* option = """"); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Doub",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:20248,Availability,down,down,20248,"Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void Ge",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:20458,Availability,down,down,20458,"nt_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void GetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; {bombx=fBombX; bomby=fBombY; bombz=fBombZ; bombr=fBombR;}. Int_t GetBombMode() const; {return fExplodedView;}. TGeoNode * Get",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:6238,Deployability,update,update,6238,,MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:17911,Deployability,update,update,17911,"n shape. void ExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); Execute mouse actions on a given volume. const char * GetVolumeInfo(const TGeoVolume* volume, Int_t px, Int_t py) const; Get some info about the current selected volume. TGeoChecker * GetChecker(); Create/return geometry checker. void GetViewAngles(Double_t& longitude, Double_t& latitude, Double_t& psi); Get the current view angles. void GrabFocus(Int_t nfr = 0, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to current volume. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void LocalToMasterVect(const Double_t* local, Double_t* master) const; Convert a local vector according view rotation matrix. void ModifiedPad(Bool_t update = kFALSE) const; Check if a pad and view are present and send signal ""Modified"" to pad. void Paint(Option_t* option = """"); Paint current geometry according to option. void PaintOverlap(void* ovlp, Option_t* option = """"); Paint an overlap. void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. Bool_t PaintShape(const TGeoShape& shape, Option_t* option) const; Paint the supplied shape into the current 3D viewer. void PaintShape(TGeoShape* shape, Option_t* option = """"); Paint an overlap. void PaintPhysicalNode(TGeoPhysicalNode* node, Option_t* option = """"); Paints a physical node associated with a path. void PrintOverlaps() const; Print overlaps (see TGeoChecker::PrintOverlaps()). void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* ",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:354,Integrability,interface,interfaces,354,". TGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMPAINTER; » TGeoPainter. class TGeoPainter: public TVirtualGeoPainter. TGeoPainter - class implementing all draw interfaces for a generic 3D viewer; using TBuffer3D mechanism. Function Members (Methods); public:. TGeoPainter(TGeoManager* manager); TGeoPainter(const TGeoPainter&); virtual~TGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* part); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); voidCheckEdit(); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level)",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:8801,Modifiability,plugin,plugin,8801,"BombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); virtual voidSetCheckedNode(TGeoNode* node); virtual voidSetClippingShape(TGeoShape* shape); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExplodedView(Int_t iopt = 0); virtual voidSetGeoManager(TGeoManager* geom); virtual voidSetIteratorPlugin(TGeoIteratorPlugin* plugin); virtual voidSetNmeshPoints(Int_t npoints); virtual voidSetNsegments(Int_t nseg = 20); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualGeoPainter::SetPainter(const TVirtualGeoPainter* painter); virtual voidSetRaytracing(Bool_t flag = kTRUE); virtual voidSetTopVisible(Bool_t vis = kTRUE); virtual voidSetTopVolume(TGeoVolume* vol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisLevel(Int_t level = 3); virtual voidSetVisOption(Int_t option = 0); virtual Int_tShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTest(Int_t npoints, Option_t* option); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestOverlaps(const char* path); virtual Bool_tTestVoxels(TGeoVolume* vol); virtual voidUnbombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidClearVisibleVolumes(); virtual voidTObject::DoError(int level, const cha",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:12126,Modifiability,plugin,plugin,12126,"; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static TVirtualGeoPainter*TVirtualGeoPainter::fgGeoPainterPointer to class painter. private:. Double_tfBombRbomb factor on radius (cyl or sph); Double_tfBombXbomb factor on X; Double_tfBombYbomb factor on Y; Double_tfBombZbomb factor on Z; TBuffer3D*fBufferbuffer used for painting; Double_tfCheckedBox[6]bounding box of checked node; TGeoNode*fCheckedNodechecked node; TGeoChecker*fCheckergeometry checker; TGeoShape*fClippingShapeclipping shape; Int_tfExplodedViewtype of exploding current view; TGeoManager*fGeoManagergeometry to which applies; TGeoHMatrix*fGlobalcurrent global matrix; Bool_tfIsEditableflag that geometry is editable; Bool_tfIsPaintingShapeflag for shape painting; Bool_tfIsRaytracingraytracing flag; TGeoVolume*fLastVolumelast drawn volume; Double_tfMat[9]view rotation matrix; Int_tfNVisNodesnumber of visible nodes; Int_tfNsegmentsnumber of segments approximating circles; TGeoOverlap*fOverlapcurrent overlap; Bool_tfPaintingOverlapslock overlaps painting; TGeoIteratorPlugin*fPluginUser iterator plugin for changing pain volume properties; Bool_tfTopVisibleset top volume visible; TGeoVolume*fTopVolumetop drawn volume; TStringfVisBranchdrawn branch; Int_tfVisLeveldepth for drawing; Bool_tfVisLocklock for adding visible volumes; Int_tfVisOptionglobal visualization option; TObjArray*fVisVolumeslist of visible volumes; TStringfVolInfovolume info. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPainter(TGeoManager* manager); -*-*Geometry painter default constructor; *-* ====================================. ~TGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. void AddSize3D(Int_t numpoints, Int_t numsegs, Int_",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:22240,Modifiability,plugin,plugin,22240,"n_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void GetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; {bombx=fBombX; bomby=fBombY; bombz=fBombZ; bombr=fBombR;}. Int_t GetBombMode() const; {return fExplodedView;}. TGeoNode * GetCheckedNode(); {return fCheckedNode;}. const char * GetDrawPath() const; {return fVisBranch.Data();}. TGeoVolume * GetTopVolume() const; {return fTopVolume;}. Int_t GetVisLevel() const; {return fVisLevel;}. Int_t GetVisOption() const; {return fVisOption;}. Int_t GetNsegments() const; {return fNsegments;}. Double_t * GetViewBox(); {return &fCheckedBox[0];}. Bool_t IsExplodedView() const; {return ((fExplodedView==kGeoVisDefault)?kFALSE:kTRUE);}. Bool_t IsRaytracing() const; {return fIsRaytracing;}. Bool_t IsPaintingShape() const; {return fIsPaintingShape;}. void Lock(Bool_t flag = kTRUE); {fVisLock = flag;}. void SetClippingShape(TGeoShape* shape); {fClippingShape = shape;}. void SetGeoManager(TGeoManager* geom); {fGeoManager=geom;}. void SetIteratorPlugin(TGeoIteratorPlugin* plugin); {fPlugin = plugin; ModifiedPad();}. void SetRaytracing(Bool_t flag = kTRUE); {fIsRaytracing = flag;}. void SetTopVolume(TGeoVolume* vol); {fTopVolume = vol;}. » Author: Andrei Gheata 05/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:39:35 2015 » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:22260,Modifiability,plugin,plugin,22260,"n_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void GetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; {bombx=fBombX; bomby=fBombY; bombz=fBombZ; bombr=fBombR;}. Int_t GetBombMode() const; {return fExplodedView;}. TGeoNode * GetCheckedNode(); {return fCheckedNode;}. const char * GetDrawPath() const; {return fVisBranch.Data();}. TGeoVolume * GetTopVolume() const; {return fTopVolume;}. Int_t GetVisLevel() const; {return fVisLevel;}. Int_t GetVisOption() const; {return fVisOption;}. Int_t GetNsegments() const; {return fNsegments;}. Double_t * GetViewBox(); {return &fCheckedBox[0];}. Bool_t IsExplodedView() const; {return ((fExplodedView==kGeoVisDefault)?kFALSE:kTRUE);}. Bool_t IsRaytracing() const; {return fIsRaytracing;}. Bool_t IsPaintingShape() const; {return fIsPaintingShape;}. void Lock(Bool_t flag = kTRUE); {fVisLock = flag;}. void SetClippingShape(TGeoShape* shape); {fClippingShape = shape;}. void SetGeoManager(TGeoManager* geom); {fGeoManager=geom;}. void SetIteratorPlugin(TGeoIteratorPlugin* plugin); {fPlugin = plugin; ModifiedPad();}. void SetRaytracing(Bool_t flag = kTRUE); {fIsRaytracing = flag;}. void SetTopVolume(TGeoVolume* vol); {fTopVolume = vol;}. » Author: Andrei Gheata 05/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:39:35 2015 » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:15780,Performance,load,loaded,15780,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawPolygon(const TGeoPolygon* poly); Draw a polygon in 3D. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path, Option_t* option = """"); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, I",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:15791,Performance,load,load,15791,"tFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* vol, Int_t level) const; Count number of visible nodes down to a given level. Int_t CountVisibleNodes(); Count total number of visible nodes. void CheckEdit(); Check if Ged library is loaded and load geometry editor classe. void EditGeometry(Option_t* option = """"); Start the geometry editor. void Draw(Option_t* option = """"); Draw method. void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); Draw the time evolution of a radionuclide. void DrawPolygon(const TGeoPolygon* poly); Draw a polygon in 3D. void DrawVolume(TGeoVolume* vol, Option_t* option = """"); Draw method. void DrawShape(TGeoShape* shape, Option_t* option = """"); Draw a shape. void DrawOverlap(void* ovlp, Option_t* option = """"); Draw an overlap. void DrawOnly(Option_t* option = """"); Draw only one volume. void DrawCurrentPoint(Int_t color); Draw current point in the same view. void DrawPanel(). void DrawPath(const char* path, Option_t* option = """"); Draw all volumes for a given path. void EstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); Estimate camera movement between tmin and tmax for best track display. void ExecuteManagerEvent(TGeoManager* geom, Int_t event, I",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:20279,Performance,perform,performed,20279,"Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetNmeshPoints(Int_t npoints); Set number of points to be generated on the shape outline when checking for overlaps. void SetCheckedNode(TGeoNode* node); Select a node to be checked for overlaps. All overlaps not involving it will; be ignored. void SetVisLevel(Int_t level = 3); Set default level down to which visualization is performed. void SetTopVisible(Bool_t vis = kTRUE); Set top geometry volume as visible. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn. Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; Returns distance between point px,py on the pad an a shape. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Bool_t TestVoxels(TGeoVolume* vol); Check voxels efficiency per volume. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); get the new 'unbombed' translation vector according current exploded view mode. Double_t Weight(Double_t precision, Option_t* option = ""v""); Compute weight [kg] of the current volume. TGeoPainter(TGeoManager* manager). void Ge",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:1628,Testability,test,testNo,1628,"1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountNodes(TGeoVolume* vol, Int_t level)",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:14493,Testability,test,testNo,14493,"ull bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors();",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:14583,Testability,test,test,14583,"ck the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking method (see: TGeoManager::CheckGeometry()). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; Geometry checking method (see TGeoChecker). void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; Check overlaps for the top volume of the geometry, within a limit OVLP. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); check current point in the geometry. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void ClearVisibleVolumes(); Clear the list of visible volumes; reset the kVisOnScreen bit for volumes previously in the list. void DefineColors() const; Define 100 colors with increasing light intensities for each basic color (1-7); Register these colors at indexes starting with 1000. Int_t GetColor(Int_t base, Float_t light) const; Get index of a base color with given light intensity (0,1). TGeoVolume * GetDrawnVolume() const; Get currently drawn volume. Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py); compute the closest distance of approach from point px,py to a volume. void DefaultAngles(); Set default angles for the current view. void DefaultColors(); Set default volume colors according to tracking media. Int_t CountNodes(TGeoVolume* v",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPainter.html:19032,Usability,progress bar,progress bar,19032,"view are present and send signal ""Modified"" to pad. void Paint(Option_t* option = """"); Paint current geometry according to option. void PaintOverlap(void* ovlp, Option_t* option = """"); Paint an overlap. void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0); Paint recursively a node and its content accordind to visualization options. Bool_t PaintShape(const TGeoShape& shape, Option_t* option) const; Paint the supplied shape into the current 3D viewer. void PaintShape(TGeoShape* shape, Option_t* option = """"); Paint an overlap. void PaintPhysicalNode(TGeoPhysicalNode* node, Option_t* option = """"); Paints a physical node associated with a path. void PrintOverlaps() const; Print overlaps (see TGeoChecker::PrintOverlaps()). void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"); Text progress bar. void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol = 0, Bool_t check_norm = kFALSE); Shoot nrays in the current drawn geometry. void Raytrace(Option_t* option = """"); Raytrace current drawn geometry. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); --- Set cartesian and radial bomb factors for translations. void SetExplodedView(Int_t iopt = 0); set type of exploding view. void SetNsegments(Int_t nseg = 20); Set number of segments to approximate circles. void SetN",MatchSource.WIKI,root/html534/TGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPainter.html
https://root.cern/root/html534/TGeoPara.html:3671,Availability,error,error,3671,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetA",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:3755,Availability,error,error,3755,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGe",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:2537,Safety,safe,safe,2537,"GeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:2820,Safety,safe,safe,2820,"le_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:8810,Safety,safe,safe,8810,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoPara&operator=(const TGeoPara&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:14015,Safety,safe,safe,14015,"tion documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:14100,Safety,safe,safe,14100,"tion documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:14245,Safety,safe,safe,14245,"onst char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this. Returns 0 if successfull. TGeoShape * GetMakeRuntimeSh",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:17042,Safety,safe,safe,17042,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:17078,Safety,safe,safe,17078,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoPara(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Int_t GetNmeshVertices() const; {return 8;}. Double_t GetX() const; {return fX;}. Double_t GetY() const; {return fY;}. Double_t GetZ() const; {return fZ;}. Double_t GetAlpha() const; {return fAlpha;}. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetTxy() const; {return fTxy;}. Double_t GetTxz() const; {return fTxz;}. Double_t GetTyz() const; {return fTyz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:1350,Testability,test,testNo,1350," TGeoPara(); TGeoPara(Double_t* param); TGeoPara(const TGeoPara&); TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); virtual~TGeoPara(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:13836,Testability,test,test,13836,"Z section angle; Double_tfXX half-length; Double_tfYY half-length; Double_tfZZ half-length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void Get",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoPara.html:13873,Testability,test,test,13873,"Z section angle; Double_tfXX half-length; Double_tfYY half-length; Double_tfZZ half-length. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPara(); Default constructor. TGeoPara(Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); Default constructor specifying minimum and maximum radius. TGeoPara(Double_t* param); Default constructor; param[0] = dx; param[1] = dy; param[2] = dz; param[3] = alpha; param[4] = theta; param[5] = phi. ~TGeoPara(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; test Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the para. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this paralelipiped shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void Get",MatchSource.WIKI,root/html534/TGeoPara.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPara.html
https://root.cern/root/html534/TGeoParaboloid.html:3992,Availability,error,error,3992,"nt_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Double_tDistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::Ge",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:4076,Availability,error,error,4076,"voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Double_tDistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBB",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:2771,Safety,safe,safe,2771,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Double_tDistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual ",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:3054,Safety,safe,safe,3054,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Double_tDistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArr",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:8976,Safety,safe,safe,8976,"TObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoParaboloid&operator=(const TGeoParaboloid&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetParaboloidDi",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:14216,Safety,safe,safe,14216,"e, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference fr",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:14427,Safety,safe,safe,14427," rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:14513,Safety,safe,safe,14513," rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:17957,Safety,safe,safe,17957,"D(n*(n+1)+2, n*(2*n+3), n*(n+2));. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoParaboloid(); constructors. Double_t GetRlo() const; {return fRlo;}. Double_t GetRhi() const; {return fRhi;}. Double_t GetDz() const; {return fDz;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 20/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:17993,Safety,safe,safe,17993,"D(n*(n+1)+2, n*(2*n+3), n*(n+2));. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoParaboloid(); constructors. Double_t GetRlo() const; {return fRlo;}. Double_t GetRhi() const; {return fRhi;}. Double_t GetDz() const; {return fDz;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Mihaela Gheata 20/06/04 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:1594,Testability,test,testNo,1594," TGeoParaboloid(); TGeoParaboloid(Double_t* params); TGeoParaboloid(const TGeoParaboloid&); TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); virtual~TGeoParaboloid(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsM",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaboloid.html:13763,Testability,test,test,13763,"le_tfAquadratic coeff.; Double_tfBZ value of parabola at x=y=0; Double_tfDzrange on Z axis [-dz, dz]; Double_tfRhiradius at z=+dz; Double_tfRloradius at z=-dz. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaboloid(); Dummy constructor. TGeoParaboloid(Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(const char* name, Double_t rlo, Double_t rhi, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoParaboloid(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = rlo; param[1] = rhi; param[2] = dz. ~TGeoParaboloid(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistToParaboloid(const Double_t* point, const Double_t* dir, Bool_t in) const; Compute distance from a point to the parabola given by:; z = a*rsq + b; rsq = x*x+y*y. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the paraboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the paraboloid and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the paraboloid along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with",MatchSource.WIKI,root/html534/TGeoParaboloid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaboloid.html
https://root.cern/root/html534/TGeoParaEditor.html:4611,Availability,error,error,4611,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaEditor.html
https://root.cern/root/html534/TGeoParaEditor.html:4695,Availability,error,error,4695,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaEditor.html
https://root.cern/root/html534/TGeoParaEditor.html:17971,Availability,mask,mask,17971,,MatchSource.WIKI,root/html534/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaEditor.html
https://root.cern/root/html534/TGeoParaEditor.html:21453,Usability,undo,undoing,21453,"uble_tfYiInitial Y; Double_tfZiInitial Z; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParaEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoParaEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoX(); Slot for X. void DoY(); Slot for Y. void DoZ(); Slot for Z. void DoAlpha(); Slot for alpha. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoParaEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParaEditor.html
https://root.cern/root/html534/TGeoParallelWorld.html:2096,Availability,error,error,2096,"arallelWorld(const char* name, TGeoManager* mgr); virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(const char* path); voidAddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); voidAddOverlap(const char* volname, Bool_t activate = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoPhysicalNode*FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); TGeoPhysicalNode*FindNode(Double_t* point); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoManager*GetGeometry() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoParallelWorld.html:2180,Availability,error,error,2180,"arallelWorld(const char* name, TGeoManager* mgr); virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(const char* path); voidAddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); voidAddOverlap(const char* volname, Bool_t activate = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoPhysicalNode*FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); TGeoPhysicalNode*FindNode(Double_t* point); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoManager*GetGeometry() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoParallelWorld.html:8614,Availability,toler,tolerance,8614,"with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t* point, Double_t safmax = 1.E30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOverlaps(Bool_t flag); Activate/deactivate overlap usage. {fUseOverlaps = flag;}. Bool_t IsUsingOverlaps() const; {return fUseOverlaps;}. TGeoManager * GetGeometry() const; Getters. {return fGeoManager;}. Bool_t IsClosed() const; {return fIsClosed;}. TGeoVolume * GetVolume() const; {return fVolume;}. » Author: Andrei Gheata 30/06/14 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:39:38 2015 » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoParallelWorld.html:459,Integrability,interface,interface,459,". TGeoParallelWorld. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoParallelWorld. class TGeoParallelWorld: public TNamed. TGeoParallelWorld - base class for a flat parallel geometry.; The parallel geometry can be composed by both normal volumes added; using the AddNode interface (not implemented yet) or by physical nodes; which will use as position their actual global matrix with respect to the top; volume of the main geometry.; All these nodes are added as daughters to the ""top"" volume of; the parallel world which acts as a navigation helper in this parallel; world. The parallel world has to be closed before calling any navigation; method. Function Members (Methods); public:. TGeoParallelWorld(); TGeoParallelWorld(const char* name, TGeoManager* mgr); virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(const char* path); voidAddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); voidAddOverlap(const char* volname, Bool_t activate = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const ch",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoParallelWorld.html:7384,Performance,optimiz,optimization,7384,"ete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGeoManager*fGeoManagerbase geometry; Bool_tfIsClosed! Closed flag; TGeoPhysicalNode*fLastState! Last PN touched; TStringTNamed::fNameobject identifier; TObjArray*fPathsarray of paths; TObjArray*fPhysical! array of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterB",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoParallelWorld.html:7632,Performance,optimiz,optimization,7632,"Managerbase geometry; Bool_tfIsClosed! Closed flag; TGeoPhysicalNode*fLastState! Last PN touched; TStringTNamed::fNameobject identifier; TObjArray*fPathsarray of paths; TObjArray*fPhysical! array of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t* point, Double_t safmax = 1.E30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Dr",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoParallelWorld.html:7872,Safety,detect,detected,7872,"ray of physical nodes; TStringTNamed::fTitleobject title; Bool_tfUseOverlapsActivated if user defined overlapping candidates; TGeoVolume*fVolume! helper volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoParallelWorld(const char* name, TGeoManager* mgr); Default constructor. ~TGeoParallelWorld(); Destructor. void AddNode(const char* path); Add a node normally to this world. Overlapping nodes not allowed. void AddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t* point, Double_t safmax = 1.E30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOverlaps(Bool_t",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoParallelWorld.html:8516,Safety,safe,safety,8516,"with any of the physical nodes of the parallel world. Better; be done before misalignment. void AddOverlap(const char* volname, Bool_t activate = kTRUE); To use this optimization, the user should declare the full list of volumes; which may overlap with any of the physical nodes of the parallel world. Better; be done before misalignment. Int_t PrintDetectedOverlaps() const; Print the overlaps which were detected during real tracking. void ResetOverlaps() const; Reset overlapflag for all volumes in geometry. Bool_t CloseGeometry(); The main geometry must be closed. void RefreshPhysicalNodes(); Refresh the node pointers and re-voxelize. To be called mandatory in case; re-alignment happened. TGeoPhysicalNode * FindNode(Double_t* point); Finds physical node containing the point. TGeoPhysicalNode * FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); Same functionality as TGeoNavigator::FindNextDaughterBoundary for the; parallel world. Double_t Safety(Double_t* point, Double_t safmax = 1.E30); Compute safety for the parallel world. void CheckOverlaps(Double_t ovlp = 0.001); Check overlaps within a tolerance value. void Draw(Option_t* option); Draw the parallel world. TGeoParallelWorld(const TGeoParallelWorld& ). TGeoParallelWorld& operator=(const TGeoParallelWorld& ). TGeoParallelWorld(); constructors. {}. void SetUseOverlaps(Bool_t flag); Activate/deactivate overlap usage. {fUseOverlaps = flag;}. Bool_t IsUsingOverlaps() const; {return fUseOverlaps;}. TGeoManager * GetGeometry() const; Getters. {return fGeoManager;}. Bool_t IsClosed() const; {return fIsClosed;}. TGeoVolume * GetVolume() const; {return fVolume;}. » Author: Andrei Gheata 30/06/14 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: Sat Mar 14 16:39:38 2015 » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoParallelWorld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html
https://root.cern/root/html534/TGeoPatternCylPhi.html:2699,Availability,error,error,2699,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternCylPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternCylPhi.html
https://root.cern/root/html534/TGeoPatternCylPhi.html:2783,Availability,error,error,2783,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternCylPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternCylPhi.html
https://root.cern/root/html534/TGeoPatternCylR.html:2727,Availability,error,error,2727,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternCylR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternCylR.html
https://root.cern/root/html534/TGeoPatternCylR.html:2811,Availability,error,error,2811,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternCylR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternCylR.html
https://root.cern/root/html534/TGeoPatternFinder.html:1397,Availability,avail,available,1397," division type which applies only to a given; shape type. The implemented patterns are for the moment equidistant slices; on different axis. Implemented patterns are:. TGeoPatternX - a X axis divison pattern; TGeoPatternY - a Y axis divison pattern; TGeoPatternZ - a Z axis divison pattern; TGeoPatternParaX - a X axis divison pattern for PARA shape; TGeoPatternParaY - a Y axis divison pattern for PARA shape; TGeoPatternParaZ - a Z axis divison pattern for PARA shape; TGeoPatternTrapZ - a Z axis divison pattern for TRAP or GTRA shapes; TGeoPatternCylR - a cylindrical R divison pattern; TGeoPatternCylPhi - a cylindrical phi divison pattern; TGeoPatternSphR - a spherical R divison pattern; TGeoPatternSphTheta - a spherical theta divison pattern; TGeoPatternSphPhi - a spherical phi divison pattern; TGeoPatternHoneycomb - a divison pattern specialized for honeycombs. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoPatternFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual vo",MatchSource.WIKI,root/html534/TGeoPatternFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternFinder.html
https://root.cern/root/html534/TGeoPatternFinder.html:2530,Availability,error,error,2530,"t::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t*, const Double_t* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tGetCurrent(); virtual Int_tGetDivAxis(); Int_tGetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; Int_tGetNdiv() const; Int_tGetNext() const; TGeoNode*GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStart()",MatchSource.WIKI,root/html534/TGeoPatternFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternFinder.html
https://root.cern/root/html534/TGeoPatternFinder.html:2614,Availability,error,error,2614,"al voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t*, const Double_t* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tGetCurrent(); virtual Int_tGetDivAxis(); Int_tGetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; Int_tGetNdiv() const; Int_tGetNext() const; TGeoNode*GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStart() const; Double_tGetStep() const; TGeoPatternFinder::ThreadData_t&GetThreadData() con",MatchSource.WIKI,root/html534/TGeoPatternFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternFinder.html
https://root.cern/root/html534/TGeoPatternHoneycomb.html:2559,Availability,error,error,2559,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tTGeoPatternFinder::GetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffs",MatchSource.WIKI,root/html534/TGeoPatternHoneycomb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternHoneycomb.html
https://root.cern/root/html534/TGeoPatternHoneycomb.html:2643,Availability,error,error,2643,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tTGeoPatternFinder::GetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stati",MatchSource.WIKI,root/html534/TGeoPatternHoneycomb.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternHoneycomb.html
https://root.cern/root/html534/TGeoPatternParaX.html:2737,Availability,error,error,2737,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternParaX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternParaX.html
https://root.cern/root/html534/TGeoPatternParaX.html:2821,Availability,error,error,2821,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternParaX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternParaX.html
https://root.cern/root/html534/TGeoPatternParaY.html:2737,Availability,error,error,2737,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternParaY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternParaY.html
https://root.cern/root/html534/TGeoPatternParaY.html:2821,Availability,error,error,2821,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternParaY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternParaY.html
https://root.cern/root/html534/TGeoPatternParaZ.html:2737,Availability,error,error,2737,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternParaZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternParaZ.html
https://root.cern/root/html534/TGeoPatternParaZ.html:2821,Availability,error,error,2821,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternParaZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternParaZ.html
https://root.cern/root/html534/TGeoPatternSphPhi.html:2699,Availability,error,error,2699,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternSphPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternSphPhi.html
https://root.cern/root/html534/TGeoPatternSphPhi.html:2783,Availability,error,error,2783,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternSphPhi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternSphPhi.html
https://root.cern/root/html534/TGeoPatternSphR.html:2727,Availability,error,error,2727,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternSphR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternSphR.html
https://root.cern/root/html534/TGeoPatternSphR.html:2811,Availability,error,error,2811,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternSphR.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternSphR.html
https://root.cern/root/html534/TGeoPatternSphTheta.html:2767,Availability,error,error,2767,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternSphTheta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternSphTheta.html
https://root.cern/root/html534/TGeoPatternSphTheta.html:2851,Availability,error,error,2851,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternSphTheta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternSphTheta.html
https://root.cern/root/html534/TGeoPatternTrapZ.html:2737,Availability,error,error,2737,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); vir",MatchSource.WIKI,root/html534/TGeoPatternTrapZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternTrapZ.html
https://root.cern/root/html534/TGeoPatternTrapZ.html:2821,Availability,error,error,2821,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TGeoPatternTrapZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternTrapZ.html
https://root.cern/root/html534/TGeoPatternX.html:2697,Availability,error,error,2697,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html534/TGeoPatternX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternX.html
https://root.cern/root/html534/TGeoPatternX.html:2781,Availability,error,error,2781,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtu",MatchSource.WIKI,root/html534/TGeoPatternX.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternX.html
https://root.cern/root/html534/TGeoPatternY.html:2697,Availability,error,error,2697,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html534/TGeoPatternY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternY.html
https://root.cern/root/html534/TGeoPatternY.html:2781,Availability,error,error,2781,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtu",MatchSource.WIKI,root/html534/TGeoPatternY.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternY.html
https://root.cern/root/html534/TGeoPatternZ.html:2697,Availability,error,error,2697,"se(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternF",MatchSource.WIKI,root/html534/TGeoPatternZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternZ.html
https://root.cern/root/html534/TGeoPatternZ.html:2781,Availability,error,error,2781,"ext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidTGeoPatternFinder::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindNextBoundary(Double_t* point, Double_t* dir, Int_t& indnext); virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPatternFinder::GetNdiv() const; Int_tTGeoPatternFinder::GetNext() const; TGeoNode*TGeoPatternFinder::GetNodeOffset(Int_t idiv); virtu",MatchSource.WIKI,root/html534/TGeoPatternZ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPatternZ.html
https://root.cern/root/html534/TGeoPcon.html:3660,Availability,error,error,3660," 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) ",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:3744,Availability,error,error,3744,"mOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* ma",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:15606,Performance,perform,performed,15606,"le_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(const Double_t* point, Int_t ",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:2428,Safety,safe,safe,2428,"char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:2711,Safety,safe,safe,2711," points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidDefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* meth",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:8831,Safety,safe,safe,8831,"nst char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&Rmax(Int_t ipl); Double_t&Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:14497,Safety,safe,safe,14497,"r. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, ",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:14850,Safety,safe,safe,14850," operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns number of segments on each mesh circle segment. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Z divisions can be; performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:16706,Safety,safe,safety,16706,".; In case a wrong division axis is supplied, returns pointer to; volume that was divided. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetRmin(Int_t ipl) const; Returns Rmin for Z segment IPL. Double_t GetRmax(Int_t ipl) const; Returns Rmax for Z segment IPL. Double_t GetZ(Int_t ipl) const; Returns Z for segment IPL. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t SafetyToSegment(const Double_t* point, Int_t ipl, Bool_t in = kTRUE, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint.; ---> localize the Z segment. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set polycone dimensions starting from an array. void SetPoints(Double_t* points) const; create polycone mesh points. void SetPoints(Float_t* points) const; create polycone mesh points. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomer();; if (!painter) return;; Int_t n;. n = gGeoManager->GetNsegments()+1;. Int_t numPoints = fNz*2*n;; Int_t numSegs = 4*(fNz*n-1+(fDphi",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:19164,Safety,safe,safe,19164,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 60+12*fNz;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Int_t GetNz() const; {return fNz;}. Double_t * GetRmin() const; {return fRmin;}. Double_t * GetRmax() const; {return fRmax;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Double_t & Phi1(); {return fPhi1;}. Double_t & Dphi(); {return fDphi;}. Double_t & Rmin(Int_t ipl); {return fRmin[ipl];}. Double_t & Rmax(Int_t ipl); {return fRmax[ipl];}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:19200,Safety,safe,safe,19200,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 60+12*fNz;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Int_t GetNz() const; {return fNz;}. Double_t * GetRmin() const; {return fRmin;}. Double_t * GetRmax() const; {return fRmax;}. Double_t * GetZ() const; {return fZ;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. Double_t & Phi1(); {return fPhi1;}. Double_t & Dphi(); {return fDphi;}. Double_t & Rmin(Int_t ipl); {return fRmin[ipl];}. Double_t & Rmax(Int_t ipl); {return fRmax[ipl];}. Double_t & Z(Int_t ipl); {return fZ[ipl];}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:1170,Testability,test,testNo,1170," TGeoPcon(); TGeoPcon(Double_t* params); TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); virtual~TGeoPcon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPcon.html:14207,Testability,test,test,14207,":fTitleobject title; Double_t*fZ[fNz] pointer to array of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPcon(); dummy ctor. TGeoPcon(Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(const char* name, Double_t phi, Double_t dphi, Int_t nz); Default constructor. TGeoPcon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nz. param[3] = z1; param[4] = Rmin1; param[5] = Rmax1. TGeoPcon(const TGeoPcon& ); copy constructor. TGeoPcon& operator=(const TGeoPcon& ); assignment operator. ~TGeoPcon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the pcon; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polycone. Double_t DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; compute distance to a pcon Z slice. Segment iz must be valid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube. void DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); Defines z position of a section plane, rmin and rmax at this z. Sections; should be defined in increasing or decreasing Z order and the last section; HAS to be snum = fNz-1. Int_t GetNsegments() const; Returns n",MatchSource.WIKI,root/html534/TGeoPcon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPcon.html
https://root.cern/root/html534/TGeoPconEditor.html:4606,Availability,error,error,4606,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPconEditor.html
https://root.cern/root/html534/TGeoPconEditor.html:4690,Availability,error,error,4690,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPconEditor.html
https://root.cern/root/html534/TGeoPconEditor.html:18110,Availability,mask,mask,18110,,MatchSource.WIKI,root/html534/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPconEditor.html
https://root.cern/root/html534/TGeoPconEditor.html:22092,Usability,undo,undoing,22092,"c Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPconEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPconEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given pcon. void CreateSections(Int_t inew); Change dynamically the number of sections. Bool_t CheckSections(Bool_t change = kFALSE); Check validity of sections. void UpdateSections(); Update sections according fShape. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoSectionChange(Int_t i); Change parameters of section isect;. void DoNz(); Change number of sections. void DoPhi(); Change phi range. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); {;}. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoPconEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPconEditor.html
https://root.cern/root/html534/TGeoPconSection.html:4290,Availability,error,error,4290,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tT",MatchSource.WIKI,root/html534/TGeoPconSection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPconSection.html
https://root.cern/root/html534/TGeoPconSection.html:4374,Availability,error,error,4374,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_",MatchSource.WIKI,root/html534/TGeoPconSection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPconSection.html
https://root.cern/root/html534/TGeoPconSection.html:17386,Availability,mask,mask,17386,,MatchSource.WIKI,root/html534/TGeoPconSection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPconSection.html
https://root.cern/root/html534/TGeoPgon.html:3844,Availability,error,error,3844,"TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoPcon::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoPcon::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tTGeoPcon::GetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:3928,Availability,error,error,3928,"ble_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoPcon::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoPcon::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tTGeoPcon::GetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeo",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:18837,Performance,perform,performed,18837,"lice(const Double_t* point, const Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the polygone. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Phi divisions are; allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; Z divisions can be performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at ",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:2592,Safety,safe,safe,2592,"wname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* op",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:2875,Safety,safe,safe,2875," const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t nthreads); virtual voidTGeoPcon::DefineSection(Int_t snum, Double_t z, Double_t rmin, Double_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(const Double_t* point, const Double_t* dir, Int_t& iz) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:9249,Safety,safe,safe,9249,"asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); Double_t&TGeoPcon::Phi1(); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); Double_t&TGeoPcon::Rmax(Int_t ipl); Double_t&TGeoPcon::Rmin(Int_t ipl); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tSafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:16380,Safety,safe,safe,16380,"eads); Create thread data for n threads max. TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(const Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(const Double_t* point, const Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(const Double_t* point, const Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t ",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:18200,Safety,safe,safe,18200,"stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(const Double_t* point, const Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax.; Protection in case point is in phi gap or close to phi boundaries and exiting. Bool_t SliceCrossing(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax. Bool_t IsCrossingSlice(const Double_t* point, const Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the polygone. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. Phi divisions are; allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; Z divisions can be performed if the divided range is in between two consecutive Z planes.; In case a wrong division axis is supplied, returns pointer to volume that was divided. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void Inspect",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:20103,Safety,safe,safety,20103,"aram[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; Inspect the PGON parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Rpg(Double_t z, Int_t ipl, Bool_t inner, Double_t& a, Double_t& b) const; Computes projected pgon radius (inner or outer) corresponding to a given Z; value. Fills corresponding coefficients of:; Rpg(z) = a + b*z; Note: ipl must be in range [0,fNz-2]. Double_t Rproj(Double_t z, const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& a, Double_t& b) const; Computes projected distance at a given Z for a given ray inside a given sector; and fills coefficients:; Rproj = a + b*z. Double_t SafetyToSegment(const Double_t* point, Int_t ipl, Int_t iphi, Bool_t in, Double_t safphi, Double_t safmin = TGeoShape::Big()) const; Compute safety from POINT to segment between planes ipl, ipl+1 within safmin. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set PGON dimensions starting from an array. void SetPoints(Double_t* points) const; create polygone mesh points. void SetPoints(Float_t* points) const; create polygone mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:22450,Safety,safe,safe,22450,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:22486,Safety,safe,safe,22486,"le_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. ThreadData_t& GetThreadData() const. TGeoPgon(); constructors. Int_t GetByteCount() const; {return 64+12*fNz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNedges() const; {return fNedges;}. Int_t GetNsegments() const; {return fNedges;}. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; {return TGeoBBox::GetPointsOnSegments(npoints,array);}. void SetNedges(Int_t ne); {if (ne>2) fNedges=ne;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:1337,Testability,test,testNo,1337," TGeoPgon(); TGeoPgon(Double_t* params); TGeoPgon(const TGeoPgon&); TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); virtual~TGeoPgon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidCon",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgon.html:16195,Testability,test,test,16195,"ray of Z planes positions . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ClearThreadData() const. void CreateThreadData(Int_t nthreads); Create thread data for n threads max. TGeoPgon(); dummy ctor. TGeoPgon(Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(const char* name, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); Default constructor. TGeoPgon(Double_t* params); Default constructor in GEANT3 style; param[0] = phi1; param[1] = dphi; param[2] = nedges; param[3] = nz. param[4] = z1; param[5] = Rmin1; param[6] = Rmax1. ~TGeoPgon(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a polygone; Check if the sections are in increasing Z order. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(const Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(const Double_t* point, const Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ",MatchSource.WIKI,root/html534/TGeoPgon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgon.html
https://root.cern/root/html534/TGeoPgonEditor.html:4704,Availability,error,error,4704,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgonEditor.html
https://root.cern/root/html534/TGeoPgonEditor.html:4788,Availability,error,error,4788,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgonEditor.html
https://root.cern/root/html534/TGeoPgonEditor.html:18482,Availability,mask,mask,18482,,MatchSource.WIKI,root/html534/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgonEditor.html
https://root.cern/root/html534/TGeoPgonEditor.html:22158,Usability,undo,undoing,22158,"b*TGeoGedFrame::fTabtab of the ged-editor; TGeoTabManager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoPconEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Double_t*TGeoPconEditor::fZiInitial Z positions; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPgonEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for polycone editor. ~TGeoPgonEditor(); Destructor. void SetModel(TObject* obj); Connect to a given pcon. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. void CreateEdges(); Create number entry for Nedges. void DoNedges(); Change number of edges. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoPgonEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPgonEditor.html
https://root.cern/root/html534/TGeoPhysicalNode.html:3150,Availability,error,error,3150,,MatchSource.WIKI,root/html534/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPhysicalNode.html
https://root.cern/root/html534/TGeoPhysicalNode.html:3234,Availability,error,error,3234,"al voidTObject::Browse(TBrowser* b); voidcd() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TGeoHMatrix*GetMatrix(Int_t level = -1) const; TGeoNode*GetMother(Int_t levup = 1) const; virtual const char*TNamed::GetName() const; TGeoNode*GetNode(Int_t level = -1) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoHMatrix*GetOriginalMatrix() const; TGeoShape*GetShap",MatchSource.WIKI,root/html534/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPhysicalNode.html
https://root.cern/root/html534/TGeoPhysicalNode.html:9624,Performance,perform,perform,9624,"lor_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArray*fMatricesglobal transformation matrices; TGeoHMatrix*fMatrixOrigoriginal local matrix of the last node in the path; TStringTNamed::fNameobject identifier; TObjArray*fNodesbranch of nodes; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoPhysicalNode(); Default constructor. TGeoPhysicalNode(const char* path); Constructor. TGeoPhysicalNode(const TGeoPhysicalNode& ); copy constructor. TGeoPhysicalNode& operator=(const TGeoPhysicalNode& ); assignment operator. ~TGeoPhysicalNode(); Destructor. Bool_t Align(TGeoMatrix* newmat = 0, TGeoShape* newshape = 0, Bool_t check = kFALSE, Double_t ovlp = 0.001); Align a physical node with a new relative matrix/shape.; Example: /TOP_1/A_1/B_1/C_1; node->Align(transl_1, box) will perform:; - change RELATIVE translation of C_1 node (with respect to its; container volume B) to transl_1; - change the shape of the C volume; *NOTE* The operations will affect ONLY the LAST node in the branch. All; volumes/nodes in the branch represented by this physical node are; CLONED so the operation does not affect other possible replicas. void cd() const. void Draw(Option_t* option = """"); Draw this node. TGeoNode * GetMother(Int_t levup = 1) const; Return parent at LEVUP generation. TGeoHMatrix * GetMatrix(Int_t level = -1) const; Return global matrix for node at LEVEL. TGeoNode * GetNode(Int_t level = -1) const; Return node in branch at LEVEL. If not specified, return last leaf. TGeoVolume * GetVolume(Int_t level = -1) const; Return volume associated with node at LEVEL in the branch. TGeoShape * GetShape(Int_t level = -1) const; Return shape associated with volume. void Paint(Option_t* option = """"); Paint this node and its content according to visualization settings. void Print(Option_t* option = """") const; Print info about this node. void Refresh();",MatchSource.WIKI,root/html534/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPhysicalNode.html
https://root.cern/root/html534/TGeoPhysicalNode.html:683,Safety,detect,detector,683,". TGeoPhysicalNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPhysicalNode. class TGeoPhysicalNode: public TNamed, public TAttLine. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPhysicalNode(); TGeoPhysicalNode(const char* path); virtual~TGeoPhy",MatchSource.WIKI,root/html534/TGeoPhysicalNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPhysicalNode.html
https://root.cern/root/html534/TGeoPNEntry.html:2906,Availability,error,error,2906,"(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoHMatrix*GetGlobalOrig() const; virtual const char*TObject::GetIconName() const; const TGeoHMatrix*GetMatrix() const; TGeoHMatrix*GetMatrixOrig() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPath() const; TGeoPhysicalNode*GetPhysicalNode() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; vi",MatchSource.WIKI,root/html534/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPNEntry.html
https://root.cern/root/html534/TGeoPNEntry.html:2990,Availability,error,error,2990,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoHMatrix*GetGlobalOrig() const; virtual const char*TObject::GetIconName() const; const TGeoHMatrix*GetMatrix() const; TGeoHMatrix*GetMatrixOrig() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPath() const; TGeoPhysicalNode*GetPhysicalNode() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const",MatchSource.WIKI,root/html534/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPNEntry.html
https://root.cern/root/html534/TGeoPNEntry.html:651,Safety,detect,detector,651,". TGeoPNEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoPNEntry. class TGeoPNEntry: public TNamed. TGeoPhysicalNode, TGeoPNEntry. Physical nodes are the actual 'touchable' objects in the geometry, representing; a path of positioned volumes starting with the top node:; path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes.; The number of physical nodes is given by the total number of possible of; branches in the geometry hierarchy. In case of detector geometries and; specially for calorimeters this number can be of the order 1e6-1e9, therefore; it is impossible to create all physical nodes as objects in memory. In TGeo,; physical nodes are represented by the class TGeoPhysicalNode and can be created; on demand for alignment purposes:. TGeoPhysicalNode *pn = new TGeoPhysicalNode(""path_to_object""). Once created, a physical node can be misaligned, meaning that its position; or even shape can be changed:. pn->Align(TGeoMatrix* newmat, TGeoShape* newshape, Bool_t check=kFALSE). The knowledge of the path to the objects that need to be misaligned is; essential since there is no other way of identifying them. One can however; create 'symbolic links' to any complex path to make it more representable; for the object it designates:. TGeoPNEntry *pne = new TGeoPNEntry(""TPC_SECTOR_2"", ""path_to_tpc_sect2"");; pne->SetPhysicalNode(pn). Such a symbolic link hides the complexity of the path to the align object and; replaces it with a more meaningful name. In addition, TGeoPNEntry objects are; faster to search by name and they may optionally store an additional user; matrix. For more details please read the misalignment section in the Users Guide. Function Members (Methods); public:. TGeoPNEntry(); TGeoPNEntry(const char* unique_name, const char* path); virtual~TGeoPNEntry(); voidTObje",MatchSource.WIKI,root/html534/TGeoPNEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPNEntry.html
https://root.cern/root/html534/TGeoPolygon.html:2805,Availability,error,error,2805,"&); virtual~TGeoPolygon(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFinishPolygon(); voidGetConvexVertices(Double_t* x, Double_t* y) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNconvex() const; Int_tGetNvert() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetVertices(Double_t* x, Double_t* y) const; Double_t*GetX(); Double_t*GetY(); virtual Bool_tTOb",MatchSource.WIKI,root/html534/TGeoPolygon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPolygon.html
https://root.cern/root/html534/TGeoPolygon.html:2889,Availability,error,error,2889,"rtual voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFinishPolygon(); voidGetConvexVertices(Double_t* x, Double_t* y) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNconvex() const; Int_tGetNvert() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetVertices(Double_t* x, Double_t* y) const; Double_t*GetX(); Double_t*GetY(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual void",MatchSource.WIKI,root/html534/TGeoPolygon.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoPolygon.html
https://root.cern/root/html534/TGeoRCExtension.html:685,Availability,avail,available,685,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. TGeoRCExtension(); TGeoRCExtension(TObject* obj); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root/html534/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRCExtension.html
https://root.cern/root/html534/TGeoRCExtension.html:1709,Availability,error,error,1709," TGeoRCExtension(); TGeoRCExtension(TObject* obj); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root/html534/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRCExtension.html
https://root.cern/root/html534/TGeoRCExtension.html:1793,Availability,error,error,1793," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TObject*GetUserObject() const; virtual TGeoExtension*Grab(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObje",MatchSource.WIKI,root/html534/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRCExtension.html
https://root.cern/root/html534/TGeoRCExtension.html:473,Deployability,release,release,473,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. TGeoRCExtension(); TGeoRCExtension(TObject* obj); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root/html534/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRCExtension.html
https://root.cern/root/html534/TGeoRCExtension.html:395,Integrability,interface,interface,395,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. TGeoRCExtension(); TGeoRCExtension(TObject* obj); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root/html534/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRCExtension.html
https://root.cern/root/html534/TGeoRCExtension.html:595,Testability,log,logical,595,". TGeoRCExtension. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRCExtension. class TGeoRCExtension: public TGeoExtension. TGeoExtension - ABC for user objects attached to TGeoVolume or TGeoNode.; Provides interface for getting a reference (grab) and; releasing the extension object (release), allowing for; derived classes to implement reference counted sharing.; The user who should attach extensions to logical volumes; or nodes BEFORE applying misalignment information so that; these will be available to all copies. Function Members (Methods); public:. TGeoRCExtension(); TGeoRCExtension(TObject* obj); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root/html534/TGeoRCExtension.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRCExtension.html
https://root.cern/root/html534/TGeoRotation.html:6228,Availability,error,error,6228,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:8330,Availability,error,error,8330,"hi2, Double_t theta3, Double_t phi3); virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(const Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; voidGetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; voidGetInverse(Double_t* invmat) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:8414,Availability,error,error,8414,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(const Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; voidGetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; voidGetInverse(Double_t* invmat) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObje",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:3100,Integrability,interface,interface,3100," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:6234,Integrability,message,message,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:6979,Modifiability,variab,variable,6979,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject:",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:484,Performance,optimiz,optimize,484,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:493,Performance,perform,performance,493,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:978,Performance,perform,performed,978,". TGeoRotation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoRotation. class TGeoRotation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:1704,Performance,perform,performed,1704,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:6211,Performance,perform,performed,6211,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoRotation(); TGeoRotation(const TGeoRotation& other); TGeoRotation(const TGeoMatrix& other); TGeoRotation(const char* name); TGeoRotation(const char* name, Double_t phi, Double_t theta, Doubl",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:18867,Performance,perform,performes,18867,"ply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:18989,Performance,perform,performed,18989,"ply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to XY. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:16517,Testability,test,test,16517,"& other); Copy ctor. TGeoRotation(const TGeoMatrix& other); Copy ctor. TGeoRotation(const char* name); Named rotation constructor. TGeoRotation(const char* name, Double_t phi, Double_t theta, Double_t psi); Default rotation constructor with Euler angles. Phi is the rotation angle about; Z axis and is done first, theta is the rotation about new Y and is done; second, psi is the rotation angle about new Z and is done third. All angles are in; degrees. TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Rotation constructor a la GEANT3. Angles theta(i), phi(i) are the polar and azimuthal; angles of the (i) axis of the rotated system with respect to the initial non-rotated; system.; Example : the identity matrix (no rotation) is composed by; theta1=90, phi1=0, theta2=90, phi2=90, theta3=0, phi3=0; SetBit(kGeoRotation);. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t IsValid() const; Perform orthogonality test for rotation. void Clear(Option_t* option = """"); reset data members. void FastRotZ(const Double_t* sincos); Perform a rotation about Z having the sine/cosine of the rotation angle. Double_t GetPhiRotation(Bool_t fixX = kFALSE) const; --- Returns rotation angle about Z axis in degrees. If the rotation is a pure; rotation about Z, fixX parameter does not matter, otherwise its meaning is:; - fixX = true : result is the phi angle of the projection of the rotated X axis in the un-rotated XY; - fixX = false : result is the phi angle of the projection of the rotated Y axis - 90 degrees. void LocalToMaster(const Double_t* local, Double_t* master) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix inverse. void MasterToLocal(const Double_t* master, Double_t* local) const; convert a point by multiplying its column vector (x, y, z, 1) to matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void RotateX(Double_t angle); Rotate about X ",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:1717,Usability,simpl,simple,1717,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotation.html:19090,Usability,simpl,simply,19090,"oid SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetRotation(const TGeoMatrix& other); Copy rotation elements from other rotation matrix. void SetAngles(Double_t phi, Double_t theta, Double_t psi); Set matrix elements according to Euler angles. void SetAngles(Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); Set matrix elements in the GEANT3 way. void GetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; Retreive rotation angles. void GetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; Retreive Euler angles. Double_t Determinant() const; computes determinant of the rotation matrix. void CheckMatrix(); performes an orthogonality check and finds if the matrix is a reflection; Warning(""CheckMatrix"", ""orthogonality check not performed yet"");. void GetInverse(Double_t* invmat) const; Get the inverse rotation matrix (which is simply the transpose). void MultiplyBy(TGeoRotation* rot, Bool_t after = kTRUE); Multiply this rotation with the one specified by ROT.; - after=TRUE (default): THIS*ROT; - after=FALSE : ROT*THIS. TGeoMatrix& operator=(const TGeoMatrix& matrix); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void LocalToMasterBomb(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void MasterToLocalBomb(const Double_t* master, Double_t* local) const. TGeoTranslation& operator=(const TGeoMatrix& matrix). virtual ~TGeoRotation(); {}. void SetMatrix(const Double_t* rot); {memcpy(&fRotationMatrix[0], rot, 9*sizeof(Double_t));CheckMatrix();}. » Author: Andrei Gheata 25/10",MatchSource.WIKI,root/html534/TGeoRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotation.html
https://root.cern/root/html534/TGeoRotationEditor.html:4676,Availability,error,error,4676,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotationEditor.html
https://root.cern/root/html534/TGeoRotationEditor.html:4760,Availability,error,error,4760,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotationEditor.html
https://root.cern/root/html534/TGeoRotationEditor.html:17838,Availability,mask,mask,17838,,MatchSource.WIKI,root/html534/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotationEditor.html
https://root.cern/root/html534/TGeoRotationEditor.html:22027,Usability,undo,undoing,22027,"nals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoRotationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoRotationEditor.html
https://root.cern/root/html534/TGeoScale.html:6219,Availability,error,error,6219,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:8131,Availability,error,error,8131,"ale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:8215,Availability,error,error,8215,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:3091,Integrability,interface,interface,3091," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:6225,Integrability,message,message,6225,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:6970,Modifiability,variab,variable,6970,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option =",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:475,Performance,optimiz,optimize,475,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:484,Performance,perform,performance,484,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:969,Performance,perform,performed,969,". TGeoScale. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoScale. class TGeoScale: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse sc",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:1695,Performance,perform,performed,1695,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:6202,Performance,perform,performed,6202,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoScale(); TGeoScale(const TGeoScale& other); TGeoScale(Double_t sx, Double_t sy, Double_t sz); TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTOb",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:15411,Performance,perform,perform,15411,"te; };. protected:. TStringTNamed::fNameobject identifier; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoScale & operator=(const TGeoScale& other); Assignment operator. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 1",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:15832,Performance,perform,perform,15832,"ed Members; Includes; Libraries. Function documentation; TGeoScale(); default constructor. TGeoScale(const TGeoScale& other); Copy constructor. TGeoScale(Double_t sx, Double_t sy, Double_t sz); default constructor. TGeoScale(const char* name, Double_t sx, Double_t sy, Double_t sz); default constructor. ~TGeoScale(); destructor. TGeoScale & operator=(const TGeoScale& other); Assignment operator. TGeoMatrix& Inverse() const; Return a temporary inverse of this. void SetScale(Double_t sx, Double_t sy, Double_t sz); scale setter. void LocalToMaster(const Double_t* local, Double_t* master) const; Convert a local point to the master frame. Double_t LocalToMaster(Double_t dist, const Double_t* dir = 0) const; Convert the local distance along unit vector DIR to master frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. TGeoMatrix * MakeClone() const; Make a clone of this matrix. void MasterToLocal(const Double_t* master, Double_t* local) const; Convert a global point to local frame. Double_t MasterToLocal(Double_t dist, const Double_t* dir = 0) const; Convert the distance along unit vector DIR to local frame. If DIR; is not specified perform a conversion such as the returned distance is the; the minimum for all possible directions. const Double_t * GetTranslation() const. const Double_t * GetRotationMatrix() const. const Double_t * GetScale() const. void LocalToMasterVect(const Double_t* local, Double_t* master) const. void MasterToLocalVect(const Double_t* master, Double_t* local) const. void ReflectX(Bool_t , Bool_t ). void ReflectY(Bool_t , Bool_t ). void ReflectZ(Bool_t , Bool_t ). » Author: Andrei Gheata 25/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScale.html:1708,Usability,simpl,simple,1708,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoScale.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScale.html
https://root.cern/root/html534/TGeoScaledShape.html:3360,Availability,error,error,3360,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(In",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:3444,Availability,error,error,3444,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox,",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:2226,Safety,safe,safe,2226,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:2509,Safety,safe,safe,2509,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:8431,Safety,safe,safe,8431,"bject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoScaledShape&operator=(const TGeoScaledShape&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:13198,Safety,safe,safe,13198,"UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoScaledShape(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true ",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:13411,Safety,safe,safe,13411,"e(); Default constructor. TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); Constructor. TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); Constructor. ~TGeoScaledShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3]. void ComputeBBox(); Compute bounding box of the scaled shape. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the scaled shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the scaled shape. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the scaled shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Bool_t IsAssembly() const; Returns true if the scaled shape is an assembly. Bool_t IsReflected() const; Check if the scale transformation is a reflection. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:16156,Safety,safe,safe,16156,"ts) const; Mesh points for scaled shapes. void SetPoints(Float_t* points) const; Mesh points for scaled shapes. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoScaledShape(); methods; constructors. Int_t GetNmeshVertices() const; {return fShape->GetNmeshVertices();}. TGeoShape * GetShape() const; {return fShape;}. TGeoScale * GetScale() const; {return fScale;}. Bool_t IsCylType() const; {return fShape->IsCylType();}. void SetScale(TGeoScale* scale); {fScale = scale;}. » Author: Andrei Gheata 26/09/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:16192,Safety,safe,safe,16192,"ts) const; Mesh points for scaled shapes. void SetPoints(Float_t* points) const; Mesh points for scaled shapes. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoScaledShape(); methods; constructors. Int_t GetNmeshVertices() const; {return fShape->GetNmeshVertices();}. TGeoShape * GetShape() const; {return fShape;}. TGeoScale * GetScale() const; {return fScale;}. Bool_t IsCylType() const; {return fShape->IsCylType();}. void SetScale(TGeoScale* scale); {fScale = scale;}. » Author: Andrei Gheata 26/09/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoScaledShape.html:1049,Testability,test,testNo,1049," TGeoScaledShape(); TGeoScaledShape(const TGeoScaledShape&); TGeoScaledShape(TGeoShape* shape, TGeoScale* scale); TGeoScaledShape(const char* name, TGeoShape* shape, TGeoScale* scale); virtual~TGeoScaledShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::",MatchSource.WIKI,root/html534/TGeoScaledShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoScaledShape.html
https://root.cern/root/html534/TGeoShape.html:6663,Availability,avail,available,6663,"outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t*, const Double_t*, Double_t*, Int_t); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t*, Bool_t*, Int_t) const; virtu",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:9101,Availability,error,error,9101,"e_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; static Double_tDistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; virtual TGeoShape*GetMakeRu",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:9185,Availability,error,error,9185,"uble_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; static Double_tDistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; virtual TGeoShape*GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; virtual voidGetMeshNumbers(Int",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:16611,Availability,error,error,16611,"(); voidSetOnBoundary(Bool_t); voidTransformPoints(Double_t* points, UInt_t NbPoints) const. Data Members; public:. enum EShapeType { kBitMask32; kGeoNoShape; kGeoBad; kGeoRSeg; kGeoPhiSeg; kGeoThetaSeg; kGeoVisX; kGeoVisY; kGeoVisZ; kGeoRunTimeShape; kGeoInvalidShape; kGeoTorus; kGeoBox; kGeoPara; kGeoSph; kGeoTube; kGeoTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Dou",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:17257,Availability,error,error,17257,"enced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the sem",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:17398,Availability,error,error,17398,"ie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bo",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:18354,Availability,toler,tolerance,18354,"s different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(const Double_t* point, const Double_t* dir, Double_t cphi, Double_t sphi, Double_t& snext, Double_t& rxy); Compute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4); Check if segments (A,B) and (C,D) are crossing,; where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4). Double_t DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); compute distance from point (inside phi) to both phi planes. Return minimum. void NormalPhi(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Compute d",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:6135,Performance,perform,performed,6135,"uble_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule is that that divisions are possible on whatever axis that; produces still known shapes as slices. The division of shapes should not be; performed by TGeoShape::Divide() calls, but rather by TGeoVolume::Divide().; The algorithm for dividing a specific shape is known by the shape object, but; is always invoked in a generic way from the volume level. Details on how to; do that can be found in TGeoVolume class. One can see how all division options; are interpreted and which is their result inside specific shape classes. /*. */. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Double_tBig(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidCheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); v",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:941,Safety,safe,safe,941,". TGeoShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoShape. class TGeoShape: public TNamed. TGeoShape - Base abstract class for all shapes. Shapes are geometrical objects that provide the basic modelling; functionality. They provide the definition of the LOCAL frame of coordinates,; with respect to which they are defined. Any implementation of a shape deriving; from the base TGeoShape class has to provide methods for :; - finding out if a point defined in their local frame is or not contained; inside;; - computing the distance from a local point to getting outside/entering the; shape, given a known direction;; - computing the maximum distance in any direction from a local point that; does NOT result in a boundary crossing of the shape (safe distance);; - computing the cosines of the normal vector to the crossed shape surface,; given a starting local point and an ongoing direction.; All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, shapes have also to; implement additional specific abstract methods :; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager cl",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:4068,Safety,safe,safe,4068,"metimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX, halfY, halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"", ""mat2"", rmin, rmax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(const Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:4387,Safety,safe,safe,4387,"ax, halfZ);; ... (see MakeXXX() utilities in TGeoManager class). Shape queries. Note that global queries related to a geometry are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(const Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(const Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E)",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:4490,Safety,safe,safe,4490,"are handled by the manager class.; However, shape-related queries might be sometimes usefull. A) Bool_t TGeoShape::Contains(const Double_t *point[3]); - this method returns true if POINT is actually inside the shape. The point; has to be defined in the local shape reference. For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(const Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed sha",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:4760,Safety,safe,safe,4760,"For instance, for a box having; DX, DY and DZ half-lengths a point will be considered inside if :; | -DX <= point[0] <= DX; | -DY <= point[1] <= DY; | -DZ <= point[2] <= DZ. B) Double_t TGeoShape::DistFromInside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(const Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied afte",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:5018,Safety,safe,safe,5018,"t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to exiting a shape from a given point INSIDE, along; a given direction. The direction is given by its director cosines with respect; to the local shape coordinate system. This method provides additional; information according the value of IACT input parameter :; IACT = 0 => compute only safe distance and fill it at the location; given by SAFE; IACT = 1 => a proposed STEP is supplied. The safe distance is computed; first. If this is bigger than STEP than the proposed step; is approved and returned by the method since it does not; cross the shape boundaries. Otherwise, the distance to; exiting the shape is computed and returned.; IACT = 2 => compute both safe distance and distance to exiting, ignoring; the proposed step.; IACT > 2 => compute only the distance to exiting, ignoring anything else. C) Double_t TGeoShape::DistFromOutside(Double_t *point[3], Double_t *dir[3],; Int_t iact, Double_t step, Double_t *safe); - computes the distance to entering a shape from a given point OUTSIDE. Acts; in the same way as B). D) Double_t Safety(const Double_t *point[3], Bool_t inside). - compute maximum shift of a point in any direction that does not change its; INSIDE/OUTSIDE state (does not cross shape boundaries). The state of the point; have to be properly supplied. E) Double_t *Normal(Double_t *point[3], Double_t *dir[3], Bool_t inside). - returns director cosines of normal to the crossed shape surface from a; given point towards a direction. One has to specify if the point is inside; or outside shape. According to this, the normal will be outwards or inwards; shape respectively. Normal components are statically stored by shape class,; so it has to be copied after retreival in a different array. Dividing shapes. Shapes can generally be divided along a given axis. Supported axis are; X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis.; The general rule ",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:8062,Safety,safe,safe,8062,"onst char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t*, const Double_t*, Double_t*, Int_t); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t*, Bool_t*, Int_t) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; static Double_tDistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:8314,Safety,safe,safe,8314,"voidComputeBBox(); static Double_tComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t*, const Double_t*, Double_t*, Int_t); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t*, Bool_t*, Int_t) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidCreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t*, const Double_t*, Double_t*, Int_t, Double_t*) const; static Double_tDistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tEpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* ms",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:19112,Safety,safe,safety,19112,"ute distance from POINT to semiplane defined by PHI angle along DIR. Computes; also radius at crossing point. This might be negative in case the crossing is; on the other side of the semiplane. Bool_t IsSameWithinTolerance(Double_t a, Double_t b); Check if two numbers differ with less than a tolerance. Bool_t IsSegCrossing(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4); Check if segments (A,B) and (C,D) are crossing,; where: A(x1,y1), B(x2,y2), C(x3,y3), D(x4,y4). Double_t DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); compute distance from point (inside phi) to both phi planes. Return minimum. void NormalPhi(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Static method to compute normal to phi planes. Double_t SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2). void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) con",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:20089,Safety,avoid,avoid,20089,"e_t phi1, Double_t phi2); Static method to compute safety w.r.t a phi corner defined by cosines/sines; of the angles phi1, phi2. Double_t SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Compute distance from point of coordinates (r,z) to segment (r1,z1):(r2,z2). void SetShapeBit(UInt_t f, Bool_t set); Equivalent of TObject::SetBit. TGeoMatrix * GetTransform(); Returns current transformation matrix that applies to shape. void SetTransform(TGeoMatrix* matrix); Set current transformation matrix that applies to shape. void TransformPoints(Double_t* points, UInt_t NbPoints) const; Tranform a set of points (LocalToMaster). void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const; Fill the supplied buffer, with sections in desired frame; See TBuffer3D.h for explanation of sections, frame etc. Int_t GetBasicColor() const; Get the basic color (0-7). const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Stub implementation to avoid forcing implementation at this stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t D",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:21179,Safety,safe,safe,21179,"s stage. const char * GetPointerName() const; Provide a pointer name containing uid. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite()",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:21329,Safety,safe,safe,21329," actions on this shape. void Draw(Option_t* option = """"); Draw this shape. void Paint(Option_t* option = """"); Paint this shape. void ClearThreadData() const; {}. void CreateThreadData(Int_t ); {}. void SetOnBoundary(Bool_t ); {;}. Double_t Big(); methods. {return 1.E30;}. Double_t Tolerance(); {return 1.E-10;}. void AfterStreamer(); {}. Double_t Capacity() const. void ComputeBBox(). void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm). void ComputeNormal_v(const Double_t* , const Double_t* , Double_t* , Int_t ); {}. Bool_t Contains(const Double_t* point) const. void Contains_v(const Double_t* , Bool_t* , Int_t ) const; {}. Bool_t CouldBeCrossed(const Double_t* point, const Double_t* dir) const. Int_t DistancetoPrimitive(Int_t px, Int_t py). Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; {}. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const. void GetBoundingCylinder(Double_t* param) const. Int_t GetByteCount() const. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const. Int_t GetId() const; {return fShapeId;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const. void GetMeshNumbers(Int_t& , Int_t& , Int_t& ) const; {;}. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kFALSE;}. Bool_t IsComposite() const; {return kFALSE;}. Bool_t IsCylType() const. Bool_t IsReflected() const; {return kFALSE;}. Bool_t IsRunTimeShape() const; {return TestShapeBit",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:2325,Security,access,accessible,2325,"; - computation of the minimal box bounding the shape, given that this box have; to be aligned with the local coordinates;; - algorithms for dividing the shape along a given axis and producing resulting; divisions volumes. The modeler currently provides a set of 16 basic shapes, which we will call; primitives. It also provides a special class allowing the creation of shapes; made as a result of boolean operations between primitives. These are called; composite shapes and the composition operation can be recursive (composition; of composites). This allows the creation of a quite large number of different; shape topologies and combinations. Shapes are named objects and register themselves to the manager class at; creation time. This is responsible for their final deletion. Shapes; can be created without name if their retreival by name is no needed. Generally; shapes are objects that are usefull only at geometry creation stage. The pointer; to a shape is in fact needed only when referring to a given volume and it is; always accessible at that level. A shape may be referenced by several volumes,; therefore its deletion is not possible once volumes were defined based on it. Creating shapes. Shape objects embeed only the minimum set of parameters that are fully; describing a valid physical shape. For instance, a tube is represented by; its half length, the minimum radius and the maximum radius. Shapes are used; togeather with media in order to create volumes, which in their turn; are the main components of the geometrical tree. A specific shape can be created; stand-alone :. TGeoBBox *box = new TGeoBBox(""s_box"", halfX, halfY, halfZ); // named; TGeoTube *tub = new TGeoTube(rmin, rmax, halfZ); // no name; ... (see each specific shape constructors). Sometimes it is much easier to create a volume having a given shape in one; step, since shapes are not direcly linked in the geometrical tree but volumes; are :. TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"", ""mat1"", halfX",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:6976,Testability,test,testNo,6976,,MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:16839,Testability,test,testNo,16839,"RunTimeShape; kGeoInvalidShape; kGeoTorus; kGeoBox; kGeoPara; kGeoSph; kGeoTube; kGeoTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a ",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShape.html:16942,Testability,test,test,16942,"oTubeSeg; kGeoCone; kGeoConeSeg; kGeoPcon; kGeoPgon; kGeoArb8; kGeoEltu; kGeoTrap; kGeoCtub; kGeoTrd1; kGeoTrd2; kGeoComb; kGeoClosedShape; kGeoXtru; kGeoParaboloid; kGeoHalfSpace; kGeoHype; kGeoSavePrimitive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tfShapeBitsshape bits; Int_tfShapeIdshape id; TStringTNamed::fTitleobject title. private:. static Double_tfgEpsMchMachine round-off error; static TGeoMatrix*fgTransformcurrent transformation matrix that applies to shape. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGeoShape(); Destructor. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). Double_t ComputeEpsMch(); Compute machine round-off double precision error as the smallest number that; if added to 1.0 is different than 1.0. Double_t EpsMch(); static function returning the machine round-off error. const char * GetName() const; Get the shape name. Int_t ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; Returns distance to shape primitive mesh. Bool_t IsCloseToPhi(Double_t epsil, const Double_t* point, Double_t c1, Double_t s1, Double_t c2, Double_t s2); True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. Bool_t IsInPhiRange(const Double_t* point, Double_t phi1, Double_t phi2); Static method to check if a point is in the phi range (phi1, phi2) [degrees]. Bool_t IsCrossingSemiplane(const ",MatchSource.WIKI,root/html534/TGeoShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShape.html
https://root.cern/root/html534/TGeoShapeAssembly.html:3308,Availability,error,error,3308,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFa",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:3392,Availability,error,error,3392,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox*",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:2174,Safety,safe,safe,2174,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:2457,Safety,safe,safe,2457,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:8320,Safety,safe,safe,8320,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoShapeAssembly&operator=(const TGeoShapeAssembly&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); voidRecomputeBoxLast(); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidTGeoBBox::SetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual v",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:13019,Safety,safe,safe,13019,"::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title; TGeoVolumeAssembly*fVolumeassembly volume. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(const Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is ",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:13231,Safety,safe,safe,13231,"documentation; TGeoShapeAssembly(); Default constructor. TGeoShapeAssembly(TGeoVolumeAssembly* vol); Constructor specifying hyperboloid parameters. ~TGeoShapeAssembly(); destructor. void ComputeBBox(); Compute bounding box of the assembly. void RecomputeBoxLast(); Recompute bounding box of the assembly after adding a node. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Should not be called. Bool_t Contains(const Double_t* point) const; Test if point is inside the assembly. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Should not be called. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid.; fVolume->SetNextNodeIndex(-1);. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide assemblies. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; No mesh for assemblies. void SetPo",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:15453,Safety,safe,safe,15453,"SetPoints(Float_t* points) const; No mesh for assemblies. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoShapeAssembly(); methods; constructors. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void NeedsBBoxRecompute(); {fBBoxOK = kFALSE;}. » Author: Andrei Gheata 02/06/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:15489,Safety,safe,safe,15489,"SetPoints(Float_t* points) const; No mesh for assemblies. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoShapeAssembly(); methods; constructors. Int_t GetNmeshVertices() const; {return 0;}. Bool_t IsAssembly() const; {return kTRUE;}. Bool_t IsCylType() const; {return kFALSE;}. void NeedsBBoxRecompute(); {fBBoxOK = kFALSE;}. » Author: Andrei Gheata 02/06/05 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeAssembly.html:997,Testability,test,testNo,997," TGeoShapeAssembly(); TGeoShapeAssembly(TGeoVolumeAssembly* vol); TGeoShapeAssembly(const TGeoShapeAssembly&); virtual~TGeoShapeAssembly(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tTGeoBBox::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDis",MatchSource.WIKI,root/html534/TGeoShapeAssembly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeAssembly.html
https://root.cern/root/html534/TGeoShapeDialog.html:5127,Availability,error,error,5127,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeDialog.html
https://root.cern/root/html534/TGeoShapeDialog.html:5211,Availability,error,error,5211,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeDialog.html
https://root.cern/root/html534/TGeoShapeDialog.html:19810,Availability,mask,mask,19810,,MatchSource.WIKI,root/html534/TGeoShapeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoShapeDialog.html
https://root.cern/root/html534/TGeoSphere.html:3827,Availability,error,error,3827,"Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoB",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:3911,Availability,error,error,3911,"st Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:14446,Availability,toler,tolerance,14446,". TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); Default constructor specifying minimum and maximum radius. TGeoSphere(Double_t* param, Int_t nparam = 6); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = theta1; param[3] = theta2; param[4] = phi1; param[5] = phi2. ~TGeoSphere(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the sphere; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(const Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:2557,Safety,safe,safe,2557,"tual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Draw",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:2840,Safety,safe,safe,2840,"const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virt",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:9085,Safety,safe,safe,9085,"(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoSphere&operator=(const TGeoSphere&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); voidSetDimensions(Double_t* param, Int_t nparam); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNu",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:15167,Safety,safe,safe,15167," zmin, zmax;. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(const Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:15442,Safety,safe,safe,15442,"e to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) cons",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:18898,Safety,safe,safe,18898,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page ha",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:18934,Safety,safe,safe,18934,"nt_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoSphere(); methods; constructors. Int_t GetByteCount() const; {return 42;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Int_t GetNumberOfDivisions() const; {return fNseg;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Int_t GetNz() const; {return fNz;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetTheta1() const; {return fTheta1;}. Double_t GetTheta2() const; {return fTheta2;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page ha",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:1380,Testability,test,testNo,1380," TGeoSphere(); TGeoSphere(const TGeoSphere&); TGeoSphere(Double_t* param, Int_t nparam = 6); TGeoSphere(Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); TGeoSphere(const char* name, Double_t rmin, Double_t rmax, Double_t theta1 = 0, Double_t theta2 = 180, Double_t phi1 = 0, Double_t phi2 = 360); virtual~TGeoSphere(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_t",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphere.html:14875,Testability,test,test,14875," param[0] = Rmin; param[1] = Rmax; param[2] = theta1; param[3] = theta2; param[4] = phi1; param[5] = phi2. ~TGeoSphere(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the sphere; Double_t xmin, xmax, ymin, ymax, zmin, zmax;. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Int_t IsOnBoundary(const Double_t* point) const; Check if a point in local sphere coordinates is close to a boundary within; shape tolerance. Return values:; 0 - not close to boundary; 1 - close to Rmin boundary; 2 - close to Rmax boundary; 3,4 - close to phi1/phi2 boundary; 5,6 - close to theta1/theta2 boundary. Bool_t IsPointInside(const Double_t* point, Bool_t checkR = kTRUE, Bool_t checkTh = kTRUE, Bool_t checkPh = kTRUE) const; Check if a point is inside radius/theta/phi ranges for the spherical sector. Bool_t Contains(const Double_t* point) const; test if point is inside this sphere; check Rmin<=R<=Rmax. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the sphere; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the sphere. Double_t DistToSphere(const Double_t* point, const Double_t* dir, Double_t rsph, Bool_t check = kTRUE, Bool_t firstcross = kTRUE) const; compute distance to sphere of radius rsph. Direction has to be a unit vector. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step). const char * GetAxisName(In",MatchSource.WIKI,root/html534/TGeoSphere.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphere.html
https://root.cern/root/html534/TGeoSphereEditor.html:4679,Availability,error,error,4679,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphereEditor.html
https://root.cern/root/html534/TGeoSphereEditor.html:4763,Availability,error,error,4763,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphereEditor.html
https://root.cern/root/html534/TGeoSphereEditor.html:18021,Availability,mask,mask,18021,,MatchSource.WIKI,root/html534/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphereEditor.html
https://root.cern/root/html534/TGeoSphereEditor.html:21709,Usability,undo,undoing,21709,"r suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoSphereEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for sphere editor. ~TGeoSphereEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a given sphere. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoTheta1(); Slot for theta1. void DoTheta2(); Slot for theta2. void DoTheta(); Slot for theta slider. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoSphereEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSphereEditor.html
https://root.cern/root/html534/TGeoSubtraction.html:3016,Availability,error,error,3016,"const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; TGeoBoolNode::ThreadData_t&TGeoBool",MatchSource.WIKI,root/html534/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html
https://root.cern/root/html534/TGeoSubtraction.html:3100,Availability,error,error,3100,"const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; TGeoBoolNode::ThreadData_t&TGeoBoolNode::GetThreadData() const; virtual const char*TObject::GetTitle() const; virtual U",MatchSource.WIKI,root/html534/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html
https://root.cern/root/html534/TGeoSubtraction.html:2506,Safety,safe,safe,2506,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root/html534/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html
https://root.cern/root/html534/TGeoSubtraction.html:2644,Safety,safe,safe,2644,"ar*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoBoolNode::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root/html534/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html
https://root.cern/root/html534/TGeoSubtraction.html:9383,Safety,safe,safe,9383,"ers are preserved. void Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root/html534/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html
https://root.cern/root/html534/TGeoSubtraction.html:9580,Safety,safe,safe,9580,"id Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html
https://root.cern/root/html534/TGeoSubtraction.html:9830,Safety,safe,safety,9830,"id Paint(Option_t* option); Paint method. TGeoSubtraction(); Default constructor. TGeoSubtraction(const char* expr1, const char* expr2); Constructor. TGeoSubtraction(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoSubtraction(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a subtraction of two shapes. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(const Double_t* point) const; Find if a subtraction of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this subtraction. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const. » Author: Andrei Gheata 30/05/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoSubtraction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoSubtraction.html
https://root.cern/root/html534/TGeoTabManager.html:1943,Availability,error,error,1943,"Editor* ged); virtual~TGeoTabManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(TGCompositeFrame* frame); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TGeoTabManager*GetMakeTabManager(TGedEditor* ged); voidGetMaterialEditor(TGeoMaterial* material); voidGetMatrixEditor(TGeoMatrix* matrix); voidGetMediumEditor(TGeoMedium* medium); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() const; voidGetShapeEditor(TGeoShape* shape); TGTab*GetTab() const; Int_tGetTabIndex() const; virtual const",MatchSource.WIKI,root/html534/TGeoTabManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTabManager.html
https://root.cern/root/html534/TGeoTabManager.html:2027,Availability,error,error,2027,"od) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(TGCompositeFrame* frame); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TGeoTabManager*GetMakeTabManager(TGedEditor* ged); voidGetMaterialEditor(TGeoMaterial* material); voidGetMatrixEditor(TGeoMatrix* matrix); voidGetMediumEditor(TGeoMedium* medium); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVirtualPad*GetPad() const; voidGetShapeEditor(TGeoShape* shape); TGTab*GetTab() const; Int_tGetTabIndex() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TGeoVol",MatchSource.WIKI,root/html534/TGeoTabManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTabManager.html
https://root.cern/root/html534/TGeoTorus.html:3741,Availability,error,error,3741,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) ",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:3825,Availability,error,error,3825,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* ma",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:2607,Safety,safe,safe,2607,"psMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); Double_tDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:2890,Safety,safe,safe,2890,"t Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); Double_tDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Double_tDDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:8736,Safety,safe,safe,8736,"fy(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTorus&operator=(const TGeoTorus&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:14466,Safety,safe,safe,14466," Dphi. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the torus. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a sh",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:14672,Safety,safe,safe,14672,"* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; Test if point is inside the torus.; check phi range. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each vertex. Double_t Daxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes distance to axis of the torus from point pt + t*dir;. Double_t DDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Computes derivative w.r.t. t of the distance to axis of the torus from point pt + t*dir;. Double_t DDDaxis(const Double_t* pt, const Double_t* dir, Double_t t) const; Second derivative of distance to torus axis w.r.t t. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the torus. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the torus. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this torus shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; Create a shape fitting the mother. void InspectShape() const; print shape parameters. TBuffer3D * MakeBuffer3D() const; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetS",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:19184,Safety,safe,safe,19184,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:19220,Safety,safe,safe,19220,"id Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTorus(); constructors. virtual ~TGeoTorus(); destructor. {}. Int_t GetByteCount() const; {return 56;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetR() const; {return fR;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetDphi() const; {return fDphi;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 28/07/03 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorus.html:1205,Testability,test,testNo,1205," TGeoTorus(); TGeoTorus(Double_t* params); TGeoTorus(const TGeoTorus&); TGeoTorus(Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoTorus(const char* name, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); virtual~TGeoTorus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; vir",MatchSource.WIKI,root/html534/TGeoTorus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorus.html
https://root.cern/root/html534/TGeoTorusEditor.html:4608,Availability,error,error,4608,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorusEditor.html
https://root.cern/root/html534/TGeoTorusEditor.html:4692,Availability,error,error,4692,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorusEditor.html
https://root.cern/root/html534/TGeoTorusEditor.html:17928,Availability,mask,mask,17928,,MatchSource.WIKI,root/html534/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorusEditor.html
https://root.cern/root/html534/TGeoTorusEditor.html:21434,Usability,undo,undoing,21434,"rame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTorusEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for torus editor. ~TGeoTorusEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoR(); Slot for R. void DoRmin(); Slot for Rmin. void DoRmax(); Slot for Rmax. void DoPhi1(); Slot for phi. void DoDphi(); Slot for Dphi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTorusEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTorusEditor.html
https://root.cern/root/html534/TGeoTrack.html:2037,Availability,error,error,2037,"Double_t nframes = 200, Option_t* option = ""/*"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*TVirtualGeoTrack::FindTrackWithId(Int_t id) const; TVirtualGeoTrack*TVirtualGeoTrack::GetDaughter(Int_t index) const; virtual Int_tTVirtualGeoTrack::GetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*TVirtualGeoTrack::GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tTVirtualGeoTrack::GetId() const; const Double_t*TVirtualGeoTrack::GetLastPoint() const; Int_tTVirtualGeoTrack::GetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tT",MatchSource.WIKI,root/html534/TGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrack.html
https://root.cern/root/html534/TGeoTrack.html:2121,Availability,error,error,2121,"d(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*TVirtualGeoTrack::FindTrackWithId(Int_t id) const; TVirtualGeoTrack*TVirtualGeoTrack::GetDaughter(Int_t index) const; virtual Int_tTVirtualGeoTrack::GetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*TVirtualGeoTrack::GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tTVirtualGeoTrack::GetId() const; const Double_t*TVirtualGeoTrack::GetLastPoint() const; Int_tTVirtualGeoTrack::GetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtua",MatchSource.WIKI,root/html534/TGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrack.html
https://root.cern/root/html534/TGeoTransientPanel.html:4885,Availability,error,error,4885,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTransientPanel.html
https://root.cern/root/html534/TGeoTransientPanel.html:4969,Availability,error,error,4969,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTransientPanel.html
https://root.cern/root/html534/TGeoTransientPanel.html:19257,Availability,mask,mask,19257,,MatchSource.WIKI,root/html534/TGeoTransientPanel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTransientPanel.html
https://root.cern/root/html534/TGeoTranslation.html:6237,Availability,error,error,6237,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:8266,Availability,error,error,8266,"y, Double_t dz); virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:8350,Availability,error,error,8350,"method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:3109,Integrability,interface,interface,3109," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:6243,Integrability,message,message,6243,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:6988,Modifiability,variab,variable,6988,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* name, Double_t dx, Double_t dy, Double_t dz); virtual~TGeoTranslation(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TGeoTranslation* other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Optio",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:493,Performance,optimiz,optimize,493,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:502,Performance,perform,performance,502,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:987,Performance,perform,performed,987,". TGeoTranslation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TGeoTranslation. class TGeoTranslation: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1.",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:1713,Performance,perform,performed,1713,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:6220,Performance,perform,performed,6220,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoTranslation(); TGeoTranslation(const TGeoTranslation& other); TGeoTranslation(const TGeoMatrix& other); TGeoTranslation(Double_t dx, Double_t dy, Double_t dz); TGeoTranslation(const char* na",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslation.html:1726,Usability,simpl,simple,1726,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html534/TGeoTranslation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslation.html
https://root.cern/root/html534/TGeoTranslationEditor.html:4723,Availability,error,error,4723,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslationEditor.html
https://root.cern/root/html534/TGeoTranslationEditor.html:4807,Availability,error,error,4807,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslationEditor.html
https://root.cern/root/html534/TGeoTranslationEditor.html:17828,Availability,mask,mask,17828,,MatchSource.WIKI,root/html534/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslationEditor.html
https://root.cern/root/html534/TGeoTranslationEditor.html:21404,Usability,undo,undoing,21404,"t_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTranslationEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTranslationEditor.html
https://root.cern/root/html534/TGeoTrap.html:4639,Availability,error,error,4639,"ouble_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() ",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:4723,Availability,error,error,4723,"ide_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const;",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:3402,Safety,safe,safe,3402,"name = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidTGeoArb8::ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") cons",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:3685,Safety,safe,safe,3685,"mal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(const Double_t* point) const; virtual voidTGeoArb8::Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod*",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:10315,Safety,safe,safe,10315,"uble_t s2); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); Double_tTGeoArb8::SafetyToFace(const Double_t* point, Int_t iseg, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoArb8::SetDz(Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:15822,Safety,safe,safe,15822,"tringTNamed::fTitleobject title; Double_tfTl1half length in x at low z and y high edge; Double_tfTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const;",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:16032,Safety,safe,safe,16032,"TGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrap(); Default ctor. TGeoTrap(Double_t dz, Double_t theta, Double_t phi); Constructor providing just a range in Z, theta and phi. TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Normal constructor. TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor with name. ~TGeoTrap(); destructor. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trapezoid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trapezoid. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trapezoid shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these have to be computed; in order to fit the mother. Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:17759,Safety,safe,safe,17759,". Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrap(); constructors. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetH1() const; {return fH1;}. Double_t GetBl1() const; {return fBl1;}. Double_t GetTl1() const; {return fTl1;}. Double_t GetAlpha1() const; {return fAlpha1;}. Double_t GetH2() const; {return fH2;}. Double_t GetBl2() const; {return fBl2;}. Double_t GetTl2() const; {return fTl2;}. Double_t GetAlpha2() const; {return fAlpha2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:17795,Safety,safe,safe,17795,". Double_t Safety(const Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrap(); constructors. Double_t GetTheta() const; {return fTheta;}. Double_t GetPhi() const; {return fPhi;}. Double_t GetH1() const; {return fH1;}. Double_t GetBl1() const; {return fBl1;}. Double_t GetTl1() const; {return fTl1;}. Double_t GetAlpha1() const; {return fAlpha1;}. Double_t GetH2() const; {return fH2;}. Double_t GetBl2() const; {return fBl2;}. Double_t GetTl2() const; {return fTl2;}. Double_t GetAlpha2() const; {return fAlpha2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrap.html:2135,Testability,test,testNo,2135," TGeoTrap(); TGeoTrap(const TGeoTrap&); TGeoTrap(Double_t dz, Double_t theta, Double_t phi); TGeoTrap(Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoTrap(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoTrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTG",MatchSource.WIKI,root/html534/TGeoTrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrap.html
https://root.cern/root/html534/TGeoTrapEditor.html:4671,Availability,error,error,4671,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrapEditor.html
https://root.cern/root/html534/TGeoTrapEditor.html:4755,Availability,error,error,4755,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrapEditor.html
https://root.cern/root/html534/TGeoTrapEditor.html:18415,Availability,mask,mask,18415,"nges; Bool_tTGedFrame::fAvoidSignalflag for executing slots; TGCompositeFrame*fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Double_tfBl1iInitial half length in x at low z and y low edge; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*fDelayedCheck button for delayed draw; Double_tfDziInitial Dz; TGNumberEntry*fEAlpha1Number entry for Alpha1; TGNumberEntry*fEBl1Number entry for Bl1; TGNumberEntry*fEDzNumber entry for DZ; TGNumberEntry*fEH1Number entry for H1 ; TGNumberEntry*fEPhiNumber entry for Theta ; TGNumberEntry*fESc1Number entry for lower scale; TGNumberEntry*fESc2Number entry for upper scale; TGNumberEntry*fEThetaNumber entry for Theta ; TGNumberEntry*fETl1Number entry for Tl1; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; Double_tfH1iInitial half length in y at low z; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tfIsModifiedFlag that volume was modified; Bool_tfIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGF",MatchSource.WIKI,root/html534/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrapEditor.html
https://root.cern/root/html534/TGeoTrapEditor.html:21991,Usability,undo,undoing,21991,"ed for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrapEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrapEditor.html
https://root.cern/root/html534/TGeoTrd1.html:3491,Availability,error,error,3491,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; Double_tGetDy() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual ",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:3575,Availability,error,error,3575,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; Double_tGetDy() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index ",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:2357,Safety,safe,safe,2357,"GeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:2640,Safety,safe,safe,2640,"le_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:8710,Safety,safe,safe,8710,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd1&operator=(const TGeoTrd1&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:13544,Safety,safe,safe,13544,"TGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; retu",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:13629,Safety,safe,safe,13629,"TGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; retu",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:14079,Safety,safe,safe,14079,"r. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real para",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:14165,Safety,safe,safe,14165,"r. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Y divisions. For Z divisions just; return the pointer to the volume to be divided. In case a wrong; division axis is supplied, returns pointer to volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real para",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:17067,Safety,safe,safe,17067,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:17103,Safety,safe,safe,17103,"onst; create arb8 mesh points. void SetPoints(Float_t* points) const; create arb8 mesh points. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd1(); methods; constructors. Int_t GetByteCount() const; {return 52;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy() const; {return fDy;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:1170,Testability,test,testNo,1170," TGeoTrd1(); TGeoTrd1(Double_t* params); TGeoTrd1(const TGeoTrd1&); TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); virtual~TGeoTrd1(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1.html:13365,Testability,test,test,13365,"er Z surface (+dz); Double_tfDyhalf length in Y; Double_tfDzhalf length in Z; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1(); dummy ctor. TGeoTrd1(Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(const char* name, Double_t dx1, Double_t dx2, Double_t dy, Double_t dz); constructor. TGeoTrd1(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy; param[3] = dz. ~TGeoTrd1(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd1. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd1; Boundary safe algorithm. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd1; Boundary safe algorithm. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd1 shape belonging to volume ""voldiv"" into ndiv vo",MatchSource.WIKI,root/html534/TGeoTrd1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1.html
https://root.cern/root/html534/TGeoTrd1Editor.html:4585,Availability,error,error,4585,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1Editor.html
https://root.cern/root/html534/TGeoTrd1Editor.html:4669,Availability,error,error,4669,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1Editor.html
https://root.cern/root/html534/TGeoTrd1Editor.html:17922,Availability,mask,mask,17922,,MatchSource.WIKI,root/html534/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1Editor.html
https://root.cern/root/html534/TGeoTrd1Editor.html:21285,Usability,undo,undoing,21285,"GFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd1 editor. ~TGeoTrd1Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy(); Slot for dy. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrd1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd1Editor.html
https://root.cern/root/html534/TGeoTrd2.html:3532,Availability,error,error,3532,"p) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDy1() const; Double_tGetDy2() const; Double",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:3616,Availability,error,error,3616,", Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1() const; Double_tGetDx2() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDy1() const; Double_tGetDy2() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:2398,Safety,safe,safe,2398,"GeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:2681,Safety,safe,safe,2681,"le_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t p",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:8776,Safety,safe,safe,8776,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTrd2&operator=(const TGeoTrd2&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoin",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:13739,Safety,safe,safe,13739,"::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the gi",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:13824,Safety,safe,safe,13824,"::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the gi",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:13969,Safety,safe,safe,13969,"dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Doub",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:14055,Safety,safe,safe,14055,"dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this trd2 shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Only Z divisions; are supported. For Z divisions just return the pointer to the volume to be; divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. void GetBoundingCylinder(Doub",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:17222,Safety,safe,safe,17222,"t vertex of a corner according to visibility flags. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd2(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy1() const; {return fDy1;}. Double_t GetDy2() const; {return fDy2;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:17258,Safety,safe,safe,17258,"t vertex of a corner according to visibility flags. void Sizeof3D() const; fill size of this 3-D object. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTrd2(); methods; constructors. Int_t GetByteCount() const; {return 56;}. Double_t GetDx1() const; {return fDx1;}. Double_t GetDx2() const; {return fDx2;}. Double_t GetDy1() const; {return fDy1;}. Double_t GetDy2() const; {return fDy2;}. Double_t GetDz() const; {return fDz;}. Bool_t IsCylType() const; {return kFALSE;}. » Author: Andrei Gheata 31/01/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/geom:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:1211,Testability,test,testNo,1211," TGeoTrd2(); TGeoTrd2(Double_t* params); TGeoTrd2(const TGeoTrd2&); TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); virtual~TGeoTrd2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) cons",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2.html:13560,Testability,test,test,13560,"; Double_tfDzhalf length in Z; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2(); dummy ctor. TGeoTrd2(Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(const char* name, Double_t dx1, Double_t dx2, Double_t dy1, Double_t dy2, Double_t dz); constructor. TGeoTrd2(Double_t* params); ctor with an array of parameters; param[0] = dx1; param[1] = dx2; param[2] = dy1; param[3] = dy2; param[4] = dz. ~TGeoTrd2(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box for a trd2. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check Z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the trd2; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the trd2; Boundary safe algorithm. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetVisibleCorner(const Double_t* point, Double_t* vertex, Double_t* normals) const; get the most visible corner from outside point and the normals. void GetOppositeCorner(const Double_t* point, Int_t inorm, Double_t* vertex, Double_t* normals) const; get the opposite corner of the intersected face. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int",MatchSource.WIKI,root/html534/TGeoTrd2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2.html
https://root.cern/root/html534/TGeoTrd2Editor.html:4599,Availability,error,error,4599,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2Editor.html
https://root.cern/root/html534/TGeoTrd2Editor.html:4683,Availability,error,error,4683,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2Editor.html
https://root.cern/root/html534/TGeoTrd2Editor.html:18007,Availability,mask,mask,18007,,MatchSource.WIKI,root/html534/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2Editor.html
https://root.cern/root/html534/TGeoTrd2Editor.html:21370,Usability,undo,undoing,21370,"_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrd2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for trd2 editor. ~TGeoTrd2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoDx1(); Slot for dx1. void DoDx2(); Slot for dx2. void DoDy1(); Slot for dy1. void DoDy2(); Slot for dy2. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTrd2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTrd2Editor.html
https://root.cern/root/html534/TGeoTreeDialog.html:1033,Availability,avail,available,1033,"inks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoTreeDialog. class TGeoTreeDialog: public TGTransientFrame. TGeoTabManager - manager for all editor tabs. TGeoTreeDialog - Base class for dialog frames for selecting objects; with a tree hierarchy. Specific implementations are:; TGeoVolumeDialog - Special tree dialog class for selecting volumes.; TGeoShapeDialog - Special tree dialog class for selecting shapes.; TGeoMediumDialog - Special tree dialog class for selecting media.; TGeoMaterialDialog - Special tree dialog class for selecting materials.; TGeoMatrixDialog - Special tree dialog class for selecting matrices.; TGeoTransientPanel - Special transient tab holding TGeo editors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGeoTreeDialog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); st",MatchSource.WIKI,root/html534/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTreeDialog.html
https://root.cern/root/html534/TGeoTreeDialog.html:5156,Availability,error,error,5156,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTreeDialog.html
https://root.cern/root/html534/TGeoTreeDialog.html:5240,Availability,error,error,5240,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTreeDialog.html
https://root.cern/root/html534/TGeoTreeDialog.html:19775,Availability,mask,mask,19775,,MatchSource.WIKI,root/html534/TGeoTreeDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTreeDialog.html
https://root.cern/root/html534/TGeoTube.html:4525,Availability,error,error,4525,"irs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:4609,Availability,error,error,4609,"utsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatr",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:3038,Safety,safe,safe,3038,"ompare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* ",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:3440,Safety,safe,safe,3440,"ble_t rmax, Double_t dz); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidDistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:9530,Safety,safe,safe,9530,"tify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTube&operator=(const TGeoTube&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:14927,Safety,safe,safe,14927,"and maximum radius. TGeoTube(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz. ~TGeoTube(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta);",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:15107,Safety,safe,safe,15107," Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOT",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:15192,Safety,safe,safe,15192," Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOT",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:15417,Safety,safe,safe,15417,"ouble_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:15579,Safety,safe,safe,15579,"Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volume",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:15659,Safety,safe,safe,15659,"Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volume",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:15683,Safety,safe,safe,15683,"Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the tube and safe distance; Boundary safe algorithm.; fist localize point w.r.t tube. void DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); Static method computing the distance to a tube with given radius, starting from; POINT along DIR director cosines. The distance is computed as :; RSQ = point[0]*point[0]+point[1]*point[1]; NSQ = dir[0]*dir[0]+dir[1]*dir[1] ---> should NOT be 0 !!!; RDOTN = point[0]*dir[0]+point[1]*dir[1]; The distance can be computed as :; D = -B +/- DELTA; where DELTA.GT.0 and D.GT.0. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radial division; creates all volume",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:20359,Safety,safe,safe,20359," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:20395,Safety,safe,safe,20395," const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. TGeoTube(); methods; constructors. Int_t GetByteCount() const; {return 48;}. Double_t GetRmin() const; {return fRmin;}. Double_t GetRmax() const; {return fRmax;}. Double_t GetDz() const; {return fDz;}. Bool_t HasRmin() const; {return (fRmin>0)?kTRUE:kFALSE;}. Bool_t IsCylType() const; {return kTRUE;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:1731,Testability,test,testNo,1731," TGeoTube(); TGeoTube(Double_t* params); TGeoTube(const TGeoTube&); TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); virtual~TGeoTube(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTGeoShape::ClearThreadData() const; virtual TObject*TNamed::Clone(const char* newn",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTube.html:14597,Testability,test,test,14597,"be(); Default constructor. TGeoTube(Double_t rmin, Double_t rmax, Double_t dz); Default constructor specifying minimum and maximum radius. TGeoTube(const char* name, Double_t rmin, Double_t rmax, Double_t dz); Default constructor specifying minimum and maximum radius. TGeoTube(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz. ~TGeoTube(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Compute distance from inside point to surface of the tube (static); Boundary safe algorithm.; compute distance to surface; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Static method to compute distance from outside point to a tube with given parameters; Boundary safe algorithm.; check Z planes. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) co",MatchSource.WIKI,root/html534/TGeoTube.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTube.html
https://root.cern/root/html534/TGeoTubeEditor.html:4591,Availability,error,error,4591,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeEditor.html
https://root.cern/root/html534/TGeoTubeEditor.html:4675,Availability,error,error,4675,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeEditor.html
https://root.cern/root/html534/TGeoTubeEditor.html:17928,Availability,mask,mask,17928,,MatchSource.WIKI,root/html534/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeEditor.html
https://root.cern/root/html534/TGeoTubeEditor.html:21363,Usability,undo,undoing,21363,"doUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTubeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeEditor.html
https://root.cern/root/html534/TGeoTubeSeg.html:4882,Availability,error,error,4882,"e_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:4966,Availability,error,error,4966," c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:3199,Safety,safe,safe,3199,"eBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual voidComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); static voidComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(const Double_t* point) const; virtual voidContains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm,",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:3694,Safety,safe,safe,3694,"ntains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(const Double_t* point, const Double_t* dir) const; virtual voidTGeoShape::CreateThreadData(Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tDistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; s",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:10003,Safety,safe,safe,10003,"; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoTubeSeg&operator=(const TGeoTubeSeg&); virtual voidTGeoShape::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(const Double_t* point, Bool_t in = kTRUE) const; virtual voidSafety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; static Double_tTGeoShape::SafetyPhi(const Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tSafetyS(const Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Int_t skipz = 0); static Double_tTGeoShape::SafetySeg(Double_t r, Double_t z, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Bool_t outer); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* na",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:16476,Safety,safe,safe,16476," Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, cons",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:16627,Safety,safe,safe,16627,"rmal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z div",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:16720,Safety,safe,safe,16720,"rmal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z div",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:17032,Safety,safe,safe,17032,"ouble_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) co",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:17177,Safety,safe,safe,17177,",py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outside point; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube segment; fist localize point w.r.t tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this tube segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For radialdivision; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:21507,Safety,safe,safe,21507,"ager->GetNsegments()+1;; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4-2;. painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoTubeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:21543,Safety,safe,safe,21543,"ager->GetNsegments()+1;; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4-2;. painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. void Contains_v(const Double_t* points, Bool_t* inside, Int_t vecsize) const; Check the inside status for each of the points in the array.; Input: Array of point coordinates + vector size; Output: Array of Booleans for the inside of each point. void ComputeNormal_v(const Double_t* points, const Double_t* dirs, Double_t* norms, Int_t vecsize); Compute the normal for an array o points so that norm.dot.dir is positive; Input: Arrays of point coordinates and directions + vector size; Output: Array of normal directions. void DistFromInside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; Compute distance from array of input points having directions specisied by dirs. Store output in dists. void Safety_v(const Double_t* points, const Bool_t* inside, Double_t* safe, Int_t vecsize) const; Compute safe distance from each of the points in the input array.; Input: Array of point coordinates, array of statuses for these points, size of the arrays; Output: Safety values. Int_t GetByteCount() const; {return 48;}. TGeoTubeSeg(); constructors. Double_t GetPhi1() const; {return fPhi1;}. Double_t GetPhi2() const; {return fPhi2;}. » Author: Andrei Gheata 24/10/01 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:1840,Testability,test,testNo,1840," TGeoTubeSeg(); TGeoTubeSeg(Double_t* params); TGeoTubeSeg(const TGeoTubeSeg&); TGeoTubeSeg(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); TGeoTubeSeg(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); virtual~TGeoTubeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidAfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t*",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSeg.html:15996,Testability,test,test,15996,"fault constructor specifying minimum and maximum radius; param[0] = Rmin; param[1] = Rmax; param[2] = dz; param[3] = phi1; param[4] = phi2. ~TGeoTubeSeg(); destructor. void AfterStreamer(); Function called after streaming an object of this class. void InitTrigonometry(); Init frequently used trigonometric values. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(const Double_t* point, const Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube segment; first check if point is inside the tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Compute distance from inside point to surface of the tube segment (static); Boundary safe algorithm.; Do Z. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the tube segment; Boundary safe algorithm. Double_t DistFromOutsideS(const Double_t* point, const Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); Static method to compute distance to arbitrary tube segment from outsid",MatchSource.WIKI,root/html534/TGeoTubeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSeg.html
https://root.cern/root/html534/TGeoTubeSegEditor.html:4732,Availability,error,error,4732,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSegEditor.html
https://root.cern/root/html534/TGeoTubeSegEditor.html:4816,Availability,error,error,4816,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSegEditor.html
https://root.cern/root/html534/TGeoTubeSegEditor.html:18300,Availability,mask,mask,18300,,MatchSource.WIKI,root/html534/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSegEditor.html
https://root.cern/root/html534/TGeoTubeSegEditor.html:21938,Usability,undo,undoing,21938,"f the ged-editor; TGeoTabManager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGeoTubeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoTubeSegEditor.html
https://root.cern/root/html534/TGeoUniformMagField.html:1457,Availability,error,error,1457,"ormMagField(Double_t Bx, Double_t By, Double_t Bz); virtual~TGeoUniformMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t*, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFieldValue() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virt",MatchSource.WIKI,root/html534/TGeoUniformMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGeoUniformMagField.html
